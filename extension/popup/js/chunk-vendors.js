(self["webpackChunkminiradio"] = self["webpackChunkminiradio"] || []).push([["chunk-vendors"],{

/***/ "./node_modules/@davland7/rplayer/dist/rplayer.js":
/*!********************************************************!*\
  !*** ./node_modules/@davland7/rplayer/dist/rplayer.js ***!
  \********************************************************/
/***/ ((module) => {

!function(t,e){ true?module.exports=e():0}(self,(()=>(()=>{var t={182:function(t){"undefined"!=typeof window&&(t.exports=function(t){var e={};function r(i){if(e[i])return e[i].exports;var a=e[i]={i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=t,r.c=e,r.d=function(t,e,i){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:i})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(r.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var a in t)r.d(i,a,function(e){return t[e]}.bind(null,a));return i},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="/dist/",r(r.s=19)}([function(t,e,r){"use strict";var i;r.d(e,"a",(function(){return i})),function(t){t.MEDIA_ATTACHING="hlsMediaAttaching",t.MEDIA_ATTACHED="hlsMediaAttached",t.MEDIA_DETACHING="hlsMediaDetaching",t.MEDIA_DETACHED="hlsMediaDetached",t.BUFFER_RESET="hlsBufferReset",t.BUFFER_CODECS="hlsBufferCodecs",t.BUFFER_CREATED="hlsBufferCreated",t.BUFFER_APPENDING="hlsBufferAppending",t.BUFFER_APPENDED="hlsBufferAppended",t.BUFFER_EOS="hlsBufferEos",t.BUFFER_FLUSHING="hlsBufferFlushing",t.BUFFER_FLUSHED="hlsBufferFlushed",t.MANIFEST_LOADING="hlsManifestLoading",t.MANIFEST_LOADED="hlsManifestLoaded",t.MANIFEST_PARSED="hlsManifestParsed",t.LEVEL_SWITCHING="hlsLevelSwitching",t.LEVEL_SWITCHED="hlsLevelSwitched",t.LEVEL_LOADING="hlsLevelLoading",t.LEVEL_LOADED="hlsLevelLoaded",t.LEVEL_UPDATED="hlsLevelUpdated",t.LEVEL_PTS_UPDATED="hlsLevelPtsUpdated",t.LEVELS_UPDATED="hlsLevelsUpdated",t.AUDIO_TRACKS_UPDATED="hlsAudioTracksUpdated",t.AUDIO_TRACK_SWITCHING="hlsAudioTrackSwitching",t.AUDIO_TRACK_SWITCHED="hlsAudioTrackSwitched",t.AUDIO_TRACK_LOADING="hlsAudioTrackLoading",t.AUDIO_TRACK_LOADED="hlsAudioTrackLoaded",t.SUBTITLE_TRACKS_UPDATED="hlsSubtitleTracksUpdated",t.SUBTITLE_TRACKS_CLEARED="hlsSubtitleTracksCleared",t.SUBTITLE_TRACK_SWITCH="hlsSubtitleTrackSwitch",t.SUBTITLE_TRACK_LOADING="hlsSubtitleTrackLoading",t.SUBTITLE_TRACK_LOADED="hlsSubtitleTrackLoaded",t.SUBTITLE_FRAG_PROCESSED="hlsSubtitleFragProcessed",t.CUES_PARSED="hlsCuesParsed",t.NON_NATIVE_TEXT_TRACKS_FOUND="hlsNonNativeTextTracksFound",t.INIT_PTS_FOUND="hlsInitPtsFound",t.FRAG_LOADING="hlsFragLoading",t.FRAG_LOAD_EMERGENCY_ABORTED="hlsFragLoadEmergencyAborted",t.FRAG_LOADED="hlsFragLoaded",t.FRAG_DECRYPTED="hlsFragDecrypted",t.FRAG_PARSING_INIT_SEGMENT="hlsFragParsingInitSegment",t.FRAG_PARSING_USERDATA="hlsFragParsingUserdata",t.FRAG_PARSING_METADATA="hlsFragParsingMetadata",t.FRAG_PARSED="hlsFragParsed",t.FRAG_BUFFERED="hlsFragBuffered",t.FRAG_CHANGED="hlsFragChanged",t.FPS_DROP="hlsFpsDrop",t.FPS_DROP_LEVEL_CAPPING="hlsFpsDropLevelCapping",t.ERROR="hlsError",t.DESTROYING="hlsDestroying",t.KEY_LOADING="hlsKeyLoading",t.KEY_LOADED="hlsKeyLoaded",t.LIVE_BACK_BUFFER_REACHED="hlsLiveBackBufferReached",t.BACK_BUFFER_REACHED="hlsBackBufferReached"}(i||(i={}))},function(t,e,r){"use strict";r.d(e,"a",(function(){return o})),r.d(e,"b",(function(){return l}));var i=function(){},a={trace:i,debug:i,log:i,warn:i,info:i,error:i},n=a;function s(t){var e=self.console[t];return e?e.bind(self.console,"["+t+"] >"):i}function o(t){if(self.console&&!0===t||"object"==typeof t){!function(t){for(var e=arguments.length,r=new Array(e>1?e-1:0),i=1;i<e;i++)r[i-1]=arguments[i];r.forEach((function(e){n[e]=t[e]?t[e].bind(t):s(e)}))}(t,"debug","log","info","warn","error");try{n.log()}catch(t){n=a}}else n=a}var l=a},function(t,e,r){"use strict";var i,a;r.d(e,"b",(function(){return i})),r.d(e,"a",(function(){return a})),function(t){t.NETWORK_ERROR="networkError",t.MEDIA_ERROR="mediaError",t.KEY_SYSTEM_ERROR="keySystemError",t.MUX_ERROR="muxError",t.OTHER_ERROR="otherError"}(i||(i={})),function(t){t.KEY_SYSTEM_NO_KEYS="keySystemNoKeys",t.KEY_SYSTEM_NO_ACCESS="keySystemNoAccess",t.KEY_SYSTEM_NO_SESSION="keySystemNoSession",t.KEY_SYSTEM_LICENSE_REQUEST_FAILED="keySystemLicenseRequestFailed",t.KEY_SYSTEM_NO_INIT_DATA="keySystemNoInitData",t.MANIFEST_LOAD_ERROR="manifestLoadError",t.MANIFEST_LOAD_TIMEOUT="manifestLoadTimeOut",t.MANIFEST_PARSING_ERROR="manifestParsingError",t.MANIFEST_INCOMPATIBLE_CODECS_ERROR="manifestIncompatibleCodecsError",t.LEVEL_EMPTY_ERROR="levelEmptyError",t.LEVEL_LOAD_ERROR="levelLoadError",t.LEVEL_LOAD_TIMEOUT="levelLoadTimeOut",t.LEVEL_SWITCH_ERROR="levelSwitchError",t.AUDIO_TRACK_LOAD_ERROR="audioTrackLoadError",t.AUDIO_TRACK_LOAD_TIMEOUT="audioTrackLoadTimeOut",t.SUBTITLE_LOAD_ERROR="subtitleTrackLoadError",t.SUBTITLE_TRACK_LOAD_TIMEOUT="subtitleTrackLoadTimeOut",t.FRAG_LOAD_ERROR="fragLoadError",t.FRAG_LOAD_TIMEOUT="fragLoadTimeOut",t.FRAG_DECRYPT_ERROR="fragDecryptError",t.FRAG_PARSING_ERROR="fragParsingError",t.REMUX_ALLOC_ERROR="remuxAllocError",t.KEY_LOAD_ERROR="keyLoadError",t.KEY_LOAD_TIMEOUT="keyLoadTimeOut",t.BUFFER_ADD_CODEC_ERROR="bufferAddCodecError",t.BUFFER_INCOMPATIBLE_CODECS_ERROR="bufferIncompatibleCodecsError",t.BUFFER_APPEND_ERROR="bufferAppendError",t.BUFFER_APPENDING_ERROR="bufferAppendingError",t.BUFFER_STALLED_ERROR="bufferStalledError",t.BUFFER_FULL_ERROR="bufferFullError",t.BUFFER_SEEK_OVER_HOLE="bufferSeekOverHole",t.BUFFER_NUDGE_ON_STALL="bufferNudgeOnStall",t.INTERNAL_EXCEPTION="internalException",t.INTERNAL_ABORTED="aborted",t.UNKNOWN="unknown"}(a||(a={}))},function(t,e,r){"use strict";r.d(e,"a",(function(){return i}));var i=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)};Number.MAX_SAFE_INTEGER},function(t,e,r){"use strict";var i,a;r.d(e,"a",(function(){return i})),r.d(e,"b",(function(){return a})),function(t){t.MANIFEST="manifest",t.LEVEL="level",t.AUDIO_TRACK="audioTrack",t.SUBTITLE_TRACK="subtitleTrack"}(i||(i={})),function(t){t.MAIN="main",t.AUDIO="audio",t.SUBTITLE="subtitle"}(a||(a={}))},function(t,e,r){"use strict";r.d(e,"a",(function(){return i})),r.d(e,"b",(function(){return v})),r.d(e,"c",(function(){return g}));var i,a=r(3),n=r(11),s=r(1),o=r(15),l=r(12);function u(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,d(t,e)}function d(t,e){return(d=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function h(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function f(t,e,r){return e&&h(t.prototype,e),r&&h(t,r),t}!function(t){t.AUDIO="audio",t.VIDEO="video",t.AUDIOVIDEO="audiovideo"}(i||(i={}));var c=function(){function t(t){var e;this._byteRange=null,this._url=null,this.baseurl=void 0,this.relurl=void 0,this.elementaryStreams=((e={})[i.AUDIO]=null,e[i.VIDEO]=null,e[i.AUDIOVIDEO]=null,e),this.baseurl=t}return t.prototype.setByteRange=function(t,e){var r=t.split("@",2),i=[];1===r.length?i[0]=e?e.byteRangeEndOffset:0:i[0]=parseInt(r[1]),i[1]=parseInt(r[0])+i[0],this._byteRange=i},f(t,[{key:"byteRange",get:function(){return this._byteRange?this._byteRange:[]}},{key:"byteRangeStartOffset",get:function(){return this.byteRange[0]}},{key:"byteRangeEndOffset",get:function(){return this.byteRange[1]}},{key:"url",get:function(){return!this._url&&this.baseurl&&this.relurl&&(this._url=Object(n.buildAbsoluteURL)(this.baseurl,this.relurl,{alwaysNormalize:!0})),this._url||""},set:function(t){this._url=t}}]),t}(),v=function(t){function e(e,r){var i;return(i=t.call(this,r)||this)._decryptdata=null,i.rawProgramDateTime=null,i.programDateTime=null,i.tagList=[],i.duration=0,i.sn=0,i.levelkey=void 0,i.type=void 0,i.loader=null,i.level=-1,i.cc=0,i.startPTS=void 0,i.endPTS=void 0,i.appendedPTS=void 0,i.startDTS=void 0,i.endDTS=void 0,i.start=0,i.deltaPTS=void 0,i.maxStartPTS=void 0,i.minEndPTS=void 0,i.stats=new l.a,i.urlId=0,i.data=void 0,i.bitrateTest=!1,i.title=null,i.initSegment=null,i.type=e,i}u(e,t);var r=e.prototype;return r.createInitializationVector=function(t){for(var e=new Uint8Array(16),r=12;r<16;r++)e[r]=t>>8*(15-r)&255;return e},r.setDecryptDataFromLevelKey=function(t,e){var r=t;return"AES-128"===(null==t?void 0:t.method)&&t.uri&&!t.iv&&((r=o.a.fromURI(t.uri)).method=t.method,r.iv=this.createInitializationVector(e),r.keyFormat="identity"),r},r.setElementaryStreamInfo=function(t,e,r,i,a,n){void 0===n&&(n=!1);var s=this.elementaryStreams,o=s[t];o?(o.startPTS=Math.min(o.startPTS,e),o.endPTS=Math.max(o.endPTS,r),o.startDTS=Math.min(o.startDTS,i),o.endDTS=Math.max(o.endDTS,a)):s[t]={startPTS:e,endPTS:r,startDTS:i,endDTS:a,partial:n}},r.clearElementaryStreamInfo=function(){var t=this.elementaryStreams;t[i.AUDIO]=null,t[i.VIDEO]=null,t[i.AUDIOVIDEO]=null},f(e,[{key:"decryptdata",get:function(){if(!this.levelkey&&!this._decryptdata)return null;if(!this._decryptdata&&this.levelkey){var t=this.sn;"number"!=typeof t&&(this.levelkey&&"AES-128"===this.levelkey.method&&!this.levelkey.iv&&s.b.warn('missing IV for initialization segment with method="'+this.levelkey.method+'" - compliance issue'),t=0),this._decryptdata=this.setDecryptDataFromLevelKey(this.levelkey,t)}return this._decryptdata}},{key:"end",get:function(){return this.start+this.duration}},{key:"endProgramDateTime",get:function(){if(null===this.programDateTime)return null;if(!Object(a.a)(this.programDateTime))return null;var t=Object(a.a)(this.duration)?this.duration:0;return this.programDateTime+1e3*t}},{key:"encrypted",get:function(){var t;return!(null===(t=this.decryptdata)||void 0===t||!t.keyFormat||!this.decryptdata.uri)}}]),e}(c),g=function(t){function e(e,r,i,a,n){var s;(s=t.call(this,i)||this).fragOffset=0,s.duration=0,s.gap=!1,s.independent=!1,s.relurl=void 0,s.fragment=void 0,s.index=void 0,s.stats=new l.a,s.duration=e.decimalFloatingPoint("DURATION"),s.gap=e.bool("GAP"),s.independent=e.bool("INDEPENDENT"),s.relurl=e.enumeratedString("URI"),s.fragment=r,s.index=a;var o=e.enumeratedString("BYTERANGE");return o&&s.setByteRange(o,n),n&&(s.fragOffset=n.fragOffset+n.duration),s}return u(e,t),f(e,[{key:"start",get:function(){return this.fragment.start+this.fragOffset}},{key:"end",get:function(){return this.start+this.duration}},{key:"loaded",get:function(){var t=this.elementaryStreams;return!!(t.audio||t.video||t.audiovideo)}}]),e}(c)},function(t,e,r){"use strict";r.d(e,"b",(function(){return d})),r.d(e,"g",(function(){return h})),r.d(e,"f",(function(){return f})),r.d(e,"d",(function(){return c})),r.d(e,"c",(function(){return v})),r.d(e,"e",(function(){return p})),r.d(e,"h",(function(){return m})),r.d(e,"a",(function(){return y}));var i=r(8),a=r(5),n=Math.pow(2,32)-1,s=[].push;function o(t){return String.fromCharCode.apply(null,t)}function l(t,e){"data"in t&&(e+=t.start,t=t.data);var r=t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3];return r<0?4294967296+r:r}function u(t,e,r){"data"in t&&(e+=t.start,t=t.data),t[e]=r>>24,t[e+1]=r>>16&255,t[e+2]=r>>8&255,t[e+3]=255&r}function d(t,e){var r,i,a,n=[];if(!e.length)return n;"data"in t?(r=t.data,i=t.start,a=t.end):(i=0,a=(r=t).byteLength);for(var u=i;u<a;){var h=l(r,u),f=h>1?u+h:a;if(o(r.subarray(u+4,u+8))===e[0])if(1===e.length)n.push({data:r,start:u+8,end:f});else{var c=d({data:r,start:u+8,end:f},e.slice(1));c.length&&s.apply(n,c)}u=f}return n}function h(t){var e=d(t,["moov"])[0],r=e?e.end:null,i=d(t,["sidx"]);if(!i||!i[0])return null;var a=[],n=i[0],s=n.data[0],o=0===s?8:16,u=l(n,o);o+=4,o+=0===s?8:16,o+=2;var h=n.end+0,f=function(t,e){"data"in t&&(e+=t.start,t=t.data);var r=t[e]<<8|t[e+1];return r<0?65536+r:r}(n,o);o+=2;for(var c=0;c<f;c++){var v=o,g=l(n,v);v+=4;var p=2147483647&g;if(1==(2147483648&g)>>>31)return console.warn("SIDX has hierarchical references (not supported)"),null;var m=l(n,v);v+=4,a.push({referenceSize:p,subsegmentDuration:m,info:{duration:m/u,start:h,end:h+p-1}}),h+=p,o=v+=4}return{earliestPresentationTime:0,timescale:u,version:s,referencesCount:f,references:a,moovEndOffset:r}}function f(t){for(var e=[],r=d(t,["moov","trak"]),i=0;i<r.length;i++){var n=r[i],s=d(n,["tkhd"])[0];if(s){var u=s.data[s.start],h=0===u?12:20,f=l(s,h),c=d(n,["mdia","mdhd"])[0];if(c){var v=l(c,h=0===(u=c.data[c.start])?12:20),g=d(n,["mdia","hdlr"])[0];if(g){var p=o(g.data.subarray(g.start+8,g.start+12)),m={soun:a.a.AUDIO,vide:a.a.VIDEO}[p];if(m){var y=d(n,["mdia","minf","stbl","stsd"])[0],b=void 0;y&&(b=o(y.data.subarray(y.start+12,y.start+16))),e[f]={timescale:v,type:m},e[m]={timescale:v,id:f,codec:b}}}}}}return d(t,["moov","mvex","trex"]).forEach((function(t){var r=l(t,4),i=e[r];i&&(i.default={duration:l(t,12),flags:l(t,20)})})),e}function c(t,e){return d(e,["moof","traf"]).reduce((function(e,r){var i=d(r,["tfdt"])[0],a=i.data[i.start],n=d(r,["tfhd"]).reduce((function(e,r){var n=l(r,4),s=t[n];if(s){var o=l(i,4);1===a&&(o*=Math.pow(2,32),o+=l(i,8));var u=o/(s.timescale||9e4);if(isFinite(u)&&(null===e||u<e))return u}return e}),null);return null!==n&&isFinite(n)&&(null===e||n<e)?n:e}),null)||0}function v(t,e){for(var r=0,i=0,n=0,s=d(t,["moof","traf"]),o=0;o<s.length;o++){var u=s[o],f=d(u,["tfhd"])[0],c=e[l(f,4)];if(c){var v=c.default,p=l(f,0)|(null==v?void 0:v.flags),m=null==v?void 0:v.duration;8&p&&(m=l(f,2&p?12:8));for(var y=c.timescale||9e4,b=d(u,["trun"]),T=0;T<b.length;T++)!(r=g(b[T]))&&m&&(r=m*l(b[T],4)),c.type===a.a.VIDEO?i+=r/y:c.type===a.a.AUDIO&&(n+=r/y)}}if(0===i&&0===n){var E=h(t);if(null!=E&&E.references)return E.references.reduce((function(t,e){return t+e.info.duration||0}),0)}return i||n}function g(t){var e=l(t,0),r=8;1&e&&(r+=4),4&e&&(r+=4);for(var i=0,a=l(t,4),n=0;n<a;n++)256&e&&(i+=l(t,r),r+=4),512&e&&(r+=4),1024&e&&(r+=4),2048&e&&(r+=4);return i}function p(t,e,r){d(e,["moof","traf"]).forEach((function(e){d(e,["tfhd"]).forEach((function(i){var a=l(i,4),s=t[a];if(s){var o=s.timescale||9e4;d(e,["tfdt"]).forEach((function(t){var e=t.data[t.start],i=l(t,4);if(0===e)u(t,4,i-r*o);else{i*=Math.pow(2,32),i+=l(t,8),i-=r*o,i=Math.max(i,0);var a=Math.floor(i/(n+1)),s=Math.floor(i%(n+1));u(t,4,a),u(t,8,s)}}))}}))}))}function m(t){var e={valid:null,remainder:null},r=d(t,["moof"]);if(!r)return e;if(r.length<2)return e.remainder=t,e;var a=r[r.length-1];return e.valid=Object(i.a)(t,0,a.start-8),e.remainder=Object(i.a)(t,a.start-8),e}function y(t,e){var r=new Uint8Array(t.length+e.length);return r.set(t),r.set(e,t.length),r}},function(t,e,r){"use strict";r.d(e,"b",(function(){return s})),r.d(e,"a",(function(){return l})),r.d(e,"d",(function(){return u})),r.d(e,"e",(function(){return d})),r.d(e,"c",(function(){return f})),r.d(e,"f",(function(){return y}));var i,a=function(t,e){return e+10<=t.length&&73===t[e]&&68===t[e+1]&&51===t[e+2]&&t[e+3]<255&&t[e+4]<255&&t[e+6]<128&&t[e+7]<128&&t[e+8]<128&&t[e+9]<128},n=function(t,e){return e+10<=t.length&&51===t[e]&&68===t[e+1]&&73===t[e+2]&&t[e+3]<255&&t[e+4]<255&&t[e+6]<128&&t[e+7]<128&&t[e+8]<128&&t[e+9]<128},s=function(t,e){for(var r=e,i=0;a(t,e);)i+=10,i+=o(t,e+6),n(t,e+10)&&(i+=10),e+=i;if(i>0)return t.subarray(r,r+i)},o=function(t,e){var r=0;return r=(127&t[e])<<21,r|=(127&t[e+1])<<14,(r|=(127&t[e+2])<<7)|127&t[e+3]},l=function(t,e){return a(t,e)&&o(t,e+6)+10<=t.length-e},u=function(t){for(var e=f(t),r=0;r<e.length;r++){var i=e[r];if(d(i))return m(i)}},d=function(t){return t&&"PRIV"===t.key&&"com.apple.streaming.transportStreamTimestamp"===t.info},h=function(t){var e=String.fromCharCode(t[0],t[1],t[2],t[3]),r=o(t,4);return{type:e,size:r,data:t.subarray(10,10+r)}},f=function(t){for(var e=0,r=[];a(t,e);){for(var i=o(t,e+6),s=(e+=10)+i;e+8<s;){var l=h(t.subarray(e)),u=c(l);u&&r.push(u),e+=l.size+10}n(t,e)&&(e+=10)}return r},c=function(t){return"PRIV"===t.type?v(t):"W"===t.type[0]?p(t):g(t)},v=function(t){if(!(t.size<2)){var e=y(t.data,!0),r=new Uint8Array(t.data.subarray(e.length+1));return{key:t.type,info:e,data:r.buffer}}},g=function(t){if(!(t.size<2)){if("TXXX"===t.type){var e=1,r=y(t.data.subarray(e),!0);e+=r.length+1;var i=y(t.data.subarray(e));return{key:t.type,info:r,data:i}}var a=y(t.data.subarray(1));return{key:t.type,data:a}}},p=function(t){if("WXXX"===t.type){if(t.size<2)return;var e=1,r=y(t.data.subarray(e),!0);e+=r.length+1;var i=y(t.data.subarray(e));return{key:t.type,info:r,data:i}}var a=y(t.data);return{key:t.type,data:a}},m=function(t){if(8===t.data.byteLength){var e=new Uint8Array(t.data),r=1&e[3],i=(e[4]<<23)+(e[5]<<15)+(e[6]<<7)+e[7];return i/=45,r&&(i+=47721858.84),Math.round(i)}},y=function(t,e){void 0===e&&(e=!1);var r=b();if(r){var i=r.decode(t);if(e){var a=i.indexOf("\0");return-1!==a?i.substring(0,a):i}return i.replace(/\0/g,"")}for(var n,s,o,l=t.length,u="",d=0;d<l;){if(0===(n=t[d++])&&e)return u;if(0!==n&&3!==n)switch(n>>4){case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:u+=String.fromCharCode(n);break;case 12:case 13:s=t[d++],u+=String.fromCharCode((31&n)<<6|63&s);break;case 14:s=t[d++],o=t[d++],u+=String.fromCharCode((15&n)<<12|(63&s)<<6|(63&o)<<0)}}return u};function b(){return i||void 0===self.TextDecoder||(i=new self.TextDecoder("utf-8")),i}},function(t,e,r){"use strict";function i(t,e,r){return Uint8Array.prototype.slice?t.slice(e,r):new Uint8Array(Array.prototype.slice.call(t,e,r))}r.d(e,"a",(function(){return i}))},function(t,e,r){"use strict";r.d(e,"c",(function(){return Et})),r.d(e,"d",(function(){return Lt})),r.d(e,"a",(function(){return At})),r.d(e,"b",(function(){return Rt}));var i=r(0),a=r(2),n=r(14),s=r(3),o=r(7),l=r(6),u=r(8),d=function(){function t(){this._audioTrack=void 0,this._id3Track=void 0,this.frameIndex=0,this.cachedData=null,this.initPTS=null}var e=t.prototype;return e.resetInitSegment=function(t,e,r){this._id3Track={type:"id3",id:3,pid:-1,inputTimeScale:9e4,sequenceNumber:0,samples:[],dropped:0}},e.resetTimeStamp=function(){},e.resetContiguity=function(){},e.canParse=function(t,e){return!1},e.appendFrame=function(t,e,r){},e.demux=function(t,e){this.cachedData&&(t=Object(l.a)(this.cachedData,t),this.cachedData=null);var r,i,a=o.b(t,0),n=a?a.length:0,s=this._audioTrack,d=this._id3Track,f=a?o.d(a):void 0,c=t.length;for(0!==this.frameIndex&&null!==this.initPTS||(this.initPTS=h(f,e)),a&&a.length>0&&d.samples.push({pts:this.initPTS,dts:this.initPTS,data:a}),i=this.initPTS;n<c;){if(this.canParse(t,n)){var v=this.appendFrame(s,t,n);v?(this.frameIndex++,i=v.sample.pts,r=n+=v.length):n=c}else o.a(t,n)?(a=o.b(t,n),d.samples.push({pts:i,dts:i,data:a}),r=n+=a.length):n++;if(n===c&&r!==c){var g=Object(u.a)(t,r);this.cachedData?this.cachedData=Object(l.a)(this.cachedData,g):this.cachedData=g}}return{audioTrack:s,avcTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0},id3Track:d,textTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0}}},e.demuxSampleAes=function(t,e,r){return Promise.reject(new Error("["+this+"] This demuxer does not support Sample-AES decryption"))},e.flush=function(t){var e=this.cachedData;return e&&(this.cachedData=null,this.demux(e,0)),this.frameIndex=0,{audioTrack:this._audioTrack,avcTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0},id3Track:this._id3Track,textTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0}}},e.destroy=function(){},t}(),h=function(t,e){return Object(s.a)(t)?90*t:9e4*e},f=d,c=r(1);function v(t,e){return 255===t[e]&&240==(246&t[e+1])}function g(t,e){return 1&t[e+1]?7:9}function p(t,e){return(3&t[e+3])<<11|t[e+4]<<3|(224&t[e+5])>>>5}function m(t,e){return e+1<t.length&&v(t,e)}function y(t,e){if(m(t,e)){var r=g(t,e);if(e+r>=t.length)return!1;var i=p(t,e);if(i<=r)return!1;var a=e+i;return a===t.length||m(t,a)}return!1}function b(t,e,r,n,s){if(!t.samplerate){var o=function(t,e,r,n){var s,o,l,u,d=navigator.userAgent.toLowerCase(),h=n,f=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350];s=1+((192&e[r+2])>>>6);var v=(60&e[r+2])>>>2;if(!(v>f.length-1))return l=(1&e[r+2])<<2,l|=(192&e[r+3])>>>6,c.b.log("manifest codec:"+n+", ADTS type:"+s+", samplingIndex:"+v),/firefox/i.test(d)?v>=6?(s=5,u=new Array(4),o=v-3):(s=2,u=new Array(2),o=v):-1!==d.indexOf("android")?(s=2,u=new Array(2),o=v):(s=5,u=new Array(4),n&&(-1!==n.indexOf("mp4a.40.29")||-1!==n.indexOf("mp4a.40.5"))||!n&&v>=6?o=v-3:((n&&-1!==n.indexOf("mp4a.40.2")&&(v>=6&&1===l||/vivaldi/i.test(d))||!n&&1===l)&&(s=2,u=new Array(2)),o=v)),u[0]=s<<3,u[0]|=(14&v)>>1,u[1]|=(1&v)<<7,u[1]|=l<<3,5===s&&(u[1]|=(14&o)>>1,u[2]=(1&o)<<7,u[2]|=8,u[3]=0),{config:u,samplerate:f[v],channelCount:l,codec:"mp4a.40."+s,manifestCodec:h};t.trigger(i.a.ERROR,{type:a.b.MEDIA_ERROR,details:a.a.FRAG_PARSING_ERROR,fatal:!0,reason:"invalid ADTS sampling index:"+v})}(e,r,n,s);if(!o)return;t.config=o.config,t.samplerate=o.samplerate,t.channelCount=o.channelCount,t.codec=o.codec,t.manifestCodec=o.manifestCodec,c.b.log("parsed codec:"+t.codec+", rate:"+o.samplerate+", channels:"+o.channelCount)}}function T(t){return 9216e4/t}function E(t,e,r,i,a){var n=function(t,e,r,i,a){var n=g(t,e),s=p(t,e);if((s-=n)>0)return{headerLength:n,frameLength:s,stamp:r+i*a}}(e,r,i,a,T(t.samplerate));if(n){var s,o=n.frameLength,l=n.headerLength,u=n.stamp,d=l+o,h=Math.max(0,r+d-e.length);h?(s=new Uint8Array(d-l)).set(e.subarray(r+l,e.length),0):s=e.subarray(r+l,r+d);var f={unit:s,pts:u};return h||t.samples.push(f),{sample:f,length:d,missing:h}}}function S(t,e){return(S=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var L=function(t){var e,r;function i(e,r){var i;return(i=t.call(this)||this).observer=void 0,i.config=void 0,i.observer=e,i.config=r,i}r=t,(e=i).prototype=Object.create(r.prototype),e.prototype.constructor=e,S(e,r);var a=i.prototype;return a.resetInitSegment=function(e,r,i){t.prototype.resetInitSegment.call(this,e,r,i),this._audioTrack={container:"audio/adts",type:"audio",id:2,pid:-1,sequenceNumber:0,isAAC:!0,samples:[],manifestCodec:e,duration:i,inputTimeScale:9e4,dropped:0}},i.probe=function(t){if(!t)return!1;for(var e=(o.b(t,0)||[]).length,r=t.length;e<r;e++)if(y(t,e))return c.b.log("ADTS sync word found !"),!0;return!1},a.canParse=function(t,e){return function(t,e){return function(t,e){return e+5<t.length}(t,e)&&v(t,e)&&p(t,e)<=t.length-e}(t,e)},a.appendFrame=function(t,e,r){b(t,this.observer,e,r,t.manifestCodec);var i=E(t,e,r,this.initPTS,this.frameIndex);if(i&&0===i.missing)return i},i}(f);L.minProbeByteLength=9;var A=L,R=function(){function t(t,e){this.remainderData=null,this.config=void 0,this.config=e}var e=t.prototype;return e.resetTimeStamp=function(){},e.resetInitSegment=function(){},e.resetContiguity=function(){},t.probe=function(t){return Object(l.b)({data:t,start:0,end:Math.min(t.length,16384)},["moof"]).length>0},e.demux=function(t){var e=t,r={type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0};if(this.config.progressive){this.remainderData&&(e=Object(l.a)(this.remainderData,t));var i=Object(l.h)(e);this.remainderData=i.remainder,r.samples=i.valid||new Uint8Array}else r.samples=e;return{audioTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0},avcTrack:r,id3Track:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0},textTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0}}},e.flush=function(){var t={type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0};return t.samples=this.remainderData||new Uint8Array,this.remainderData=null,{audioTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0},avcTrack:t,id3Track:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0},textTrack:{type:"",id:-1,pid:-1,inputTimeScale:9e4,sequenceNumber:-1,samples:[],dropped:0}}},e.demuxSampleAes=function(t,e,r){return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))},e.destroy=function(){},t}();R.minProbeByteLength=1024;var D=R,_=null,k=[32,64,96,128,160,192,224,256,288,320,352,384,416,448,32,48,56,64,80,96,112,128,160,192,224,256,320,384,32,40,48,56,64,80,96,112,128,160,192,224,256,320,32,48,56,64,80,96,112,128,144,160,176,192,224,256,8,16,24,32,40,48,56,64,80,96,112,128,144,160],x=[44100,48e3,32e3,22050,24e3,16e3,11025,12e3,8e3],w=[[0,72,144,12],[0,0,0,0],[0,72,144,12],[0,144,144,12]],C=[0,1,1,4];function O(t,e,r,i,a){if(!(r+24>e.length)){var n=I(e,r);if(n&&r+n.frameLength<=e.length){var s=i+a*(9e4*n.samplesPerFrame/n.sampleRate),o={unit:e.subarray(r,r+n.frameLength),pts:s,dts:s};return t.config=[],t.channelCount=n.channelCount,t.samplerate=n.sampleRate,t.samples.push(o),{sample:o,length:n.frameLength,missing:0}}}}function I(t,e){var r=t[e+1]>>3&3,i=t[e+1]>>1&3,a=t[e+2]>>4&15,n=t[e+2]>>2&3;if(1!==r&&0!==a&&15!==a&&3!==n){var s=t[e+2]>>1&1,o=t[e+3]>>6,l=1e3*k[14*(3===r?3-i:3===i?3:4)+a-1],u=x[3*(3===r?0:2===r?1:2)+n],d=3===o?1:2,h=w[r][i],f=C[i],c=8*h*f,v=Math.floor(h*l/u+s)*f;if(null===_){var g=(navigator.userAgent||"").match(/Chrome\/(\d+)/i);_=g?parseInt(g[1]):0}return!!_&&_<=87&&2===i&&l>=224e3&&0===o&&(t[e+3]=128|t[e+3]),{sampleRate:u,channelCount:d,frameLength:v,samplesPerFrame:c}}}function P(t,e){return 255===t[e]&&224==(224&t[e+1])&&0!=(6&t[e+1])}function F(t,e){return e+1<t.length&&P(t,e)}function M(t,e){if(e+1<t.length&&P(t,e)){var r=I(t,e),i=4;null!=r&&r.frameLength&&(i=r.frameLength);var a=e+i;return a===t.length||F(t,a)}return!1}var N=function(){function t(t){this.data=void 0,this.bytesAvailable=void 0,this.word=void 0,this.bitsAvailable=void 0,this.data=t,this.bytesAvailable=t.byteLength,this.word=0,this.bitsAvailable=0}var e=t.prototype;return e.loadWord=function(){var t=this.data,e=this.bytesAvailable,r=t.byteLength-e,i=new Uint8Array(4),a=Math.min(4,e);if(0===a)throw new Error("no bytes available");i.set(t.subarray(r,r+a)),this.word=new DataView(i.buffer).getUint32(0),this.bitsAvailable=8*a,this.bytesAvailable-=a},e.skipBits=function(t){var e;this.bitsAvailable>t?(this.word<<=t,this.bitsAvailable-=t):(t-=this.bitsAvailable,t-=(e=t>>3)>>3,this.bytesAvailable-=e,this.loadWord(),this.word<<=t,this.bitsAvailable-=t)},e.readBits=function(t){var e=Math.min(this.bitsAvailable,t),r=this.word>>>32-e;return t>32&&c.b.error("Cannot read more than 32 bits at a time"),this.bitsAvailable-=e,this.bitsAvailable>0?this.word<<=e:this.bytesAvailable>0&&this.loadWord(),(e=t-e)>0&&this.bitsAvailable?r<<e|this.readBits(e):r},e.skipLZ=function(){var t;for(t=0;t<this.bitsAvailable;++t)if(0!=(this.word&2147483648>>>t))return this.word<<=t,this.bitsAvailable-=t,t;return this.loadWord(),t+this.skipLZ()},e.skipUEG=function(){this.skipBits(1+this.skipLZ())},e.skipEG=function(){this.skipBits(1+this.skipLZ())},e.readUEG=function(){var t=this.skipLZ();return this.readBits(t+1)-1},e.readEG=function(){var t=this.readUEG();return 1&t?1+t>>>1:-1*(t>>>1)},e.readBoolean=function(){return 1===this.readBits(1)},e.readUByte=function(){return this.readBits(8)},e.readUShort=function(){return this.readBits(16)},e.readUInt=function(){return this.readBits(32)},e.skipScalingList=function(t){for(var e=8,r=8,i=0;i<t;i++)0!==r&&(r=(e+this.readEG()+256)%256),e=0===r?e:r},e.readSPS=function(){var t,e,r,i=0,a=0,n=0,s=0,o=this.readUByte.bind(this),l=this.readBits.bind(this),u=this.readUEG.bind(this),d=this.readBoolean.bind(this),h=this.skipBits.bind(this),f=this.skipEG.bind(this),c=this.skipUEG.bind(this),v=this.skipScalingList.bind(this);o();var g=o();if(l(5),h(3),o(),c(),100===g||110===g||122===g||244===g||44===g||83===g||86===g||118===g||128===g){var p=u();if(3===p&&h(1),c(),c(),h(1),d())for(e=3!==p?8:12,r=0;r<e;r++)d()&&v(r<6?16:64)}c();var m=u();if(0===m)u();else if(1===m)for(h(1),f(),f(),t=u(),r=0;r<t;r++)f();c(),h(1);var y=u(),b=u(),T=l(1);0===T&&h(1),h(1),d()&&(i=u(),a=u(),n=u(),s=u());var E=[1,1];if(d()&&d())switch(o()){case 1:E=[1,1];break;case 2:E=[12,11];break;case 3:E=[10,11];break;case 4:E=[16,11];break;case 5:E=[40,33];break;case 6:E=[24,11];break;case 7:E=[20,11];break;case 8:E=[32,11];break;case 9:E=[80,33];break;case 10:E=[18,11];break;case 11:E=[15,11];break;case 12:E=[64,33];break;case 13:E=[160,99];break;case 14:E=[4,3];break;case 15:E=[3,2];break;case 16:E=[2,1];break;case 255:E=[o()<<8|o(),o()<<8|o()]}return{width:Math.ceil(16*(y+1)-2*i-2*a),height:(2-T)*(b+1)*16-(T?2:4)*(n+s),pixelRatio:E}},e.readSliceType=function(){return this.readUByte(),this.readUEG(),this.readUEG()},t}(),B=function(){function t(t,e,r){this.keyData=void 0,this.decrypter=void 0,this.keyData=r,this.decrypter=new n.a(t,e,{removePKCS7Padding:!1})}var e=t.prototype;return e.decryptBuffer=function(t,e){this.decrypter.decrypt(t,this.keyData.key.buffer,this.keyData.iv.buffer,e)},e.decryptAacSample=function(t,e,r,i){var a=t[e].unit,n=a.subarray(16,a.length-a.length%16),s=n.buffer.slice(n.byteOffset,n.byteOffset+n.length),o=this;this.decryptBuffer(s,(function(n){var s=new Uint8Array(n);a.set(s,16),i||o.decryptAacSamples(t,e+1,r)}))},e.decryptAacSamples=function(t,e,r){for(;;e++){if(e>=t.length)return void r();if(!(t[e].unit.length<32)){var i=this.decrypter.isSync();if(this.decryptAacSample(t,e,r,i),!i)return}}},e.getAvcEncryptedData=function(t){for(var e=16*Math.floor((t.length-48)/160)+16,r=new Int8Array(e),i=0,a=32;a<t.length-16;a+=160,i+=16)r.set(t.subarray(a,a+16),i);return r},e.getAvcDecryptedUnit=function(t,e){for(var r=new Uint8Array(e),i=0,a=32;a<t.length-16;a+=160,i+=16)t.set(r.subarray(i,i+16),a);return t},e.decryptAvcSample=function(t,e,r,i,a,n){var s=X(a.data),o=this.getAvcEncryptedData(s),l=this;this.decryptBuffer(o.buffer,(function(o){a.data=l.getAvcDecryptedUnit(s,o),n||l.decryptAvcSamples(t,e,r+1,i)}))},e.decryptAvcSamples=function(t,e,r,i){if(t instanceof Uint8Array)throw new Error("Cannot decrypt samples of type Uint8Array");for(;;e++,r=0){if(e>=t.length)return void i();for(var a=t[e].units;!(r>=a.length);r++){var n=a[r];if(!(n.data.length<=48||1!==n.type&&5!==n.type)){var s=this.decrypter.isSync();if(this.decryptAvcSample(t,e,r,i,n,s),!s)return}}}},t}(),U={video:1,audio:2,id3:3,text:4},G=function(){function t(t,e,r){this.observer=void 0,this.config=void 0,this.typeSupported=void 0,this.sampleAes=null,this.pmtParsed=!1,this.audioCodec=void 0,this.videoCodec=void 0,this._duration=0,this.aacLastPTS=null,this._initPTS=null,this._initDTS=null,this._pmtId=-1,this._avcTrack=void 0,this._audioTrack=void 0,this._id3Track=void 0,this._txtTrack=void 0,this.aacOverFlow=null,this.avcSample=null,this.remainderData=null,this.observer=t,this.config=e,this.typeSupported=r}t.probe=function(e){var r=t.syncOffset(e);return!(r<0||(r&&c.b.warn("MPEG2-TS detected but first sync word found @ offset "+r+", junk ahead ?"),0))},t.syncOffset=function(t){for(var e=Math.min(1e3,t.length-564),r=0;r<e;){if(71===t[r]&&71===t[r+188]&&71===t[r+376])return r;r++}return-1},t.createTrack=function(t,e){return{container:"video"===t||"audio"===t?"video/mp2t":void 0,type:t,id:U[t],pid:-1,inputTimeScale:9e4,sequenceNumber:0,samples:[],dropped:0,duration:"audio"===t?e:void 0}};var e=t.prototype;return e.resetInitSegment=function(e,r,i){this.pmtParsed=!1,this._pmtId=-1,this._avcTrack=t.createTrack("video",i),this._audioTrack=t.createTrack("audio",i),this._id3Track=t.createTrack("id3",i),this._txtTrack=t.createTrack("text",i),this._audioTrack.isAAC=!0,this.aacOverFlow=null,this.aacLastPTS=null,this.avcSample=null,this.audioCodec=e,this.videoCodec=r,this._duration=i},e.resetTimeStamp=function(){},e.resetContiguity=function(){var t=this._audioTrack,e=this._avcTrack,r=this._id3Track;t&&(t.pesData=null),e&&(e.pesData=null),r&&(r.pesData=null),this.aacOverFlow=null,this.aacLastPTS=null},e.demux=function(e,r,n,s){var o;void 0===n&&(n=!1),void 0===s&&(s=!1),n||(this.sampleAes=null);var u=this._avcTrack,d=this._audioTrack,h=this._id3Track,f=u.pid,v=u.pesData,g=d.pid,p=h.pid,m=d.pesData,y=h.pesData,b=!1,T=this.pmtParsed,E=this._pmtId,S=e.length;if(this.remainderData&&(S=(e=Object(l.a)(this.remainderData,e)).length,this.remainderData=null),S<188&&!s)return this.remainderData=e,{audioTrack:d,avcTrack:u,id3Track:h,textTrack:this._txtTrack};var L=Math.max(0,t.syncOffset(e));(S-=(S+L)%188)<e.byteLength&&!s&&(this.remainderData=new Uint8Array(e.buffer,S,e.buffer.byteLength-S));for(var A=0,R=L;R<S;R+=188)if(71===e[R]){var D=!!(64&e[R+1]),_=((31&e[R+1])<<8)+e[R+2],k=void 0;if((48&e[R+3])>>4>1){if((k=R+5+e[R+4])===R+188)continue}else k=R+4;switch(_){case f:D&&(v&&(o=V(v))&&this.parseAVCPES(o,!1),v={data:[],size:0}),v&&(v.data.push(e.subarray(k,R+188)),v.size+=R+188-k);break;case g:D&&(m&&(o=V(m))&&(d.isAAC?this.parseAACPES(o):this.parseMPEGPES(o)),m={data:[],size:0}),m&&(m.data.push(e.subarray(k,R+188)),m.size+=R+188-k);break;case p:D&&(y&&(o=V(y))&&this.parseID3PES(o),y={data:[],size:0}),y&&(y.data.push(e.subarray(k,R+188)),y.size+=R+188-k);break;case 0:D&&(k+=e[k]+1),E=this._pmtId=H(e,k);break;case E:D&&(k+=e[k]+1);var x=K(e,k,!0===this.typeSupported.mpeg||!0===this.typeSupported.mp3,n);(f=x.avc)>0&&(u.pid=f),(g=x.audio)>0&&(d.pid=g,d.isAAC=x.isAAC),(p=x.id3)>0&&(h.pid=p),b&&!T&&(c.b.log("reparse from beginning"),b=!1,R=L-188),T=this.pmtParsed=!0;break;case 17:case 8191:break;default:b=!0}}else A++;A>0&&this.observer.emit(i.a.ERROR,i.a.ERROR,{type:a.b.MEDIA_ERROR,details:a.a.FRAG_PARSING_ERROR,fatal:!1,reason:"Found "+A+" TS packet/s that do not start with 0x47"}),u.pesData=v,d.pesData=m,h.pesData=y;var w={audioTrack:d,avcTrack:u,id3Track:h,textTrack:this._txtTrack};return s&&this.extractRemainingSamples(w),w},e.flush=function(){var t,e=this.remainderData;return this.remainderData=null,t=e?this.demux(e,-1,!1,!0):{audioTrack:this._audioTrack,avcTrack:this._avcTrack,textTrack:this._txtTrack,id3Track:this._id3Track},this.extractRemainingSamples(t),this.sampleAes?this.decrypt(t,this.sampleAes):t},e.extractRemainingSamples=function(t){var e,r=t.audioTrack,i=t.avcTrack,a=t.id3Track,n=i.pesData,s=r.pesData,o=a.pesData;n&&(e=V(n))?(this.parseAVCPES(e,!0),i.pesData=null):i.pesData=n,s&&(e=V(s))?(r.isAAC?this.parseAACPES(e):this.parseMPEGPES(e),r.pesData=null):(null!=s&&s.size&&c.b.log("last AAC PES packet truncated,might overlap between fragments"),r.pesData=s),o&&(e=V(o))?(this.parseID3PES(e),a.pesData=null):a.pesData=o},e.demuxSampleAes=function(t,e,r){var i=this.demux(t,r,!0,!this.config.progressive),a=this.sampleAes=new B(this.observer,this.config,e);return this.decrypt(i,a)},e.decrypt=function(t,e){return new Promise((function(r){var i=t.audioTrack,a=t.avcTrack;i.samples&&i.isAAC?e.decryptAacSamples(i.samples,0,(function(){a.samples?e.decryptAvcSamples(a.samples,0,0,(function(){r(t)})):r(t)})):a.samples&&e.decryptAvcSamples(a.samples,0,0,(function(){r(t)}))}))},e.destroy=function(){this._initPTS=this._initDTS=null,this._duration=0},e.parseAVCPES=function(t,e){var r,i=this,a=this._avcTrack,n=this.parseAVCNALu(t.data),s=this.avcSample,l=!1;t.data=null,s&&n.length&&!a.audFound&&(W(s,a),s=this.avcSample=j(!1,t.pts,t.dts,"")),n.forEach((function(e){switch(e.type){case 1:r=!0,s||(s=i.avcSample=j(!0,t.pts,t.dts,"")),s.frame=!0;var n=e.data;if(l&&n.length>4){var u=new N(n).readSliceType();2!==u&&4!==u&&7!==u&&9!==u||(s.key=!0)}break;case 5:r=!0,s||(s=i.avcSample=j(!0,t.pts,t.dts,"")),s.key=!0,s.frame=!0;break;case 6:r=!0;var d=new N(X(e.data));d.readUByte();for(var h=0,f=0,c=!1,v=0;!c&&d.bytesAvailable>1;){h=0;do{h+=v=d.readUByte()}while(255===v);f=0;do{f+=v=d.readUByte()}while(255===v);if(4===h&&0!==d.bytesAvailable){if(c=!0,181===d.readUByte()&&49===d.readUShort()&&1195456820===d.readUInt()&&3===d.readUByte()){for(var g=d.readUByte(),p=31&g,m=[g,d.readUByte()],y=0;y<p;y++)m.push(d.readUByte()),m.push(d.readUByte()),m.push(d.readUByte());Y(i._txtTrack.samples,{type:3,pts:t.pts,bytes:m})}}else if(5===h&&0!==d.bytesAvailable){if(c=!0,f>16){for(var b=[],T=0;T<16;T++)b.push(d.readUByte().toString(16)),3!==T&&5!==T&&7!==T&&9!==T||b.push("-");for(var E=f-16,S=new Uint8Array(E),L=0;L<E;L++)S[L]=d.readUByte();Y(i._txtTrack.samples,{pts:t.pts,payloadType:h,uuid:b.join(""),userData:Object(o.f)(S),userDataBytes:S})}}else if(f<d.bytesAvailable)for(var A=0;A<f;A++)d.readUByte()}break;case 7:if(r=!0,l=!0,!a.sps){var R=new N(e.data).readSPS();a.width=R.width,a.height=R.height,a.pixelRatio=R.pixelRatio,a.sps=[e.data],a.duration=i._duration;for(var D=e.data.subarray(1,4),_="avc1.",k=0;k<3;k++){var x=D[k].toString(16);x.length<2&&(x="0"+x),_+=x}a.codec=_}break;case 8:r=!0,a.pps||(a.pps=[e.data]);break;case 9:r=!1,a.audFound=!0,s&&W(s,a),s=i.avcSample=j(!1,t.pts,t.dts,"");break;case 12:r=!1;break;default:r=!1,s&&(s.debug+="unknown NAL "+e.type+" ")}s&&r&&s.units.push(e)})),e&&s&&(W(s,a),this.avcSample=null)},e.getLastNalUnit=function(){var t,e,r=this.avcSample;if(!r||0===r.units.length){var i=this._avcTrack.samples;r=i[i.length-1]}if(null!==(t=r)&&void 0!==t&&t.units){var a=r.units;e=a[a.length-1]}return e},e.parseAVCNALu=function(t){var e,r,i=t.byteLength,a=this._avcTrack,n=a.naluState||0,s=n,o=[],l=0,u=-1,d=0;for(-1===n&&(u=0,d=31&t[0],n=0,l=1);l<i;)if(e=t[l++],n)if(1!==n)if(e)if(1===e){if(u>=0){var h={data:t.subarray(u,l-n-1),type:d};o.push(h)}else{var f=this.getLastNalUnit();if(f&&(s&&l<=4-s&&f.state&&(f.data=f.data.subarray(0,f.data.byteLength-s)),(r=l-n-1)>0)){var c=new Uint8Array(f.data.byteLength+r);c.set(f.data,0),c.set(t.subarray(0,r),f.data.byteLength),f.data=c,f.state=0}}l<i?(u=l,d=31&t[l],n=0):n=-1}else n=0;else n=3;else n=e?0:2;else n=e?0:1;if(u>=0&&n>=0){var v={data:t.subarray(u,i),type:d,state:n};o.push(v)}if(0===o.length){var g=this.getLastNalUnit();if(g){var p=new Uint8Array(g.data.byteLength+t.byteLength);p.set(g.data,0),p.set(t,g.data.byteLength),g.data=p}}return a.naluState=n,o},e.parseAACPES=function(t){var e,r,n,s,o,l=0,u=this._audioTrack,d=this.aacOverFlow,h=t.data;if(d){this.aacOverFlow=null;var f=d.sample.unit.byteLength,v=Math.min(d.missing,f),g=f-v;d.sample.unit.set(h.subarray(0,v),g),u.samples.push(d.sample),l=d.missing}for(e=l,r=h.length;e<r-1&&!m(h,e);e++);if(e===l||(e<r-1?(n="AAC PES did not start with ADTS header,offset:"+e,s=!1):(n="no ADTS header found in AAC PES",s=!0),c.b.warn("parsing error:"+n),this.observer.emit(i.a.ERROR,i.a.ERROR,{type:a.b.MEDIA_ERROR,details:a.a.FRAG_PARSING_ERROR,fatal:s,reason:n}),!s)){if(b(u,this.observer,h,e,this.audioCodec),void 0!==t.pts)o=t.pts;else{if(!d)return void c.b.warn("[tsdemuxer]: AAC PES unknown PTS");var p=T(u.samplerate);o=d.sample.pts+p}for(var y=0;e<r;){if(m(h,e)){if(e+5<r){var S=E(u,h,e,o,y);if(S){if(!S.missing){e+=S.length,y++;continue}this.aacOverFlow=S}}break}e++}}},e.parseMPEGPES=function(t){var e=t.data,r=e.length,i=0,a=0,n=t.pts;if(void 0!==n)for(;a<r;)if(F(e,a)){var s=O(this._audioTrack,e,a,n,i);if(!s)break;a+=s.length,i++}else a++;else c.b.warn("[tsdemuxer]: MPEG PES unknown PTS")},e.parseID3PES=function(t){void 0!==t.pts?this._id3Track.samples.push(t):c.b.warn("[tsdemuxer]: ID3 PES unknown PTS")},t}();function j(t,e,r,i){return{key:t,frame:!1,pts:e,dts:r,units:[],debug:i,length:0}}function H(t,e){return(31&t[e+10])<<8|t[e+11]}function K(t,e,r,i){var a={audio:-1,avc:-1,id3:-1,isAAC:!0},n=e+3+((15&t[e+1])<<8|t[e+2])-4;for(e+=12+((15&t[e+10])<<8|t[e+11]);e<n;){var s=(31&t[e+1])<<8|t[e+2];switch(t[e]){case 207:if(!i){c.b.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");break}case 15:-1===a.audio&&(a.audio=s);break;case 21:-1===a.id3&&(a.id3=s);break;case 219:if(!i){c.b.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");break}case 27:-1===a.avc&&(a.avc=s);break;case 3:case 4:r?-1===a.audio&&(a.audio=s,a.isAAC=!1):c.b.log("MPEG audio found, not supported in this browser");break;case 36:c.b.warn("Unsupported HEVC stream type found")}e+=5+((15&t[e+3])<<8|t[e+4])}return a}function V(t){var e,r,i,a,n,s=0,o=t.data;if(!t||0===t.size)return null;for(;o[0].length<19&&o.length>1;){var l=new Uint8Array(o[0].length+o[1].length);l.set(o[0]),l.set(o[1],o[0].length),o[0]=l,o.splice(1,1)}if(1===((e=o[0])[0]<<16)+(e[1]<<8)+e[2]){if((r=(e[4]<<8)+e[5])&&r>t.size-6)return null;var u=e[7];192&u&&(a=536870912*(14&e[9])+4194304*(255&e[10])+16384*(254&e[11])+128*(255&e[12])+(254&e[13])/2,64&u?a-(n=536870912*(14&e[14])+4194304*(255&e[15])+16384*(254&e[16])+128*(255&e[17])+(254&e[18])/2)>54e5&&(c.b.warn(Math.round((a-n)/9e4)+"s delta between PTS and DTS, align them"),a=n):n=a);var d=(i=e[8])+9;if(t.size<=d)return null;t.size-=d;for(var h=new Uint8Array(t.size),f=0,v=o.length;f<v;f++){var g=(e=o[f]).byteLength;if(d){if(d>g){d-=g;continue}e=e.subarray(d),g-=d,d=0}h.set(e,s),s+=g}return r&&(r-=i+3),{data:h,pts:a,dts:n,len:r}}return null}function W(t,e){if(t.units.length&&t.frame){if(void 0===t.pts){var r=e.samples,i=r.length;if(!i)return void e.dropped++;var a=r[i-1];t.pts=a.pts,t.dts=a.dts}e.samples.push(t)}t.debug.length&&c.b.log(t.pts+"/"+t.dts+":"+t.debug)}function Y(t,e){var r=t.length;if(r>0){if(e.pts>=t[r-1].pts)t.push(e);else for(var i=r-1;i>=0;i--)if(e.pts<t[i].pts){t.splice(i,0,e);break}}else t.push(e)}function X(t){for(var e=t.byteLength,r=[],i=1;i<e-2;)0===t[i]&&0===t[i+1]&&3===t[i+2]?(r.push(i+2),i+=2):i++;if(0===r.length)return t;var a=e-r.length,n=new Uint8Array(a),s=0;for(i=0;i<a;s++,i++)s===r[0]&&(s++,r.shift()),n[i]=t[s];return n}G.minProbeByteLength=188;var q=G;function z(t,e){return(z=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var Q=function(t){var e,r;function i(){return t.apply(this,arguments)||this}r=t,(e=i).prototype=Object.create(r.prototype),e.prototype.constructor=e,z(e,r);var a=i.prototype;return a.resetInitSegment=function(e,r,i){t.prototype.resetInitSegment.call(this,e,r,i),this._audioTrack={container:"audio/mpeg",type:"audio",id:2,pid:-1,sequenceNumber:0,isAAC:!1,samples:[],manifestCodec:e,duration:i,inputTimeScale:9e4,dropped:0}},i.probe=function(t){if(!t)return!1;for(var e=(o.b(t,0)||[]).length,r=t.length;e<r;e++)if(M(t,e))return c.b.log("MPEG Audio sync word found !"),!0;return!1},a.canParse=function(t,e){return function(t,e){return P(t,e)&&4<=t.length-e}(t,e)},a.appendFrame=function(t,e,r){if(null!==this.initPTS)return O(t,e,r,this.initPTS,this.frameIndex)},i}(f);Q.minProbeByteLength=4;var $=Q,Z=function(){function t(){}return t.getSilentFrame=function(t,e){if("mp4a.40.2"===t){if(1===e)return new Uint8Array([0,200,0,128,35,128]);if(2===e)return new Uint8Array([33,0,73,144,2,25,0,35,128]);if(3===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,142]);if(4===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,128,44,128,8,2,56]);if(5===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,56]);if(6===e)return new Uint8Array([0,200,0,128,32,132,1,38,64,8,100,0,130,48,4,153,0,33,144,2,0,178,0,32,8,224])}else{if(1===e)return new Uint8Array([1,64,34,128,163,78,230,128,186,8,0,0,0,28,6,241,193,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(2===e)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94]);if(3===e)return new Uint8Array([1,64,34,128,163,94,230,128,186,8,0,0,0,0,149,0,6,241,161,10,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,90,94])}},t}(),J=Math.pow(2,32)-1,tt=function(){function t(){}return t.init=function(){var e;for(e in t.types={avc1:[],avcC:[],btrt:[],dinf:[],dref:[],esds:[],ftyp:[],hdlr:[],mdat:[],mdhd:[],mdia:[],mfhd:[],minf:[],moof:[],moov:[],mp4a:[],".mp3":[],mvex:[],mvhd:[],pasp:[],sdtp:[],stbl:[],stco:[],stsc:[],stsd:[],stsz:[],stts:[],tfdt:[],tfhd:[],traf:[],trak:[],trun:[],trex:[],tkhd:[],vmhd:[],smhd:[]},t.types)t.types.hasOwnProperty(e)&&(t.types[e]=[e.charCodeAt(0),e.charCodeAt(1),e.charCodeAt(2),e.charCodeAt(3)]);var r=new Uint8Array([0,0,0,0,0,0,0,0,118,105,100,101,0,0,0,0,0,0,0,0,0,0,0,0,86,105,100,101,111,72,97,110,100,108,101,114,0]),i=new Uint8Array([0,0,0,0,0,0,0,0,115,111,117,110,0,0,0,0,0,0,0,0,0,0,0,0,83,111,117,110,100,72,97,110,100,108,101,114,0]);t.HDLR_TYPES={video:r,audio:i};var a=new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,12,117,114,108,32,0,0,0,1]),n=new Uint8Array([0,0,0,0,0,0,0,0]);t.STTS=t.STSC=t.STCO=n,t.STSZ=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0]),t.VMHD=new Uint8Array([0,0,0,1,0,0,0,0,0,0,0,0]),t.SMHD=new Uint8Array([0,0,0,0,0,0,0,0]),t.STSD=new Uint8Array([0,0,0,0,0,0,0,1]);var s=new Uint8Array([105,115,111,109]),o=new Uint8Array([97,118,99,49]),l=new Uint8Array([0,0,0,1]);t.FTYP=t.box(t.types.ftyp,s,l,s,o),t.DINF=t.box(t.types.dinf,t.box(t.types.dref,a))},t.box=function(t){for(var e=8,r=arguments.length,i=new Array(r>1?r-1:0),a=1;a<r;a++)i[a-1]=arguments[a];for(var n=i.length,s=n;n--;)e+=i[n].byteLength;var o=new Uint8Array(e);for(o[0]=e>>24&255,o[1]=e>>16&255,o[2]=e>>8&255,o[3]=255&e,o.set(t,4),n=0,e=8;n<s;n++)o.set(i[n],e),e+=i[n].byteLength;return o},t.hdlr=function(e){return t.box(t.types.hdlr,t.HDLR_TYPES[e])},t.mdat=function(e){return t.box(t.types.mdat,e)},t.mdhd=function(e,r){r*=e;var i=Math.floor(r/(J+1)),a=Math.floor(r%(J+1));return t.box(t.types.mdhd,new Uint8Array([1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,e>>24&255,e>>16&255,e>>8&255,255&e,i>>24,i>>16&255,i>>8&255,255&i,a>>24,a>>16&255,a>>8&255,255&a,85,196,0,0]))},t.mdia=function(e){return t.box(t.types.mdia,t.mdhd(e.timescale,e.duration),t.hdlr(e.type),t.minf(e))},t.mfhd=function(e){return t.box(t.types.mfhd,new Uint8Array([0,0,0,0,e>>24,e>>16&255,e>>8&255,255&e]))},t.minf=function(e){return"audio"===e.type?t.box(t.types.minf,t.box(t.types.smhd,t.SMHD),t.DINF,t.stbl(e)):t.box(t.types.minf,t.box(t.types.vmhd,t.VMHD),t.DINF,t.stbl(e))},t.moof=function(e,r,i){return t.box(t.types.moof,t.mfhd(e),t.traf(i,r))},t.moov=function(e){for(var r=e.length,i=[];r--;)i[r]=t.trak(e[r]);return t.box.apply(null,[t.types.moov,t.mvhd(e[0].timescale,e[0].duration)].concat(i).concat(t.mvex(e)))},t.mvex=function(e){for(var r=e.length,i=[];r--;)i[r]=t.trex(e[r]);return t.box.apply(null,[t.types.mvex].concat(i))},t.mvhd=function(e,r){r*=e;var i=Math.floor(r/(J+1)),a=Math.floor(r%(J+1)),n=new Uint8Array([1,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,e>>24&255,e>>16&255,e>>8&255,255&e,i>>24,i>>16&255,i>>8&255,255&i,a>>24,a>>16&255,a>>8&255,255&a,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255]);return t.box(t.types.mvhd,n)},t.sdtp=function(e){var r,i,a=e.samples||[],n=new Uint8Array(4+a.length);for(r=0;r<a.length;r++)i=a[r].flags,n[r+4]=i.dependsOn<<4|i.isDependedOn<<2|i.hasRedundancy;return t.box(t.types.sdtp,n)},t.stbl=function(e){return t.box(t.types.stbl,t.stsd(e),t.box(t.types.stts,t.STTS),t.box(t.types.stsc,t.STSC),t.box(t.types.stsz,t.STSZ),t.box(t.types.stco,t.STCO))},t.avc1=function(e){var r,i,a,n=[],s=[];for(r=0;r<e.sps.length;r++)a=(i=e.sps[r]).byteLength,n.push(a>>>8&255),n.push(255&a),n=n.concat(Array.prototype.slice.call(i));for(r=0;r<e.pps.length;r++)a=(i=e.pps[r]).byteLength,s.push(a>>>8&255),s.push(255&a),s=s.concat(Array.prototype.slice.call(i));var o=t.box(t.types.avcC,new Uint8Array([1,n[3],n[4],n[5],255,224|e.sps.length].concat(n).concat([e.pps.length]).concat(s))),l=e.width,u=e.height,d=e.pixelRatio[0],h=e.pixelRatio[1];return t.box(t.types.avc1,new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,l>>8&255,255&l,u>>8&255,255&u,0,72,0,0,0,72,0,0,0,0,0,0,0,1,18,100,97,105,108,121,109,111,116,105,111,110,47,104,108,115,46,106,115,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,17,17]),o,t.box(t.types.btrt,new Uint8Array([0,28,156,128,0,45,198,192,0,45,198,192])),t.box(t.types.pasp,new Uint8Array([d>>24,d>>16&255,d>>8&255,255&d,h>>24,h>>16&255,h>>8&255,255&h])))},t.esds=function(t){var e=t.config.length;return new Uint8Array([0,0,0,0,3,23+e,0,1,0,4,15+e,64,21,0,0,0,0,0,0,0,0,0,0,0,5].concat([e]).concat(t.config).concat([6,1,2]))},t.mp4a=function(e){var r=e.samplerate;return t.box(t.types.mp4a,new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,e.channelCount,0,16,0,0,0,0,r>>8&255,255&r,0,0]),t.box(t.types.esds,t.esds(e)))},t.mp3=function(e){var r=e.samplerate;return t.box(t.types[".mp3"],new Uint8Array([0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,e.channelCount,0,16,0,0,0,0,r>>8&255,255&r,0,0]))},t.stsd=function(e){return"audio"===e.type?e.isAAC||"mp3"!==e.codec?t.box(t.types.stsd,t.STSD,t.mp4a(e)):t.box(t.types.stsd,t.STSD,t.mp3(e)):t.box(t.types.stsd,t.STSD,t.avc1(e))},t.tkhd=function(e){var r=e.id,i=e.duration*e.timescale,a=e.width,n=e.height,s=Math.floor(i/(J+1)),o=Math.floor(i%(J+1));return t.box(t.types.tkhd,new Uint8Array([1,0,0,7,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,3,r>>24&255,r>>16&255,r>>8&255,255&r,0,0,0,0,s>>24,s>>16&255,s>>8&255,255&s,o>>24,o>>16&255,o>>8&255,255&o,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,0,a>>8&255,255&a,0,0,n>>8&255,255&n,0,0]))},t.traf=function(e,r){var i=t.sdtp(e),a=e.id,n=Math.floor(r/(J+1)),s=Math.floor(r%(J+1));return t.box(t.types.traf,t.box(t.types.tfhd,new Uint8Array([0,0,0,0,a>>24,a>>16&255,a>>8&255,255&a])),t.box(t.types.tfdt,new Uint8Array([1,0,0,0,n>>24,n>>16&255,n>>8&255,255&n,s>>24,s>>16&255,s>>8&255,255&s])),t.trun(e,i.length+16+20+8+16+8+8),i)},t.trak=function(e){return e.duration=e.duration||4294967295,t.box(t.types.trak,t.tkhd(e),t.mdia(e))},t.trex=function(e){var r=e.id;return t.box(t.types.trex,new Uint8Array([0,0,0,0,r>>24,r>>16&255,r>>8&255,255&r,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1]))},t.trun=function(e,r){var i,a,n,s,o,l,u=e.samples||[],d=u.length,h=12+16*d,f=new Uint8Array(h);for(r+=8+h,f.set([0,0,15,1,d>>>24&255,d>>>16&255,d>>>8&255,255&d,r>>>24&255,r>>>16&255,r>>>8&255,255&r],0),i=0;i<d;i++)n=(a=u[i]).duration,s=a.size,o=a.flags,l=a.cts,f.set([n>>>24&255,n>>>16&255,n>>>8&255,255&n,s>>>24&255,s>>>16&255,s>>>8&255,255&s,o.isLeading<<2|o.dependsOn,o.isDependedOn<<6|o.hasRedundancy<<4|o.paddingValue<<1|o.isNonSync,61440&o.degradPrio,15&o.degradPrio,l>>>24&255,l>>>16&255,l>>>8&255,255&l],12+16*i);return t.box(t.types.trun,f)},t.initSegment=function(e){t.types||t.init();var r=t.moov(e),i=new Uint8Array(t.FTYP.byteLength+r.byteLength);return i.set(t.FTYP),i.set(r,t.FTYP.byteLength),i},t}();tt.types=void 0,tt.HDLR_TYPES=void 0,tt.STTS=void 0,tt.STSC=void 0,tt.STCO=void 0,tt.STSZ=void 0,tt.VMHD=void 0,tt.SMHD=void 0,tt.STSD=void 0,tt.FTYP=void 0,tt.DINF=void 0;var et=tt,rt=r(4);function it(t,e){return void 0===e&&(e=!1),function(t,e,r,i){void 0===r&&(r=1),void 0===i&&(i=!1);var a=t*e*r;return i?Math.round(a):a}(t,1e3,1/9e4,e)}function at(){return(at=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t}).apply(this,arguments)}var nt=null,st=null,ot=!1,lt=function(){function t(t,e,r,i){if(void 0===i&&(i=""),this.observer=void 0,this.config=void 0,this.typeSupported=void 0,this.ISGenerated=!1,this._initPTS=void 0,this._initDTS=void 0,this.nextAvcDts=null,this.nextAudioPts=null,this.isAudioContiguous=!1,this.isVideoContiguous=!1,this.observer=t,this.config=e,this.typeSupported=r,this.ISGenerated=!1,null===nt){var a=(navigator.userAgent||"").match(/Chrome\/(\d+)/i);nt=a?parseInt(a[1]):0}if(null===st){var n=navigator.userAgent.match(/Safari\/(\d+)/i);st=n?parseInt(n[1]):0}ot=!!nt&&nt<75||!!st&&st<600}var e=t.prototype;return e.destroy=function(){},e.resetTimeStamp=function(t){c.b.log("[mp4-remuxer]: initPTS & initDTS reset"),this._initPTS=this._initDTS=t},e.resetNextTimestamp=function(){c.b.log("[mp4-remuxer]: reset next timestamp"),this.isVideoContiguous=!1,this.isAudioContiguous=!1},e.resetInitSegment=function(){c.b.log("[mp4-remuxer]: ISGenerated flag reset"),this.ISGenerated=!1},e.getVideoStartPts=function(t){var e=!1,r=t.reduce((function(t,r){var i=r.pts-t;return i<-4294967296?(e=!0,ut(t,r.pts)):i>0?t:r.pts}),t[0].pts);return e&&c.b.debug("PTS rollover detected"),r},e.remux=function(t,e,r,i,a,n,s,o){var l,u,d,h,f,v,g=a,p=a,m=t.pid>-1,y=e.pid>-1,b=e.samples.length,T=t.samples.length>0,E=b>1;if((!m||T)&&(!y||E)||this.ISGenerated||s){this.ISGenerated||(d=this.generateIS(t,e,a));var S=this.isVideoContiguous,L=-1;if(E&&(L=function(t){for(var e=0;e<t.length;e++)if(t[e].key)return e;return-1}(e.samples),!S&&this.config.forceKeyFrameOnDiscontinuity))if(v=!0,L>0){c.b.warn("[mp4-remuxer]: Dropped "+L+" out of "+b+" video samples due to a missing keyframe");var A=this.getVideoStartPts(e.samples);e.samples=e.samples.slice(L),e.dropped+=L,p+=(e.samples[0].pts-A)/(e.timescale||9e4)}else-1===L&&(c.b.warn("[mp4-remuxer]: No keyframe found out of "+b+" video samples"),v=!1);if(this.ISGenerated){if(T&&E){var R=this.getVideoStartPts(e.samples),D=(ut(t.samples[0].pts,R)-R)/e.inputTimeScale;g+=Math.max(0,D),p+=Math.max(0,-D)}if(T){if(t.samplerate||(c.b.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"),d=this.generateIS(t,e,a)),u=this.remuxAudio(t,g,this.isAudioContiguous,n,y||E||o===rt.b.AUDIO?p:void 0),E){var _=u?u.endPTS-u.startPTS:0;e.inputTimeScale||(c.b.warn("[mp4-remuxer]: regenerate InitSegment as video detected"),d=this.generateIS(t,e,a)),l=this.remuxVideo(e,p,S,_)}}else E&&(l=this.remuxVideo(e,p,S,0));l&&(l.firstKeyFrame=L,l.independent=-1!==L)}}return this.ISGenerated&&(r.samples.length&&(f=this.remuxID3(r,a)),i.samples.length&&(h=this.remuxText(i,a))),{audio:u,video:l,initSegment:d,independent:v,text:h,id3:f}},e.generateIS=function(t,e,r){var i,a,n,o=t.samples,l=e.samples,u=this.typeSupported,d={},h=!Object(s.a)(this._initPTS),f="audio/mp4";if(h&&(i=a=1/0),t.config&&o.length&&(t.timescale=t.samplerate,t.isAAC||(u.mpeg?(f="audio/mpeg",t.codec=""):u.mp3&&(t.codec="mp3")),d.audio={id:"audio",container:f,codec:t.codec,initSegment:!t.isAAC&&u.mpeg?new Uint8Array(0):et.initSegment([t]),metadata:{channelCount:t.channelCount}},h&&(n=t.inputTimeScale,i=a=o[0].pts-Math.round(n*r))),e.sps&&e.pps&&l.length&&(e.timescale=e.inputTimeScale,d.video={id:"main",container:"video/mp4",codec:e.codec,initSegment:et.initSegment([e]),metadata:{width:e.width,height:e.height}},h)){n=e.inputTimeScale;var c=this.getVideoStartPts(l),v=Math.round(n*r);a=Math.min(a,ut(l[0].dts,c)-v),i=Math.min(i,c-v)}if(Object.keys(d).length)return this.ISGenerated=!0,h&&(this._initPTS=i,this._initDTS=a),{tracks:d,initPTS:i,timescale:n}},e.remuxVideo=function(t,e,r,n){var s,o,l,u=t.inputTimeScale,d=t.samples,h=[],f=d.length,v=this._initPTS,g=this.nextAvcDts,p=8,m=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY,b=0,T=!1;r&&null!==g||(g=e*u-(d[0].pts-ut(d[0].dts,d[0].pts)));for(var E=0;E<f;E++){var S=d[E];S.pts=ut(S.pts-v,g),S.dts=ut(S.dts-v,g),S.dts>S.pts&&(b=Math.max(Math.min(b,S.pts-S.dts),-18e3)),S.dts<d[E>0?E-1:E].dts&&(T=!0)}T&&d.sort((function(t,e){var r=t.dts-e.dts,i=t.pts-e.pts;return r||i})),o=d[0].dts,l=d[d.length-1].dts;var L=Math.round((l-o)/(f-1));if(b<0){if(b<-2*L){c.b.warn("PTS < DTS detected in video samples, offsetting DTS from PTS by "+it(-L,!0)+" ms");for(var A=b,R=0;R<f;R++)d[R].dts=A=Math.max(A,d[R].pts-L),d[R].pts=Math.max(A,d[R].pts)}else{c.b.warn("PTS < DTS detected in video samples, shifting DTS by "+it(b,!0)+" ms to overcome this issue");for(var D=0;D<f;D++)d[D].dts=d[D].dts+b}o=d[0].dts}if(r){var _=o-g,k=_>L;if(k||_<-1){k?c.b.warn("AVC: "+it(_,!0)+" ms ("+_+"dts) hole between fragments detected, filling it"):c.b.warn("AVC: "+it(-_,!0)+" ms ("+_+"dts) overlapping between fragments detected"),o=g;var x=d[0].pts-_;d[0].dts=o,d[0].pts=x,c.b.log("Video: First PTS/DTS adjusted: "+it(x,!0)+"/"+it(o,!0)+", delta: "+it(_,!0)+" ms")}}ot&&(o=Math.max(0,o));for(var w=0,C=0,O=0;O<f;O++){for(var I=d[O],P=I.units,F=P.length,M=0,N=0;N<F;N++)M+=P[N].data.length;C+=M,w+=F,I.length=M,I.dts=Math.max(I.dts,o),I.pts=Math.max(I.pts,I.dts,0),m=Math.min(I.pts,m),y=Math.max(I.pts,y)}l=d[f-1].dts;var B,U=C+4*w+8;try{B=new Uint8Array(U)}catch(t){return void this.observer.emit(i.a.ERROR,i.a.ERROR,{type:a.b.MUX_ERROR,details:a.a.REMUX_ALLOC_ERROR,fatal:!1,bytes:U,reason:"fail allocating video mdat "+U})}var G=new DataView(B.buffer);G.setUint32(0,U),B.set(et.types.mdat,4);for(var j=0;j<f;j++){for(var H=d[j],K=H.units,V=0,W=0,Y=K.length;W<Y;W++){var X=K[W],q=X.data,z=X.data.byteLength;G.setUint32(p,z),p+=4,B.set(q,p),p+=z,V+=4+z}if(j<f-1)s=d[j+1].dts-H.dts;else{var Q=this.config,$=H.dts-d[j>0?j-1:j].dts;if(Q.stretchShortVideoTrack&&null!==this.nextAudioPts){var Z=Math.floor(Q.maxBufferHole*u),J=(n?m+n*u:this.nextAudioPts)-H.pts;J>Z?((s=J-$)<0&&(s=$),c.b.log("[mp4-remuxer]: It is approximately "+J/90+" ms to the next segment; using duration "+s/90+" ms for the last video frame.")):s=$}else s=$}var tt=Math.round(H.pts-H.dts);h.push(new dt(H.key,s,V,tt))}if(h.length&&nt&&nt<70){var rt=h[0].flags;rt.dependsOn=2,rt.isNonSync=0}this.nextAvcDts=g=l+s,this.isVideoContiguous=!0;var st={data1:et.moof(t.sequenceNumber++,o,at({},t,{samples:h})),data2:B,startPTS:m/u,endPTS:(y+s)/u,startDTS:o/u,endDTS:g/u,type:"video",hasAudio:!1,hasVideo:!0,nb:h.length,dropped:t.dropped};return t.samples=[],t.dropped=0,st},e.remuxAudio=function(t,e,r,n,s){var o=t.inputTimeScale,l=o/(t.samplerate?t.samplerate:o),u=t.isAAC?1024:1152,d=u*l,h=this._initPTS,f=!t.isAAC&&this.typeSupported.mpeg,v=[],g=t.samples,p=f?0:8,m=this.nextAudioPts||-1,y=e*o;if(this.isAudioContiguous=r=r||g.length&&m>0&&(n&&Math.abs(y-m)<9e3||Math.abs(ut(g[0].pts-h,y)-m)<20*d),g.forEach((function(t){t.pts=ut(t.pts-h,y)})),!r||m<0){if(!(g=g.filter((function(t){return t.pts>=0}))).length)return;m=0===s?0:n?Math.max(0,y):g[0].pts}if(t.isAAC)for(var b=void 0!==s,T=this.config.maxAudioFramesDrift,E=0,S=m;E<g.length;E++){var L=g[E],A=L.pts,R=A-S,D=Math.abs(1e3*R/o);if(R<=-T*d&&b)0===E&&(c.b.warn("Audio frame @ "+(A/o).toFixed(3)+"s overlaps nextAudioPts by "+Math.round(1e3*R/o)+" ms."),this.nextAudioPts=m=S=A);else if(R>=T*d&&D<1e4&&b){var _=Math.round(R/d);(S=A-_*d)<0&&(_--,S+=d),0===E&&(this.nextAudioPts=m=S),c.b.warn("[mp4-remuxer]: Injecting "+_+" audio frame @ "+(S/o).toFixed(3)+"s due to "+Math.round(1e3*R/o)+" ms gap.");for(var k=0;k<_;k++){var x=Math.max(S,0),w=Z.getSilentFrame(t.manifestCodec||t.codec,t.channelCount);w||(c.b.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."),w=L.unit.subarray()),g.splice(E,0,{unit:w,pts:x}),S+=d,E++}}L.pts=S,S+=d}for(var C,O=null,I=null,P=0,F=g.length;F--;)P+=g[F].unit.byteLength;for(var M=0,N=g.length;M<N;M++){var B=g[M],U=B.unit,G=B.pts;if(null!==I)v[M-1].duration=Math.round((G-I)/l);else{if(r&&t.isAAC&&(G=m),O=G,!(P>0))return;P+=p;try{C=new Uint8Array(P)}catch(t){return void this.observer.emit(i.a.ERROR,i.a.ERROR,{type:a.b.MUX_ERROR,details:a.a.REMUX_ALLOC_ERROR,fatal:!1,bytes:P,reason:"fail allocating audio mdat "+P})}f||(new DataView(C.buffer).setUint32(0,P),C.set(et.types.mdat,4))}C.set(U,p);var j=U.byteLength;p+=j,v.push(new dt(!0,u,j,0)),I=G}var H=v.length;if(H){var K=v[v.length-1];this.nextAudioPts=m=I+l*K.duration;var V=f?new Uint8Array(0):et.moof(t.sequenceNumber++,O/l,at({},t,{samples:v}));t.samples=[];var W=O/o,Y=m/o,X={data1:V,data2:C,startPTS:W,endPTS:Y,startDTS:W,endDTS:Y,type:"audio",hasAudio:!0,hasVideo:!1,nb:H};return this.isAudioContiguous=!0,X}},e.remuxEmptyAudio=function(t,e,r,i){var a=t.inputTimeScale,n=a/(t.samplerate?t.samplerate:a),s=this.nextAudioPts,o=(null!==s?s:i.startDTS*a)+this._initDTS,l=i.endDTS*a+this._initDTS,u=1024*n,d=Math.ceil((l-o)/u),h=Z.getSilentFrame(t.manifestCodec||t.codec,t.channelCount);if(c.b.warn("[mp4-remuxer]: remux empty Audio"),h){for(var f=[],v=0;v<d;v++){var g=o+v*u;f.push({unit:h,pts:g,dts:g})}return t.samples=f,this.remuxAudio(t,e,r,!1)}c.b.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec")},e.remuxID3=function(t,e){var r=t.samples.length;if(r){for(var i=t.inputTimeScale,a=this._initPTS,n=this._initDTS,s=0;s<r;s++){var o=t.samples[s];o.pts=ut(o.pts-a,e*i)/i,o.dts=ut(o.dts-n,e*i)/i}var l=t.samples;return t.samples=[],{samples:l}}},e.remuxText=function(t,e){var r=t.samples.length;if(r){for(var i=t.inputTimeScale,a=this._initPTS,n=0;n<r;n++){var s=t.samples[n];s.pts=ut(s.pts-a,e*i)/i}t.samples.sort((function(t,e){return t.pts-e.pts}));var o=t.samples;return t.samples=[],{samples:o}}},t}();function ut(t,e){var r;if(null===e)return t;for(r=e<t?-8589934592:8589934592;Math.abs(t-e)>4294967296;)t+=r;return t}var dt=function(t,e,r,i){this.size=void 0,this.duration=void 0,this.cts=void 0,this.flags=void 0,this.duration=e,this.size=r,this.cts=i,this.flags=new ht(t)},ht=function(t){this.isLeading=0,this.isDependedOn=0,this.hasRedundancy=0,this.degradPrio=0,this.dependsOn=1,this.isNonSync=1,this.dependsOn=t?2:1,this.isNonSync=t?0:1},ft=r(5),ct=function(){function t(){this.emitInitSegment=!1,this.audioCodec=void 0,this.videoCodec=void 0,this.initData=void 0,this.initPTS=void 0,this.initTracks=void 0,this.lastEndDTS=null}var e=t.prototype;return e.destroy=function(){},e.resetTimeStamp=function(t){this.initPTS=t,this.lastEndDTS=null},e.resetNextTimestamp=function(){this.lastEndDTS=null},e.resetInitSegment=function(t,e,r){this.audioCodec=e,this.videoCodec=r,this.generateInitSegment(t),this.emitInitSegment=!0},e.generateInitSegment=function(t){var e=this.audioCodec,r=this.videoCodec;if(!t||!t.byteLength)return this.initTracks=void 0,void(this.initData=void 0);var i=this.initData=Object(l.f)(t);e||(e=gt(i.audio,ft.a.AUDIO)),r||(r=gt(i.video,ft.a.VIDEO));var a={};i.audio&&i.video?a.audiovideo={container:"video/mp4",codec:e+","+r,initSegment:t,id:"main"}:i.audio?a.audio={container:"audio/mp4",codec:e,initSegment:t,id:"audio"}:i.video?a.video={container:"video/mp4",codec:r,initSegment:t,id:"main"}:c.b.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."),this.initTracks=a},e.remux=function(t,e,r,i,a){var n=this.initPTS,o=this.lastEndDTS,u={audio:void 0,video:void 0,text:i,id3:r,initSegment:void 0};Object(s.a)(o)||(o=this.lastEndDTS=a||0);var d=e.samples;if(!d||!d.length)return u;var h={initPTS:void 0,timescale:1},f=this.initData;if(f&&f.length||(this.generateInitSegment(d),f=this.initData),!f||!f.length)return c.b.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."),u;this.emitInitSegment&&(h.tracks=this.initTracks,this.emitInitSegment=!1),Object(s.a)(n)||(this.initPTS=h.initPTS=n=vt(f,d,o));var v=Object(l.c)(d,f),g=o,p=v+g;Object(l.e)(f,d,n),v>0?this.lastEndDTS=p:(c.b.warn("Duration parsed from mp4 should be greater than zero"),this.resetNextTimestamp());var m=!!f.audio,y=!!f.video,b="";m&&(b+="audio"),y&&(b+="video");var T={data1:d,startPTS:g,startDTS:g,endPTS:p,endDTS:p,type:b,hasAudio:m,hasVideo:y,nb:1,dropped:0};return u.audio="audio"===T.type?T:void 0,u.video="audio"!==T.type?T:void 0,u.text=i,u.id3=r,u.initSegment=h,u},t}(),vt=function(t,e,r){return Object(l.d)(t,e)-r};function gt(t,e){var r=null==t?void 0:t.codec;return r&&r.length>4?r:"hvc1"===r?"hvc1.1.c.L120.90":"av01"===r?"av01.0.04M.08":"avc1"===r||e===ft.a.VIDEO?"avc1.42e01e":"mp4a.40.5"}var pt,mt=ct,yt=r(16);try{pt=self.performance.now.bind(self.performance)}catch(t){c.b.debug("Unable to use Performance API on this environment"),pt=self.Date.now}var bt=[{demux:q,remux:lt},{demux:D,remux:mt},{demux:A,remux:lt},{demux:$,remux:lt}],Tt=1024;bt.forEach((function(t){var e=t.demux;Tt=Math.max(Tt,e.minProbeByteLength)}));var Et=function(){function t(t,e,r,i,a){this.observer=void 0,this.typeSupported=void 0,this.config=void 0,this.vendor=void 0,this.id=void 0,this.demuxer=void 0,this.remuxer=void 0,this.decrypter=void 0,this.probe=void 0,this.decryptionPromise=null,this.transmuxConfig=void 0,this.currentTransmuxState=void 0,this.cache=new yt.a,this.observer=t,this.typeSupported=e,this.config=r,this.vendor=i,this.id=a}var e=t.prototype;return e.configure=function(t){this.transmuxConfig=t,this.decrypter&&this.decrypter.reset()},e.push=function(t,e,r,i){var a=this,n=r.transmuxing;n.executeStart=pt();var s=new Uint8Array(t),o=this.cache,u=this.config,d=this.currentTransmuxState,h=this.transmuxConfig;i&&(this.currentTransmuxState=i);var f=function(t,e){var r=null;return t.byteLength>0&&null!=e&&null!=e.key&&null!==e.iv&&null!=e.method&&(r=e),r}(s,e);if(f&&"AES-128"===f.method){var c=this.getDecrypter();if(!u.enableSoftwareAES)return this.decryptionPromise=c.webCryptoDecrypt(s,f.key.buffer,f.iv.buffer).then((function(t){var e=a.push(t,null,r);return a.decryptionPromise=null,e})),this.decryptionPromise;var v=c.softwareDecrypt(s,f.key.buffer,f.iv.buffer);if(!v)return n.executeEnd=pt(),St(r);s=new Uint8Array(v)}var g=i||d,p=g.contiguous,m=g.discontinuity,y=g.trackSwitch,b=g.accurateTimeOffset,T=g.timeOffset,E=g.initSegmentChange,S=h.audioCodec,L=h.videoCodec,A=h.defaultInitPts,R=h.duration,D=h.initSegmentData;if((m||y||E)&&this.resetInitSegment(D,S,L,R),(m||E)&&this.resetInitialTimestamp(A),p||this.resetContiguity(),this.needsProbing(s,m,y)){if(o.dataLength){var _=o.flush();s=Object(l.a)(_,s)}this.configureTransmuxer(s,h)}var k=this.transmux(s,f,T,b,r),x=this.currentTransmuxState;return x.contiguous=!0,x.discontinuity=!1,x.trackSwitch=!1,n.executeEnd=pt(),k},e.flush=function(t){var e=this,r=t.transmuxing;r.executeStart=pt();var n=this.decrypter,s=this.cache,o=this.currentTransmuxState,l=this.decryptionPromise;if(l)return l.then((function(){return e.flush(t)}));var u=[],d=o.timeOffset;if(n){var h=n.flush();h&&u.push(this.push(h,null,t))}var f=s.dataLength;s.reset();var c=this.demuxer,v=this.remuxer;if(!c||!v)return f>=Tt&&this.observer.emit(i.a.ERROR,i.a.ERROR,{type:a.b.MEDIA_ERROR,details:a.a.FRAG_PARSING_ERROR,fatal:!0,reason:"no demux matching with content found"}),r.executeEnd=pt(),[St(t)];var g=c.flush(d);return Lt(g)?g.then((function(r){return e.flushRemux(u,r,t),u})):(this.flushRemux(u,g,t),u)},e.flushRemux=function(t,e,r){var i=e.audioTrack,a=e.avcTrack,n=e.id3Track,s=e.textTrack,o=this.currentTransmuxState,l=o.accurateTimeOffset,u=o.timeOffset;c.b.log("[transmuxer.ts]: Flushed fragment "+r.sn+(r.part>-1?" p: "+r.part:"")+" of level "+r.level);var d=this.remuxer.remux(i,a,n,s,u,l,!0,this.id);t.push({remuxResult:d,chunkMeta:r}),r.transmuxing.executeEnd=pt()},e.resetInitialTimestamp=function(t){var e=this.demuxer,r=this.remuxer;e&&r&&(e.resetTimeStamp(t),r.resetTimeStamp(t))},e.resetContiguity=function(){var t=this.demuxer,e=this.remuxer;t&&e&&(t.resetContiguity(),e.resetNextTimestamp())},e.resetInitSegment=function(t,e,r,i){var a=this.demuxer,n=this.remuxer;a&&n&&(a.resetInitSegment(e,r,i),n.resetInitSegment(t,e,r))},e.destroy=function(){this.demuxer&&(this.demuxer.destroy(),this.demuxer=void 0),this.remuxer&&(this.remuxer.destroy(),this.remuxer=void 0)},e.transmux=function(t,e,r,i,a){return e&&"SAMPLE-AES"===e.method?this.transmuxSampleAes(t,e,r,i,a):this.transmuxUnencrypted(t,r,i,a)},e.transmuxUnencrypted=function(t,e,r,i){var a=this.demuxer.demux(t,e,!1,!this.config.progressive),n=a.audioTrack,s=a.avcTrack,o=a.id3Track,l=a.textTrack;return{remuxResult:this.remuxer.remux(n,s,o,l,e,r,!1,this.id),chunkMeta:i}},e.transmuxSampleAes=function(t,e,r,i,a){var n=this;return this.demuxer.demuxSampleAes(t,e,r).then((function(t){return{remuxResult:n.remuxer.remux(t.audioTrack,t.avcTrack,t.id3Track,t.textTrack,r,i,!1,n.id),chunkMeta:a}}))},e.configureTransmuxer=function(t,e){for(var r,i=this.config,a=this.observer,n=this.typeSupported,s=this.vendor,o=e.audioCodec,l=e.defaultInitPts,u=e.duration,d=e.initSegmentData,h=e.videoCodec,f=0,v=bt.length;f<v;f++)if(bt[f].demux.probe(t)){r=bt[f];break}r||(c.b.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough"),r={demux:D,remux:mt});var g=this.demuxer,p=this.remuxer,m=r.remux,y=r.demux;p&&p instanceof m||(this.remuxer=new m(a,i,n,s)),g&&g instanceof y||(this.demuxer=new y(a,i,n),this.probe=y.probe),this.resetInitSegment(d,o,h,u),this.resetInitialTimestamp(l)},e.needsProbing=function(t,e,r){return!this.demuxer||!this.remuxer||e||r},e.getDecrypter=function(){var t=this.decrypter;return t||(t=this.decrypter=new n.a(this.observer,this.config)),t},t}(),St=function(t){return{remuxResult:{},chunkMeta:t}};function Lt(t){return"then"in t&&t.then instanceof Function}var At=function(t,e,r,i,a){this.audioCodec=void 0,this.videoCodec=void 0,this.initSegmentData=void 0,this.duration=void 0,this.defaultInitPts=void 0,this.audioCodec=t,this.videoCodec=e,this.initSegmentData=r,this.duration=i,this.defaultInitPts=a},Rt=function(t,e,r,i,a,n){this.discontinuity=void 0,this.contiguous=void 0,this.accurateTimeOffset=void 0,this.trackSwitch=void 0,this.timeOffset=void 0,this.initSegmentChange=void 0,this.discontinuity=t,this.contiguous=e,this.accurateTimeOffset=r,this.trackSwitch=i,this.timeOffset=a,this.initSegmentChange=n}},function(t,e){t.exports=void 0},function(t,e,r){var i,a,n,s,o;i=/^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#[^]*)?$/,a=/^([^\/?#]*)([^]*)$/,n=/(?:\/|^)\.(?=\/)/g,s=/(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g,o={buildAbsoluteURL:function(t,e,r){if(r=r||{},t=t.trim(),!(e=e.trim())){if(!r.alwaysNormalize)return t;var i=o.parseURL(t);if(!i)throw new Error("Error trying to parse base URL.");return i.path=o.normalizePath(i.path),o.buildURLFromParts(i)}var n=o.parseURL(e);if(!n)throw new Error("Error trying to parse relative URL.");if(n.scheme)return r.alwaysNormalize?(n.path=o.normalizePath(n.path),o.buildURLFromParts(n)):e;var s=o.parseURL(t);if(!s)throw new Error("Error trying to parse base URL.");if(!s.netLoc&&s.path&&"/"!==s.path[0]){var l=a.exec(s.path);s.netLoc=l[1],s.path=l[2]}s.netLoc&&!s.path&&(s.path="/");var u={scheme:s.scheme,netLoc:n.netLoc,path:null,params:n.params,query:n.query,fragment:n.fragment};if(!n.netLoc&&(u.netLoc=s.netLoc,"/"!==n.path[0]))if(n.path){var d=s.path,h=d.substring(0,d.lastIndexOf("/")+1)+n.path;u.path=o.normalizePath(h)}else u.path=s.path,n.params||(u.params=s.params,n.query||(u.query=s.query));return null===u.path&&(u.path=r.alwaysNormalize?o.normalizePath(n.path):n.path),o.buildURLFromParts(u)},parseURL:function(t){var e=i.exec(t);return e?{scheme:e[1]||"",netLoc:e[2]||"",path:e[3]||"",params:e[4]||"",query:e[5]||"",fragment:e[6]||""}:null},normalizePath:function(t){for(t=t.split("").reverse().join("").replace(n,"");t.length!==(t=t.replace(s,"")).length;);return t.split("").reverse().join("")},buildURLFromParts:function(t){return t.scheme+t.netLoc+t.path+t.params+t.query+t.fragment}},t.exports=o},function(t,e,r){"use strict";r.d(e,"a",(function(){return i}));var i=function(){this.aborted=!1,this.loaded=0,this.retry=0,this.total=0,this.chunkCount=0,this.bwEstimate=0,this.loading={start:0,first:0,end:0},this.parsing={start:0,end:0},this.buffering={start:0,first:0,end:0}}},function(t,e,r){"use strict";var i=Object.prototype.hasOwnProperty,a="~";function n(){}function s(t,e,r){this.fn=t,this.context=e,this.once=r||!1}function o(t,e,r,i,n){if("function"!=typeof r)throw new TypeError("The listener must be a function");var o=new s(r,i||t,n),l=a?a+e:e;return t._events[l]?t._events[l].fn?t._events[l]=[t._events[l],o]:t._events[l].push(o):(t._events[l]=o,t._eventsCount++),t}function l(t,e){0==--t._eventsCount?t._events=new n:delete t._events[e]}function u(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(a=!1)),u.prototype.eventNames=function(){var t,e,r=[];if(0===this._eventsCount)return r;for(e in t=this._events)i.call(t,e)&&r.push(a?e.slice(1):e);return Object.getOwnPropertySymbols?r.concat(Object.getOwnPropertySymbols(t)):r},u.prototype.listeners=function(t){var e=a?a+t:t,r=this._events[e];if(!r)return[];if(r.fn)return[r.fn];for(var i=0,n=r.length,s=new Array(n);i<n;i++)s[i]=r[i].fn;return s},u.prototype.listenerCount=function(t){var e=a?a+t:t,r=this._events[e];return r?r.fn?1:r.length:0},u.prototype.emit=function(t,e,r,i,n,s){var o=a?a+t:t;if(!this._events[o])return!1;var l,u,d=this._events[o],h=arguments.length;if(d.fn){switch(d.once&&this.removeListener(t,d.fn,void 0,!0),h){case 1:return d.fn.call(d.context),!0;case 2:return d.fn.call(d.context,e),!0;case 3:return d.fn.call(d.context,e,r),!0;case 4:return d.fn.call(d.context,e,r,i),!0;case 5:return d.fn.call(d.context,e,r,i,n),!0;case 6:return d.fn.call(d.context,e,r,i,n,s),!0}for(u=1,l=new Array(h-1);u<h;u++)l[u-1]=arguments[u];d.fn.apply(d.context,l)}else{var f,c=d.length;for(u=0;u<c;u++)switch(d[u].once&&this.removeListener(t,d[u].fn,void 0,!0),h){case 1:d[u].fn.call(d[u].context);break;case 2:d[u].fn.call(d[u].context,e);break;case 3:d[u].fn.call(d[u].context,e,r);break;case 4:d[u].fn.call(d[u].context,e,r,i);break;default:if(!l)for(f=1,l=new Array(h-1);f<h;f++)l[f-1]=arguments[f];d[u].fn.apply(d[u].context,l)}}return!0},u.prototype.on=function(t,e,r){return o(this,t,e,r,!1)},u.prototype.once=function(t,e,r){return o(this,t,e,r,!0)},u.prototype.removeListener=function(t,e,r,i){var n=a?a+t:t;if(!this._events[n])return this;if(!e)return l(this,n),this;var s=this._events[n];if(s.fn)s.fn!==e||i&&!s.once||r&&s.context!==r||l(this,n);else{for(var o=0,u=[],d=s.length;o<d;o++)(s[o].fn!==e||i&&!s[o].once||r&&s[o].context!==r)&&u.push(s[o]);u.length?this._events[n]=1===u.length?u[0]:u:l(this,n)}return this},u.prototype.removeAllListeners=function(t){var e;return t?(e=a?a+t:t,this._events[e]&&l(this,e)):(this._events=new n,this._eventsCount=0),this},u.prototype.off=u.prototype.removeListener,u.prototype.addListener=u.prototype.on,u.prefixed=a,u.EventEmitter=u,t.exports=u},function(t,e,r){"use strict";r.d(e,"a",(function(){return u}));var i=function(){function t(t,e){this.subtle=void 0,this.aesIV=void 0,this.subtle=t,this.aesIV=e}return t.prototype.decrypt=function(t,e){return this.subtle.decrypt({name:"AES-CBC",iv:this.aesIV},e,t)},t}(),a=function(){function t(t,e){this.subtle=void 0,this.key=void 0,this.subtle=t,this.key=e}return t.prototype.expandKey=function(){return this.subtle.importKey("raw",this.key,{name:"AES-CBC"},!1,["encrypt","decrypt"])},t}(),n=r(8),s=function(){function t(){this.rcon=[0,1,2,4,8,16,32,64,128,27,54],this.subMix=[new Uint32Array(256),new Uint32Array(256),new Uint32Array(256),new Uint32Array(256)],this.invSubMix=[new Uint32Array(256),new Uint32Array(256),new Uint32Array(256),new Uint32Array(256)],this.sBox=new Uint32Array(256),this.invSBox=new Uint32Array(256),this.key=new Uint32Array(0),this.ksRows=0,this.keySize=0,this.keySchedule=void 0,this.invKeySchedule=void 0,this.initTable()}var e=t.prototype;return e.uint8ArrayToUint32Array_=function(t){for(var e=new DataView(t),r=new Uint32Array(4),i=0;i<4;i++)r[i]=e.getUint32(4*i);return r},e.initTable=function(){var t=this.sBox,e=this.invSBox,r=this.subMix,i=r[0],a=r[1],n=r[2],s=r[3],o=this.invSubMix,l=o[0],u=o[1],d=o[2],h=o[3],f=new Uint32Array(256),c=0,v=0,g=0;for(g=0;g<256;g++)f[g]=g<128?g<<1:g<<1^283;for(g=0;g<256;g++){var p=v^v<<1^v<<2^v<<3^v<<4;p=p>>>8^255&p^99,t[c]=p,e[p]=c;var m=f[c],y=f[m],b=f[y],T=257*f[p]^16843008*p;i[c]=T<<24|T>>>8,a[c]=T<<16|T>>>16,n[c]=T<<8|T>>>24,s[c]=T,T=16843009*b^65537*y^257*m^16843008*c,l[p]=T<<24|T>>>8,u[p]=T<<16|T>>>16,d[p]=T<<8|T>>>24,h[p]=T,c?(c=m^f[f[f[b^m]]],v^=f[f[v]]):c=v=1}},e.expandKey=function(t){for(var e=this.uint8ArrayToUint32Array_(t),r=!0,i=0;i<e.length&&r;)r=e[i]===this.key[i],i++;if(!r){this.key=e;var a=this.keySize=e.length;if(4!==a&&6!==a&&8!==a)throw new Error("Invalid aes key size="+a);var n,s,o,l,u=this.ksRows=4*(a+6+1),d=this.keySchedule=new Uint32Array(u),h=this.invKeySchedule=new Uint32Array(u),f=this.sBox,c=this.rcon,v=this.invSubMix,g=v[0],p=v[1],m=v[2],y=v[3];for(n=0;n<u;n++)n<a?o=d[n]=e[n]:(l=o,n%a==0?(l=f[(l=l<<8|l>>>24)>>>24]<<24|f[l>>>16&255]<<16|f[l>>>8&255]<<8|f[255&l],l^=c[n/a|0]<<24):a>6&&n%a==4&&(l=f[l>>>24]<<24|f[l>>>16&255]<<16|f[l>>>8&255]<<8|f[255&l]),d[n]=o=(d[n-a]^l)>>>0);for(s=0;s<u;s++)n=u-s,l=3&s?d[n]:d[n-4],h[s]=s<4||n<=4?l:g[f[l>>>24]]^p[f[l>>>16&255]]^m[f[l>>>8&255]]^y[f[255&l]],h[s]=h[s]>>>0}},e.networkToHostOrderSwap=function(t){return t<<24|(65280&t)<<8|(16711680&t)>>8|t>>>24},e.decrypt=function(t,e,r){for(var i,a,n,s,o,l,u,d,h,f,c,v,g,p,m=this.keySize+6,y=this.invKeySchedule,b=this.invSBox,T=this.invSubMix,E=T[0],S=T[1],L=T[2],A=T[3],R=this.uint8ArrayToUint32Array_(r),D=R[0],_=R[1],k=R[2],x=R[3],w=new Int32Array(t),C=new Int32Array(w.length),O=this.networkToHostOrderSwap;e<w.length;){for(h=O(w[e]),f=O(w[e+1]),c=O(w[e+2]),v=O(w[e+3]),o=h^y[0],l=v^y[1],u=c^y[2],d=f^y[3],g=4,p=1;p<m;p++)i=E[o>>>24]^S[l>>16&255]^L[u>>8&255]^A[255&d]^y[g],a=E[l>>>24]^S[u>>16&255]^L[d>>8&255]^A[255&o]^y[g+1],n=E[u>>>24]^S[d>>16&255]^L[o>>8&255]^A[255&l]^y[g+2],s=E[d>>>24]^S[o>>16&255]^L[l>>8&255]^A[255&u]^y[g+3],o=i,l=a,u=n,d=s,g+=4;i=b[o>>>24]<<24^b[l>>16&255]<<16^b[u>>8&255]<<8^b[255&d]^y[g],a=b[l>>>24]<<24^b[u>>16&255]<<16^b[d>>8&255]<<8^b[255&o]^y[g+1],n=b[u>>>24]<<24^b[d>>16&255]<<16^b[o>>8&255]<<8^b[255&l]^y[g+2],s=b[d>>>24]<<24^b[o>>16&255]<<16^b[l>>8&255]<<8^b[255&u]^y[g+3],C[e]=O(i^D),C[e+1]=O(s^_),C[e+2]=O(n^k),C[e+3]=O(a^x),D=h,_=f,k=c,x=v,e+=4}return C.buffer},t}(),o=r(1),l=r(6),u=function(){function t(t,e,r){var i=(void 0===r?{}:r).removePKCS7Padding,a=void 0===i||i;if(this.logEnabled=!0,this.observer=void 0,this.config=void 0,this.removePKCS7Padding=void 0,this.subtle=null,this.softwareDecrypter=null,this.key=null,this.fastAesKey=null,this.remainderData=null,this.currentIV=null,this.currentResult=null,this.observer=t,this.config=e,this.removePKCS7Padding=a,a)try{var n=self.crypto;n&&(this.subtle=n.subtle||n.webkitSubtle)}catch(t){}null===this.subtle&&(this.config.enableSoftwareAES=!0)}var e=t.prototype;return e.destroy=function(){this.observer=null},e.isSync=function(){return this.config.enableSoftwareAES},e.flush=function(){var t=this.currentResult;if(t){var e,r,i,a=new Uint8Array(t);return this.reset(),this.removePKCS7Padding?(i=(r=(e=a).byteLength)&&new DataView(e.buffer).getUint8(r-1))?Object(n.a)(e,0,r-i):e:a}this.reset()},e.reset=function(){this.currentResult=null,this.currentIV=null,this.remainderData=null,this.softwareDecrypter&&(this.softwareDecrypter=null)},e.decrypt=function(t,e,r,i){if(this.config.enableSoftwareAES){this.softwareDecrypt(new Uint8Array(t),e,r);var a=this.flush();a&&i(a.buffer)}else this.webCryptoDecrypt(new Uint8Array(t),e,r).then(i)},e.softwareDecrypt=function(t,e,r){var i=this.currentIV,a=this.currentResult,o=this.remainderData;this.logOnce("JS AES decrypt"),o&&(t=Object(l.a)(o,t),this.remainderData=null);var u=this.getValidChunk(t);if(!u.length)return null;i&&(r=i);var d=this.softwareDecrypter;d||(d=this.softwareDecrypter=new s),d.expandKey(e);var h=a;return this.currentResult=d.decrypt(u.buffer,0,r),this.currentIV=Object(n.a)(u,-16).buffer,h||null},e.webCryptoDecrypt=function(t,e,r){var n=this,s=this.subtle;return this.key===e&&this.fastAesKey||(this.key=e,this.fastAesKey=new a(s,e)),this.fastAesKey.expandKey().then((function(e){return s?new i(s,r).decrypt(t.buffer,e):Promise.reject(new Error("web crypto not initialized"))})).catch((function(i){return n.onWebCryptoError(i,t,e,r)}))},e.onWebCryptoError=function(t,e,r,i){return o.b.warn("[decrypter.ts]: WebCrypto Error, disable WebCrypto API:",t),this.config.enableSoftwareAES=!0,this.logEnabled=!0,this.softwareDecrypt(e,r,i)},e.getValidChunk=function(t){var e=t,r=t.length-t.length%16;return r!==t.length&&(e=Object(n.a)(t,0,r),this.remainderData=Object(n.a)(t,r)),e},e.logOnce=function(t){this.logEnabled&&(o.b.log("[decrypter.ts]: "+t),this.logEnabled=!1)},t}()},function(t,e,r){"use strict";r.d(e,"a",(function(){return n}));var i=r(11);function a(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var n=function(){function t(t,e){this._uri=null,this.method=null,this.keyFormat=null,this.keyFormatVersions=null,this.keyID=null,this.key=null,this.iv=null,this._uri=e?Object(i.buildAbsoluteURL)(t,e,{alwaysNormalize:!0}):t}var e,r;return t.fromURL=function(e,r){return new t(e,r)},t.fromURI=function(e){return new t(e)},e=t,(r=[{key:"uri",get:function(){return this._uri}}])&&a(e.prototype,r),t}()},function(t,e,r){"use strict";r.d(e,"a",(function(){return i}));var i=function(){function t(){this.chunks=[],this.dataLength=0}var e=t.prototype;return e.push=function(t){this.chunks.push(t),this.dataLength+=t.length},e.flush=function(){var t,e=this.chunks,r=this.dataLength;return e.length?(t=1===e.length?e[0]:function(t,e){for(var r=new Uint8Array(e),i=0,a=0;a<t.length;a++){var n=t[a];r.set(n,i),i+=n.length}return r}(e,r),this.reset(),t):new Uint8Array(0)},e.reset=function(){this.chunks.length=0,this.dataLength=0},t}()},function(t,e,r){function i(t){var e={};function r(i){if(e[i])return e[i].exports;var a=e[i]={i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.m=t,r.c=e,r.i=function(t){return t},r.d=function(t,e,i){r.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},r.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="/",r.oe=function(t){throw console.error(t),t};var i=r(r.s=ENTRY_MODULE);return i.default||i}function a(t){return(t+"").replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}function n(t,e,i){var n={};n[i]=[];var s=e.toString(),o=s.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/);if(!o)return n;for(var l,u=o[1],d=new RegExp("(\\\\n|\\W)"+a(u)+"\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)","g");l=d.exec(s);)"dll-reference"!==l[3]&&n[i].push(l[3]);for(d=new RegExp("\\("+a(u)+'\\("(dll-reference\\s([\\.|\\-|\\+|\\w|/|@]+))"\\)\\)\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)',"g");l=d.exec(s);)t[l[2]]||(n[i].push(l[1]),t[l[2]]=r(l[1]).m),n[l[2]]=n[l[2]]||[],n[l[2]].push(l[4]);for(var h,f=Object.keys(n),c=0;c<f.length;c++)for(var v=0;v<n[f[c]].length;v++)h=n[f[c]][v],isNaN(1*h)||(n[f[c]][v]=1*n[f[c]][v]);return n}function s(t){return Object.keys(t).reduce((function(e,r){return e||t[r].length>0}),!1)}t.exports=function(t,e){e=e||{};var a={main:r.m},o=e.all?{main:Object.keys(a.main)}:function(t,e){for(var r={main:[e]},i={main:[]},a={main:{}};s(r);)for(var o=Object.keys(r),l=0;l<o.length;l++){var u=o[l],d=r[u].pop();if(a[u]=a[u]||{},!a[u][d]&&t[u][d]){a[u][d]=!0,i[u]=i[u]||[],i[u].push(d);for(var h=n(t,t[u][d],u),f=Object.keys(h),c=0;c<f.length;c++)r[f[c]]=r[f[c]]||[],r[f[c]]=r[f[c]].concat(h[f[c]])}}return i}(a,t),l="";Object.keys(o).filter((function(t){return"main"!==t})).forEach((function(t){for(var e=0;o[t][e];)e++;o[t].push(e),a[t][e]="(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })",l=l+"var "+t+" = ("+i.toString().replace("ENTRY_MODULE",JSON.stringify(e))+")({"+o[t].map((function(e){return JSON.stringify(e)+": "+a[t][e].toString()})).join(",")+"});\n"})),l=l+"new (("+i.toString().replace("ENTRY_MODULE",JSON.stringify(t))+")({"+o.main.map((function(t){return JSON.stringify(t)+": "+a.main[t].toString()})).join(",")+"}))(self);";var u=new window.Blob([l],{type:"text/javascript"});if(e.bare)return u;var d=(window.URL||window.webkitURL||window.mozURL||window.msURL).createObjectURL(u),h=new window.Worker(d);return h.objectURL=d,h}},function(t,e,r){"use strict";r.r(e),r.d(e,"default",(function(){return o}));var i=r(9),a=r(0),n=r(1),s=r(13);function o(t){var e=new s.EventEmitter,r=function(e,r){t.postMessage({event:e,data:r})};e.on(a.a.FRAG_DECRYPTED,r),e.on(a.a.ERROR,r),t.addEventListener("message",(function(a){var s=a.data;switch(s.cmd){case"init":var o=JSON.parse(s.config);t.transmuxer=new i.c(e,s.typeSupported,o,s.vendor,s.id),Object(n.a)(o.debug),r("init",null);break;case"configure":t.transmuxer.configure(s.config);break;case"demux":var u=t.transmuxer.push(s.data,s.decryptdata,s.chunkMeta,s.state);Object(i.d)(u)?u.then((function(e){l(t,e)})):l(t,u);break;case"flush":var h=s.chunkMeta,f=t.transmuxer.flush(h);Object(i.d)(f)?f.then((function(e){d(t,e,h)})):d(t,f,h)}}))}function l(t,e){if((r=e.remuxResult).audio||r.video||r.text||r.id3||r.initSegment){var r,i=[],a=e.remuxResult,n=a.audio,s=a.video;n&&u(i,n),s&&u(i,s),t.postMessage({event:"transmuxComplete",data:e},i)}}function u(t,e){e.data1&&t.push(e.data1.buffer),e.data2&&t.push(e.data2.buffer)}function d(t,e,r){e.forEach((function(e){l(t,e)})),t.postMessage({event:"flush",data:r})}},function(t,e,r){"use strict";r.r(e),r.d(e,"default",(function(){return xe}));var i=r(11),a=r(3),n=r(0),s=r(2),o=r(1),l=r(6),u=r(5);function d(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var h=function(){function t(t){this.PTSKnown=!1,this.alignedSliding=!1,this.averagetargetduration=void 0,this.endCC=0,this.endSN=0,this.fragments=void 0,this.fragmentHint=void 0,this.partList=null,this.live=!0,this.ageHeader=0,this.advancedDateTime=void 0,this.updated=!0,this.advanced=!0,this.availabilityDelay=void 0,this.misses=0,this.needSidxRanges=!1,this.startCC=0,this.startSN=0,this.startTimeOffset=null,this.targetduration=0,this.totalduration=0,this.type=null,this.url=void 0,this.m3u8="",this.version=null,this.canBlockReload=!1,this.canSkipUntil=0,this.canSkipDateRanges=!1,this.skippedSegments=0,this.recentlyRemovedDateranges=void 0,this.partHoldBack=0,this.holdBack=0,this.partTarget=0,this.preloadHint=void 0,this.renditionReports=void 0,this.tuneInGoal=0,this.deltaUpdateFailed=void 0,this.driftStartTime=0,this.driftEndTime=0,this.driftStart=0,this.driftEnd=0,this.fragments=[],this.url=t}var e,r;return t.prototype.reloaded=function(t){if(!t)return this.advanced=!0,void(this.updated=!0);var e=this.lastPartSn-t.lastPartSn,r=this.lastPartIndex-t.lastPartIndex;this.updated=this.endSN!==t.endSN||!!r||!!e,this.advanced=this.endSN>t.endSN||e>0||0===e&&r>0,this.updated||this.advanced?this.misses=Math.floor(.6*t.misses):this.misses=t.misses+1,this.availabilityDelay=t.availabilityDelay},e=t,(r=[{key:"hasProgramDateTime",get:function(){return!!this.fragments.length&&Object(a.a)(this.fragments[this.fragments.length-1].programDateTime)}},{key:"levelTargetDuration",get:function(){return this.averagetargetduration||this.targetduration||10}},{key:"drift",get:function(){var t=this.driftEndTime-this.driftStartTime;return t>0?1e3*(this.driftEnd-this.driftStart)/t:1}},{key:"edge",get:function(){return this.partEnd||this.fragmentEnd}},{key:"partEnd",get:function(){var t;return null!==(t=this.partList)&&void 0!==t&&t.length?this.partList[this.partList.length-1].end:this.fragmentEnd}},{key:"fragmentEnd",get:function(){var t;return null!==(t=this.fragments)&&void 0!==t&&t.length?this.fragments[this.fragments.length-1].end:0}},{key:"age",get:function(){return this.advancedDateTime?Math.max(Date.now()-this.advancedDateTime,0)/1e3:0}},{key:"lastPartIndex",get:function(){var t;return null!==(t=this.partList)&&void 0!==t&&t.length?this.partList[this.partList.length-1].index:-1}},{key:"lastPartSn",get:function(){var t;return null!==(t=this.partList)&&void 0!==t&&t.length?this.partList[this.partList.length-1].fragment.sn:this.endSN}}])&&d(e.prototype,r),t}(),f=r(15),c=/^(\d+)x(\d+)$/,v=/\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,g=function(){function t(e){for(var r in"string"==typeof e&&(e=t.parseAttrList(e)),e)e.hasOwnProperty(r)&&(this[r]=e[r])}var e=t.prototype;return e.decimalInteger=function(t){var e=parseInt(this[t],10);return e>Number.MAX_SAFE_INTEGER?1/0:e},e.hexadecimalInteger=function(t){if(this[t]){var e=(this[t]||"0x").slice(2);e=(1&e.length?"0":"")+e;for(var r=new Uint8Array(e.length/2),i=0;i<e.length/2;i++)r[i]=parseInt(e.slice(2*i,2*i+2),16);return r}return null},e.hexadecimalIntegerAsNumber=function(t){var e=parseInt(this[t],16);return e>Number.MAX_SAFE_INTEGER?1/0:e},e.decimalFloatingPoint=function(t){return parseFloat(this[t])},e.optionalFloat=function(t,e){var r=this[t];return r?parseFloat(r):e},e.enumeratedString=function(t){return this[t]},e.bool=function(t){return"YES"===this[t]},e.decimalResolution=function(t){var e=c.exec(this[t]);if(null!==e)return{width:parseInt(e[1],10),height:parseInt(e[2],10)}},t.parseAttrList=function(t){var e,r={};for(v.lastIndex=0;null!==(e=v.exec(t));){var i=e[2];0===i.indexOf('"')&&i.lastIndexOf('"')===i.length-1&&(i=i.slice(1,-1)),r[e[1]]=i}return r},t}(),p={audio:{a3ds:!0,"ac-3":!0,"ac-4":!0,alac:!0,alaw:!0,dra1:!0,"dts+":!0,"dts-":!0,dtsc:!0,dtse:!0,dtsh:!0,"ec-3":!0,enca:!0,g719:!0,g726:!0,m4ae:!0,mha1:!0,mha2:!0,mhm1:!0,mhm2:!0,mlpa:!0,mp4a:!0,"raw ":!0,Opus:!0,samr:!0,sawb:!0,sawp:!0,sevc:!0,sqcp:!0,ssmv:!0,twos:!0,ulaw:!0},video:{avc1:!0,avc2:!0,avc3:!0,avc4:!0,avcp:!0,av01:!0,drac:!0,dvav:!0,dvhe:!0,encv:!0,hev1:!0,hvc1:!0,mjp2:!0,mp4v:!0,mvc1:!0,mvc2:!0,mvc3:!0,mvc4:!0,resv:!0,rv60:!0,s263:!0,svc1:!0,svc2:!0,"vc-1":!0,vp08:!0,vp09:!0},text:{stpp:!0,wvtt:!0}};function m(t,e){return MediaSource.isTypeSupported((e||"video")+'/mp4;codecs="'+t+'"')}var y=/#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+/g,b=/#EXT-X-MEDIA:(.*)/g,T=new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,/(?!#) *(\S[\S ]*)/.source,/#EXT-X-BYTERANGE:*(.+)/.source,/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,/#.*/.source].join("|"),"g"),E=new RegExp([/#(EXTM3U)/.source,/#EXT-X-(PLAYLIST-TYPE):(.+)/.source,/#EXT-X-(MEDIA-SEQUENCE): *(\d+)/.source,/#EXT-X-(SKIP):(.+)/.source,/#EXT-X-(TARGETDURATION): *(\d+)/.source,/#EXT-X-(KEY):(.+)/.source,/#EXT-X-(START):(.+)/.source,/#EXT-X-(ENDLIST)/.source,/#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\d+)/.source,/#EXT-X-(DIS)CONTINUITY/.source,/#EXT-X-(VERSION):(\d+)/.source,/#EXT-X-(MAP):(.+)/.source,/#EXT-X-(SERVER-CONTROL):(.+)/.source,/#EXT-X-(PART-INF):(.+)/.source,/#EXT-X-(GAP)/.source,/#EXT-X-(BITRATE):\s*(\d+)/.source,/#EXT-X-(PART):(.+)/.source,/#EXT-X-(PRELOAD-HINT):(.+)/.source,/#EXT-X-(RENDITION-REPORT):(.+)/.source,/(#)([^:]*):(.*)/.source,/(#)(.*)(?:.*)\r?\n?/.source].join("|")),S=/\.(mp4|m4s|m4v|m4a)$/i,L=function(){function t(){}return t.findGroup=function(t,e){for(var r=0;r<t.length;r++){var i=t[r];if(i.id===e)return i}},t.convertAVC1ToAVCOTI=function(t){var e=t.split(".");if(e.length>2){var r=e.shift()+".";return(r+=parseInt(e.shift()).toString(16))+("000"+parseInt(e.shift()).toString(16)).substr(-4)}return t},t.resolve=function(t,e){return i.buildAbsoluteURL(e,t,{alwaysNormalize:!0})},t.parseMasterPlaylist=function(e,r){var i,a=[],n={},s=!1;for(y.lastIndex=0;null!=(i=y.exec(e));)if(i[1]){var o=new g(i[1]),l={attrs:o,bitrate:o.decimalInteger("AVERAGE-BANDWIDTH")||o.decimalInteger("BANDWIDTH"),name:o.NAME,url:t.resolve(i[2],r)},u=o.decimalResolution("RESOLUTION");u&&(l.width=u.width,l.height=u.height),A((o.CODECS||"").split(/[ ,]+/).filter((function(t){return t})),l),l.videoCodec&&-1!==l.videoCodec.indexOf("avc1")&&(l.videoCodec=t.convertAVC1ToAVCOTI(l.videoCodec)),a.push(l)}else if(i[3]){var d=new g(i[3]);d["DATA-ID"]&&(s=!0,n[d["DATA-ID"]]=d)}return{levels:a,sessionData:s?n:null}},t.parseMasterPlaylistMedia=function(e,r,i,a){var n;void 0===a&&(a=[]);var s=[],o=0;for(b.lastIndex=0;null!==(n=b.exec(e));){var l=new g(n[1]);if(l.TYPE===i){var u={attrs:l,bitrate:0,id:o++,groupId:l["GROUP-ID"],instreamId:l["INSTREAM-ID"],name:l.NAME||l.LANGUAGE||"",type:i,default:l.bool("DEFAULT"),autoselect:l.bool("AUTOSELECT"),forced:l.bool("FORCED"),lang:l.LANGUAGE,url:l.URI?t.resolve(l.URI,r):""};if(a.length){var d=t.findGroup(a,u.groupId)||a[0];R(u,d,"audioCodec"),R(u,d,"textCodec")}s.push(u)}}return s},t.parseLevelPlaylist=function(t,e,r,n,s){var l,d,c,v=new h(e),p=v.fragments,m=null,y=0,b=0,L=0,A=0,R=null,_=new u.b(n,e),k=-1,x=!1;for(T.lastIndex=0,v.m3u8=t;null!==(l=T.exec(t));){x&&(x=!1,(_=new u.b(n,e)).start=L,_.sn=y,_.cc=A,_.level=r,m&&(_.initSegment=m,_.rawProgramDateTime=m.rawProgramDateTime));var w=l[1];if(w){_.duration=parseFloat(w);var C=(" "+l[2]).slice(1);_.title=C||null,_.tagList.push(C?["INF",w,C]:["INF",w])}else if(l[3])Object(a.a)(_.duration)&&(_.start=L,c&&(_.levelkey=c),_.sn=y,_.level=r,_.cc=A,_.urlId=s,p.push(_),_.relurl=(" "+l[3]).slice(1),D(_,R),R=_,L+=_.duration,y++,b=0,x=!0);else if(l[4]){var O=(" "+l[4]).slice(1);R?_.setByteRange(O,R):_.setByteRange(O)}else if(l[5])_.rawProgramDateTime=(" "+l[5]).slice(1),_.tagList.push(["PROGRAM-DATE-TIME",_.rawProgramDateTime]),-1===k&&(k=p.length);else{if(!(l=l[0].match(E))){o.b.warn("No matches on slow regex match for level playlist!");continue}for(d=1;d<l.length&&void 0===l[d];d++);var I=(" "+l[d]).slice(1),P=(" "+l[d+1]).slice(1),F=l[d+2]?(" "+l[d+2]).slice(1):"";switch(I){case"PLAYLIST-TYPE":v.type=P.toUpperCase();break;case"MEDIA-SEQUENCE":y=v.startSN=parseInt(P);break;case"SKIP":var M=new g(P),N=M.decimalInteger("SKIPPED-SEGMENTS");if(Object(a.a)(N)){v.skippedSegments=N;for(var B=N;B--;)p.unshift(null);y+=N}var U=M.enumeratedString("RECENTLY-REMOVED-DATERANGES");U&&(v.recentlyRemovedDateranges=U.split("\t"));break;case"TARGETDURATION":v.targetduration=parseFloat(P);break;case"VERSION":v.version=parseInt(P);break;case"EXTM3U":break;case"ENDLIST":v.live=!1;break;case"#":(P||F)&&_.tagList.push(F?[P,F]:[P]);break;case"DIS":A++;case"GAP":_.tagList.push([I]);break;case"BITRATE":_.tagList.push([I,P]);break;case"DISCONTINUITY-SEQ":A=parseInt(P);break;case"KEY":var G,j=new g(P),H=j.enumeratedString("METHOD"),K=j.URI,V=j.hexadecimalInteger("IV"),W=j.enumeratedString("KEYFORMATVERSIONS"),Y=j.enumeratedString("KEYID"),X=null!=(G=j.enumeratedString("KEYFORMAT"))?G:"identity";if(["com.apple.streamingkeydelivery","com.microsoft.playready","urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed","com.widevine"].indexOf(X)>-1){o.b.warn("Keyformat "+X+" is not supported from the manifest");continue}if("identity"!==X)continue;H&&(c=f.a.fromURL(e,K),K&&["AES-128","SAMPLE-AES","SAMPLE-AES-CENC"].indexOf(H)>=0&&(c.method=H,c.keyFormat=X,Y&&(c.keyID=Y),W&&(c.keyFormatVersions=W),c.iv=V));break;case"START":var q=new g(P).decimalFloatingPoint("TIME-OFFSET");Object(a.a)(q)&&(v.startTimeOffset=q);break;case"MAP":var z=new g(P);_.relurl=z.URI,z.BYTERANGE&&_.setByteRange(z.BYTERANGE),_.level=r,_.sn="initSegment",c&&(_.levelkey=c),_.initSegment=null,m=_,x=!0;break;case"SERVER-CONTROL":var Q=new g(P);v.canBlockReload=Q.bool("CAN-BLOCK-RELOAD"),v.canSkipUntil=Q.optionalFloat("CAN-SKIP-UNTIL",0),v.canSkipDateRanges=v.canSkipUntil>0&&Q.bool("CAN-SKIP-DATERANGES"),v.partHoldBack=Q.optionalFloat("PART-HOLD-BACK",0),v.holdBack=Q.optionalFloat("HOLD-BACK",0);break;case"PART-INF":var $=new g(P);v.partTarget=$.decimalFloatingPoint("PART-TARGET");break;case"PART":var Z=v.partList;Z||(Z=v.partList=[]);var J=b>0?Z[Z.length-1]:void 0,tt=b++,et=new u.c(new g(P),_,e,tt,J);Z.push(et),_.duration+=et.duration;break;case"PRELOAD-HINT":var rt=new g(P);v.preloadHint=rt;break;case"RENDITION-REPORT":var it=new g(P);v.renditionReports=v.renditionReports||[],v.renditionReports.push(it);break;default:o.b.warn("line parsed but not handled: "+l)}}}R&&!R.relurl?(p.pop(),L-=R.duration,v.partList&&(v.fragmentHint=R)):v.partList&&(D(_,R),_.cc=A,v.fragmentHint=_);var at=p.length,nt=p[0],st=p[at-1];if((L+=v.skippedSegments*v.targetduration)>0&&at&&st){v.averagetargetduration=L/at;var ot=st.sn;v.endSN="initSegment"!==ot?ot:0,nt&&(v.startCC=nt.cc,nt.initSegment||v.fragments.every((function(t){return t.relurl&&(e=t.relurl,S.test(null!=(r=null===(a=i.parseURL(e))||void 0===a?void 0:a.path)?r:""));var e,r,a}))&&(o.b.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"),(_=new u.b(n,e)).relurl=st.relurl,_.level=r,_.sn="initSegment",nt.initSegment=_,v.needSidxRanges=!0))}else v.endSN=0,v.startCC=0;return v.fragmentHint&&(L+=v.fragmentHint.duration),v.totalduration=L,v.endCC=A,k>0&&function(t,e){for(var r=t[e],i=e;i--;){var a=t[i];if(!a)return;a.programDateTime=r.programDateTime-1e3*a.duration,r=a}}(p,k),v},t}();function A(t,e){["video","audio","text"].forEach((function(r){var i=t.filter((function(t){return function(t,e){var r=p[e];return!!r&&!0===r[t.slice(0,4)]}(t,r)}));if(i.length){var a=i.filter((function(t){return 0===t.lastIndexOf("avc1",0)||0===t.lastIndexOf("mp4a",0)}));e[r+"Codec"]=a.length>0?a[0]:i[0],t=t.filter((function(t){return-1===i.indexOf(t)}))}})),e.unknownCodecs=t}function R(t,e,r){var i=e[r];i&&(t[r]=i)}function D(t,e){t.rawProgramDateTime?t.programDateTime=Date.parse(t.rawProgramDateTime):null!=e&&e.programDateTime&&(t.programDateTime=e.endProgramDateTime),Object(a.a)(t.programDateTime)||(t.programDateTime=null,t.rawProgramDateTime=null)}var _=r(4);function k(t,e){var r=t.url;return void 0!==r&&0!==r.indexOf("data:")||(r=e.url),r}var x=function(){function t(t){this.hls=void 0,this.loaders=Object.create(null),this.hls=t,this.registerListeners()}var e=t.prototype;return e.registerListeners=function(){var t=this.hls;t.on(n.a.MANIFEST_LOADING,this.onManifestLoading,this),t.on(n.a.LEVEL_LOADING,this.onLevelLoading,this),t.on(n.a.AUDIO_TRACK_LOADING,this.onAudioTrackLoading,this),t.on(n.a.SUBTITLE_TRACK_LOADING,this.onSubtitleTrackLoading,this)},e.unregisterListeners=function(){var t=this.hls;t.off(n.a.MANIFEST_LOADING,this.onManifestLoading,this),t.off(n.a.LEVEL_LOADING,this.onLevelLoading,this),t.off(n.a.AUDIO_TRACK_LOADING,this.onAudioTrackLoading,this),t.off(n.a.SUBTITLE_TRACK_LOADING,this.onSubtitleTrackLoading,this)},e.createInternalLoader=function(t){var e=this.hls.config,r=e.pLoader,i=e.loader,a=new(r||i)(e);return t.loader=a,this.loaders[t.type]=a,a},e.getInternalLoader=function(t){return this.loaders[t.type]},e.resetInternalLoader=function(t){this.loaders[t]&&delete this.loaders[t]},e.destroyInternalLoaders=function(){for(var t in this.loaders){var e=this.loaders[t];e&&e.destroy(),this.resetInternalLoader(t)}},e.destroy=function(){this.unregisterListeners(),this.destroyInternalLoaders()},e.onManifestLoading=function(t,e){var r=e.url;this.load({id:null,groupId:null,level:0,responseType:"text",type:_.a.MANIFEST,url:r,deliveryDirectives:null})},e.onLevelLoading=function(t,e){var r=e.id,i=e.level,a=e.url,n=e.deliveryDirectives;this.load({id:r,groupId:null,level:i,responseType:"text",type:_.a.LEVEL,url:a,deliveryDirectives:n})},e.onAudioTrackLoading=function(t,e){var r=e.id,i=e.groupId,a=e.url,n=e.deliveryDirectives;this.load({id:r,groupId:i,level:null,responseType:"text",type:_.a.AUDIO_TRACK,url:a,deliveryDirectives:n})},e.onSubtitleTrackLoading=function(t,e){var r=e.id,i=e.groupId,a=e.url,n=e.deliveryDirectives;this.load({id:r,groupId:i,level:null,responseType:"text",type:_.a.SUBTITLE_TRACK,url:a,deliveryDirectives:n})},e.load=function(t){var e,r,i,a,n,s,l=this.hls.config,u=this.getInternalLoader(t);if(u){var d=u.context;if(d&&d.url===t.url)return void o.b.trace("[playlist-loader]: playlist request ongoing");o.b.log("[playlist-loader]: aborting previous loader for type: "+t.type),u.abort()}switch(t.type){case _.a.MANIFEST:r=l.manifestLoadingMaxRetry,i=l.manifestLoadingTimeOut,a=l.manifestLoadingRetryDelay,n=l.manifestLoadingMaxRetryTimeout;break;case _.a.LEVEL:case _.a.AUDIO_TRACK:case _.a.SUBTITLE_TRACK:r=0,i=l.levelLoadingTimeOut;break;default:r=l.levelLoadingMaxRetry,i=l.levelLoadingTimeOut,a=l.levelLoadingRetryDelay,n=l.levelLoadingMaxRetryTimeout}if(u=this.createInternalLoader(t),null!==(e=t.deliveryDirectives)&&void 0!==e&&e.part&&(t.type===_.a.LEVEL&&null!==t.level?s=this.hls.levels[t.level].details:t.type===_.a.AUDIO_TRACK&&null!==t.id?s=this.hls.audioTracks[t.id].details:t.type===_.a.SUBTITLE_TRACK&&null!==t.id&&(s=this.hls.subtitleTracks[t.id].details),s)){var h=s.partTarget,f=s.targetduration;h&&f&&(i=Math.min(1e3*Math.max(3*h,.8*f),i))}var c={timeout:i,maxRetry:r,retryDelay:a,maxRetryDelay:n,highWaterMark:0},v={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this)};u.load(t,c,v)},e.loadsuccess=function(t,e,r,i){if(void 0===i&&(i=null),r.isSidxRequest)return this.handleSidxRequest(t,r),void this.handlePlaylistLoaded(t,e,r,i);this.resetInternalLoader(r.type);var a=t.data;0===a.indexOf("#EXTM3U")?(e.parsing.start=performance.now(),a.indexOf("#EXTINF:")>0||a.indexOf("#EXT-X-TARGETDURATION:")>0?this.handleTrackOrLevelPlaylist(t,e,r,i):this.handleMasterPlaylist(t,e,r,i)):this.handleManifestParsingError(t,r,"no EXTM3U delimiter",i)},e.loaderror=function(t,e,r){void 0===r&&(r=null),this.handleNetworkError(e,r,!1,t)},e.loadtimeout=function(t,e,r){void 0===r&&(r=null),this.handleNetworkError(e,r,!0)},e.handleMasterPlaylist=function(t,e,r,i){var a=this.hls,s=t.data,l=k(t,r),u=L.parseMasterPlaylist(s,l),d=u.levels,h=u.sessionData;if(d.length){var f=d.map((function(t){return{id:t.attrs.AUDIO,audioCodec:t.audioCodec}})),c=d.map((function(t){return{id:t.attrs.SUBTITLES,textCodec:t.textCodec}})),v=L.parseMasterPlaylistMedia(s,l,"AUDIO",f),p=L.parseMasterPlaylistMedia(s,l,"SUBTITLES",c),m=L.parseMasterPlaylistMedia(s,l,"CLOSED-CAPTIONS");v.length&&(v.some((function(t){return!t.url}))||!d[0].audioCodec||d[0].attrs.AUDIO||(o.b.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"),v.unshift({type:"main",name:"main",default:!1,autoselect:!1,forced:!1,id:-1,attrs:new g({}),bitrate:0,url:""}))),a.trigger(n.a.MANIFEST_LOADED,{levels:d,audioTracks:v,subtitles:p,captions:m,url:l,stats:e,networkDetails:i,sessionData:h})}else this.handleManifestParsingError(t,r,"no level found in manifest",i)},e.handleTrackOrLevelPlaylist=function(t,e,r,i){var o=this.hls,l=r.id,u=r.level,d=r.type,h=k(t,r),f=Object(a.a)(l)?l:0,c=Object(a.a)(u)?u:f,v=function(t){switch(t.type){case _.a.AUDIO_TRACK:return _.b.AUDIO;case _.a.SUBTITLE_TRACK:return _.b.SUBTITLE;default:return _.b.MAIN}}(r),p=L.parseLevelPlaylist(t.data,h,c,v,f);if(p.fragments.length){if(d===_.a.MANIFEST){var m={attrs:new g({}),bitrate:0,details:p,name:"",url:h};o.trigger(n.a.MANIFEST_LOADED,{levels:[m],audioTracks:[],url:h,stats:e,networkDetails:i,sessionData:null})}if(e.parsing.end=performance.now(),p.needSidxRanges){var y,b=null===(y=p.fragments[0].initSegment)||void 0===y?void 0:y.url;this.load({url:b,isSidxRequest:!0,type:d,level:u,levelDetails:p,id:l,groupId:null,rangeStart:0,rangeEnd:2048,responseType:"arraybuffer",deliveryDirectives:null})}else r.levelDetails=p,this.handlePlaylistLoaded(t,e,r,i)}else o.trigger(n.a.ERROR,{type:s.b.NETWORK_ERROR,details:s.a.LEVEL_EMPTY_ERROR,fatal:!1,url:h,reason:"no fragments found in level",level:"number"==typeof r.level?r.level:void 0})},e.handleSidxRequest=function(t,e){var r=Object(l.g)(new Uint8Array(t.data));if(r){var i=r.references,a=e.levelDetails;i.forEach((function(t,e){var i=t.info,n=a.fragments[e];0===n.byteRange.length&&n.setByteRange(String(1+i.end-i.start)+"@"+String(i.start)),n.initSegment&&n.initSegment.setByteRange(String(r.moovEndOffset)+"@0")}))}},e.handleManifestParsingError=function(t,e,r,i){this.hls.trigger(n.a.ERROR,{type:s.b.NETWORK_ERROR,details:s.a.MANIFEST_PARSING_ERROR,fatal:e.type===_.a.MANIFEST,url:t.url,reason:r,response:t,context:e,networkDetails:i})},e.handleNetworkError=function(t,e,r,i){void 0===r&&(r=!1),o.b.warn("[playlist-loader]: A network "+(r?"timeout":"error")+" occurred while loading "+t.type+" level: "+t.level+" id: "+t.id+' group-id: "'+t.groupId+'"');var a=s.a.UNKNOWN,l=!1,u=this.getInternalLoader(t);switch(t.type){case _.a.MANIFEST:a=r?s.a.MANIFEST_LOAD_TIMEOUT:s.a.MANIFEST_LOAD_ERROR,l=!0;break;case _.a.LEVEL:a=r?s.a.LEVEL_LOAD_TIMEOUT:s.a.LEVEL_LOAD_ERROR,l=!1;break;case _.a.AUDIO_TRACK:a=r?s.a.AUDIO_TRACK_LOAD_TIMEOUT:s.a.AUDIO_TRACK_LOAD_ERROR,l=!1;break;case _.a.SUBTITLE_TRACK:a=r?s.a.SUBTITLE_TRACK_LOAD_TIMEOUT:s.a.SUBTITLE_LOAD_ERROR,l=!1}u&&this.resetInternalLoader(t.type);var d={type:s.b.NETWORK_ERROR,details:a,fatal:l,url:t.url,loader:u,context:t,networkDetails:e};i&&(d.response=i),this.hls.trigger(n.a.ERROR,d)},e.handlePlaylistLoaded=function(t,e,r,i){var a=r.type,s=r.level,o=r.id,l=r.groupId,u=r.loader,d=r.levelDetails,h=r.deliveryDirectives;if(null!=d&&d.targetduration){if(u)switch(d.live&&(u.getCacheAge&&(d.ageHeader=u.getCacheAge()||0),u.getCacheAge&&!isNaN(d.ageHeader)||(d.ageHeader=0)),a){case _.a.MANIFEST:case _.a.LEVEL:this.hls.trigger(n.a.LEVEL_LOADED,{details:d,level:s||0,id:o||0,stats:e,networkDetails:i,deliveryDirectives:h});break;case _.a.AUDIO_TRACK:this.hls.trigger(n.a.AUDIO_TRACK_LOADED,{details:d,id:o||0,groupId:l||"",stats:e,networkDetails:i,deliveryDirectives:h});break;case _.a.SUBTITLE_TRACK:this.hls.trigger(n.a.SUBTITLE_TRACK_LOADED,{details:d,id:o||0,groupId:l||"",stats:e,networkDetails:i,deliveryDirectives:h})}}else this.handleManifestParsingError(t,r,"invalid target duration",i)},t}(),w=function(){function t(t){this.hls=void 0,this.loaders={},this.decryptkey=null,this.decrypturl=null,this.hls=t,this._registerListeners()}var e=t.prototype;return e._registerListeners=function(){this.hls.on(n.a.KEY_LOADING,this.onKeyLoading,this)},e._unregisterListeners=function(){this.hls.off(n.a.KEY_LOADING,this.onKeyLoading)},e.destroy=function(){for(var t in this._unregisterListeners(),this.loaders){var e=this.loaders[t];e&&e.destroy()}this.loaders={}},e.onKeyLoading=function(t,e){var r=e.frag,i=r.type,a=this.loaders[i];if(r.decryptdata){var s=r.decryptdata.uri;if(s!==this.decrypturl||null===this.decryptkey){var l=this.hls.config;if(a&&(o.b.warn("abort previous key loader for type:"+i),a.abort()),!s)return void o.b.warn("key uri is falsy");var u=l.loader,d=r.loader=this.loaders[i]=new u(l);this.decrypturl=s,this.decryptkey=null;var h={url:s,frag:r,responseType:"arraybuffer"},f={timeout:l.fragLoadingTimeOut,maxRetry:0,retryDelay:l.fragLoadingRetryDelay,maxRetryDelay:l.fragLoadingMaxRetryTimeout,highWaterMark:0},c={onSuccess:this.loadsuccess.bind(this),onError:this.loaderror.bind(this),onTimeout:this.loadtimeout.bind(this)};d.load(h,f,c)}else this.decryptkey&&(r.decryptdata.key=this.decryptkey,this.hls.trigger(n.a.KEY_LOADED,{frag:r}))}else o.b.warn("Missing decryption data on fragment in onKeyLoading")},e.loadsuccess=function(t,e,r){var i=r.frag;i.decryptdata?(this.decryptkey=i.decryptdata.key=new Uint8Array(t.data),i.loader=null,delete this.loaders[i.type],this.hls.trigger(n.a.KEY_LOADED,{frag:i})):o.b.error("after key load, decryptdata unset")},e.loaderror=function(t,e){var r=e.frag,i=r.loader;i&&i.abort(),delete this.loaders[r.type],this.hls.trigger(n.a.ERROR,{type:s.b.NETWORK_ERROR,details:s.a.KEY_LOAD_ERROR,fatal:!1,frag:r,response:t})},e.loadtimeout=function(t,e){var r=e.frag,i=r.loader;i&&i.abort(),delete this.loaders[r.type],this.hls.trigger(n.a.ERROR,{type:s.b.NETWORK_ERROR,details:s.a.KEY_LOAD_TIMEOUT,fatal:!1,frag:r})},t}();function C(t,e){var r;try{r=new Event("addtrack")}catch(t){(r=document.createEvent("Event")).initEvent("addtrack",!1,!1)}r.track=t,e.dispatchEvent(r)}var O=r(7),I=function(){function t(t){this.hls=void 0,this.id3Track=null,this.media=null,this.hls=t,this._registerListeners()}var e=t.prototype;return e.destroy=function(){this._unregisterListeners()},e._registerListeners=function(){var t=this.hls;t.on(n.a.MEDIA_ATTACHED,this.onMediaAttached,this),t.on(n.a.MEDIA_DETACHING,this.onMediaDetaching,this),t.on(n.a.FRAG_PARSING_METADATA,this.onFragParsingMetadata,this),t.on(n.a.BUFFER_FLUSHING,this.onBufferFlushing,this)},e._unregisterListeners=function(){var t=this.hls;t.off(n.a.MEDIA_ATTACHED,this.onMediaAttached,this),t.off(n.a.MEDIA_DETACHING,this.onMediaDetaching,this),t.off(n.a.FRAG_PARSING_METADATA,this.onFragParsingMetadata,this),t.off(n.a.BUFFER_FLUSHING,this.onBufferFlushing,this)},e.onMediaAttached=function(t,e){this.media=e.media},e.onMediaDetaching=function(){this.id3Track&&(function(t){var e=t.mode;if("disabled"===e&&(t.mode="hidden"),t.cues)for(var r=t.cues.length;r--;)t.removeCue(t.cues[r]);"disabled"===e&&(t.mode=e)}(this.id3Track),this.id3Track=null,this.media=null)},e.getID3Track=function(t){if(this.media){for(var e=0;e<t.length;e++){var r=t[e];if("metadata"===r.kind&&"id3"===r.label)return C(r,this.media),r}return this.media.addTextTrack("metadata","id3")}},e.onFragParsingMetadata=function(t,e){if(this.media){var r=e.frag,i=e.samples;this.id3Track||(this.id3Track=this.getID3Track(this.media.textTracks),this.id3Track.mode="hidden");for(var a=self.WebKitDataCue||self.VTTCue||self.TextTrackCue,n=0;n<i.length;n++){var s=O.c(i[n].data);if(s){var o=i[n].pts,l=n<i.length-1?i[n+1].pts:r.end;l-o<=0&&(l=o+.25);for(var u=0;u<s.length;u++){var d=s[u];if(!O.e(d)){var h=new a(o,l,"");h.value=d,this.id3Track.addCue(h)}}}}}},e.onBufferFlushing=function(t,e){var r=e.startOffset,i=e.endOffset,a=e.type;if(!a||"audio"===a){var n=this.id3Track;n&&function(t,e,r){var i=t.mode;if("disabled"===i&&(t.mode="hidden"),t.cues&&t.cues.length>0)for(var a=function(t,e,r){var i=[],a=function(t,e){if(e<t[0].startTime)return 0;var r=t.length-1;if(e>t[r].endTime)return-1;for(var i=0,a=r;i<=a;){var n=Math.floor((a+i)/2);if(e<t[n].startTime)a=n-1;else{if(!(e>t[n].startTime&&i<r))return n;i=n+1}}return t[i].startTime-e<e-t[a].startTime?i:a}(t,e);if(a>-1)for(var n=a,s=t.length;n<s;n++){var o=t[n];if(o.startTime>=e&&o.endTime<=r)i.push(o);else if(o.startTime>r)return i}return i}(t.cues,e,r),n=0;n<a.length;n++)t.removeCue(a[n]);"disabled"===i&&(t.mode=i)}(n,r,i)}},t}();function P(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var F,M=function(){function t(t){var e=this;this.hls=void 0,this.config=void 0,this.media=null,this.levelDetails=null,this.currentTime=0,this.stallCount=0,this._latency=null,this.timeupdateHandler=function(){return e.timeupdate()},this.hls=t,this.config=t.config,this.registerListeners()}var e,r,i=t.prototype;return i.destroy=function(){this.unregisterListeners(),this.onMediaDetaching(),this.levelDetails=null,this.hls=this.timeupdateHandler=null},i.registerListeners=function(){this.hls.on(n.a.MEDIA_ATTACHED,this.onMediaAttached,this),this.hls.on(n.a.MEDIA_DETACHING,this.onMediaDetaching,this),this.hls.on(n.a.MANIFEST_LOADING,this.onManifestLoading,this),this.hls.on(n.a.LEVEL_UPDATED,this.onLevelUpdated,this),this.hls.on(n.a.ERROR,this.onError,this)},i.unregisterListeners=function(){this.hls.off(n.a.MEDIA_ATTACHED,this.onMediaAttached),this.hls.off(n.a.MEDIA_DETACHING,this.onMediaDetaching),this.hls.off(n.a.MANIFEST_LOADING,this.onManifestLoading),this.hls.off(n.a.LEVEL_UPDATED,this.onLevelUpdated),this.hls.off(n.a.ERROR,this.onError)},i.onMediaAttached=function(t,e){this.media=e.media,this.media.addEventListener("timeupdate",this.timeupdateHandler)},i.onMediaDetaching=function(){this.media&&(this.media.removeEventListener("timeupdate",this.timeupdateHandler),this.media=null)},i.onManifestLoading=function(){this.levelDetails=null,this._latency=null,this.stallCount=0},i.onLevelUpdated=function(t,e){var r=e.details;this.levelDetails=r,r.advanced&&this.timeupdate(),!r.live&&this.media&&this.media.removeEventListener("timeupdate",this.timeupdateHandler)},i.onError=function(t,e){e.details===s.a.BUFFER_STALLED_ERROR&&(this.stallCount++,o.b.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))},i.timeupdate=function(){var t=this.media,e=this.levelDetails;if(t&&e){this.currentTime=t.currentTime;var r=this.computeLatency();if(null!==r){this._latency=r;var i=this.config,a=i.lowLatencyMode,n=i.maxLiveSyncPlaybackRate;if(a&&1!==n){var s=this.targetLatency;if(null!==s){var o=r-s,l=o<Math.min(this.maxLatency,s+e.targetduration);if(e.live&&l&&o>.05&&this.forwardBufferLength>1){var u=Math.min(2,Math.max(1,n)),d=Math.round(2/(1+Math.exp(-.75*o-this.edgeStalled))*20)/20;t.playbackRate=Math.min(u,Math.max(1,d))}else 1!==t.playbackRate&&0!==t.playbackRate&&(t.playbackRate=1)}}}}},i.estimateLiveEdge=function(){var t=this.levelDetails;return null===t?null:t.edge+t.age},i.computeLatency=function(){var t=this.estimateLiveEdge();return null===t?null:t-this.currentTime},e=t,(r=[{key:"latency",get:function(){return this._latency||0}},{key:"maxLatency",get:function(){var t=this.config,e=this.levelDetails;return void 0!==t.liveMaxLatencyDuration?t.liveMaxLatencyDuration:e?t.liveMaxLatencyDurationCount*e.targetduration:0}},{key:"targetLatency",get:function(){var t=this.levelDetails;if(null===t)return null;var e=t.holdBack,r=t.partHoldBack,i=t.targetduration,a=this.config,n=a.liveSyncDuration,s=a.liveSyncDurationCount,o=a.lowLatencyMode,l=this.hls.userConfig,u=o&&r||e;(l.liveSyncDuration||l.liveSyncDurationCount||0===u)&&(u=void 0!==n?n:s*i);var d=i;return u+Math.min(1*this.stallCount,d)}},{key:"liveSyncPosition",get:function(){var t=this.estimateLiveEdge(),e=this.targetLatency,r=this.levelDetails;if(null===t||null===e||null===r)return null;var i=r.edge,a=t-e-this.edgeStalled,n=i-r.totalduration,s=i-(this.config.lowLatencyMode&&r.partTarget||r.targetduration);return Math.min(Math.max(n,a),s)}},{key:"drift",get:function(){var t=this.levelDetails;return null===t?1:t.drift}},{key:"edgeStalled",get:function(){var t=this.levelDetails;if(null===t)return 0;var e=3*(this.config.lowLatencyMode&&t.partTarget||t.targetduration);return Math.max(t.age-e,0)}},{key:"forwardBufferLength",get:function(){var t=this.media,e=this.levelDetails;if(!t||!e)return 0;var r=t.buffered.length;return r?t.buffered.end(r-1):e.edge-this.currentTime}}])&&P(e.prototype,r),t}();function N(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}!function(t){t.No="",t.Yes="YES",t.v2="v2"}(F||(F={}));var B=function(){function t(t,e,r){this.msn=void 0,this.part=void 0,this.skip=void 0,this.msn=t,this.part=e,this.skip=r}return t.prototype.addDirectives=function(t){var e=new self.URL(t);return void 0!==this.msn&&e.searchParams.set("_HLS_msn",this.msn.toString()),void 0!==this.part&&e.searchParams.set("_HLS_part",this.part.toString()),this.skip&&e.searchParams.set("_HLS_skip",this.skip),e.toString()},t}(),U=function(){function t(t){this.attrs=void 0,this.audioCodec=void 0,this.bitrate=void 0,this.codecSet=void 0,this.height=void 0,this.id=void 0,this.name=void 0,this.videoCodec=void 0,this.width=void 0,this.unknownCodecs=void 0,this.audioGroupIds=void 0,this.details=void 0,this.fragmentError=0,this.loadError=0,this.loaded=void 0,this.realBitrate=0,this.textGroupIds=void 0,this.url=void 0,this._urlId=0,this.url=[t.url],this.attrs=t.attrs,this.bitrate=t.bitrate,t.details&&(this.details=t.details),this.id=t.id||0,this.name=t.name,this.width=t.width||0,this.height=t.height||0,this.audioCodec=t.audioCodec,this.videoCodec=t.videoCodec,this.unknownCodecs=t.unknownCodecs,this.codecSet=[t.videoCodec,t.audioCodec].filter((function(t){return t})).join(",").replace(/\.[^.,]+/g,"")}var e,r;return e=t,(r=[{key:"maxBitrate",get:function(){return Math.max(this.realBitrate,this.bitrate)}},{key:"uri",get:function(){return this.url[this._urlId]||""}},{key:"urlId",get:function(){return this._urlId},set:function(t){var e=t%this.url.length;this._urlId!==e&&(this.details=void 0,this._urlId=e)}}])&&N(e.prototype,r),t}();function G(t,e,r){switch(e){case"audio":t.audioGroupIds||(t.audioGroupIds=[]),t.audioGroupIds.push(r);break;case"text":t.textGroupIds||(t.textGroupIds=[]),t.textGroupIds.push(r)}}function j(t){var e={};t.forEach((function(t){var r=t.groupId||"";t.id=e[r]=e[r]||0,e[r]++}))}function H(t,e){var r=e.startPTS;if(Object(a.a)(r)){var i,n=0;e.sn>t.sn?(n=r-t.start,i=t):(n=t.start-r,i=e),i.duration!==n&&(i.duration=n)}else e.sn>t.sn?t.cc===e.cc&&t.minEndPTS?e.start=t.start+(t.minEndPTS-t.start):e.start=t.start+t.duration:e.start=Math.max(t.start-e.duration,0)}function K(t,e,r,i,n,s){i-r<=0&&(o.b.warn("Fragment should have a positive duration",e),i=r+e.duration,s=n+e.duration);var l=r,u=i,d=e.startPTS,h=e.endPTS;if(Object(a.a)(d)){var f=Math.abs(d-r);Object(a.a)(e.deltaPTS)?e.deltaPTS=Math.max(f,e.deltaPTS):e.deltaPTS=f,l=Math.max(r,d),r=Math.min(r,d),n=Math.min(n,e.startDTS),u=Math.min(i,h),i=Math.max(i,h),s=Math.max(s,e.endDTS)}e.duration=i-r;var c=r-e.start;e.appendedPTS=i,e.start=e.startPTS=r,e.maxStartPTS=l,e.startDTS=n,e.endPTS=i,e.minEndPTS=u,e.endDTS=s;var v,g=e.sn;if(!t||g<t.startSN||g>t.endSN)return 0;var p=g-t.startSN,m=t.fragments;for(m[p]=e,v=p;v>0;v--)H(m[v],m[v-1]);for(v=p;v<m.length-1;v++)H(m[v],m[v+1]);return t.fragmentHint&&H(m[m.length-1],t.fragmentHint),t.PTSKnown=t.alignedSliding=!0,c}function V(t,e){for(var r=null,i=t.fragments,n=i.length-1;n>=0;n--){var s=i[n].initSegment;if(s){r=s;break}}t.fragmentHint&&delete t.fragmentHint.endPTS;var l,u=0;if(function(t,e,r){for(var i=e.skippedSegments,a=Math.max(t.startSN,e.startSN)-e.startSN,n=(t.fragmentHint?1:0)+(i?e.endSN:Math.min(t.endSN,e.endSN))-e.startSN,s=e.startSN-t.startSN,o=e.fragmentHint?e.fragments.concat(e.fragmentHint):e.fragments,l=t.fragmentHint?t.fragments.concat(t.fragmentHint):t.fragments,u=a;u<=n;u++){var d=l[s+u],h=o[u];i&&!h&&u<i&&(h=e.fragments[u]=d),d&&h&&r(d,h)}}(t,e,(function(t,i){t.relurl&&(u=t.cc-i.cc),Object(a.a)(t.startPTS)&&Object(a.a)(t.endPTS)&&(i.start=i.startPTS=t.startPTS,i.startDTS=t.startDTS,i.appendedPTS=t.appendedPTS,i.maxStartPTS=t.maxStartPTS,i.endPTS=t.endPTS,i.endDTS=t.endDTS,i.minEndPTS=t.minEndPTS,i.duration=t.endPTS-t.startPTS,i.duration&&(l=i),e.PTSKnown=e.alignedSliding=!0),i.elementaryStreams=t.elementaryStreams,i.loader=t.loader,i.stats=t.stats,i.urlId=t.urlId,t.initSegment&&(i.initSegment=t.initSegment,r=t.initSegment)})),r&&(e.fragmentHint?e.fragments.concat(e.fragmentHint):e.fragments).forEach((function(t){var e;t.initSegment&&t.initSegment.relurl!==(null===(e=r)||void 0===e?void 0:e.relurl)||(t.initSegment=r)})),e.skippedSegments&&(e.deltaUpdateFailed=e.fragments.some((function(t){return!t})),e.deltaUpdateFailed)){o.b.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");for(var d=e.skippedSegments;d--;)e.fragments.shift();e.startSN=e.fragments[0].sn,e.startCC=e.fragments[0].cc}var h=e.fragments;if(u){o.b.warn("discontinuity sliding from playlist, take drift into account");for(var f=0;f<h.length;f++)h[f].cc+=u}e.skippedSegments&&(e.startCC=e.fragments[0].cc),function(t,e,r){if(t&&e)for(var i=0,a=0,n=t.length;a<=n;a++){var s=t[a],o=e[a+i];s&&o&&s.index===o.index&&s.fragment.sn===o.fragment.sn?r(s,o):i--}}(t.partList,e.partList,(function(t,e){e.elementaryStreams=t.elementaryStreams,e.stats=t.stats})),l?K(e,l,l.startPTS,l.endPTS,l.startDTS,l.endDTS):W(t,e),h.length&&(e.totalduration=e.edge-h[0].start),e.driftStartTime=t.driftStartTime,e.driftStart=t.driftStart;var c=e.advancedDateTime;if(e.advanced&&c){var v=e.edge;e.driftStart||(e.driftStartTime=c,e.driftStart=v),e.driftEndTime=c,e.driftEnd=v}else e.driftEndTime=t.driftEndTime,e.driftEnd=t.driftEnd,e.advancedDateTime=t.advancedDateTime}function W(t,e){var r=e.startSN+e.skippedSegments-t.startSN,i=t.fragments;r<0||r>=i.length||function(t,e){if(e){for(var r=t.fragments,i=t.skippedSegments;i<r.length;i++)r[i].start+=e;t.fragmentHint&&(t.fragmentHint.start+=e)}}(e,i[r].start)}var Y=function(){function t(t,e){this.hls=void 0,this.timer=-1,this.canLoad=!1,this.retryCount=0,this.log=void 0,this.warn=void 0,this.log=o.b.log.bind(o.b,e+":"),this.warn=o.b.warn.bind(o.b,e+":"),this.hls=t}var e=t.prototype;return e.destroy=function(){this.clearTimer(),this.hls=this.log=this.warn=null},e.onError=function(t,e){e.fatal&&e.type===s.b.NETWORK_ERROR&&this.clearTimer()},e.clearTimer=function(){clearTimeout(this.timer),this.timer=-1},e.startLoad=function(){this.canLoad=!0,this.retryCount=0,this.loadPlaylist()},e.stopLoad=function(){this.canLoad=!1,this.clearTimer()},e.switchParams=function(t,e){var r=null==e?void 0:e.renditionReports;if(r)for(var i=0;i<r.length;i++){var n=r[i],s=""+n.URI;if(s===t.substr(-s.length)){var o=parseInt(n["LAST-MSN"]),l=parseInt(n["LAST-PART"]);if(e&&this.hls.config.lowLatencyMode){var u=Math.min(e.age-e.partTarget,e.targetduration);void 0!==l&&u>e.partTarget&&(l+=1)}if(Object(a.a)(o))return new B(o,Object(a.a)(l)?l:void 0,F.No)}}},e.loadPlaylist=function(t){},e.shouldLoadTrack=function(t){return this.canLoad&&t&&!!t.url&&(!t.details||t.details.live)},e.playlistLoaded=function(t,e,r){var i=this,a=e.details,n=e.stats,s=n.loading.end?Math.max(0,self.performance.now()-n.loading.end):0;if(a.advancedDateTime=Date.now()-s,a.live||null!=r&&r.live){if(a.reloaded(r),r&&this.log("live playlist "+t+" "+(a.advanced?"REFRESHED "+a.lastPartSn+"-"+a.lastPartIndex:"MISSED")),r&&a.fragments.length>0&&V(r,a),!this.canLoad||!a.live)return;var o,l=void 0,u=void 0;if(a.canBlockReload&&a.endSN&&a.advanced){var d=this.hls.config.lowLatencyMode,h=a.lastPartSn,f=a.endSN,c=a.lastPartIndex,v=h===f;-1!==c?(l=v?f+1:h,u=v?d?0:c:c+1):l=f+1;var g=a.age,p=g+a.ageHeader,m=Math.min(p-a.partTarget,1.5*a.targetduration);if(m>0){if(r&&m>r.tuneInGoal)this.warn("CDN Tune-in goal increased from: "+r.tuneInGoal+" to: "+m+" with playlist age: "+a.age),m=0;else{var y=Math.floor(m/a.targetduration);l+=y,void 0!==u&&(u+=Math.round(m%a.targetduration/a.partTarget)),this.log("CDN Tune-in age: "+a.ageHeader+"s last advanced "+g.toFixed(2)+"s goal: "+m+" skip sn "+y+" to part "+u)}a.tuneInGoal=m}if(o=this.getDeliveryDirectives(a,e.deliveryDirectives,l,u),d||!v)return void this.loadPlaylist(o)}else o=this.getDeliveryDirectives(a,e.deliveryDirectives,l,u);var b=function(t,e){var r,i=1e3*t.levelTargetDuration,a=i/2,n=t.age,s=n>0&&n<3*i,o=e.loading.end-e.loading.start,l=t.availabilityDelay;if(!1===t.updated)if(s){var u=333*t.misses;r=Math.max(Math.min(a,2*o),u),t.availabilityDelay=(t.availabilityDelay||0)+r}else r=a;else s?(l=Math.min(l||i/2,n),t.availabilityDelay=l,r=l+i-n):r=i-o;return Math.round(r)}(a,n);void 0!==l&&a.canBlockReload&&(b-=a.partTarget||1),this.log("reload live playlist "+t+" in "+Math.round(b)+" ms"),this.timer=self.setTimeout((function(){return i.loadPlaylist(o)}),b)}else this.clearTimer()},e.getDeliveryDirectives=function(t,e,r,i){var a=function(t,e){var r=t.canSkipUntil,i=t.canSkipDateRanges,a=t.endSN;return r&&(void 0!==e?e-a:0)<r?i?F.v2:F.Yes:F.No}(t,r);return null!=e&&e.skip&&t.deltaUpdateFailed&&(r=e.msn,i=e.part,a=F.No),new B(r,i,a)},e.retryLoadingOrFail=function(t){var e,r=this,i=this.hls.config,a=this.retryCount<i.levelLoadingMaxRetry;if(a)if(this.retryCount++,t.details.indexOf("LoadTimeOut")>-1&&null!==(e=t.context)&&void 0!==e&&e.deliveryDirectives)this.warn("retry playlist loading #"+this.retryCount+' after "'+t.details+'"'),this.loadPlaylist();else{var n=Math.min(Math.pow(2,this.retryCount)*i.levelLoadingRetryDelay,i.levelLoadingMaxRetryTimeout);this.timer=self.setTimeout((function(){return r.loadPlaylist()}),n),this.warn("retry playlist loading #"+this.retryCount+" in "+n+' ms after "'+t.details+'"')}else this.warn('cannot recover from error "'+t.details+'"'),this.clearTimer(),t.fatal=!0;return a},t}();function X(){return(X=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t}).apply(this,arguments)}function q(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function z(t,e){return(z=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var Q,$=/chrome|firefox/.test(navigator.userAgent.toLowerCase()),Z=function(t){var e,r;function i(e){var r;return(r=t.call(this,e,"[level-controller]")||this)._levels=[],r._firstLevel=-1,r._startLevel=void 0,r.currentLevelIndex=-1,r.manualLevelIndex=-1,r.onParsedComplete=void 0,r._registerListeners(),r}r=t,(e=i).prototype=Object.create(r.prototype),e.prototype.constructor=e,z(e,r);var a,o,l=i.prototype;return l._registerListeners=function(){var t=this.hls;t.on(n.a.MANIFEST_LOADED,this.onManifestLoaded,this),t.on(n.a.LEVEL_LOADED,this.onLevelLoaded,this),t.on(n.a.AUDIO_TRACK_SWITCHED,this.onAudioTrackSwitched,this),t.on(n.a.FRAG_LOADED,this.onFragLoaded,this),t.on(n.a.ERROR,this.onError,this)},l._unregisterListeners=function(){var t=this.hls;t.off(n.a.MANIFEST_LOADED,this.onManifestLoaded,this),t.off(n.a.LEVEL_LOADED,this.onLevelLoaded,this),t.off(n.a.AUDIO_TRACK_SWITCHED,this.onAudioTrackSwitched,this),t.off(n.a.FRAG_LOADED,this.onFragLoaded,this),t.off(n.a.ERROR,this.onError,this)},l.destroy=function(){this._unregisterListeners(),this.manualLevelIndex=-1,this._levels.length=0,t.prototype.destroy.call(this)},l.startLoad=function(){this._levels.forEach((function(t){t.loadError=0})),t.prototype.startLoad.call(this)},l.onManifestLoaded=function(t,e){var r,i,a=[],o=[],l=[],u={},d=!1,h=!1,f=!1;if(e.levels.forEach((function(t){var e=t.attrs;d=d||!(!t.width||!t.height),h=h||!!t.videoCodec,f=f||!!t.audioCodec,$&&t.audioCodec&&-1!==t.audioCodec.indexOf("mp4a.40.34")&&(t.audioCodec=void 0);var r=t.bitrate+"-"+t.attrs.RESOLUTION+"-"+t.attrs.CODECS;(i=u[r])?i.url.push(t.url):(i=new U(t),u[r]=i,a.push(i)),e&&(e.AUDIO&&G(i,"audio",e.AUDIO),e.SUBTITLES&&G(i,"text",e.SUBTITLES))})),(d||h)&&f&&(a=a.filter((function(t){var e=t.videoCodec,r=t.width,i=t.height;return!!e||!(!r||!i)}))),a=a.filter((function(t){var e=t.audioCodec,r=t.videoCodec;return(!e||m(e,"audio"))&&(!r||m(r,"video"))})),e.audioTracks&&j(o=e.audioTracks.filter((function(t){return!t.audioCodec||m(t.audioCodec,"audio")}))),e.subtitles&&j(l=e.subtitles),a.length>0){r=a[0].bitrate,a.sort((function(t,e){return t.bitrate-e.bitrate})),this._levels=a;for(var c=0;c<a.length;c++)if(a[c].bitrate===r){this._firstLevel=c,this.log("manifest loaded, "+a.length+" level(s) found, first bitrate: "+r);break}var v=f&&!h,g={levels:a,audioTracks:o,subtitleTracks:l,firstLevel:this._firstLevel,stats:e.stats,audio:f,video:h,altAudio:!v&&o.some((function(t){return!!t.url}))};this.hls.trigger(n.a.MANIFEST_PARSED,g),(this.hls.config.autoStartLoad||this.hls.forceStartLoad)&&this.hls.startLoad(this.hls.config.startPosition)}else this.hls.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,fatal:!0,url:e.url,reason:"no level with compatible codecs found in manifest"})},l.onError=function(e,r){if(t.prototype.onError.call(this,e,r),!r.fatal){var i=r.context,a=this._levels[this.currentLevelIndex];if(i&&(i.type===_.a.AUDIO_TRACK&&a.audioGroupIds&&i.groupId===a.audioGroupIds[a.urlId]||i.type===_.a.SUBTITLE_TRACK&&a.textGroupIds&&i.groupId===a.textGroupIds[a.urlId]))this.redundantFailover(this.currentLevelIndex);else{var n,o=!1,l=!0;switch(r.details){case s.a.FRAG_LOAD_ERROR:case s.a.FRAG_LOAD_TIMEOUT:case s.a.KEY_LOAD_ERROR:case s.a.KEY_LOAD_TIMEOUT:if(r.frag){var u=this._levels[r.frag.level];u?(u.fragmentError++,u.fragmentError>this.hls.config.fragLoadingMaxRetry&&(n=r.frag.level)):n=r.frag.level}break;case s.a.LEVEL_LOAD_ERROR:case s.a.LEVEL_LOAD_TIMEOUT:i&&(i.deliveryDirectives&&(l=!1),n=i.level),o=!0;break;case s.a.REMUX_ALLOC_ERROR:n=r.level,o=!0}void 0!==n&&this.recoverLevel(r,n,o,l)}}},l.recoverLevel=function(t,e,r,i){var a=t.details,n=this._levels[e];if(n.loadError++,r){if(!this.retryLoadingOrFail(t))return void(this.currentLevelIndex=-1);t.levelRetry=!0}if(i){var s=n.url.length;if(s>1&&n.loadError<s)t.levelRetry=!0,this.redundantFailover(e);else if(-1===this.manualLevelIndex){var o=0===e?this._levels.length-1:e-1;this.currentLevelIndex!==o&&0===this._levels[o].loadError&&(this.warn(a+": switch to "+o),t.levelRetry=!0,this.hls.nextAutoLevel=o)}}},l.redundantFailover=function(t){var e=this._levels[t],r=e.url.length;if(r>1){var i=(e.urlId+1)%r;this.warn("Switching to redundant URL-id "+i),this._levels.forEach((function(t){t.urlId=i})),this.level=t}},l.onFragLoaded=function(t,e){var r=e.frag;if(void 0!==r&&r.type===_.b.MAIN){var i=this._levels[r.level];void 0!==i&&(i.fragmentError=0,i.loadError=0)}},l.onLevelLoaded=function(t,e){var r,i,a=e.level,n=e.details,s=this._levels[a];if(!s)return this.warn("Invalid level index "+a),void(null!==(i=e.deliveryDirectives)&&void 0!==i&&i.skip&&(n.deltaUpdateFailed=!0));a===this.currentLevelIndex?(0===s.fragmentError&&(s.loadError=0,this.retryCount=0),this.playlistLoaded(a,e,s.details)):null!==(r=e.deliveryDirectives)&&void 0!==r&&r.skip&&(n.deltaUpdateFailed=!0)},l.onAudioTrackSwitched=function(t,e){var r=this.hls.levels[this.currentLevelIndex];if(r&&r.audioGroupIds){for(var i=-1,a=this.hls.audioTracks[e.id].groupId,n=0;n<r.audioGroupIds.length;n++)if(r.audioGroupIds[n]===a){i=n;break}i!==r.urlId&&(r.urlId=i,this.startLoad())}},l.loadPlaylist=function(t){var e=this.currentLevelIndex,r=this._levels[e];if(this.canLoad&&r&&r.url.length>0){var i=r.urlId,a=r.url[i];if(t)try{a=t.addDirectives(a)}catch(t){this.warn("Could not construct new URL with HLS Delivery Directives: "+t)}this.log("Attempt loading level index "+e+(t?" at sn "+t.msn+" part "+t.part:"")+" with URL-id "+i+" "+a),this.clearTimer(),this.hls.trigger(n.a.LEVEL_LOADING,{url:a,level:e,id:i,deliveryDirectives:t||null})}},l.removeLevel=function(t,e){var r=function(t,r){return r!==e},i=this._levels.filter((function(i,a){return a!==t||i.url.length>1&&void 0!==e&&(i.url=i.url.filter(r),i.audioGroupIds&&(i.audioGroupIds=i.audioGroupIds.filter(r)),i.textGroupIds&&(i.textGroupIds=i.textGroupIds.filter(r)),i.urlId=0,!0)})).map((function(t,e){var r=t.details;return null!=r&&r.fragments&&r.fragments.forEach((function(t){t.level=e})),t}));this._levels=i,this.hls.trigger(n.a.LEVELS_UPDATED,{levels:i})},a=i,(o=[{key:"levels",get:function(){return 0===this._levels.length?null:this._levels}},{key:"level",get:function(){return this.currentLevelIndex},set:function(t){var e,r=this._levels;if(0!==r.length&&(this.currentLevelIndex!==t||null===(e=r[t])||void 0===e||!e.details)){if(t<0||t>=r.length){var i=t<0;if(this.hls.trigger(n.a.ERROR,{type:s.b.OTHER_ERROR,details:s.a.LEVEL_SWITCH_ERROR,level:t,fatal:i,reason:"invalid level idx"}),i)return;t=Math.min(t,r.length-1)}this.clearTimer();var a=this.currentLevelIndex,o=r[a],l=r[t];this.log("switching to level "+t+" from "+a),this.currentLevelIndex=t;var u=X({},l,{level:t,maxBitrate:l.maxBitrate,uri:l.uri,urlId:l.urlId});delete u._urlId,this.hls.trigger(n.a.LEVEL_SWITCHING,u);var d=l.details;if(!d||d.live){var h=this.switchParams(l.uri,null==o?void 0:o.details);this.loadPlaylist(h)}}}},{key:"manualLevel",get:function(){return this.manualLevelIndex},set:function(t){this.manualLevelIndex=t,void 0===this._startLevel&&(this._startLevel=t),-1!==t&&(this.level=t)}},{key:"firstLevel",get:function(){return this._firstLevel},set:function(t){this._firstLevel=t}},{key:"startLevel",get:function(){if(void 0===this._startLevel){var t=this.hls.config.startLevel;return void 0!==t?t:this._firstLevel}return this._startLevel},set:function(t){this._startLevel=t}},{key:"nextLoadLevel",get:function(){return-1!==this.manualLevelIndex?this.manualLevelIndex:this.hls.nextAutoLevel},set:function(t){this.level=t,-1===this.manualLevelIndex&&(this.hls.nextAutoLevel=t)}}])&&q(a.prototype,o),i}(Y);!function(t){t.NOT_LOADED="NOT_LOADED",t.BACKTRACKED="BACKTRACKED",t.APPENDING="APPENDING",t.PARTIAL="PARTIAL",t.OK="OK"}(Q||(Q={}));var J=function(){function t(t){this.activeFragment=null,this.activeParts=null,this.fragments=Object.create(null),this.timeRanges=Object.create(null),this.bufferPadding=.2,this.hls=void 0,this.hls=t,this._registerListeners()}var e=t.prototype;return e._registerListeners=function(){var t=this.hls;t.on(n.a.BUFFER_APPENDED,this.onBufferAppended,this),t.on(n.a.FRAG_BUFFERED,this.onFragBuffered,this),t.on(n.a.FRAG_LOADED,this.onFragLoaded,this)},e._unregisterListeners=function(){var t=this.hls;t.off(n.a.BUFFER_APPENDED,this.onBufferAppended,this),t.off(n.a.FRAG_BUFFERED,this.onFragBuffered,this),t.off(n.a.FRAG_LOADED,this.onFragLoaded,this)},e.destroy=function(){this._unregisterListeners(),this.fragments=this.timeRanges=null},e.getAppendedFrag=function(t,e){if(e===_.b.MAIN){var r=this.activeFragment,i=this.activeParts;if(!r)return null;if(i)for(var a=i.length;a--;){var n=i[a],s=n?n.end:r.appendedPTS;if(n.start<=t&&void 0!==s&&t<=s)return a>9&&(this.activeParts=i.slice(a-9)),n}else if(r.start<=t&&void 0!==r.appendedPTS&&t<=r.appendedPTS)return r}return this.getBufferedFrag(t,e)},e.getBufferedFrag=function(t,e){for(var r=this.fragments,i=Object.keys(r),a=i.length;a--;){var n=r[i[a]];if((null==n?void 0:n.body.type)===e&&n.buffered){var s=n.body;if(s.start<=t&&t<=s.end)return s}}return null},e.detectEvictedFragments=function(t,e,r){var i=this;Object.keys(this.fragments).forEach((function(a){var n=i.fragments[a];if(n)if(n.buffered){var s=n.range[t];s&&s.time.some((function(t){var r=!i.isTimeBuffered(t.startPTS,t.endPTS,e);return r&&i.removeFragment(n.body),r}))}else n.body.type===r&&i.removeFragment(n.body)}))},e.detectPartialFragments=function(t){var e=this,r=this.timeRanges,i=t.frag,a=t.part;if(r&&"initSegment"!==i.sn){var n=et(i),s=this.fragments[n];s&&(Object.keys(r).forEach((function(t){var n=i.elementaryStreams[t];if(n){var o=r[t],l=null!==a||!0===n.partial;s.range[t]=e.getBufferedTimes(i,a,l,o)}})),s.backtrack=s.loaded=null,Object.keys(s.range).length?s.buffered=!0:this.removeFragment(s.body))}},e.fragBuffered=function(t){var e=et(t),r=this.fragments[e];r&&(r.backtrack=r.loaded=null,r.buffered=!0)},e.getBufferedTimes=function(t,e,r,i){for(var a={time:[],partial:r},n=e?e.start:t.start,s=e?e.end:t.end,o=t.minEndPTS||s,l=t.maxStartPTS||n,u=0;u<i.length;u++){var d=i.start(u)-this.bufferPadding,h=i.end(u)+this.bufferPadding;if(l>=d&&o<=h){a.time.push({startPTS:Math.max(n,i.start(u)),endPTS:Math.min(s,i.end(u))});break}if(n<h&&s>d)a.partial=!0,a.time.push({startPTS:Math.max(n,i.start(u)),endPTS:Math.min(s,i.end(u))});else if(s<=d)break}return a},e.getPartialFragment=function(t){var e,r,i,a=null,n=0,s=this.bufferPadding,o=this.fragments;return Object.keys(o).forEach((function(l){var u=o[l];u&&tt(u)&&(r=u.body.start-s,i=u.body.end+s,t>=r&&t<=i&&(e=Math.min(t-r,i-t),n<=e&&(a=u.body,n=e)))})),a},e.getState=function(t){var e=et(t),r=this.fragments[e];return r?r.buffered?tt(r)?Q.PARTIAL:Q.OK:r.backtrack?Q.BACKTRACKED:Q.APPENDING:Q.NOT_LOADED},e.backtrack=function(t,e){var r=et(t),i=this.fragments[r];if(!i||i.backtrack)return null;var a=i.backtrack=e||i.loaded;return i.loaded=null,a},e.getBacktrackData=function(t){var e=et(t),r=this.fragments[e];if(r){var i,a=r.backtrack;if(null!=a&&null!==(i=a.payload)&&void 0!==i&&i.byteLength)return a;this.removeFragment(t)}return null},e.isTimeBuffered=function(t,e,r){for(var i,a,n=0;n<r.length;n++){if(i=r.start(n)-this.bufferPadding,a=r.end(n)+this.bufferPadding,t>=i&&e<=a)return!0;if(e<=i)return!1}return!1},e.onFragLoaded=function(t,e){var r=e.frag,i=e.part;if("initSegment"!==r.sn&&!r.bitrateTest&&!i){var a=et(r);this.fragments[a]={body:r,loaded:e,backtrack:null,buffered:!1,range:Object.create(null)}}},e.onBufferAppended=function(t,e){var r=this,i=e.frag,a=e.part,n=e.timeRanges;if(i.type===_.b.MAIN)if(this.activeFragment=i,a){var s=this.activeParts;s||(this.activeParts=s=[]),s.push(a)}else this.activeParts=null;this.timeRanges=n,Object.keys(n).forEach((function(t){var e=n[t];if(r.detectEvictedFragments(t,e),!a)for(var s=0;s<e.length;s++)i.appendedPTS=Math.max(e.end(s),i.appendedPTS||0)}))},e.onFragBuffered=function(t,e){this.detectPartialFragments(e)},e.hasFragment=function(t){var e=et(t);return!!this.fragments[e]},e.removeFragmentsInRange=function(t,e,r){var i=this;Object.keys(this.fragments).forEach((function(a){var n=i.fragments[a];if(n&&n.buffered){var s=n.body;s.type===r&&s.start<e&&s.end>t&&i.removeFragment(s)}}))},e.removeFragment=function(t){var e=et(t);t.stats.loaded=0,t.clearElementaryStreamInfo(),delete this.fragments[e]},e.removeAllFragments=function(){this.fragments=Object.create(null),this.activeFragment=null,this.activeParts=null},t}();function tt(t){var e,r;return t.buffered&&((null===(e=t.range.video)||void 0===e?void 0:e.partial)||(null===(r=t.range.audio)||void 0===r?void 0:r.partial))}function et(t){return t.type+"_"+t.level+"_"+t.urlId+"_"+t.sn}var rt=function(){function t(){this._boundTick=void 0,this._tickTimer=null,this._tickInterval=null,this._tickCallCount=0,this._boundTick=this.tick.bind(this)}var e=t.prototype;return e.destroy=function(){this.onHandlerDestroying(),this.onHandlerDestroyed()},e.onHandlerDestroying=function(){this.clearNextTick(),this.clearInterval()},e.onHandlerDestroyed=function(){},e.hasInterval=function(){return!!this._tickInterval},e.hasNextTick=function(){return!!this._tickTimer},e.setInterval=function(t){return!this._tickInterval&&(this._tickInterval=self.setInterval(this._boundTick,t),!0)},e.clearInterval=function(){return!!this._tickInterval&&(self.clearInterval(this._tickInterval),this._tickInterval=null,!0)},e.clearNextTick=function(){return!!this._tickTimer&&(self.clearTimeout(this._tickTimer),this._tickTimer=null,!0)},e.tick=function(){this._tickCallCount++,1===this._tickCallCount&&(this.doTick(),this._tickCallCount>1&&this.tickImmediate(),this._tickCallCount=0)},e.tickImmediate=function(){this.clearNextTick(),this._tickTimer=self.setTimeout(this._boundTick,0)},e.doTick=function(){},t}(),it={length:0,start:function(){return 0},end:function(){return 0}},at=function(){function t(){}return t.isBuffered=function(e,r){try{if(e)for(var i=t.getBuffered(e),a=0;a<i.length;a++)if(r>=i.start(a)&&r<=i.end(a))return!0}catch(t){}return!1},t.bufferInfo=function(e,r,i){try{if(e){var a,n=t.getBuffered(e),s=[];for(a=0;a<n.length;a++)s.push({start:n.start(a),end:n.end(a)});return this.bufferedInfo(s,r,i)}}catch(t){}return{len:0,start:r,end:r,nextStart:void 0}},t.bufferedInfo=function(t,e,r){e=Math.max(0,e),t.sort((function(t,e){return t.start-e.start||e.end-t.end}));var i=[];if(r)for(var a=0;a<t.length;a++){var n=i.length;if(n){var s=i[n-1].end;t[a].start-s<r?t[a].end>s&&(i[n-1].end=t[a].end):i.push(t[a])}else i.push(t[a])}else i=t;for(var o,l=0,u=e,d=e,h=0;h<i.length;h++){var f=i[h].start,c=i[h].end;if(e+r>=f&&e<c)u=f,l=(d=c)-e;else if(e+r<f){o=f;break}}return{len:l,start:u||0,end:d||0,nextStart:o}},t.getBuffered=function(t){try{return t.buffered}catch(t){return o.b.log("failed to get media.buffered",t),it}},t}(),nt=function(t,e,r,i,a,n){void 0===i&&(i=0),void 0===a&&(a=-1),void 0===n&&(n=!1),this.level=void 0,this.sn=void 0,this.part=void 0,this.id=void 0,this.size=void 0,this.partial=void 0,this.transmuxing={start:0,executeStart:0,executeEnd:0,end:0},this.buffering={audio:{start:0,executeStart:0,executeEnd:0,end:0},video:{start:0,executeStart:0,executeEnd:0,end:0},audiovideo:{start:0,executeStart:0,executeEnd:0,end:0}},this.level=t,this.sn=e,this.id=r,this.size=i,this.part=a,this.partial=n};function st(t,e){if(t){var r=t.start+e;t.start=t.startPTS=r,t.endPTS=r+t.duration}}function ot(t,e){for(var r=e.fragments,i=0,a=r.length;i<a;i++)st(r[i],t);e.fragmentHint&&st(e.fragmentHint,t),e.alignedSliding=!0}function lt(t,e,r){e&&(function(t,e,r){if(function(t,e,r){return!(!e.details||!(r.endCC>r.startCC||t&&t.cc<r.startCC))}(t,r,e)){var i=function(t,e){var r=t.fragments,i=e.fragments;if(i.length&&r.length){var a=function(t,e){for(var r=null,i=0,a=t.length;i<a;i++){var n=t[i];if(n&&n.cc===e){r=n;break}}return r}(r,i[0].cc);if(a&&(!a||a.startPTS))return a;o.b.log("No frag in previous level to align on")}else o.b.log("No fragments to align")}(r.details,e);i&&Object(a.a)(i.start)&&(o.b.log("Adjusting PTS using last level due to CC increase within current level "+e.url),ot(i.start,e))}}(t,r,e),!r.alignedSliding&&e.details&&function(t,e){if(e.fragments.length&&t.hasProgramDateTime&&e.hasProgramDateTime){var r=e.fragments[0].programDateTime,i=t.fragments[0].programDateTime,n=(i-r)/1e3+e.fragments[0].start;n&&Object(a.a)(n)&&(o.b.log("Adjusting PTS using programDateTime delta "+(i-r)+"ms, sliding:"+n.toFixed(3)+" "+t.url+" "),ot(n,t))}}(r,e.details),r.alignedSliding||!e.details||r.skippedSegments||W(e.details,r))}var ut=function(t,e){for(var r=0,i=t.length-1,a=null,n=null;r<=i;){var s=e(n=t[a=(r+i)/2|0]);if(s>0)r=a+1;else{if(!(s<0))return n;i=a-1}}return null};function dt(t,e,r){void 0===t&&(t=0),void 0===e&&(e=0);var i=Math.min(e,r.duration+(r.deltaPTS?r.deltaPTS:0));return r.start+r.duration-i<=t?1:r.start-i>t&&r.start?-1:0}function ht(t,e,r){var i=1e3*Math.min(e,r.duration+(r.deltaPTS?r.deltaPTS:0));return(r.endProgramDateTime||0)-i>t}function ft(t){var e="function"==typeof Map?new Map:void 0;return(ft=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,i)}function i(){return ct(t,arguments,pt(this).constructor)}return i.prototype=Object.create(t.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),gt(i,t)})(t)}function ct(t,e,r){return(ct=vt()?Reflect.construct:function(t,e,r){var i=[null];i.push.apply(i,e);var a=new(Function.bind.apply(t,i));return r&&gt(a,r.prototype),a}).apply(null,arguments)}function vt(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function gt(t,e){return(gt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function pt(t){return(pt=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}var mt=Math.pow(2,17),yt=function(){function t(t){this.config=void 0,this.loader=null,this.partLoadTimeout=-1,this.config=t}var e=t.prototype;return e.destroy=function(){this.loader&&(this.loader.destroy(),this.loader=null)},e.abort=function(){this.loader&&this.loader.abort()},e.load=function(t,e){var r=this,i=t.url;if(!i)return Promise.reject(new Tt({type:s.b.NETWORK_ERROR,details:s.a.FRAG_LOAD_ERROR,fatal:!1,frag:t,networkDetails:null},"Fragment does not have a "+(i?"part list":"url")));this.abort();var a=this.config,n=a.fLoader,o=a.loader;return new Promise((function(i,l){r.loader&&r.loader.destroy();var u=r.loader=t.loader=n?new n(a):new o(a),d=bt(t),h={timeout:a.fragLoadingTimeOut,maxRetry:0,retryDelay:0,maxRetryDelay:a.fragLoadingMaxRetryTimeout,highWaterMark:mt};t.stats=u.stats,u.load(d,h,{onSuccess:function(e,a,n,s){r.resetLoader(t,u),i({frag:t,part:null,payload:e.data,networkDetails:s})},onError:function(e,i,a){r.resetLoader(t,u),l(new Tt({type:s.b.NETWORK_ERROR,details:s.a.FRAG_LOAD_ERROR,fatal:!1,frag:t,response:e,networkDetails:a}))},onAbort:function(e,i,a){r.resetLoader(t,u),l(new Tt({type:s.b.NETWORK_ERROR,details:s.a.INTERNAL_ABORTED,fatal:!1,frag:t,networkDetails:a}))},onTimeout:function(e,i,a){r.resetLoader(t,u),l(new Tt({type:s.b.NETWORK_ERROR,details:s.a.FRAG_LOAD_TIMEOUT,fatal:!1,frag:t,networkDetails:a}))},onProgress:function(r,i,a,n){e&&e({frag:t,part:null,payload:a,networkDetails:n})}})}))},e.loadPart=function(t,e,r){var i=this;this.abort();var a=this.config,n=a.fLoader,o=a.loader;return new Promise((function(l,u){i.loader&&i.loader.destroy();var d=i.loader=t.loader=n?new n(a):new o(a),h=bt(t,e),f={timeout:a.fragLoadingTimeOut,maxRetry:0,retryDelay:0,maxRetryDelay:a.fragLoadingMaxRetryTimeout,highWaterMark:mt};e.stats=d.stats,d.load(h,f,{onSuccess:function(a,n,s,o){i.resetLoader(t,d),i.updateStatsFromPart(t,e);var u={frag:t,part:e,payload:a.data,networkDetails:o};r(u),l(u)},onError:function(r,a,n){i.resetLoader(t,d),u(new Tt({type:s.b.NETWORK_ERROR,details:s.a.FRAG_LOAD_ERROR,fatal:!1,frag:t,part:e,response:r,networkDetails:n}))},onAbort:function(r,a,n){t.stats.aborted=e.stats.aborted,i.resetLoader(t,d),u(new Tt({type:s.b.NETWORK_ERROR,details:s.a.INTERNAL_ABORTED,fatal:!1,frag:t,part:e,networkDetails:n}))},onTimeout:function(r,a,n){i.resetLoader(t,d),u(new Tt({type:s.b.NETWORK_ERROR,details:s.a.FRAG_LOAD_TIMEOUT,fatal:!1,frag:t,part:e,networkDetails:n}))}})}))},e.updateStatsFromPart=function(t,e){var r=t.stats,i=e.stats,a=i.total;if(r.loaded+=i.loaded,a){var n=Math.round(t.duration/e.duration),s=Math.min(Math.round(r.loaded/a),n),o=(n-s)*Math.round(r.loaded/s);r.total=r.loaded+o}else r.total=Math.max(r.loaded,r.total);var l=r.loading,u=i.loading;l.start?l.first+=u.first-u.start:(l.start=u.start,l.first=u.first),l.end=u.end},e.resetLoader=function(t,e){t.loader=null,this.loader===e&&(self.clearTimeout(this.partLoadTimeout),this.loader=null),e.destroy()},t}();function bt(t,e){void 0===e&&(e=null);var r=e||t,i={frag:t,part:e,responseType:"arraybuffer",url:r.url,headers:{},rangeStart:0,rangeEnd:0},n=r.byteRangeStartOffset,s=r.byteRangeEndOffset;return Object(a.a)(n)&&Object(a.a)(s)&&(i.rangeStart=n,i.rangeEnd=s),i}var Tt=function(t){var e,r;function i(e){for(var r,i=arguments.length,a=new Array(i>1?i-1:0),n=1;n<i;n++)a[n-1]=arguments[n];return(r=t.call.apply(t,[this].concat(a))||this).data=void 0,r.data=e,r}return r=t,(e=i).prototype=Object.create(r.prototype),e.prototype.constructor=e,gt(e,r),i}(ft(Error)),Et=r(14),St=function(t){for(var e="",r=t.length,i=0;i<r;i++)e+="["+t.start(i).toFixed(3)+","+t.end(i).toFixed(3)+"]";return e};function Lt(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function At(t,e){return(At=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var Rt="STOPPED",Dt="IDLE",_t="KEY_LOADING",kt="FRAG_LOADING",xt="FRAG_LOADING_WAITING_RETRY",wt="PARSING",Ct="PARSED",Ot="BACKTRACKING",It="ENDED",Pt="ERROR",Ft="WAITING_LEVEL",Mt=function(t){var e,r;function i(e,r,i){var a;return(a=t.call(this)||this).hls=void 0,a.fragPrevious=null,a.fragCurrent=null,a.fragmentTracker=void 0,a.transmuxer=null,a._state=Rt,a.media=void 0,a.mediaBuffer=void 0,a.config=void 0,a.bitrateTest=!1,a.lastCurrentTime=0,a.nextLoadPosition=0,a.startPosition=0,a.loadedmetadata=!1,a.fragLoadError=0,a.retryDate=0,a.levels=null,a.fragmentLoader=void 0,a.levelLastLoaded=null,a.startFragRequested=!1,a.decrypter=void 0,a.initPTS=[],a.onvseeking=null,a.onvended=null,a.logPrefix="",a.log=void 0,a.warn=void 0,a.logPrefix=i,a.log=o.b.log.bind(o.b,i+":"),a.warn=o.b.warn.bind(o.b,i+":"),a.hls=e,a.fragmentLoader=new yt(e.config),a.fragmentTracker=r,a.config=e.config,a.decrypter=new Et.a(e,e.config),e.on(n.a.KEY_LOADED,a.onKeyLoaded,function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(a)),a}r=t,(e=i).prototype=Object.create(r.prototype),e.prototype.constructor=e,At(e,r);var u,d,h=i.prototype;return h.doTick=function(){this.onTickEnd()},h.onTickEnd=function(){},h.startLoad=function(t){},h.stopLoad=function(){this.fragmentLoader.abort();var t=this.fragCurrent;t&&this.fragmentTracker.removeFragment(t),this.resetTransmuxer(),this.fragCurrent=null,this.fragPrevious=null,this.clearInterval(),this.clearNextTick(),this.state=Rt},h._streamEnded=function(t,e){var r=this.fragCurrent,i=this.fragmentTracker;if(!e.live&&r&&r.sn>=e.endSN&&!t.nextStart){var a=e.partList;if(null!=a&&a.length){var n=a[a.length-1];return at.isBuffered(this.media,n.start+n.duration/2)}var s=i.getState(r);return s===Q.PARTIAL||s===Q.OK}return!1},h.onMediaAttached=function(t,e){var r=this.media=this.mediaBuffer=e.media;this.onvseeking=this.onMediaSeeking.bind(this),this.onvended=this.onMediaEnded.bind(this),r.addEventListener("seeking",this.onvseeking),r.addEventListener("ended",this.onvended);var i=this.config;this.levels&&i.autoStartLoad&&this.state===Rt&&this.startLoad(i.startPosition)},h.onMediaDetaching=function(){var t=this.media;null!=t&&t.ended&&(this.log("MSE detaching and video ended, reset startPosition"),this.startPosition=this.lastCurrentTime=0),t&&(t.removeEventListener("seeking",this.onvseeking),t.removeEventListener("ended",this.onvended),this.onvseeking=this.onvended=null),this.media=this.mediaBuffer=null,this.loadedmetadata=!1,this.fragmentTracker.removeAllFragments(),this.stopLoad()},h.onMediaSeeking=function(){var t=this.config,e=this.fragCurrent,r=this.media,i=this.mediaBuffer,n=this.state,s=r?r.currentTime:0,o=at.bufferInfo(i||r,s,t.maxBufferHole);if(this.log("media seeking to "+(Object(a.a)(s)?s.toFixed(3):s)+", state: "+n),n===It)this.resetLoadingState();else if(e&&!o.len){var l=t.maxFragLookUpTolerance,u=e.start-l,d=s>e.start+e.duration+l;(s<u||d)&&(d&&e.loader&&(this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"),e.loader.abort()),this.resetLoadingState())}r&&(this.lastCurrentTime=s),this.loadedmetadata||o.len||(this.nextLoadPosition=this.startPosition=s),this.tickImmediate()},h.onMediaEnded=function(){this.startPosition=this.lastCurrentTime=0},h.onKeyLoaded=function(t,e){if(this.state===_t&&e.frag===this.fragCurrent&&this.levels){this.state=Dt;var r=this.levels[e.frag.level].details;r&&this.loadFragment(e.frag,r,e.frag.start)}},h.onHandlerDestroying=function(){this.stopLoad(),t.prototype.onHandlerDestroying.call(this)},h.onHandlerDestroyed=function(){this.state=Rt,this.hls.off(n.a.KEY_LOADED,this.onKeyLoaded,this),this.fragmentLoader&&this.fragmentLoader.destroy(),this.decrypter&&this.decrypter.destroy(),this.hls=this.log=this.warn=this.decrypter=this.fragmentLoader=this.fragmentTracker=null,t.prototype.onHandlerDestroyed.call(this)},h.loadKey=function(t,e){this.log("Loading key for "+t.sn+" of ["+e.startSN+"-"+e.endSN+"], "+("[stream-controller]"===this.logPrefix?"level":"track")+" "+t.level),this.state=_t,this.fragCurrent=t,this.hls.trigger(n.a.KEY_LOADING,{frag:t})},h.loadFragment=function(t,e,r){this._loadFragForPlayback(t,e,r)},h._loadFragForPlayback=function(t,e,r){var i=this;this._doFragLoad(t,e,r,(function(e){if(i.fragContextChanged(t))return i.warn("Fragment "+t.sn+(e.part?" p: "+e.part.index:"")+" of level "+t.level+" was dropped during download."),void i.fragmentTracker.removeFragment(t);t.stats.chunkCount++,i._handleFragmentLoadProgress(e)})).then((function(e){if(e){i.fragLoadError=0;var r=i.state;if(!i.fragContextChanged(t))return"payload"in e&&(i.log("Loaded fragment "+t.sn+" of level "+t.level),i.hls.trigger(n.a.FRAG_LOADED,e),i.state===Ot)?(i.fragmentTracker.backtrack(t,e),void i.resetFragmentLoading(t)):void i._handleFragmentLoadComplete(e);(r===kt||r===Ot||!i.fragCurrent&&r===wt)&&(i.fragmentTracker.removeFragment(t),i.state=Dt)}})).catch((function(e){i.warn(e),i.resetFragmentLoading(t)}))},h.flushMainBuffer=function(t,e,r){if(void 0===r&&(r=null),t-e){var i={startOffset:t,endOffset:e,type:r};this.fragLoadError=0,this.hls.trigger(n.a.BUFFER_FLUSHING,i)}},h._loadInitSegment=function(t){var e=this;this._doFragLoad(t).then((function(r){if(!r||e.fragContextChanged(t)||!e.levels)throw new Error("init load aborted");return r})).then((function(r){var i=e.hls,a=r.payload,s=t.decryptdata;if(a&&a.byteLength>0&&s&&s.key&&s.iv&&"AES-128"===s.method){var o=self.performance.now();return e.decrypter.webCryptoDecrypt(new Uint8Array(a),s.key.buffer,s.iv.buffer).then((function(e){var a=self.performance.now();return i.trigger(n.a.FRAG_DECRYPTED,{frag:t,payload:e,stats:{tstart:o,tdecrypt:a}}),r.payload=e,r}))}return r})).then((function(r){var i=e.fragCurrent,a=e.hls,s=e.levels;if(!s)throw new Error("init load aborted, missing levels");s[t.level].details;var o=t.stats;e.state=Dt,e.fragLoadError=0,t.data=new Uint8Array(r.payload),o.parsing.start=o.buffering.start=self.performance.now(),o.parsing.end=o.buffering.end=self.performance.now(),r.frag===i&&a.trigger(n.a.FRAG_BUFFERED,{stats:o,frag:i,part:null,id:t.type}),e.tick()})).catch((function(r){e.warn(r),e.resetFragmentLoading(t)}))},h.fragContextChanged=function(t){var e=this.fragCurrent;return!t||!e||t.level!==e.level||t.sn!==e.sn||t.urlId!==e.urlId},h.fragBufferedComplete=function(t,e){var r=this.mediaBuffer?this.mediaBuffer:this.media;this.log("Buffered "+t.type+" sn: "+t.sn+(e?" part: "+e.index:"")+" of "+("[stream-controller]"===this.logPrefix?"level":"track")+" "+t.level+" "+St(at.getBuffered(r))),this.state=Dt,this.tick()},h._handleFragmentLoadComplete=function(t){var e=this.transmuxer;if(e){var r=t.frag,i=t.part,a=t.partsLoaded,n=!a||0===a.length||a.some((function(t){return!t})),s=new nt(r.level,r.sn,r.stats.chunkCount+1,0,i?i.index:-1,!n);e.flush(s)}},h._handleFragmentLoadProgress=function(t){},h._doFragLoad=function(t,e,r,i){var s=this;if(void 0===r&&(r=null),!this.levels)throw new Error("frag load aborted, missing levels");if(r=Math.max(t.start,r||0),this.config.lowLatencyMode&&e){var o=e.partList;if(o&&i){r>t.end&&e.fragmentHint&&(t=e.fragmentHint);var l=this.getNextPart(o,t,r);if(l>-1){var u=o[l];return this.log("Loading part sn: "+t.sn+" p: "+u.index+" cc: "+t.cc+" of playlist ["+e.startSN+"-"+e.endSN+"] parts [0-"+l+"-"+(o.length-1)+"] "+("[stream-controller]"===this.logPrefix?"level":"track")+": "+t.level+", target: "+parseFloat(r.toFixed(3))),this.nextLoadPosition=u.start+u.duration,this.state=kt,this.hls.trigger(n.a.FRAG_LOADING,{frag:t,part:o[l],targetBufferTime:r}),this.doFragPartsLoad(t,o,l,i).catch((function(t){return s.handleFragLoadError(t)}))}if(!t.url||this.loadedEndOfParts(o,r))return Promise.resolve(null)}}return this.log("Loading fragment "+t.sn+" cc: "+t.cc+" "+(e?"of ["+e.startSN+"-"+e.endSN+"] ":"")+("[stream-controller]"===this.logPrefix?"level":"track")+": "+t.level+", target: "+parseFloat(r.toFixed(3))),Object(a.a)(t.sn)&&!this.bitrateTest&&(this.nextLoadPosition=t.start+t.duration),this.state=kt,this.hls.trigger(n.a.FRAG_LOADING,{frag:t,targetBufferTime:r}),this.fragmentLoader.load(t,i).catch((function(t){return s.handleFragLoadError(t)}))},h.doFragPartsLoad=function(t,e,r,i){var a=this;return new Promise((function(s,o){var l=[];!function r(u){var d=e[u];a.fragmentLoader.loadPart(t,d,i).then((function(i){l[d.index]=i;var o=i.part;a.hls.trigger(n.a.FRAG_LOADED,i);var h=e[u+1];if(!h||h.fragment!==t)return s({frag:t,part:o,partsLoaded:l});r(u+1)})).catch(o)}(r)}))},h.handleFragLoadError=function(t){var e=t.data;return e&&e.details===s.a.INTERNAL_ABORTED?this.handleFragLoadAborted(e.frag,e.part):this.hls.trigger(n.a.ERROR,e),null},h._handleTransmuxerFlush=function(t){var e=this.getCurrentContext(t);if(e&&this.state===wt){var r=e.frag,i=e.part,a=e.level,n=self.performance.now();r.stats.parsing.end=n,i&&(i.stats.parsing.end=n),this.updateLevelTiming(r,i,a,t.partial)}else this.fragCurrent||(this.state=Dt)},h.getCurrentContext=function(t){var e=this.levels,r=t.level,i=t.sn,a=t.part;if(!e||!e[r])return this.warn("Levels object was unset while buffering fragment "+i+" of level "+r+". The current chunk will not be buffered."),null;var n=e[r],s=a>-1?function(t,e,r){if(!t||!t.details)return null;var i=t.details.partList;if(i)for(var a=i.length;a--;){var n=i[a];if(n.index===r&&n.fragment.sn===e)return n}return null}(n,i,a):null,o=s?s.fragment:function(t,e,r){if(!t||!t.details)return null;var i=t.details,a=i.fragments[e-i.startSN];return a||((a=i.fragmentHint)&&a.sn===e?a:e<i.startSN&&r&&r.sn===e?r:null)}(n,i,this.fragCurrent);return o?{frag:o,part:s,level:n}:null},h.bufferFragmentData=function(t,e,r,i){if(t&&this.state===wt){var a=t.data1,s=t.data2,o=a;if(a&&s&&(o=Object(l.a)(a,s)),o&&o.length){var u={type:t.type,frag:e,part:r,chunkMeta:i,parent:e.type,data:o};this.hls.trigger(n.a.BUFFER_APPENDING,u),t.dropped&&t.independent&&!r&&this.flushBufferGap(e)}}},h.flushBufferGap=function(t){var e=this.media;if(e)if(at.isBuffered(e,e.currentTime)){var r=e.currentTime,i=at.bufferInfo(e,r,0),a=t.duration,n=Math.min(2*this.config.maxFragLookUpTolerance,.25*a),s=Math.max(Math.min(t.start-n,i.end-n),r+n);t.start-s>n&&this.flushMainBuffer(s,t.start)}else this.flushMainBuffer(0,t.start)},h.getFwdBufferInfo=function(t,e){var r=this.config,i=this.getLoadPosition();if(!Object(a.a)(i))return null;var n=at.bufferInfo(t,i,r.maxBufferHole);if(0===n.len&&void 0!==n.nextStart){var s=this.fragmentTracker.getBufferedFrag(i,e);if(s&&n.nextStart<s.end)return at.bufferInfo(t,i,Math.max(n.nextStart,r.maxBufferHole))}return n},h.getMaxBufferLength=function(t){var e,r=this.config;return e=t?Math.max(8*r.maxBufferSize/t,r.maxBufferLength):r.maxBufferLength,Math.min(e,r.maxMaxBufferLength)},h.reduceMaxBufferLength=function(t){var e=this.config,r=t||e.maxBufferLength;return e.maxMaxBufferLength>=r&&(e.maxMaxBufferLength/=2,this.warn("Reduce max buffer length to "+e.maxMaxBufferLength+"s"),!0)},h.getNextFragment=function(t,e){var r,i,a=e.fragments,n=a.length;if(!n)return null;var s,o=this.config,l=a[0].start;if(e.live){var u=o.initialLiveManifestSize;if(n<u)return this.warn("Not enough fragments to start playback (have: "+n+", need: "+u+")"),null;e.PTSKnown||this.startFragRequested||-1!==this.startPosition||(s=this.getInitialLiveFragment(e,a),this.startPosition=s?this.hls.liveSyncPosition||s.start:t)}else t<=l&&(s=a[0]);if(!s){var d=o.lowLatencyMode?e.partEnd:e.fragmentEnd;s=this.getFragmentAtPosition(t,d,e)}return null===(r=s)||void 0===r||!r.initSegment||null!==(i=s)&&void 0!==i&&i.initSegment.data||this.bitrateTest||(s=s.initSegment),s},h.getNextPart=function(t,e,r){for(var i=-1,a=!1,n=!0,s=0,o=t.length;s<o;s++){var l=t[s];if(n=n&&!l.independent,i>-1&&r<l.start)break;var u=l.loaded;!u&&(a||l.independent||n)&&l.fragment===e&&(i=s),a=u}return i},h.loadedEndOfParts=function(t,e){var r=t[t.length-1];return r&&e>r.start&&r.loaded},h.getInitialLiveFragment=function(t,e){var r=this.fragPrevious,i=null;if(r){if(t.hasProgramDateTime&&(this.log("Live playlist, switching playlist, load frag with same PDT: "+r.programDateTime),i=function(t,e,r){if(null===e||!Array.isArray(t)||!t.length||!Object(a.a)(e))return null;if(e<(t[0].programDateTime||0))return null;if(e>=(t[t.length-1].endProgramDateTime||0))return null;r=r||0;for(var i=0;i<t.length;++i){var n=t[i];if(ht(e,r,n))return n}return null}(e,r.endProgramDateTime,this.config.maxFragLookUpTolerance)),!i){var n=r.sn+1;if(n>=t.startSN&&n<=t.endSN){var s=e[n-t.startSN];r.cc===s.cc&&(i=s,this.log("Live playlist, switching playlist, load frag with next SN: "+i.sn))}i||(i=function(t,e){return ut(t,(function(t){return t.cc<e?1:t.cc>e?-1:0}))}(e,r.cc))&&this.log("Live playlist, switching playlist, load frag with same CC: "+i.sn)}}else{var o=this.hls.liveSyncPosition;null!==o&&(i=this.getFragmentAtPosition(o,this.bitrateTest?t.fragmentEnd:t.edge,t))}return i},h.getFragmentAtPosition=function(t,e,r){var i,a=this.config,n=this.fragPrevious,s=r.fragments,o=r.endSN,l=r.fragmentHint,u=a.maxFragLookUpTolerance,d=!!(a.lowLatencyMode&&r.partList&&l);if(d&&l&&!this.bitrateTest&&(s=s.concat(l),o=l.sn),i=t<e?function(t,e,r,i){void 0===r&&(r=0),void 0===i&&(i=0);var a=null;return t?a=e[t.sn-e[0].sn+1]||null:0===r&&0===e[0].start&&(a=e[0]),a&&0===dt(r,i,a)?a:ut(e,dt.bind(null,r,i))||a}(n,s,t,t>e-u?0:u):s[s.length-1],i){var h=i.sn-r.startSN,f=n&&i.level===n.level,c=s[h+1];if(this.fragmentTracker.getState(i)===Q.BACKTRACKED){i=null;for(var v=h;s[v]&&this.fragmentTracker.getState(s[v])===Q.BACKTRACKED;)i=n?s[v--]:s[--v];i||(i=c)}else n&&i.sn===n.sn&&!d&&f&&(i.sn<o&&this.fragmentTracker.getState(c)!==Q.OK?(this.log("SN "+i.sn+" just loaded, load next one: "+c.sn),i=c):i=null)}return i},h.synchronizeToLiveEdge=function(t){var e=this.config,r=this.media;if(r){var i=this.hls.liveSyncPosition,a=r.currentTime,n=t.fragments[0].start,s=t.edge,o=a>=n-e.maxFragLookUpTolerance&&a<=s;if(null!==i&&r.duration>i&&(a<i||!o)){var l=void 0!==e.liveMaxLatencyDuration?e.liveMaxLatencyDuration:e.liveMaxLatencyDurationCount*t.targetduration;(!o&&r.readyState<4||a<s-l)&&(this.loadedmetadata||(this.nextLoadPosition=i),r.readyState&&(this.warn("Playback: "+a.toFixed(3)+" is located too far from the end of live sliding playlist: "+s+", reset currentTime to : "+i.toFixed(3)),r.currentTime=i))}}},h.alignPlaylists=function(t,e){var r=this.levels,i=this.levelLastLoaded,n=this.fragPrevious,s=null!==i?r[i]:null,o=t.fragments.length;if(!o)return this.warn("No fragments in live playlist"),0;var l=t.fragments[0].start,u=!e,d=t.alignedSliding&&Object(a.a)(l);if(u||!d&&!l){lt(n,s,t);var h=t.fragments[0].start;return this.log("Live playlist sliding: "+h.toFixed(2)+" start-sn: "+(e?e.startSN:"na")+"->"+t.startSN+" prev-sn: "+(n?n.sn:"na")+" fragments: "+o),h}return l},h.waitForCdnTuneIn=function(t){return t.live&&t.canBlockReload&&t.tuneInGoal>Math.max(t.partHoldBack,3*t.partTarget)},h.setStartPosition=function(t,e){var r=this.startPosition;if(r<e&&(r=-1),-1===r||-1===this.lastCurrentTime){var i=t.startTimeOffset;Object(a.a)(i)?(r=e+i,i<0&&(r+=t.totalduration),r=Math.min(Math.max(e,r),e+t.totalduration),this.log("Start time offset "+i+" found in playlist, adjust startPosition to "+r),this.startPosition=r):t.live?r=this.hls.liveSyncPosition||e:this.startPosition=r=0,this.lastCurrentTime=r}this.nextLoadPosition=r},h.getLoadPosition=function(){var t=this.media,e=0;return this.loadedmetadata&&t?e=t.currentTime:this.nextLoadPosition&&(e=this.nextLoadPosition),e},h.handleFragLoadAborted=function(t,e){this.transmuxer&&"initSegment"!==t.sn&&t.stats.aborted&&(this.warn("Fragment "+t.sn+(e?" part"+e.index:"")+" of level "+t.level+" was aborted"),this.resetFragmentLoading(t))},h.resetFragmentLoading=function(t){this.fragCurrent&&this.fragContextChanged(t)||(this.state=Dt)},h.onFragmentOrKeyLoadError=function(t,e){if(!e.fatal){var r=e.frag;if(r&&r.type===t){this.fragCurrent;var i=this.config;if(this.fragLoadError+1<=i.fragLoadingMaxRetry){if(this.resetLiveStartWhenNotLoaded(r.level))return;var a=Math.min(Math.pow(2,this.fragLoadError)*i.fragLoadingRetryDelay,i.fragLoadingMaxRetryTimeout);this.warn("Fragment "+r.sn+" of "+t+" "+r.level+" failed to load, retrying in "+a+"ms"),this.retryDate=self.performance.now()+a,this.fragLoadError++,this.state=xt}else e.levelRetry?(t===_.b.AUDIO&&(this.fragCurrent=null),this.fragLoadError=0,this.state=Dt):(o.b.error(e.details+" reaches max retry, redispatch as fatal ..."),e.fatal=!0,this.hls.stopLoad(),this.state=Pt)}}},h.afterBufferFlushed=function(t,e,r){if(t){var i=at.getBuffered(t);this.fragmentTracker.detectEvictedFragments(e,i,r),this.state===It&&this.resetLoadingState()}},h.resetLoadingState=function(){this.fragCurrent=null,this.fragPrevious=null,this.state=Dt},h.resetLiveStartWhenNotLoaded=function(t){if(!this.loadedmetadata){this.startFragRequested=!1;var e=this.levels?this.levels[t].details:null;if(null!=e&&e.live)return this.startPosition=-1,this.setStartPosition(e,0),this.resetLoadingState(),!0;this.nextLoadPosition=this.startPosition}return!1},h.updateLevelTiming=function(t,e,r,i){var a=this,s=r.details;Object.keys(t.elementaryStreams).reduce((function(e,o){var l=t.elementaryStreams[o];if(l){var u=l.endPTS-l.startPTS;if(u<=0)return a.warn("Could not parse fragment "+t.sn+" "+o+" duration reliably ("+u+") resetting transmuxer to fallback to playlist timing"),a.resetTransmuxer(),e||!1;var d=i?0:K(s,t,l.startPTS,l.endPTS,l.startDTS,l.endDTS);return a.hls.trigger(n.a.LEVEL_PTS_UPDATED,{details:s,level:r,drift:d,type:o,frag:t,start:l.startPTS,end:l.endPTS}),!0}return e}),!1)?(this.state=Ct,this.hls.trigger(n.a.FRAG_PARSED,{frag:t,part:e})):this.resetLoadingState()},h.resetTransmuxer=function(){this.transmuxer&&(this.transmuxer.destroy(),this.transmuxer=null)},u=i,(d=[{key:"state",get:function(){return this._state},set:function(t){var e=this._state;e!==t&&(this._state=t,this.log(e+"->"+t))}}])&&Lt(u.prototype,d),i}(rt);function Nt(){return self.MediaSource||self.WebKitMediaSource}function Bt(){return self.SourceBuffer||self.WebKitSourceBuffer}var Ut=r(17),Gt=r(9),jt=r(13),Ht=Nt()||{isTypeSupported:function(){return!1}},Kt=function(){function t(t,e,r,i){var a=this;this.hls=void 0,this.id=void 0,this.observer=void 0,this.frag=null,this.part=null,this.worker=void 0,this.onwmsg=void 0,this.transmuxer=null,this.onTransmuxComplete=void 0,this.onFlush=void 0,this.hls=t,this.id=e,this.onTransmuxComplete=r,this.onFlush=i;var l=t.config,u=function(e,r){(r=r||{}).frag=a.frag,r.id=a.id,t.trigger(e,r)};this.observer=new jt.EventEmitter,this.observer.on(n.a.FRAG_DECRYPTED,u),this.observer.on(n.a.ERROR,u);var d={mp4:Ht.isTypeSupported("video/mp4"),mpeg:Ht.isTypeSupported("audio/mpeg"),mp3:Ht.isTypeSupported('audio/mp4; codecs="mp3"')},h=navigator.vendor;if(l.enableWorker&&"undefined"!=typeof Worker){var f;o.b.log("demuxing in webworker");try{f=this.worker=Ut(18),this.onwmsg=this.onWorkerMessage.bind(this),f.addEventListener("message",this.onwmsg),f.onerror=function(e){t.trigger(n.a.ERROR,{type:s.b.OTHER_ERROR,details:s.a.INTERNAL_EXCEPTION,fatal:!0,event:"demuxerWorker",error:new Error(e.message+"  ("+e.filename+":"+e.lineno+")")})},f.postMessage({cmd:"init",typeSupported:d,vendor:h,id:e,config:JSON.stringify(l)})}catch(t){o.b.warn("Error in worker:",t),o.b.error("Error while initializing DemuxerWorker, fallback to inline"),f&&self.URL.revokeObjectURL(f.objectURL),this.transmuxer=new Gt.c(this.observer,d,l,h,e),this.worker=null}}else this.transmuxer=new Gt.c(this.observer,d,l,h,e)}var e=t.prototype;return e.destroy=function(){var t=this.worker;if(t)t.removeEventListener("message",this.onwmsg),t.terminate(),this.worker=null;else{var e=this.transmuxer;e&&(e.destroy(),this.transmuxer=null)}var r=this.observer;r&&r.removeAllListeners(),this.observer=null},e.push=function(t,e,r,i,a,n,s,l,u,d){var h,f,c=this;u.transmuxing.start=self.performance.now();var v=this.transmuxer,g=this.worker,p=n?n.start:a.start,m=a.decryptdata,y=this.frag,b=!(y&&a.cc===y.cc),T=!(y&&u.level===y.level),E=y?u.sn-y.sn:-1,S=this.part?u.part-this.part.index:1,L=!T&&(1===E||0===E&&1===S),A=self.performance.now();(T||E||0===a.stats.parsing.start)&&(a.stats.parsing.start=A),!n||!S&&L||(n.stats.parsing.start=A);var R=!(y&&(null===(h=a.initSegment)||void 0===h?void 0:h.url)===(null===(f=y.initSegment)||void 0===f?void 0:f.url)),D=new Gt.b(b,L,l,T,p,R);if(!L||b||R){o.b.log("[transmuxer-interface, "+a.type+"]: Starting new transmux session for sn: "+u.sn+" p: "+u.part+" level: "+u.level+" id: "+u.id+"\n        discontinuity: "+b+"\n        trackSwitch: "+T+"\n        contiguous: "+L+"\n        accurateTimeOffset: "+l+"\n        timeOffset: "+p+"\n        initSegmentChange: "+R);var _=new Gt.a(r,i,e,s,d);this.configureTransmuxer(_)}if(this.frag=a,this.part=n,g)g.postMessage({cmd:"demux",data:t,decryptdata:m,chunkMeta:u,state:D},t instanceof ArrayBuffer?[t]:[]);else if(v){var k=v.push(t,m,u,D);Object(Gt.d)(k)?k.then((function(t){c.handleTransmuxComplete(t)})):this.handleTransmuxComplete(k)}},e.flush=function(t){var e=this;t.transmuxing.start=self.performance.now();var r=this.transmuxer,i=this.worker;if(i)i.postMessage({cmd:"flush",chunkMeta:t});else if(r){var a=r.flush(t);Object(Gt.d)(a)?a.then((function(r){e.handleFlushResult(r,t)})):this.handleFlushResult(a,t)}},e.handleFlushResult=function(t,e){var r=this;t.forEach((function(t){r.handleTransmuxComplete(t)})),this.onFlush(e)},e.onWorkerMessage=function(t){var e=t.data,r=this.hls;switch(e.event){case"init":self.URL.revokeObjectURL(this.worker.objectURL);break;case"transmuxComplete":this.handleTransmuxComplete(e.data);break;case"flush":this.onFlush(e.data);break;default:e.data=e.data||{},e.data.frag=this.frag,e.data.id=this.id,r.trigger(e.event,e.data)}},e.configureTransmuxer=function(t){var e=this.worker,r=this.transmuxer;e?e.postMessage({cmd:"configure",config:t}):r&&r.configure(t)},e.handleTransmuxComplete=function(t){t.chunkMeta.transmuxing.end=self.performance.now(),this.onTransmuxComplete(t)},t}(),Vt=function(){function t(t,e,r,i){this.config=void 0,this.media=void 0,this.fragmentTracker=void 0,this.hls=void 0,this.nudgeRetry=0,this.stallReported=!1,this.stalled=null,this.moved=!1,this.seeking=!1,this.config=t,this.media=e,this.fragmentTracker=r,this.hls=i}var e=t.prototype;return e.destroy=function(){this.hls=this.fragmentTracker=this.media=null},e.poll=function(t){var e=this.config,r=this.media,i=this.stalled,a=r.currentTime,n=r.seeking,s=this.seeking&&!n,l=!this.seeking&&n;if(this.seeking=n,a===t){if((l||s)&&(this.stalled=null),!r.paused&&!r.ended&&0!==r.playbackRate&&at.getBuffered(r).length){var u=at.bufferInfo(r,a,0),d=u.len>0,h=u.nextStart||0;if(d||h){if(n){var f=u.len>2,c=!h||h-a>2&&!this.fragmentTracker.getPartialFragment(a);if(f||c)return;this.moved=!1}if(!this.moved&&null!==this.stalled){var v,g=Math.max(h,u.start||0)-a,p=this.hls.levels?this.hls.levels[this.hls.currentLevel]:null,m=(null==p||null===(v=p.details)||void 0===v?void 0:v.live)?2*p.details.targetduration:2;if(g>0&&g<=m)return void this._trySkipBufferHole(null)}var y=self.performance.now();if(null!==i){var b=y-i;!n&&b>=250&&this._reportStall(u.len);var T=at.bufferInfo(r,a,e.maxBufferHole);this._tryFixBufferStall(T,b)}else this.stalled=y}}}else if(this.moved=!0,null!==i){if(this.stallReported){var E=self.performance.now()-i;o.b.warn("playback not stuck anymore @"+a+", after "+Math.round(E)+"ms"),this.stallReported=!1}this.stalled=null,this.nudgeRetry=0}},e._tryFixBufferStall=function(t,e){var r=this.config,i=this.fragmentTracker,a=this.media.currentTime,n=i.getPartialFragment(a);n&&this._trySkipBufferHole(n)||t.len>r.maxBufferHole&&e>1e3*r.highBufferWatchdogPeriod&&(o.b.warn("Trying to nudge playhead over buffer-hole"),this.stalled=null,this._tryNudgeBuffer())},e._reportStall=function(t){var e=this.hls,r=this.media;this.stallReported||(this.stallReported=!0,o.b.warn("Playback stalling at @"+r.currentTime+" due to low buffer (buffer="+t+")"),e.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.BUFFER_STALLED_ERROR,fatal:!1,buffer:t}))},e._trySkipBufferHole=function(t){for(var e=this.config,r=this.hls,i=this.media,a=i.currentTime,l=0,u=at.getBuffered(i),d=0;d<u.length;d++){var h=u.start(d);if(a+e.maxBufferHole>=l&&a<h){var f=Math.max(h+.05,i.currentTime+.1);return o.b.warn("skipping hole, adjusting currentTime from "+a+" to "+f),this.moved=!0,this.stalled=null,i.currentTime=f,t&&r.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.BUFFER_SEEK_OVER_HOLE,fatal:!1,reason:"fragment loaded with buffer holes, seeking from "+a+" to "+f,frag:t}),f}l=u.end(d)}return 0},e._tryNudgeBuffer=function(){var t=this.config,e=this.hls,r=this.media,i=r.currentTime,a=(this.nudgeRetry||0)+1;if(this.nudgeRetry=a,a<t.nudgeMaxRetry){var l=i+a*t.nudgeOffset;o.b.warn("Nudging 'currentTime' from "+i+" to "+l),r.currentTime=l,e.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.BUFFER_NUDGE_ON_STALL,fatal:!1})}else o.b.error("Playhead still not moving while enough data buffered @"+i+" after "+t.nudgeMaxRetry+" nudges"),e.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.BUFFER_STALLED_ERROR,fatal:!0})},t}();function Wt(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function Yt(t,e){return(Yt=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}var Xt=function(t){var e,r;function i(e,r){var i;return(i=t.call(this,e,r,"[stream-controller]")||this).audioCodecSwap=!1,i.gapController=null,i.level=-1,i._forceStartLoad=!1,i.altAudio=!1,i.audioOnly=!1,i.fragPlaying=null,i.onvplaying=null,i.onvseeked=null,i.fragLastKbps=0,i.stalled=!1,i.couldBacktrack=!1,i.audioCodecSwitch=!1,i.videoBuffer=null,i._registerListeners(),i}r=t,(e=i).prototype=Object.create(r.prototype),e.prototype.constructor=e,Yt(e,r);var l,d,h=i.prototype;return h._registerListeners=function(){var t=this.hls;t.on(n.a.MEDIA_ATTACHED,this.onMediaAttached,this),t.on(n.a.MEDIA_DETACHING,this.onMediaDetaching,this),t.on(n.a.MANIFEST_LOADING,this.onManifestLoading,this),t.on(n.a.MANIFEST_PARSED,this.onManifestParsed,this),t.on(n.a.LEVEL_LOADING,this.onLevelLoading,this),t.on(n.a.LEVEL_LOADED,this.onLevelLoaded,this),t.on(n.a.FRAG_LOAD_EMERGENCY_ABORTED,this.onFragLoadEmergencyAborted,this),t.on(n.a.ERROR,this.onError,this),t.on(n.a.AUDIO_TRACK_SWITCHING,this.onAudioTrackSwitching,this),t.on(n.a.AUDIO_TRACK_SWITCHED,this.onAudioTrackSwitched,this),t.on(n.a.BUFFER_CREATED,this.onBufferCreated,this),t.on(n.a.BUFFER_FLUSHED,this.onBufferFlushed,this),t.on(n.a.LEVELS_UPDATED,this.onLevelsUpdated,this),t.on(n.a.FRAG_BUFFERED,this.onFragBuffered,this)},h._unregisterListeners=function(){var t=this.hls;t.off(n.a.MEDIA_ATTACHED,this.onMediaAttached,this),t.off(n.a.MEDIA_DETACHING,this.onMediaDetaching,this),t.off(n.a.MANIFEST_LOADING,this.onManifestLoading,this),t.off(n.a.MANIFEST_PARSED,this.onManifestParsed,this),t.off(n.a.LEVEL_LOADED,this.onLevelLoaded,this),t.off(n.a.FRAG_LOAD_EMERGENCY_ABORTED,this.onFragLoadEmergencyAborted,this),t.off(n.a.ERROR,this.onError,this),t.off(n.a.AUDIO_TRACK_SWITCHING,this.onAudioTrackSwitching,this),t.off(n.a.AUDIO_TRACK_SWITCHED,this.onAudioTrackSwitched,this),t.off(n.a.BUFFER_CREATED,this.onBufferCreated,this),t.off(n.a.BUFFER_FLUSHED,this.onBufferFlushed,this),t.off(n.a.LEVELS_UPDATED,this.onLevelsUpdated,this),t.off(n.a.FRAG_BUFFERED,this.onFragBuffered,this)},h.onHandlerDestroying=function(){this._unregisterListeners(),this.onMediaDetaching()},h.startLoad=function(t){if(this.levels){var e=this.lastCurrentTime,r=this.hls;if(this.stopLoad(),this.setInterval(100),this.level=-1,this.fragLoadError=0,!this.startFragRequested){var i=r.startLevel;-1===i&&(r.config.testBandwidth?(i=0,this.bitrateTest=!0):i=r.nextAutoLevel),this.level=r.nextLoadLevel=i,this.loadedmetadata=!1}e>0&&-1===t&&(this.log("Override startPosition with lastCurrentTime @"+e.toFixed(3)),t=e),this.state=Dt,this.nextLoadPosition=this.startPosition=this.lastCurrentTime=t,this.tick()}else this._forceStartLoad=!0,this.state=Rt},h.stopLoad=function(){this._forceStartLoad=!1,t.prototype.stopLoad.call(this)},h.doTick=function(){switch(this.state){case Dt:this.doTickIdle();break;case Ft:var t,e=this.levels,r=this.level,i=null==e||null===(t=e[r])||void 0===t?void 0:t.details;if(i&&(!i.live||this.levelLastLoaded===this.level)){if(this.waitForCdnTuneIn(i))break;this.state=Dt;break}break;case xt:var a,n=self.performance.now(),s=this.retryDate;(!s||n>=s||null!==(a=this.media)&&void 0!==a&&a.seeking)&&(this.log("retryDate reached, switch back to IDLE state"),this.state=Dt)}this.onTickEnd()},h.onTickEnd=function(){t.prototype.onTickEnd.call(this),this.checkBuffer(),this.checkFragmentChanged()},h.doTickIdle=function(){var t,e,r=this.hls,i=this.levelLastLoaded,a=this.levels,s=this.media,o=r.config,l=r.nextLoadLevel;if(null!==i&&(s||!this.startFragRequested&&o.startFragPrefetch)&&(!this.altAudio||!this.audioOnly)&&a&&a[l]){var d=a[l];this.level=r.nextLoadLevel=l;var h=d.details;if(!h||this.state===Ft||h.live&&this.levelLastLoaded!==l)this.state=Ft;else{var f=this.getFwdBufferInfo(this.mediaBuffer?this.mediaBuffer:s,_.b.MAIN);if(null!==f&&!(f.len>=this.getMaxBufferLength(d.maxBitrate))){if(this._streamEnded(f,h)){var c={};return this.altAudio&&(c.type="video"),this.hls.trigger(n.a.BUFFER_EOS,c),void(this.state=It)}var v=f.end,g=this.getNextFragment(v,h);if(this.couldBacktrack&&!this.fragPrevious&&g&&"initSegment"!==g.sn){var p=g.sn-h.startSN;p>1&&(g=h.fragments[p-1],this.fragmentTracker.removeFragment(g))}if(g&&this.fragmentTracker.getState(g)===Q.OK&&this.nextLoadPosition>v){var m=this.audioOnly&&!this.altAudio?u.a.AUDIO:u.a.VIDEO;this.afterBufferFlushed(s,m,_.b.MAIN),g=this.getNextFragment(this.nextLoadPosition,h)}g&&(!g.initSegment||g.initSegment.data||this.bitrateTest||(g=g.initSegment),"identity"!==(null===(t=g.decryptdata)||void 0===t?void 0:t.keyFormat)||null!==(e=g.decryptdata)&&void 0!==e&&e.key?this.loadFragment(g,h,v):this.loadKey(g,h))}}}},h.loadFragment=function(e,r,i){var a,n=this.fragmentTracker.getState(e);if(this.fragCurrent=e,n===Q.BACKTRACKED){var s=this.fragmentTracker.getBacktrackData(e);if(s)return this._handleFragmentLoadProgress(s),void this._handleFragmentLoadComplete(s);n=Q.NOT_LOADED}n===Q.NOT_LOADED||n===Q.PARTIAL?"initSegment"===e.sn?this._loadInitSegment(e):this.bitrateTest?(e.bitrateTest=!0,this.log("Fragment "+e.sn+" of level "+e.level+" is being downloaded to test bitrate and will not be buffered"),this._loadBitrateTestFrag(e)):(this.startFragRequested=!0,t.prototype.loadFragment.call(this,e,r,i)):n===Q.APPENDING?this.reduceMaxBufferLength(e.duration)&&this.fragmentTracker.removeFragment(e):0===(null===(a=this.media)||void 0===a?void 0:a.buffered.length)&&this.fragmentTracker.removeAllFragments()},h.getAppendedFrag=function(t){var e=this.fragmentTracker.getAppendedFrag(t,_.b.MAIN);return e&&"fragment"in e?e.fragment:e},h.getBufferedFrag=function(t){return this.fragmentTracker.getBufferedFrag(t,_.b.MAIN)},h.followingBufferedFrag=function(t){return t?this.getBufferedFrag(t.end+.5):null},h.immediateLevelSwitch=function(){this.abortCurrentFrag(),this.flushMainBuffer(0,Number.POSITIVE_INFINITY)},h.nextLevelSwitch=function(){var t=this.levels,e=this.media;if(null!=e&&e.readyState){var r,i=this.getAppendedFrag(e.currentTime);if(i&&i.start>1&&this.flushMainBuffer(0,i.start-1),!e.paused&&t){var a=t[this.hls.nextLoadLevel],n=this.fragLastKbps;r=n&&this.fragCurrent?this.fragCurrent.duration*a.maxBitrate/(1e3*n)+1:0}else r=0;var s=this.getBufferedFrag(e.currentTime+r);if(s){var o=this.followingBufferedFrag(s);if(o){this.abortCurrentFrag();var l=o.maxStartPTS?o.maxStartPTS:o.start,u=o.duration,d=Math.max(s.end,l+Math.min(Math.max(u-this.config.maxFragLookUpTolerance,.5*u),.75*u));this.flushMainBuffer(d,Number.POSITIVE_INFINITY)}}}},h.abortCurrentFrag=function(){var t=this.fragCurrent;this.fragCurrent=null,null!=t&&t.loader&&t.loader.abort(),this.state===_t&&(this.state=Dt),this.nextLoadPosition=this.getLoadPosition()},h.flushMainBuffer=function(e,r){t.prototype.flushMainBuffer.call(this,e,r,this.altAudio?"video":null)},h.onMediaAttached=function(e,r){t.prototype.onMediaAttached.call(this,e,r);var i=r.media;this.onvplaying=this.onMediaPlaying.bind(this),this.onvseeked=this.onMediaSeeked.bind(this),i.addEventListener("playing",this.onvplaying),i.addEventListener("seeked",this.onvseeked),this.gapController=new Vt(this.config,i,this.fragmentTracker,this.hls)},h.onMediaDetaching=function(){var e=this.media;e&&(e.removeEventListener("playing",this.onvplaying),e.removeEventListener("seeked",this.onvseeked),this.onvplaying=this.onvseeked=null,this.videoBuffer=null),this.fragPlaying=null,this.gapController&&(this.gapController.destroy(),this.gapController=null),t.prototype.onMediaDetaching.call(this)},h.onMediaPlaying=function(){this.tick()},h.onMediaSeeked=function(){var t=this.media,e=t?t.currentTime:null;Object(a.a)(e)&&this.log("Media seeked to "+e.toFixed(3)),this.tick()},h.onManifestLoading=function(){this.log("Trigger BUFFER_RESET"),this.hls.trigger(n.a.BUFFER_RESET,void 0),this.fragmentTracker.removeAllFragments(),this.couldBacktrack=this.stalled=!1,this.startPosition=this.lastCurrentTime=0,this.fragPlaying=null},h.onManifestParsed=function(t,e){var r,i,a,n=!1,s=!1;e.levels.forEach((function(t){(r=t.audioCodec)&&(-1!==r.indexOf("mp4a.40.2")&&(n=!0),-1!==r.indexOf("mp4a.40.5")&&(s=!0))})),this.audioCodecSwitch=n&&s&&!("function"==typeof(null==(a=Bt())||null===(i=a.prototype)||void 0===i?void 0:i.changeType)),this.audioCodecSwitch&&this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"),this.levels=e.levels,this.startFragRequested=!1},h.onLevelLoading=function(t,e){var r=this.levels;if(r&&this.state===Dt){var i=r[e.level];(!i.details||i.details.live&&this.levelLastLoaded!==e.level||this.waitForCdnTuneIn(i.details))&&(this.state=Ft)}},h.onLevelLoaded=function(t,e){var r,i=this.levels,a=e.level,s=e.details,o=s.totalduration;if(i){this.log("Level "+a+" loaded ["+s.startSN+","+s.endSN+"], cc ["+s.startCC+", "+s.endCC+"] duration:"+o);var l=this.fragCurrent;!l||this.state!==kt&&this.state!==xt||l.level!==e.level&&l.loader&&(this.state=Dt,l.loader.abort());var u=i[a],d=0;if(s.live||null!==(r=u.details)&&void 0!==r&&r.live){if(s.fragments[0]||(s.deltaUpdateFailed=!0),s.deltaUpdateFailed)return;d=this.alignPlaylists(s,u.details)}if(u.details=s,this.levelLastLoaded=a,this.hls.trigger(n.a.LEVEL_UPDATED,{details:s,level:a}),this.state===Ft){if(this.waitForCdnTuneIn(s))return;this.state=Dt}this.startFragRequested?s.live&&this.synchronizeToLiveEdge(s):this.setStartPosition(s,d),this.tick()}else this.warn("Levels were reset while loading level "+a)},h._handleFragmentLoadProgress=function(t){var e,r=t.frag,i=t.part,a=t.payload,n=this.levels;if(n){var s=n[r.level],o=s.details;if(o){var l=s.videoCodec,u=o.PTSKnown||!o.live,d=null===(e=r.initSegment)||void 0===e?void 0:e.data,h=this._getAudioCodec(s),f=this.transmuxer=this.transmuxer||new Kt(this.hls,_.b.MAIN,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this)),c=i?i.index:-1,v=-1!==c,g=new nt(r.level,r.sn,r.stats.chunkCount,a.byteLength,c,v),p=this.initPTS[r.cc];f.push(a,d,h,l,r,i,o.totalduration,u,g,p)}else this.warn("Dropping fragment "+r.sn+" of level "+r.level+" after level details were reset")}else this.warn("Levels were reset while fragment load was in progress. Fragment "+r.sn+" of level "+r.level+" will not be buffered")},h.onAudioTrackSwitching=function(t,e){var r=this.altAudio,i=!!e.url,a=e.id;if(!i){if(this.mediaBuffer!==this.media){this.log("Switching on main audio, use media.buffered to schedule main fragment loading"),this.mediaBuffer=this.media;var s=this.fragCurrent;null!=s&&s.loader&&(this.log("Switching to main audio track, cancel main fragment load"),s.loader.abort()),this.resetTransmuxer(),this.resetLoadingState()}else this.audioOnly&&this.resetTransmuxer();var o=this.hls;r&&o.trigger(n.a.BUFFER_FLUSHING,{startOffset:0,endOffset:Number.POSITIVE_INFINITY,type:"audio"}),o.trigger(n.a.AUDIO_TRACK_SWITCHED,{id:a})}},h.onAudioTrackSwitched=function(t,e){var r=e.id,i=!!this.hls.audioTracks[r].url;if(i){var a=this.videoBuffer;a&&this.mediaBuffer!==a&&(this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"),this.mediaBuffer=a)}this.altAudio=i,this.tick()},h.onBufferCreated=function(t,e){var r,i,a=e.tracks,n=!1;for(var s in a){var o=a[s];if("main"===o.id){if(i=s,r=o,"video"===s){var l=a[s];l&&(this.videoBuffer=l.buffer)}}else n=!0}n&&r?(this.log("Alternate track found, use "+i+".buffered to schedule main fragment loading"),this.mediaBuffer=r.buffer):this.mediaBuffer=this.media},h.onFragBuffered=function(t,e){var r=e.frag,i=e.part;if(!r||r.type===_.b.MAIN){if(this.fragContextChanged(r))return this.warn("Fragment "+r.sn+(i?" p: "+i.index:"")+" of level "+r.level+" finished buffering, but was aborted. state: "+this.state),void(this.state===Ct&&(this.state=Dt));var a=i?i.stats:r.stats;this.fragLastKbps=Math.round(8*a.total/(a.buffering.end-a.loading.first)),"initSegment"!==r.sn&&(this.fragPrevious=r),this.fragBufferedComplete(r,i)}},h.onError=function(t,e){switch(e.details){case s.a.FRAG_LOAD_ERROR:case s.a.FRAG_LOAD_TIMEOUT:case s.a.KEY_LOAD_ERROR:case s.a.KEY_LOAD_TIMEOUT:this.onFragmentOrKeyLoadError(_.b.MAIN,e);break;case s.a.LEVEL_LOAD_ERROR:case s.a.LEVEL_LOAD_TIMEOUT:this.state!==Pt&&(e.fatal?(this.warn(""+e.details),this.state=Pt):e.levelRetry||this.state!==Ft||(this.state=Dt));break;case s.a.BUFFER_FULL_ERROR:if("main"===e.parent&&(this.state===wt||this.state===Ct)){var r=!0,i=this.getFwdBufferInfo(this.media,_.b.MAIN);i&&i.len>.5&&(r=!this.reduceMaxBufferLength(i.len)),r&&(this.warn("buffer full error also media.currentTime is not buffered, flush main"),this.immediateLevelSwitch()),this.resetLoadingState()}}},h.checkBuffer=function(){var t=this.media,e=this.gapController;if(t&&e&&t.readyState){var r=at.getBuffered(t);!this.loadedmetadata&&r.length?(this.loadedmetadata=!0,this.seekToStartPos()):e.poll(this.lastCurrentTime),this.lastCurrentTime=t.currentTime}},h.onFragLoadEmergencyAborted=function(){this.state=Dt,this.loadedmetadata||(this.startFragRequested=!1,this.nextLoadPosition=this.startPosition),this.tickImmediate()},h.onBufferFlushed=function(t,e){var r=e.type;if(r!==u.a.AUDIO||this.audioOnly&&!this.altAudio){var i=(r===u.a.VIDEO?this.videoBuffer:this.mediaBuffer)||this.media;this.afterBufferFlushed(i,r,_.b.MAIN)}},h.onLevelsUpdated=function(t,e){this.levels=e.levels},h.swapAudioCodec=function(){this.audioCodecSwap=!this.audioCodecSwap},h.seekToStartPos=function(){var t=this.media,e=t.currentTime,r=this.startPosition;if(r>=0&&e<r){if(t.seeking)return void o.b.log("could not seek to "+r+", already seeking at "+e);var i=at.getBuffered(t),a=(i.length?i.start(0):0)-r;a>0&&(a<this.config.maxBufferHole||a<this.config.maxFragLookUpTolerance)&&(o.b.log("adjusting start position by "+a+" to match buffer start"),r+=a,this.startPosition=r),this.log("seek to target start position "+r+" from current time "+e),t.currentTime=r}},h._getAudioCodec=function(t){var e=this.config.defaultAudioCodec||t.audioCodec;return this.audioCodecSwap&&e&&(this.log("Swapping audio codec"),e=-1!==e.indexOf("mp4a.40.5")?"mp4a.40.2":"mp4a.40.5"),e},h._loadBitrateTestFrag=function(t){var e=this;this._doFragLoad(t).then((function(r){var i=e.hls;if(r&&!i.nextLoadLevel&&!e.fragContextChanged(t)){e.fragLoadError=0,e.state=Dt,e.startFragRequested=!1,e.bitrateTest=!1;var a=t.stats;a.parsing.start=a.parsing.end=a.buffering.start=a.buffering.end=self.performance.now(),i.trigger(n.a.FRAG_LOADED,r)}}))},h._handleTransmuxComplete=function(t){var e,r="main",i=this.hls,s=t.remuxResult,o=t.chunkMeta,l=this.getCurrentContext(o);if(!l)return this.warn("The loading context changed while buffering fragment "+o.sn+" of level "+o.level+". This chunk will not be buffered."),void this.resetLiveStartWhenNotLoaded(o.level);var d=l.frag,h=l.part,f=l.level,c=s.video,v=s.text,g=s.id3,p=s.initSegment,m=this.altAudio?void 0:s.audio;if(!this.fragContextChanged(d)){if(this.state=wt,p){p.tracks&&(this._bufferInitSegment(f,p.tracks,d,o),i.trigger(n.a.FRAG_PARSING_INIT_SEGMENT,{frag:d,id:r,tracks:p.tracks}));var y=p.initPTS,b=p.timescale;Object(a.a)(y)&&(this.initPTS[d.cc]=y,i.trigger(n.a.INIT_PTS_FOUND,{frag:d,id:r,initPTS:y,timescale:b}))}if(c&&!1!==s.independent){if(f.details){var T=c.startPTS,E=c.endPTS,S=c.startDTS,L=c.endDTS;if(h)h.elementaryStreams[c.type]={startPTS:T,endPTS:E,startDTS:S,endDTS:L};else if(c.firstKeyFrame&&c.independent&&(this.couldBacktrack=!0),c.dropped&&c.independent){if(this.getLoadPosition()+this.config.maxBufferHole<T)return void this.backtrack(d);d.setElementaryStreamInfo(c.type,d.start,E,d.start,L,!0)}d.setElementaryStreamInfo(c.type,T,E,S,L),this.bufferFragmentData(c,d,h,o)}}else if(!1===s.independent)return void this.backtrack(d);if(m){var A=m.startPTS,R=m.endPTS,D=m.startDTS,_=m.endDTS;h&&(h.elementaryStreams[u.a.AUDIO]={startPTS:A,endPTS:R,startDTS:D,endDTS:_}),d.setElementaryStreamInfo(u.a.AUDIO,A,R,D,_),this.bufferFragmentData(m,d,h,o)}if(null!=g&&null!==(e=g.samples)&&void 0!==e&&e.length){var k={frag:d,id:r,samples:g.samples};i.trigger(n.a.FRAG_PARSING_METADATA,k)}if(v){var x={frag:d,id:r,samples:v.samples};i.trigger(n.a.FRAG_PARSING_USERDATA,x)}}},h._bufferInitSegment=function(t,e,r,i){var a=this;if(this.state===wt){this.audioOnly=!!e.audio&&!e.video,this.altAudio&&!this.audioOnly&&delete e.audio;var s=e.audio,o=e.video,l=e.audiovideo;if(s){var u=t.audioCodec,d=navigator.userAgent.toLowerCase();this.audioCodecSwitch&&(u&&(u=-1!==u.indexOf("mp4a.40.5")?"mp4a.40.2":"mp4a.40.5"),1!==s.metadata.channelCount&&-1===d.indexOf("firefox")&&(u="mp4a.40.5")),-1!==d.indexOf("android")&&"audio/mpeg"!==s.container&&(u="mp4a.40.2",this.log("Android: force audio codec to "+u)),t.audioCodec&&t.audioCodec!==u&&this.log('Swapping manifest audio codec "'+t.audioCodec+'" for "'+u+'"'),s.levelCodec=u,s.id="main",this.log("Init audio buffer, container:"+s.container+", codecs[selected/level/parsed]=["+(u||"")+"/"+(t.audioCodec||"")+"/"+s.codec+"]")}o&&(o.levelCodec=t.videoCodec,o.id="main",this.log("Init video buffer, container:"+o.container+", codecs[level/parsed]=["+(t.videoCodec||"")+"/"+o.codec+"]")),l&&this.log("Init audiovideo buffer, container:"+l.container+", codecs[level/parsed]=["+(t.attrs.CODECS||"")+"/"+l.codec+"]"),this.hls.trigger(n.a.BUFFER_CODECS,e),Object.keys(e).forEach((function(t){var s=e[t].initSegment;null!=s&&s.byteLength&&a.hls.trigger(n.a.BUFFER_APPENDING,{type:t,data:s,frag:r,part:null,chunkMeta:i,parent:r.type})})),this.tick()}},h.backtrack=function(t){this.couldBacktrack=!0,this.resetTransmuxer(),this.flushBufferGap(t);var e=this.fragmentTracker.backtrack(t);this.fragPrevious=null,this.nextLoadPosition=t.start,e?this.resetFragmentLoading(t):this.state=Ot},h.checkFragmentChanged=function(){var t=this.media,e=null;if(t&&t.readyState>1&&!1===t.seeking){var r=t.currentTime;if(at.isBuffered(t,r)?e=this.getAppendedFrag(r):at.isBuffered(t,r+.1)&&(e=this.getAppendedFrag(r+.1)),e){var i=this.fragPlaying,a=e.level;i&&e.sn===i.sn&&i.level===a&&e.urlId===i.urlId||(this.hls.trigger(n.a.FRAG_CHANGED,{frag:e}),i&&i.level===a||this.hls.trigger(n.a.LEVEL_SWITCHED,{level:a}),this.fragPlaying=e)}}},l=i,(d=[{key:"nextLevel",get:function(){var t=this.nextBufferedFrag;return t?t.level:-1}},{key:"currentLevel",get:function(){var t=this.media;if(t){var e=this.getAppendedFrag(t.currentTime);if(e)return e.level}return-1}},{key:"nextBufferedFrag",get:function(){var t=this.media;if(t){var e=this.getAppendedFrag(t.currentTime);return this.followingBufferedFrag(e)}return null}},{key:"forceStartLoad",get:function(){return this._forceStartLoad}}])&&Wt(l.prototype,d),i}(Mt),qt=function(){function t(t,e,r){void 0===e&&(e=0),void 0===r&&(r=0),this.halfLife=void 0,this.alpha_=void 0,this.estimate_=void 0,this.totalWeight_=void 0,this.halfLife=t,this.alpha_=t?Math.exp(Math.log(.5)/t):0,this.estimate_=e,this.totalWeight_=r}var e=t.prototype;return e.sample=function(t,e){var r=Math.pow(this.alpha_,t);this.estimate_=e*(1-r)+r*this.estimate_,this.totalWeight_+=t},e.getTotalWeight=function(){return this.totalWeight_},e.getEstimate=function(){if(this.alpha_){var t=1-Math.pow(this.alpha_,this.totalWeight_);if(t)return this.estimate_/t}return this.estimate_},t}(),zt=function(){function t(t,e,r){this.defaultEstimate_=void 0,this.minWeight_=void 0,this.minDelayMs_=void 0,this.slow_=void 0,this.fast_=void 0,this.defaultEstimate_=r,this.minWeight_=.001,this.minDelayMs_=50,this.slow_=new qt(t),this.fast_=new qt(e)}var e=t.prototype;return e.update=function(t,e){var r=this.slow_,i=this.fast_;this.slow_.halfLife!==t&&(this.slow_=new qt(t,r.getEstimate(),r.getTotalWeight())),this.fast_.halfLife!==e&&(this.fast_=new qt(e,i.getEstimate(),i.getTotalWeight()))},e.sample=function(t,e){var r=(t=Math.max(t,this.minDelayMs_))/1e3,i=8*e/r;this.fast_.sample(r,i),this.slow_.sample(r,i)},e.canEstimate=function(){var t=this.fast_;return t&&t.getTotalWeight()>=this.minWeight_},e.getEstimate=function(){return this.canEstimate()?Math.min(this.fast_.getEstimate(),this.slow_.getEstimate()):this.defaultEstimate_},e.destroy=function(){},t}();function Qt(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var $t=function(){function t(t){this.hls=void 0,this.lastLoadedFragLevel=0,this._nextAutoLevel=-1,this.timer=void 0,this.onCheck=this._abandonRulesCheck.bind(this),this.fragCurrent=null,this.partCurrent=null,this.bitrateTestDelay=0,this.bwEstimator=void 0,this.hls=t;var e=t.config;this.bwEstimator=new zt(e.abrEwmaSlowVoD,e.abrEwmaFastVoD,e.abrEwmaDefaultEstimate),this.registerListeners()}var e,r,i=t.prototype;return i.registerListeners=function(){var t=this.hls;t.on(n.a.FRAG_LOADING,this.onFragLoading,this),t.on(n.a.FRAG_LOADED,this.onFragLoaded,this),t.on(n.a.FRAG_BUFFERED,this.onFragBuffered,this),t.on(n.a.LEVEL_LOADED,this.onLevelLoaded,this),t.on(n.a.ERROR,this.onError,this)},i.unregisterListeners=function(){var t=this.hls;t.off(n.a.FRAG_LOADING,this.onFragLoading,this),t.off(n.a.FRAG_LOADED,this.onFragLoaded,this),t.off(n.a.FRAG_BUFFERED,this.onFragBuffered,this),t.off(n.a.LEVEL_LOADED,this.onLevelLoaded,this),t.off(n.a.ERROR,this.onError,this)},i.destroy=function(){this.unregisterListeners(),this.clearTimer(),this.hls=this.onCheck=null,this.fragCurrent=this.partCurrent=null},i.onFragLoading=function(t,e){var r,i=e.frag;i.type===_.b.MAIN&&(this.timer||(this.fragCurrent=i,this.partCurrent=null!=(r=e.part)?r:null,this.timer=self.setInterval(this.onCheck,100)))},i.onLevelLoaded=function(t,e){var r=this.hls.config;e.details.live?this.bwEstimator.update(r.abrEwmaSlowLive,r.abrEwmaFastLive):this.bwEstimator.update(r.abrEwmaSlowVoD,r.abrEwmaFastVoD)},i._abandonRulesCheck=function(){var t=this.fragCurrent,e=this.partCurrent,r=this.hls,i=r.autoLevelEnabled,s=r.config,l=r.media;if(t&&l){var u=e?e.stats:t.stats,d=e?e.duration:t.duration;if(u.aborted)return o.b.warn("frag loader destroy or aborted, disarm abandonRules"),this.clearTimer(),void(this._nextAutoLevel=-1);if(i&&!l.paused&&l.playbackRate&&l.readyState){var h=performance.now()-u.loading.start,f=Math.abs(l.playbackRate);if(!(h<=500*d/f)){var c=r.levels,v=r.minAutoLevel,g=c[t.level],p=u.total||Math.max(u.loaded,Math.round(d*g.maxBitrate/8)),m=Math.max(1,u.bwEstimate?u.bwEstimate/8:1e3*u.loaded/h),y=(p-u.loaded)/m,b=l.currentTime,T=(at.bufferInfo(l,b,s.maxBufferHole).end-b)/f;if(!(T>=2*d/f||y<=T)){var E,S=Number.POSITIVE_INFINITY;for(E=t.level-1;E>v&&!((S=d*c[E].maxBitrate/(6.4*m))<T);E--);if(!(S>=y)){var L=this.bwEstimator.getEstimate();o.b.warn("Fragment "+t.sn+(e?" part "+e.index:"")+" of level "+t.level+" is loading too slowly and will cause an underbuffer; aborting and switching to level "+E+"\n      Current BW estimate: "+(Object(a.a)(L)?(L/1024).toFixed(3):"Unknown")+" Kb/s\n      Estimated load time for current fragment: "+y.toFixed(3)+" s\n      Estimated load time for the next fragment: "+S.toFixed(3)+" s\n      Time to underbuffer: "+T.toFixed(3)+" s"),r.nextLoadLevel=E,this.bwEstimator.sample(h,u.loaded),this.clearTimer(),t.loader&&(this.fragCurrent=this.partCurrent=null,t.loader.abort()),r.trigger(n.a.FRAG_LOAD_EMERGENCY_ABORTED,{frag:t,part:e,stats:u})}}}}}},i.onFragLoaded=function(t,e){var r=e.frag,i=e.part;if(r.type===_.b.MAIN&&Object(a.a)(r.sn)){var s=i?i.stats:r.stats,o=i?i.duration:r.duration;if(this.clearTimer(),this.lastLoadedFragLevel=r.level,this._nextAutoLevel=-1,this.hls.config.abrMaxWithRealBitrate){var l=this.hls.levels[r.level],u=(l.loaded?l.loaded.bytes:0)+s.loaded,d=(l.loaded?l.loaded.duration:0)+o;l.loaded={bytes:u,duration:d},l.realBitrate=Math.round(8*u/d)}if(r.bitrateTest){var h={stats:s,frag:r,part:i,id:r.type};this.onFragBuffered(n.a.FRAG_BUFFERED,h),r.bitrateTest=!1}}},i.onFragBuffered=function(t,e){var r=e.frag,i=e.part,a=i?i.stats:r.stats;if(!a.aborted&&r.type===_.b.MAIN&&"initSegment"!==r.sn){var n=a.parsing.end-a.loading.start;this.bwEstimator.sample(n,a.loaded),a.bwEstimate=this.bwEstimator.getEstimate(),r.bitrateTest?this.bitrateTestDelay=n/1e3:this.bitrateTestDelay=0}},i.onError=function(t,e){switch(e.details){case s.a.FRAG_LOAD_ERROR:case s.a.FRAG_LOAD_TIMEOUT:this.clearTimer()}},i.clearTimer=function(){self.clearInterval(this.timer),this.timer=void 0},i.getNextABRAutoLevel=function(){var t=this.fragCurrent,e=this.partCurrent,r=this.hls,i=r.maxAutoLevel,a=r.config,n=r.minAutoLevel,s=r.media,l=e?e.duration:t?t.duration:0,u=s?s.currentTime:0,d=s&&0!==s.playbackRate?Math.abs(s.playbackRate):1,h=this.bwEstimator?this.bwEstimator.getEstimate():a.abrEwmaDefaultEstimate,f=(at.bufferInfo(s,u,a.maxBufferHole).end-u)/d,c=this.findBestLevel(h,n,i,f,a.abrBandWidthFactor,a.abrBandWidthUpFactor);if(c>=0)return c;o.b.trace((f?"rebuffering expected":"buffer is empty")+", finding optimal quality level");var v=l?Math.min(l,a.maxStarvationDelay):a.maxStarvationDelay,g=a.abrBandWidthFactor,p=a.abrBandWidthUpFactor;if(!f){var m=this.bitrateTestDelay;m&&(v=(l?Math.min(l,a.maxLoadingDelay):a.maxLoadingDelay)-m,o.b.trace("bitrate test took "+Math.round(1e3*m)+"ms, set first fragment max fetchDuration to "+Math.round(1e3*v)+" ms"),g=p=1)}return c=this.findBestLevel(h,n,i,f+v,g,p),Math.max(c,0)},i.findBestLevel=function(t,e,r,i,a,n){for(var s,l=this.fragCurrent,u=this.partCurrent,d=this.lastLoadedFragLevel,h=this.hls.levels,f=h[d],c=!(null==f||null===(s=f.details)||void 0===s||!s.live),v=null==f?void 0:f.codecSet,g=u?u.duration:l?l.duration:0,p=r;p>=e;p--){var m=h[p];if(m&&(!v||m.codecSet===v)){var y,b=m.details,T=(u?null==b?void 0:b.partTarget:null==b?void 0:b.averagetargetduration)||g;y=p<=d?a*t:n*t;var E=h[p].maxBitrate,S=E*T/y;if(o.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: "+p+"/"+Math.round(y)+"/"+E+"/"+T+"/"+i+"/"+S),y>E&&(!S||c&&!this.bitrateTestDelay||S<i))return p}}return-1},e=t,(r=[{key:"nextAutoLevel",get:function(){var t=this._nextAutoLevel,e=this.bwEstimator;if(!(-1===t||e&&e.canEstimate()))return t;var r=this.getNextABRAutoLevel();return-1!==t&&(r=Math.min(t,r)),r},set:function(t){this._nextAutoLevel=t}}])&&Qt(e.prototype,r),t}(),Zt=r(10),Jt=r.n(Zt),te=function(){function t(t){this.buffers=void 0,this.queues={video:[],audio:[],audiovideo:[]},this.buffers=t}var e=t.prototype;return e.append=function(t,e){var r=this.queues[e];r.push(t),1===r.length&&this.buffers[e]&&this.executeNext(e)},e.insertAbort=function(t,e){this.queues[e].unshift(t),this.executeNext(e)},e.appendBlocker=function(t){var e,r=new Promise((function(t){e=t})),i={execute:e,onStart:function(){},onComplete:function(){},onError:function(){}};return this.append(i,t),r},e.executeNext=function(t){var e=this.buffers,r=this.queues,i=e[t],a=r[t];if(a.length){var n=a[0];try{n.execute()}catch(e){o.b.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"),n.onError(e),i&&i.updating||(a.shift(),this.executeNext(t))}}},e.shiftAndExecuteNext=function(t){this.queues[t].shift(),this.executeNext(t)},e.current=function(t){return this.queues[t][0]},t}(),ee=Nt(),re=/([ha]vc.)(?:\.[^.,]+)+/,ie=function(){function t(t){var e=this;this.details=null,this._objectUrl=null,this.operationQueue=void 0,this.listeners=void 0,this.hls=void 0,this.bufferCodecEventsExpected=0,this._bufferCodecEventsTotal=0,this.media=null,this.mediaSource=null,this.appendError=0,this.tracks={},this.pendingTracks={},this.sourceBuffer=void 0,this._onMediaSourceOpen=function(){var t=e.hls,r=e.media,i=e.mediaSource;o.b.log("[buffer-controller]: Media source opened"),r&&(e.updateMediaElementDuration(),t.trigger(n.a.MEDIA_ATTACHED,{media:r})),i&&i.removeEventListener("sourceopen",e._onMediaSourceOpen),e.checkPendingTracks()},this._onMediaSourceClose=function(){o.b.log("[buffer-controller]: Media source closed")},this._onMediaSourceEnded=function(){o.b.log("[buffer-controller]: Media source ended")},this.hls=t,this._initSourceBuffer(),this.registerListeners()}var e=t.prototype;return e.hasSourceTypes=function(){return this.getSourceBufferTypes().length>0||Object.keys(this.pendingTracks).length>0},e.destroy=function(){this.unregisterListeners(),this.details=null},e.registerListeners=function(){var t=this.hls;t.on(n.a.MEDIA_ATTACHING,this.onMediaAttaching,this),t.on(n.a.MEDIA_DETACHING,this.onMediaDetaching,this),t.on(n.a.MANIFEST_PARSED,this.onManifestParsed,this),t.on(n.a.BUFFER_RESET,this.onBufferReset,this),t.on(n.a.BUFFER_APPENDING,this.onBufferAppending,this),t.on(n.a.BUFFER_CODECS,this.onBufferCodecs,this),t.on(n.a.BUFFER_EOS,this.onBufferEos,this),t.on(n.a.BUFFER_FLUSHING,this.onBufferFlushing,this),t.on(n.a.LEVEL_UPDATED,this.onLevelUpdated,this),t.on(n.a.FRAG_PARSED,this.onFragParsed,this),t.on(n.a.FRAG_CHANGED,this.onFragChanged,this)},e.unregisterListeners=function(){var t=this.hls;t.off(n.a.MEDIA_ATTACHING,this.onMediaAttaching,this),t.off(n.a.MEDIA_DETACHING,this.onMediaDetaching,this),t.off(n.a.MANIFEST_PARSED,this.onManifestParsed,this),t.off(n.a.BUFFER_RESET,this.onBufferReset,this),t.off(n.a.BUFFER_APPENDING,this.onBufferAppending,this),t.off(n.a.BUFFER_CODECS,this.onBufferCodecs,this),t.off(n.a.BUFFER_EOS,this.onBufferEos,this),t.off(n.a.BUFFER_FLUSHING,this.onBufferFlushing,this),t.off(n.a.LEVEL_UPDATED,this.onLevelUpdated,this),t.off(n.a.FRAG_PARSED,this.onFragParsed,this),t.off(n.a.FRAG_CHANGED,this.onFragChanged,this)},e._initSourceBuffer=function(){this.sourceBuffer={},this.operationQueue=new te(this.sourceBuffer),this.listeners={audio:[],video:[],audiovideo:[]}},e.onManifestParsed=function(t,e){var r=2;(e.audio&&!e.video||!e.altAudio)&&(r=1),this.bufferCodecEventsExpected=this._bufferCodecEventsTotal=r,this.details=null,o.b.log(this.bufferCodecEventsExpected+" bufferCodec event(s) expected")},e.onMediaAttaching=function(t,e){var r=this.media=e.media;if(r&&ee){var i=this.mediaSource=new ee;i.addEventListener("sourceopen",this._onMediaSourceOpen),i.addEventListener("sourceended",this._onMediaSourceEnded),i.addEventListener("sourceclose",this._onMediaSourceClose),r.src=self.URL.createObjectURL(i),this._objectUrl=r.src}},e.onMediaDetaching=function(){var t=this.media,e=this.mediaSource,r=this._objectUrl;if(e){if(o.b.log("[buffer-controller]: media source detaching"),"open"===e.readyState)try{e.endOfStream()}catch(t){o.b.warn("[buffer-controller]: onMediaDetaching: "+t.message+" while calling endOfStream")}this.onBufferReset(),e.removeEventListener("sourceopen",this._onMediaSourceOpen),e.removeEventListener("sourceended",this._onMediaSourceEnded),e.removeEventListener("sourceclose",this._onMediaSourceClose),t&&(r&&self.URL.revokeObjectURL(r),t.src===r?(t.removeAttribute("src"),t.load()):o.b.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")),this.mediaSource=null,this.media=null,this._objectUrl=null,this.bufferCodecEventsExpected=this._bufferCodecEventsTotal,this.pendingTracks={},this.tracks={}}this.hls.trigger(n.a.MEDIA_DETACHED,void 0)},e.onBufferReset=function(){var t=this;this.getSourceBufferTypes().forEach((function(e){var r=t.sourceBuffer[e];try{r&&(t.removeBufferListeners(e),t.mediaSource&&t.mediaSource.removeSourceBuffer(r),t.sourceBuffer[e]=void 0)}catch(t){o.b.warn("[buffer-controller]: Failed to reset the "+e+" buffer",t)}})),this._initSourceBuffer()},e.onBufferCodecs=function(t,e){var r=this,i=this.getSourceBufferTypes().length;Object.keys(e).forEach((function(t){if(i){var a=r.tracks[t];if(a&&"function"==typeof a.buffer.changeType){var n=e[t],s=n.codec,o=n.levelCodec,l=n.container;if((a.levelCodec||a.codec).replace(re,"$1")!==(o||s).replace(re,"$1")){var u=l+";codecs="+(o||s);r.appendChangeType(t,u)}}}else r.pendingTracks[t]=e[t]})),i||(this.bufferCodecEventsExpected=Math.max(this.bufferCodecEventsExpected-1,0),this.mediaSource&&"open"===this.mediaSource.readyState&&this.checkPendingTracks())},e.appendChangeType=function(t,e){var r=this,i=this.operationQueue,a={execute:function(){var a=r.sourceBuffer[t];a&&(o.b.log("[buffer-controller]: changing "+t+" sourceBuffer type to "+e),a.changeType(e)),i.shiftAndExecuteNext(t)},onStart:function(){},onComplete:function(){},onError:function(e){o.b.warn("[buffer-controller]: Failed to change "+t+" SourceBuffer type",e)}};i.append(a,t)},e.onBufferAppending=function(t,e){var r=this,i=this.hls,a=this.operationQueue,l=this.tracks,u=e.data,d=e.type,h=e.frag,f=e.part,c=e.chunkMeta,v=c.buffering[d],g=self.performance.now();v.start=g;var p=h.stats.buffering,m=f?f.stats.buffering:null;0===p.start&&(p.start=g),m&&0===m.start&&(m.start=g);var y=l.audio,b="audio"===d&&1===c.id&&"audio/mpeg"===(null==y?void 0:y.container),T={execute:function(){if(v.executeStart=self.performance.now(),b){var t=r.sourceBuffer[d];if(t){var e=h.start-t.timestampOffset;Math.abs(e)>=.1&&(o.b.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to "+h.start+" (delta: "+e+") sn: "+h.sn+")"),t.timestampOffset=h.start)}}r.appendExecutor(u,d)},onStart:function(){},onComplete:function(){var t=self.performance.now();v.executeEnd=v.end=t,0===p.first&&(p.first=t),m&&0===m.first&&(m.first=t);var e=r.sourceBuffer,i={};for(var a in e)i[a]=at.getBuffered(e[a]);r.appendError=0,r.hls.trigger(n.a.BUFFER_APPENDED,{type:d,frag:h,part:f,chunkMeta:c,parent:h.type,timeRanges:i})},onError:function(t){o.b.error("[buffer-controller]: Error encountered while trying to append to the "+d+" SourceBuffer",t);var e={type:s.b.MEDIA_ERROR,parent:h.type,details:s.a.BUFFER_APPEND_ERROR,err:t,fatal:!1};t.code===DOMException.QUOTA_EXCEEDED_ERR?e.details=s.a.BUFFER_FULL_ERROR:(r.appendError++,e.details=s.a.BUFFER_APPEND_ERROR,r.appendError>i.config.appendErrorMaxRetry&&(o.b.error("[buffer-controller]: Failed "+i.config.appendErrorMaxRetry+" times to append segment in sourceBuffer"),e.fatal=!0)),i.trigger(n.a.ERROR,e)}};a.append(T,d)},e.onBufferFlushing=function(t,e){var r=this,i=this.operationQueue,a=function(t){return{execute:r.removeExecutor.bind(r,t,e.startOffset,e.endOffset),onStart:function(){},onComplete:function(){r.hls.trigger(n.a.BUFFER_FLUSHED,{type:t})},onError:function(e){o.b.warn("[buffer-controller]: Failed to remove from "+t+" SourceBuffer",e)}}};e.type?i.append(a(e.type),e.type):this.getSourceBufferTypes().forEach((function(t){i.append(a(t),t)}))},e.onFragParsed=function(t,e){var r=this,i=e.frag,a=e.part,s=[],l=a?a.elementaryStreams:i.elementaryStreams;l[u.a.AUDIOVIDEO]?s.push("audiovideo"):(l[u.a.AUDIO]&&s.push("audio"),l[u.a.VIDEO]&&s.push("video")),0===s.length&&o.b.warn("Fragments must have at least one ElementaryStreamType set. type: "+i.type+" level: "+i.level+" sn: "+i.sn),this.blockBuffers((function(){var t=self.performance.now();i.stats.buffering.end=t,a&&(a.stats.buffering.end=t);var e=a?a.stats:i.stats;r.hls.trigger(n.a.FRAG_BUFFERED,{frag:i,part:a,stats:e,id:i.type})}),s)},e.onFragChanged=function(t,e){this.flushBackBuffer()},e.onBufferEos=function(t,e){var r=this;this.getSourceBufferTypes().reduce((function(t,i){var a=r.sourceBuffer[i];return e.type&&e.type!==i||a&&!a.ended&&(a.ended=!0,o.b.log("[buffer-controller]: "+i+" sourceBuffer now EOS")),t&&!(a&&!a.ended)}),!0)&&this.blockBuffers((function(){var t=r.mediaSource;t&&"open"===t.readyState&&t.endOfStream()}))},e.onLevelUpdated=function(t,e){var r=e.details;r.fragments.length&&(this.details=r,this.getSourceBufferTypes().length?this.blockBuffers(this.updateMediaElementDuration.bind(this)):this.updateMediaElementDuration())},e.flushBackBuffer=function(){var t=this.hls,e=this.details,r=this.media,i=this.sourceBuffer;if(r&&null!==e){var s=this.getSourceBufferTypes();if(s.length){var o=e.live&&null!==t.config.liveBackBufferLength?t.config.liveBackBufferLength:t.config.backBufferLength;if(Object(a.a)(o)&&!(o<0)){var l=r.currentTime,u=e.levelTargetDuration,d=Math.max(o,u),h=Math.floor(l/u)*u-d;s.forEach((function(r){var a=i[r];if(a){var s=at.getBuffered(a);s.length>0&&h>s.start(0)&&(t.trigger(n.a.BACK_BUFFER_REACHED,{bufferEnd:h}),e.live&&t.trigger(n.a.LIVE_BACK_BUFFER_REACHED,{bufferEnd:h}),t.trigger(n.a.BUFFER_FLUSHING,{startOffset:0,endOffset:h,type:r}))}}))}}}},e.updateMediaElementDuration=function(){if(this.details&&this.media&&this.mediaSource&&"open"===this.mediaSource.readyState){var t=this.details,e=this.hls,r=this.media,i=this.mediaSource,n=t.fragments[0].start+t.totalduration,s=r.duration,l=Object(a.a)(i.duration)?i.duration:0;t.live&&e.config.liveDurationInfinity?(o.b.log("[buffer-controller]: Media Source duration is set to Infinity"),i.duration=1/0,this.updateSeekableRange(t)):(n>l&&n>s||!Object(a.a)(s))&&(o.b.log("[buffer-controller]: Updating Media Source duration to "+n.toFixed(3)),i.duration=n)}},e.updateSeekableRange=function(t){var e=this.mediaSource,r=t.fragments;if(r.length&&t.live&&null!=e&&e.setLiveSeekableRange){var i=Math.max(0,r[0].start),a=Math.max(i,i+t.totalduration);e.setLiveSeekableRange(i,a)}},e.checkPendingTracks=function(){var t=this.bufferCodecEventsExpected,e=this.operationQueue,r=this.pendingTracks,i=Object.keys(r).length;if(i&&!t||2===i){this.createSourceBuffers(r),this.pendingTracks={};var a=this.getSourceBufferTypes();if(0===a.length)return void this.hls.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.BUFFER_INCOMPATIBLE_CODECS_ERROR,fatal:!0,reason:"could not create source buffer for media codec(s)"});a.forEach((function(t){e.executeNext(t)}))}},e.createSourceBuffers=function(t){var e=this.sourceBuffer,r=this.mediaSource;if(!r)throw Error("createSourceBuffers called when mediaSource was null");var i=0;for(var a in t)if(!e[a]){var l=t[a];if(!l)throw Error("source buffer exists for track "+a+", however track does not");var u=l.levelCodec||l.codec,d=l.container+";codecs="+u;o.b.log("[buffer-controller]: creating sourceBuffer("+d+")");try{var h=e[a]=r.addSourceBuffer(d),f=a;this.addBufferListener(f,"updatestart",this._onSBUpdateStart),this.addBufferListener(f,"updateend",this._onSBUpdateEnd),this.addBufferListener(f,"error",this._onSBUpdateError),this.tracks[a]={buffer:h,codec:u,container:l.container,levelCodec:l.levelCodec,id:l.id},i++}catch(t){o.b.error("[buffer-controller]: error while trying to add sourceBuffer: "+t.message),this.hls.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.BUFFER_ADD_CODEC_ERROR,fatal:!1,error:t,mimeType:d})}}i&&this.hls.trigger(n.a.BUFFER_CREATED,{tracks:this.tracks})},e._onSBUpdateStart=function(t){this.operationQueue.current(t).onStart()},e._onSBUpdateEnd=function(t){var e=this.operationQueue;e.current(t).onComplete(),e.shiftAndExecuteNext(t)},e._onSBUpdateError=function(t,e){o.b.error("[buffer-controller]: "+t+" SourceBuffer error",e),this.hls.trigger(n.a.ERROR,{type:s.b.MEDIA_ERROR,details:s.a.BUFFER_APPENDING_ERROR,fatal:!1});var r=this.operationQueue.current(t);r&&r.onError(e)},e.removeExecutor=function(t,e,r){var i=this.media,n=this.mediaSource,s=this.operationQueue,l=this.sourceBuffer[t];if(!i||!n||!l)return o.b.warn("[buffer-controller]: Attempting to remove from the "+t+" SourceBuffer, but it does not exist"),void s.shiftAndExecuteNext(t);var u=Object(a.a)(i.duration)?i.duration:1/0,d=Object(a.a)(n.duration)?n.duration:1/0,h=Math.max(0,e),f=Math.min(r,u,d);f>h?(o.b.log("[buffer-controller]: Removing ["+h+","+f+"] from the "+t+" SourceBuffer"),l.remove(h,f)):s.shiftAndExecuteNext(t)},e.appendExecutor=function(t,e){var r=this.operationQueue,i=this.sourceBuffer[e];if(!i)return o.b.warn("[buffer-controller]: Attempting to append to the "+e+" SourceBuffer, but it does not exist"),void r.shiftAndExecuteNext(e);i.ended=!1,i.appendBuffer(t)},e.blockBuffers=function(t,e){var r=this;if(void 0===e&&(e=this.getSourceBufferTypes()),!e.length)return o.b.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"),void Promise.resolve(t);var i=this.operationQueue,a=e.map((function(t){return i.appendBlocker(t)}));Promise.all(a).then((function(){t(),e.forEach((function(t){var e=r.sourceBuffer[t];e&&e.updating||i.shiftAndExecuteNext(t)}))}))},e.getSourceBufferTypes=function(){return Object.keys(this.sourceBuffer)},e.addBufferListener=function(t,e,r){var i=this.sourceBuffer[t];if(i){var a=r.bind(this,t);this.listeners[t].push({event:e,listener:a}),i.addEventListener(e,a)}},e.removeBufferListeners=function(t){var e=this.sourceBuffer[t];e&&this.listeners[t].forEach((function(t){e.removeEventListener(t.event,t.listener)}))},t}();function ae(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var ne=function(){function t(t){this.autoLevelCapping=void 0,this.firstLevel=void 0,this.media=void 0,this.restrictedLevels=void 0,this.timer=void 0,this.hls=void 0,this.streamController=void 0,this.clientRect=void 0,this.hls=t,this.autoLevelCapping=Number.POSITIVE_INFINITY,this.firstLevel=-1,this.media=null,this.restrictedLevels=[],this.timer=void 0,this.clientRect=null,this.registerListeners()}var e,r,i,a=t.prototype;return a.setStreamController=function(t){this.streamController=t},a.destroy=function(){this.unregisterListener(),this.hls.config.capLevelToPlayerSize&&this.stopCapping(),this.media=null,this.clientRect=null,this.hls=this.streamController=null},a.registerListeners=function(){var t=this.hls;t.on(n.a.FPS_DROP_LEVEL_CAPPING,this.onFpsDropLevelCapping,this),t.on(n.a.MEDIA_ATTACHING,this.onMediaAttaching,this),t.on(n.a.MANIFEST_PARSED,this.onManifestParsed,this),t.on(n.a.BUFFER_CODECS,this.onBufferCodecs,this),t.on(n.a.MEDIA_DETACHING,this.onMediaDetaching,this)},a.unregisterListener=function(){var t=this.hls;t.off(n.a.FPS_DROP_LEVEL_CAPPING,this.onFpsDropLevelCapping,this),t.off(n.a.MEDIA_ATTACHING,this.onMediaAttaching,this),t.off(n.a.MANIFEST_PARSED,this.onManifestParsed,this),t.off(n.a.BUFFER_CODECS,this.onBufferCodecs,this),t.off(n.a.MEDIA_DETACHING,this.onMediaDetaching,this)},a.onFpsDropLevelCapping=function(e,r){t.isLevelAllowed(r.droppedLevel,this.restrictedLevels)&&this.restrictedLevels.push(r.droppedLevel)},a.onMediaAttaching=function(t,e){this.media=e.media instanceof HTMLVideoElement?e.media:null},a.onManifestParsed=function(t,e){var r=this.hls;this.restrictedLevels=[],this.firstLevel=e.firstLevel,r.config.capLevelToPlayerSize&&e.video&&this.startCapping()},a.onBufferCodecs=function(t,e){this.hls.config.capLevelToPlayerSize&&e.video&&this.startCapping()},a.onMediaDetaching=function(){this.stopCapping()},a.detectPlayerSize=function(){if(this.media&&this.mediaHeight>0&&this.mediaWidth>0){var t=this.hls.levels;if(t.length){var e=this.hls;e.autoLevelCapping=this.getMaxLevel(t.length-1),e.autoLevelCapping>this.autoLevelCapping&&this.streamController&&this.streamController.nextLevelSwitch(),this.autoLevelCapping=e.autoLevelCapping}}},a.getMaxLevel=function(e){var r=this,i=this.hls.levels;if(!i.length)return-1;var a=i.filter((function(i,a){return t.isLevelAllowed(a,r.restrictedLevels)&&a<=e}));return this.clientRect=null,t.getMaxLevelByMediaSize(a,this.mediaWidth,this.mediaHeight)},a.startCapping=function(){this.timer||(this.autoLevelCapping=Number.POSITIVE_INFINITY,this.hls.firstLevel=this.getMaxLevel(this.firstLevel),self.clearInterval(this.timer),this.timer=self.setInterval(this.detectPlayerSize.bind(this),1e3),this.detectPlayerSize())},a.stopCapping=function(){this.restrictedLevels=[],this.firstLevel=-1,this.autoLevelCapping=Number.POSITIVE_INFINITY,this.timer&&(self.clearInterval(this.timer),this.timer=void 0)},a.getDimensions=function(){if(this.clientRect)return this.clientRect;var t=this.media,e={width:0,height:0};if(t){var r=t.getBoundingClientRect();e.width=r.width,e.height=r.height,e.width||e.height||(e.width=r.right-r.left||t.width||0,e.height=r.bottom-r.top||t.height||0)}return this.clientRect=e,e},t.isLevelAllowed=function(t,e){return void 0===e&&(e=[]),-1===e.indexOf(t)},t.getMaxLevelByMediaSize=function(t,e,r){if(!t||!t.length)return-1;for(var i,a,n=t.length-1,s=0;s<t.length;s+=1){var o=t[s];if((o.width>=e||o.height>=r)&&(i=o,!(a=t[s+1])||i.width!==a.width||i.height!==a.height)){n=s;break}}return n},e=t,i=[{key:"contentScaleFactor",get:function(){var t=1;try{t=self.devicePixelRatio}catch(t){}return t}}],(r=[{key:"mediaWidth",get:function(){return this.getDimensions().width*t.contentScaleFactor}},{key:"mediaHeight",get:function(){return this.getDimensions().height*t.contentScaleFactor}}])&&ae(e.prototype,r),i&&ae(e,i),t}(),se=function(){function t(t){this.hls=void 0,this.isVideoPlaybackQualityAvailable=!1,this.timer=void 0,this.media=null,this.lastTime=void 0,this.lastDroppedFrames=0,this.lastDecodedFrames=0,this.streamController=void 0,this.hls=t,this.registerListeners()}var e=t.prototype;return e.setStreamController=function(t){this.streamController=t},e.registerListeners=function(){this.hls.on(n.a.MEDIA_ATTACHING,this.onMediaAttaching,this)},e.unregisterListeners=function(){this.hls.off(n.a.MEDIA_ATTACHING,this.onMediaAttaching)},e.destroy=function(){this.timer&&clearInterval(this.timer),this.unregisterListeners(),this.isVideoPlaybackQualityAvailable=!1,this.media=null},e.onMediaAttaching=function(t,e){var r=this.hls.config;if(r.capLevelOnFPSDrop){var i=e.media instanceof self.HTMLVideoElement?e.media:null;this.media=i,i&&"function"==typeof i.getVideoPlaybackQuality&&(this.isVideoPlaybackQualityAvailable=!0),self.clearInterval(this.timer),this.timer=self.setInterval(this.checkFPSInterval.bind(this),r.fpsDroppedMonitoringPeriod)}},e.checkFPS=function(t,e,r){var i=performance.now();if(e){if(this.lastTime){var a=i-this.lastTime,s=r-this.lastDroppedFrames,l=e-this.lastDecodedFrames,u=1e3*s/a,d=this.hls;if(d.trigger(n.a.FPS_DROP,{currentDropped:s,currentDecoded:l,totalDroppedFrames:r}),u>0&&s>d.config.fpsDroppedMonitoringThreshold*l){var h=d.currentLevel;o.b.warn("drop FPS ratio greater than max allowed value for currentLevel: "+h),h>0&&(-1===d.autoLevelCapping||d.autoLevelCapping>=h)&&(h-=1,d.trigger(n.a.FPS_DROP_LEVEL_CAPPING,{level:h,droppedLevel:d.currentLevel}),d.autoLevelCapping=h,this.streamController.nextLevelSwitch())}}this.lastTime=i,this.lastDroppedFrames=r,this.lastDecodedFrames=e}},e.checkFPSInterval=function(){var t=this.media;if(t)if(this.isVideoPlaybackQualityAvailable){var e=t.getVideoPlaybackQuality();this.checkFPS(t,e.totalVideoFrames,e.droppedVideoFrames)}else this.checkFPS(t,t.webkitDecodedFrameCount,t.webkitDroppedFrameCount)},t}(),oe=r(12),le=/^age:\s*[\d.]+\s*$/m,ue=function(){function t(t){this.xhrSetup=void 0,this.requestTimeout=void 0,this.retryTimeout=void 0,this.retryDelay=void 0,this.config=null,this.callbacks=null,this.context=void 0,this.loader=null,this.stats=void 0,this.xhrSetup=t?t.xhrSetup:null,this.stats=new oe.a,this.retryDelay=0}var e=t.prototype;return e.destroy=function(){this.callbacks=null,this.abortInternal(),this.loader=null,this.config=null},e.abortInternal=function(){var t=this.loader;self.clearTimeout(this.requestTimeout),self.clearTimeout(this.retryTimeout),t&&(t.onreadystatechange=null,t.onprogress=null,4!==t.readyState&&(this.stats.aborted=!0,t.abort()))},e.abort=function(){var t;this.abortInternal(),null!==(t=this.callbacks)&&void 0!==t&&t.onAbort&&this.callbacks.onAbort(this.stats,this.context,this.loader)},e.load=function(t,e,r){if(this.stats.loading.start)throw new Error("Loader can only be used once.");this.stats.loading.start=self.performance.now(),this.context=t,this.config=e,this.callbacks=r,this.retryDelay=e.retryDelay,this.loadInternal()},e.loadInternal=function(){var t=this.config,e=this.context;if(t){var r=this.loader=new self.XMLHttpRequest,i=this.stats;i.loading.first=0,i.loaded=0;var a=this.xhrSetup;try{if(a)try{a(r,e.url)}catch(t){r.open("GET",e.url,!0),a(r,e.url)}r.readyState||r.open("GET",e.url,!0);var n=this.context.headers;if(n)for(var s in n)r.setRequestHeader(s,n[s])}catch(t){return void this.callbacks.onError({code:r.status,text:t.message},e,r)}e.rangeEnd&&r.setRequestHeader("Range","bytes="+e.rangeStart+"-"+(e.rangeEnd-1)),r.onreadystatechange=this.readystatechange.bind(this),r.onprogress=this.loadprogress.bind(this),r.responseType=e.responseType,self.clearTimeout(this.requestTimeout),this.requestTimeout=self.setTimeout(this.loadtimeout.bind(this),t.timeout),r.send()}},e.readystatechange=function(){var t=this.context,e=this.loader,r=this.stats;if(t&&e){var i=e.readyState,a=this.config;if(!r.aborted&&i>=2)if(self.clearTimeout(this.requestTimeout),0===r.loading.first&&(r.loading.first=Math.max(self.performance.now(),r.loading.start)),4===i){e.onreadystatechange=null,e.onprogress=null;var n=e.status;if(n>=200&&n<300){var s,l;if(r.loading.end=Math.max(self.performance.now(),r.loading.first),l="arraybuffer"===t.responseType?(s=e.response).byteLength:(s=e.responseText).length,r.loaded=r.total=l,!this.callbacks)return;var u=this.callbacks.onProgress;if(u&&u(r,t,s,e),!this.callbacks)return;var d={url:e.responseURL,data:s};this.callbacks.onSuccess(d,r,t,e)}else r.retry>=a.maxRetry||n>=400&&n<499?(o.b.error(n+" while loading "+t.url),this.callbacks.onError({code:n,text:e.statusText},t,e)):(o.b.warn(n+" while loading "+t.url+", retrying in "+this.retryDelay+"..."),this.abortInternal(),this.loader=null,self.clearTimeout(this.retryTimeout),this.retryTimeout=self.setTimeout(this.loadInternal.bind(this),this.retryDelay),this.retryDelay=Math.min(2*this.retryDelay,a.maxRetryDelay),r.retry++)}else self.clearTimeout(this.requestTimeout),this.requestTimeout=self.setTimeout(this.loadtimeout.bind(this),a.timeout)}},e.loadtimeout=function(){o.b.warn("timeout while loading "+this.context.url);var t=this.callbacks;t&&(this.abortInternal(),t.onTimeout(this.stats,this.context,this.loader))},e.loadprogress=function(t){var e=this.stats;e.loaded=t.loaded,t.lengthComputable&&(e.total=t.total)},e.getCacheAge=function(){var t=null;if(this.loader&&le.test(this.loader.getAllResponseHeaders())){var e=this.loader.getResponseHeader("age");t=e?parseFloat(e):null}return t},t}(),de=r(16);function he(t){var e="function"==typeof Map?new Map:void 0;return(he=function(t){if(null===t||(r=t,-1===Function.toString.call(r).indexOf("[native code]")))return t;var r;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(t))return e.get(t);e.set(t,i)}function i(){return fe(t,arguments,ge(this).constructor)}return i.prototype=Object.create(t.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),ve(i,t)})(t)}function fe(t,e,r){return(fe=ce()?Reflect.construct:function(t,e,r){var i=[null];i.push.apply(i,e);var a=new(Function.bind.apply(t,i));return r&&ve(a,r.prototype),a}).apply(null,arguments)}function ce(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}function ve(t,e){return(ve=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function ge(t){return(ge=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function pe(){return(pe=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t}).apply(this,arguments)}var me=function(){function t(t){this.fetchSetup=void 0,this.requestTimeout=void 0,this.request=void 0,this.response=void 0,this.controller=void 0,this.context=void 0,this.config=null,this.callbacks=null,this.stats=void 0,this.loader=null,this.fetchSetup=t.fetchSetup||ye,this.controller=new self.AbortController,this.stats=new oe.a}var e=t.prototype;return e.destroy=function(){this.loader=this.callbacks=null,this.abortInternal()},e.abortInternal=function(){var t=this.response;t&&t.ok||(this.stats.aborted=!0,this.controller.abort())},e.abort=function(){var t;this.abortInternal(),null!==(t=this.callbacks)&&void 0!==t&&t.onAbort&&this.callbacks.onAbort(this.stats,this.context,this.response)},e.load=function(t,e,r){var i=this,n=this.stats;if(n.loading.start)throw new Error("Loader can only be used once.");n.loading.start=self.performance.now();var s=function(t,e){var r={method:"GET",mode:"cors",credentials:"same-origin",signal:e,headers:new self.Headers(pe({},t.headers))};return t.rangeEnd&&r.headers.set("Range","bytes="+t.rangeStart+"-"+String(t.rangeEnd-1)),r}(t,this.controller.signal),o=r.onProgress,l="arraybuffer"===t.responseType,u=l?"byteLength":"length";this.context=t,this.config=e,this.callbacks=r,this.request=this.fetchSetup(t,s),self.clearTimeout(this.requestTimeout),this.requestTimeout=self.setTimeout((function(){i.abortInternal(),r.onTimeout(n,t,i.response)}),e.timeout),self.fetch(this.request).then((function(r){if(i.response=i.loader=r,!r.ok){var s=r.status,u=r.statusText;throw new Te(u||"fetch, bad network response",s,r)}return n.loading.first=Math.max(self.performance.now(),n.loading.start),n.total=parseInt(r.headers.get("Content-Length")||"0"),o&&Object(a.a)(e.highWaterMark)?i.loadProgressively(r,n,t,e.highWaterMark,o):l?r.arrayBuffer():r.text()})).then((function(s){var l=i.response;self.clearTimeout(i.requestTimeout),n.loading.end=Math.max(self.performance.now(),n.loading.first),n.loaded=n.total=s[u];var d={url:l.url,data:s};o&&!Object(a.a)(e.highWaterMark)&&o(n,t,s,l),r.onSuccess(d,n,t,l)})).catch((function(e){if(self.clearTimeout(i.requestTimeout),!n.aborted){var a=e.code||0;r.onError({code:a,text:e.message},t,e.details)}}))},e.getCacheAge=function(){var t=null;if(this.response){var e=this.response.headers.get("age");t=e?parseFloat(e):null}return t},e.loadProgressively=function(t,e,r,i,a){void 0===i&&(i=0);var n=new de.a,s=t.body.getReader();return function o(){return s.read().then((function(s){if(s.done)return n.dataLength&&a(e,r,n.flush(),t),Promise.resolve(new ArrayBuffer(0));var l=s.value,u=l.length;return e.loaded+=u,u<i||n.dataLength?(n.push(l),n.dataLength>=i&&a(e,r,n.flush(),t)):a(e,r,l,t),o()})).catch((function(){return Promise.reject()}))}()},t}();function ye(t,e){return new self.Request(t.url,e)}var be,Te=function(t){var e,r;function i(e,r,i){var a;return(a=t.call(this,e)||this).code=void 0,a.details=void 0,a.code=r,a.details=i,a}return r=t,(e=i).prototype=Object.create(r.prototype),e.prototype.constructor=e,ve(e,r),i}(he(Error)),Ee=me;!function(t){t.WIDEVINE="com.widevine.alpha",t.PLAYREADY="com.microsoft.playready"}(be||(be={}));var Se="undefined"!=typeof self&&self.navigator&&self.navigator.requestMediaKeySystemAccess?self.navigator.requestMediaKeySystemAccess.bind(self.navigator):null;function Le(){return(Le=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i])}return t}).apply(this,arguments)}function Ae(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,i)}return r}function Re(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?Ae(Object(r),!0).forEach((function(e){De(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):Ae(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function De(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var _e=Re(Re({autoStartLoad:!0,startPosition:-1,defaultAudioCodec:void 0,debug:!1,capLevelOnFPSDrop:!1,capLevelToPlayerSize:!1,initialLiveManifestSize:1,maxBufferLength:30,backBufferLength:1/0,maxBufferSize:6e7,maxBufferHole:.1,highBufferWatchdogPeriod:2,nudgeOffset:.1,nudgeMaxRetry:3,maxFragLookUpTolerance:.25,liveSyncDurationCount:3,liveMaxLatencyDurationCount:1/0,liveSyncDuration:void 0,liveMaxLatencyDuration:void 0,maxLiveSyncPlaybackRate:1,liveDurationInfinity:!1,liveBackBufferLength:null,maxMaxBufferLength:600,enableWorker:!0,enableSoftwareAES:!0,manifestLoadingTimeOut:1e4,manifestLoadingMaxRetry:1,manifestLoadingRetryDelay:1e3,manifestLoadingMaxRetryTimeout:64e3,startLevel:void 0,levelLoadingTimeOut:1e4,levelLoadingMaxRetry:4,levelLoadingRetryDelay:1e3,levelLoadingMaxRetryTimeout:64e3,fragLoadingTimeOut:2e4,fragLoadingMaxRetry:6,fragLoadingRetryDelay:1e3,fragLoadingMaxRetryTimeout:64e3,startFragPrefetch:!1,fpsDroppedMonitoringPeriod:5e3,fpsDroppedMonitoringThreshold:.2,appendErrorMaxRetry:3,loader:ue,fLoader:void 0,pLoader:void 0,xhrSetup:void 0,licenseXhrSetup:void 0,licenseResponseCallback:void 0,abrController:$t,bufferController:ie,capLevelController:ne,fpsController:se,stretchShortVideoTrack:!1,maxAudioFramesDrift:1,forceKeyFrameOnDiscontinuity:!0,abrEwmaFastLive:3,abrEwmaSlowLive:9,abrEwmaFastVoD:3,abrEwmaSlowVoD:9,abrEwmaDefaultEstimate:5e5,abrBandWidthFactor:.95,abrBandWidthUpFactor:.7,abrMaxWithRealBitrate:!1,maxStarvationDelay:4,maxLoadingDelay:4,minAutoBitrate:0,emeEnabled:!1,widevineLicenseUrl:void 0,drmSystemOptions:{},requestMediaKeySystemAccessFunc:Se,testBandwidth:!0,progressive:!1,lowLatencyMode:!0,cmcd:void 0},{cueHandler:Jt.a,enableCEA708Captions:!1,enableWebVTT:!1,enableIMSC1:!1,captionsTextTrack1Label:"English",captionsTextTrack1LanguageCode:"en",captionsTextTrack2Label:"Spanish",captionsTextTrack2LanguageCode:"es",captionsTextTrack3Label:"Unknown CC",captionsTextTrack3LanguageCode:"",captionsTextTrack4Label:"Unknown CC",captionsTextTrack4LanguageCode:"",renderTextTracksNatively:!0}),{},{subtitleStreamController:void 0,subtitleTrackController:void 0,timelineController:void 0,audioStreamController:void 0,audioTrackController:void 0,emeController:void 0,cmcdController:void 0});function ke(t,e){for(var r=0;r<e.length;r++){var i=e[r];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}var xe=function(){function t(e){void 0===e&&(e={}),this.config=void 0,this.userConfig=void 0,this.coreComponents=void 0,this.networkControllers=void 0,this._emitter=new jt.EventEmitter,this._autoLevelCapping=void 0,this.abrController=void 0,this.bufferController=void 0,this.capLevelController=void 0,this.latencyController=void 0,this.levelController=void 0,this.streamController=void 0,this.audioTrackController=void 0,this.subtitleTrackController=void 0,this.emeController=void 0,this.cmcdController=void 0,this._media=null,this.url=null;var r=this.config=function(t,e){if((e.liveSyncDurationCount||e.liveMaxLatencyDurationCount)&&(e.liveSyncDuration||e.liveMaxLatencyDuration))throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");if(void 0!==e.liveMaxLatencyDurationCount&&(void 0===e.liveSyncDurationCount||e.liveMaxLatencyDurationCount<=e.liveSyncDurationCount))throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');if(void 0!==e.liveMaxLatencyDuration&&(void 0===e.liveSyncDuration||e.liveMaxLatencyDuration<=e.liveSyncDuration))throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');return Le({},t,e)}(t.DefaultConfig,e);this.userConfig=e,Object(o.a)(r.debug),this._autoLevelCapping=-1,r.progressive&&function(t){var e=t.loader;e!==Ee&&e!==ue?(o.b.log("[config]: Custom loader detected, cannot enable progressive streaming"),t.progressive=!1):function(){if(self.fetch&&self.AbortController&&self.ReadableStream&&self.Request)try{return new self.ReadableStream({}),!0}catch(t){}return!1}()&&(t.loader=Ee,t.progressive=!0,t.enableSoftwareAES=!0,o.b.log("[config]: Progressive streaming enabled, using FetchLoader"))}(r);var i=r.abrController,a=r.bufferController,n=r.capLevelController,s=r.fpsController,l=this.abrController=new i(this),u=this.bufferController=new a(this),d=this.capLevelController=new n(this),h=new s(this),f=new x(this),c=new w(this),v=new I(this),g=this.levelController=new Z(this),p=new J(this),m=this.streamController=new Xt(this,p);d.setStreamController(m),h.setStreamController(m);var y=[g,m];this.networkControllers=y;var b=[f,c,l,u,d,h,v,p];this.audioTrackController=this.createController(r.audioTrackController,null,y),this.createController(r.audioStreamController,p,y),this.subtitleTrackController=this.createController(r.subtitleTrackController,null,y),this.createController(r.subtitleStreamController,p,y),this.createController(r.timelineController,null,b),this.emeController=this.createController(r.emeController,null,b),this.cmcdController=this.createController(r.cmcdController,null,b),this.latencyController=this.createController(M,null,b),this.coreComponents=b}t.isSupported=function(){return function(){var t=Nt();if(!t)return!1;var e=Bt(),r=t&&"function"==typeof t.isTypeSupported&&t.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),i=!e||e.prototype&&"function"==typeof e.prototype.appendBuffer&&"function"==typeof e.prototype.remove;return!!r&&!!i}()};var e,r,a,l=t.prototype;return l.createController=function(t,e,r){if(t){var i=e?new t(this,e):new t(this);return r&&r.push(i),i}return null},l.on=function(t,e,r){void 0===r&&(r=this),this._emitter.on(t,e,r)},l.once=function(t,e,r){void 0===r&&(r=this),this._emitter.once(t,e,r)},l.removeAllListeners=function(t){this._emitter.removeAllListeners(t)},l.off=function(t,e,r,i){void 0===r&&(r=this),this._emitter.off(t,e,r,i)},l.listeners=function(t){return this._emitter.listeners(t)},l.emit=function(t,e,r){return this._emitter.emit(t,e,r)},l.trigger=function(t,e){if(this.config.debug)return this.emit(t,t,e);try{return this.emit(t,t,e)}catch(e){o.b.error("An internal error happened while handling event "+t+'. Error message: "'+e.message+'". Here is a stacktrace:',e),this.trigger(n.a.ERROR,{type:s.b.OTHER_ERROR,details:s.a.INTERNAL_EXCEPTION,fatal:!1,event:t,error:e})}return!1},l.listenerCount=function(t){return this._emitter.listenerCount(t)},l.destroy=function(){o.b.log("destroy"),this.trigger(n.a.DESTROYING,void 0),this.detachMedia(),this.removeAllListeners(),this._autoLevelCapping=-1,this.url=null,this.networkControllers.forEach((function(t){return t.destroy()})),this.networkControllers.length=0,this.coreComponents.forEach((function(t){return t.destroy()})),this.coreComponents.length=0},l.attachMedia=function(t){o.b.log("attachMedia"),this._media=t,this.trigger(n.a.MEDIA_ATTACHING,{media:t})},l.detachMedia=function(){o.b.log("detachMedia"),this.trigger(n.a.MEDIA_DETACHING,void 0),this._media=null},l.loadSource=function(t){this.stopLoad();var e=this.media,r=this.url,a=this.url=i.buildAbsoluteURL(self.location.href,t,{alwaysNormalize:!0});o.b.log("loadSource:"+a),e&&r&&r!==a&&this.bufferController.hasSourceTypes()&&(this.detachMedia(),this.attachMedia(e)),this.trigger(n.a.MANIFEST_LOADING,{url:t})},l.startLoad=function(t){void 0===t&&(t=-1),o.b.log("startLoad("+t+")"),this.networkControllers.forEach((function(e){e.startLoad(t)}))},l.stopLoad=function(){o.b.log("stopLoad"),this.networkControllers.forEach((function(t){t.stopLoad()}))},l.swapAudioCodec=function(){o.b.log("swapAudioCodec"),this.streamController.swapAudioCodec()},l.recoverMediaError=function(){o.b.log("recoverMediaError");var t=this._media;this.detachMedia(),t&&this.attachMedia(t)},l.removeLevel=function(t,e){void 0===e&&(e=0),this.levelController.removeLevel(t,e)},e=t,a=[{key:"version",get:function(){return"1.1.5"}},{key:"Events",get:function(){return n.a}},{key:"ErrorTypes",get:function(){return s.b}},{key:"ErrorDetails",get:function(){return s.a}},{key:"DefaultConfig",get:function(){return t.defaultConfig?t.defaultConfig:_e},set:function(e){t.defaultConfig=e}}],(r=[{key:"levels",get:function(){return this.levelController.levels||[]}},{key:"currentLevel",get:function(){return this.streamController.currentLevel},set:function(t){o.b.log("set currentLevel:"+t),this.loadLevel=t,this.abrController.clearTimer(),this.streamController.immediateLevelSwitch()}},{key:"nextLevel",get:function(){return this.streamController.nextLevel},set:function(t){o.b.log("set nextLevel:"+t),this.levelController.manualLevel=t,this.streamController.nextLevelSwitch()}},{key:"loadLevel",get:function(){return this.levelController.level},set:function(t){o.b.log("set loadLevel:"+t),this.levelController.manualLevel=t}},{key:"nextLoadLevel",get:function(){return this.levelController.nextLoadLevel},set:function(t){this.levelController.nextLoadLevel=t}},{key:"firstLevel",get:function(){return Math.max(this.levelController.firstLevel,this.minAutoLevel)},set:function(t){o.b.log("set firstLevel:"+t),this.levelController.firstLevel=t}},{key:"startLevel",get:function(){return this.levelController.startLevel},set:function(t){o.b.log("set startLevel:"+t),-1!==t&&(t=Math.max(t,this.minAutoLevel)),this.levelController.startLevel=t}},{key:"capLevelToPlayerSize",get:function(){return this.config.capLevelToPlayerSize},set:function(t){var e=!!t;e!==this.config.capLevelToPlayerSize&&(e?this.capLevelController.startCapping():(this.capLevelController.stopCapping(),this.autoLevelCapping=-1,this.streamController.nextLevelSwitch()),this.config.capLevelToPlayerSize=e)}},{key:"autoLevelCapping",get:function(){return this._autoLevelCapping},set:function(t){this._autoLevelCapping!==t&&(o.b.log("set autoLevelCapping:"+t),this._autoLevelCapping=t)}},{key:"bandwidthEstimate",get:function(){var t=this.abrController.bwEstimator;return t?t.getEstimate():NaN}},{key:"autoLevelEnabled",get:function(){return-1===this.levelController.manualLevel}},{key:"manualLevel",get:function(){return this.levelController.manualLevel}},{key:"minAutoLevel",get:function(){var t=this.levels,e=this.config.minAutoBitrate;if(!t)return 0;for(var r=t.length,i=0;i<r;i++)if(t[i].maxBitrate>e)return i;return 0}},{key:"maxAutoLevel",get:function(){var t=this.levels,e=this.autoLevelCapping;return-1===e&&t&&t.length?t.length-1:e}},{key:"nextAutoLevel",get:function(){return Math.min(Math.max(this.abrController.nextAutoLevel,this.minAutoLevel),this.maxAutoLevel)},set:function(t){this.abrController.nextAutoLevel=Math.max(this.minAutoLevel,t)}},{key:"audioTracks",get:function(){var t=this.audioTrackController;return t?t.audioTracks:[]}},{key:"audioTrack",get:function(){var t=this.audioTrackController;return t?t.audioTrack:-1},set:function(t){var e=this.audioTrackController;e&&(e.audioTrack=t)}},{key:"subtitleTracks",get:function(){var t=this.subtitleTrackController;return t?t.subtitleTracks:[]}},{key:"subtitleTrack",get:function(){var t=this.subtitleTrackController;return t?t.subtitleTrack:-1},set:function(t){var e=this.subtitleTrackController;e&&(e.subtitleTrack=t)}},{key:"media",get:function(){return this._media}},{key:"subtitleDisplay",get:function(){var t=this.subtitleTrackController;return!!t&&t.subtitleDisplay},set:function(t){var e=this.subtitleTrackController;e&&(e.subtitleDisplay=t)}},{key:"lowLatencyMode",get:function(){return this.config.lowLatencyMode},set:function(t){this.config.lowLatencyMode=t}},{key:"liveSyncPosition",get:function(){return this.latencyController.liveSyncPosition}},{key:"latency",get:function(){return this.latencyController.latency}},{key:"maxLatency",get:function(){return this.latencyController.maxLatency}},{key:"targetLatency",get:function(){return this.latencyController.targetLatency}},{key:"drift",get:function(){return this.latencyController.drift}},{key:"forceStartLoad",get:function(){return this.streamController.forceStartLoad}}])&&ke(e.prototype,r),a&&ke(e,a),t}();xe.defaultConfig=void 0}]).default)}},e={};function r(i){var a=e[i];if(void 0!==a)return a.exports;var n=e[i]={exports:{}};return t[i].call(n.exports,n,n.exports,r),n.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var i in e)r.o(e,i)&&!r.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var i={};return(()=>{"use strict";r.d(i,{default:()=>a});var t=r(182),e=r.n(t);class a extends Audio{constructor(){super();const t="rplayer-volume";this.hls=null,localStorage.hasOwnProperty(t)?this.volume=localStorage.getItem(t):this.volume=.2,this.onvolumechange=()=>{localStorage.setItem(t,this.volume)}}rewind(t){this.currentTime=this.currentTime-t}playSrc(t){const r=t.indexOf(".m3u8")>0;this.stop(),e().isSupported()&&r?(this.hls=new(e()),this.hls.loadSource(t),this.hls.attachMedia(this),this.hls.on(e().Events.MANIFEST_PARSED,(()=>{this.play()}))):(this.canPlayType("application/vnd.apple.mpegurl")||e().isSupported()&&!r)&&(this.src=t,this.addEventListener("loadedmetadata",(()=>{this.play()})))}mute(){this.muted=!this.muted}stop(){this.pause(),this.currentTime=0,this.hls&&(this.hls.destroy(),this.hls=null)}upVolume(){this.#t(this.volume+.1)}downVolume(){this.#t(this.volume-.1)}#t(t){t>=0&&t<=1&&(this.volume=Number(t).toFixed(1))}get isHls(){return this.hls instanceof e()}get url(){return this.isHls?this.hls.url:this.src}get playing(){return this.currentTime>0&&!this.paused&&!this.ended&&this.readyState>2}}})(),i.default})()));

/***/ }),

/***/ "./node_modules/@vue/compat/dist/vue.runtime.esm-bundler.js":
/*!******************************************************************!*\
  !*** ./node_modules/@vue/compat/dist/vue.runtime.esm-bundler.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": () => (/* binding */ BaseTransition),
/* harmony export */   "Comment": () => (/* binding */ Comment),
/* harmony export */   "EffectScope": () => (/* binding */ EffectScope),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "KeepAlive": () => (/* binding */ KeepAlive),
/* harmony export */   "ReactiveEffect": () => (/* binding */ ReactiveEffect),
/* harmony export */   "Static": () => (/* binding */ Static),
/* harmony export */   "Suspense": () => (/* binding */ Suspense),
/* harmony export */   "Teleport": () => (/* binding */ Teleport),
/* harmony export */   "Text": () => (/* binding */ Text),
/* harmony export */   "Transition": () => (/* binding */ Transition),
/* harmony export */   "TransitionGroup": () => (/* binding */ TransitionGroup),
/* harmony export */   "VueElement": () => (/* binding */ VueElement),
/* harmony export */   "callWithAsyncErrorHandling": () => (/* binding */ callWithAsyncErrorHandling),
/* harmony export */   "callWithErrorHandling": () => (/* binding */ callWithErrorHandling),
/* harmony export */   "camelize": () => (/* binding */ camelize),
/* harmony export */   "capitalize": () => (/* binding */ capitalize),
/* harmony export */   "cloneVNode": () => (/* binding */ cloneVNode),
/* harmony export */   "compatUtils": () => (/* binding */ compatUtils),
/* harmony export */   "computed": () => (/* binding */ computed$1),
/* harmony export */   "configureCompat": () => (/* binding */ configureCompat$1),
/* harmony export */   "createApp": () => (/* binding */ createApp),
/* harmony export */   "createBlock": () => (/* binding */ createBlock),
/* harmony export */   "createCommentVNode": () => (/* binding */ createCommentVNode),
/* harmony export */   "createElementBlock": () => (/* binding */ createElementBlock),
/* harmony export */   "createElementVNode": () => (/* binding */ createBaseVNode),
/* harmony export */   "createHydrationRenderer": () => (/* binding */ createHydrationRenderer),
/* harmony export */   "createPropsRestProxy": () => (/* binding */ createPropsRestProxy),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createSSRApp": () => (/* binding */ createSSRApp),
/* harmony export */   "createSlots": () => (/* binding */ createSlots),
/* harmony export */   "createStaticVNode": () => (/* binding */ createStaticVNode),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "customRef": () => (/* binding */ customRef),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "defineAsyncComponent": () => (/* binding */ defineAsyncComponent),
/* harmony export */   "defineComponent": () => (/* binding */ defineComponent),
/* harmony export */   "defineCustomElement": () => (/* binding */ defineCustomElement),
/* harmony export */   "defineEmits": () => (/* binding */ defineEmits),
/* harmony export */   "defineExpose": () => (/* binding */ defineExpose),
/* harmony export */   "defineProps": () => (/* binding */ defineProps),
/* harmony export */   "defineSSRCustomElement": () => (/* binding */ defineSSRCustomElement),
/* harmony export */   "devtools": () => (/* binding */ devtools),
/* harmony export */   "effect": () => (/* binding */ effect),
/* harmony export */   "effectScope": () => (/* binding */ effectScope),
/* harmony export */   "getCurrentInstance": () => (/* binding */ getCurrentInstance),
/* harmony export */   "getCurrentScope": () => (/* binding */ getCurrentScope),
/* harmony export */   "getTransitionRawChildren": () => (/* binding */ getTransitionRawChildren),
/* harmony export */   "guardReactiveProps": () => (/* binding */ guardReactiveProps),
/* harmony export */   "h": () => (/* binding */ h),
/* harmony export */   "handleError": () => (/* binding */ handleError),
/* harmony export */   "hydrate": () => (/* binding */ hydrate),
/* harmony export */   "initCustomFormatter": () => (/* binding */ initCustomFormatter),
/* harmony export */   "initDirectivesForSSR": () => (/* binding */ initDirectivesForSSR),
/* harmony export */   "inject": () => (/* binding */ inject),
/* harmony export */   "isMemoSame": () => (/* binding */ isMemoSame),
/* harmony export */   "isProxy": () => (/* binding */ isProxy),
/* harmony export */   "isReactive": () => (/* binding */ isReactive),
/* harmony export */   "isReadonly": () => (/* binding */ isReadonly),
/* harmony export */   "isRef": () => (/* binding */ isRef),
/* harmony export */   "isRuntimeOnly": () => (/* binding */ isRuntimeOnly),
/* harmony export */   "isShallow": () => (/* binding */ isShallow),
/* harmony export */   "isVNode": () => (/* binding */ isVNode),
/* harmony export */   "markRaw": () => (/* binding */ markRaw),
/* harmony export */   "mergeDefaults": () => (/* binding */ mergeDefaults),
/* harmony export */   "mergeProps": () => (/* binding */ mergeProps),
/* harmony export */   "nextTick": () => (/* binding */ nextTick),
/* harmony export */   "normalizeClass": () => (/* binding */ normalizeClass),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "normalizeStyle": () => (/* binding */ normalizeStyle),
/* harmony export */   "onActivated": () => (/* binding */ onActivated),
/* harmony export */   "onBeforeMount": () => (/* binding */ onBeforeMount),
/* harmony export */   "onBeforeUnmount": () => (/* binding */ onBeforeUnmount),
/* harmony export */   "onBeforeUpdate": () => (/* binding */ onBeforeUpdate),
/* harmony export */   "onDeactivated": () => (/* binding */ onDeactivated),
/* harmony export */   "onErrorCaptured": () => (/* binding */ onErrorCaptured),
/* harmony export */   "onMounted": () => (/* binding */ onMounted),
/* harmony export */   "onRenderTracked": () => (/* binding */ onRenderTracked),
/* harmony export */   "onRenderTriggered": () => (/* binding */ onRenderTriggered),
/* harmony export */   "onScopeDispose": () => (/* binding */ onScopeDispose),
/* harmony export */   "onServerPrefetch": () => (/* binding */ onServerPrefetch),
/* harmony export */   "onUnmounted": () => (/* binding */ onUnmounted),
/* harmony export */   "onUpdated": () => (/* binding */ onUpdated),
/* harmony export */   "openBlock": () => (/* binding */ openBlock),
/* harmony export */   "popScopeId": () => (/* binding */ popScopeId),
/* harmony export */   "provide": () => (/* binding */ provide),
/* harmony export */   "proxyRefs": () => (/* binding */ proxyRefs),
/* harmony export */   "pushScopeId": () => (/* binding */ pushScopeId),
/* harmony export */   "queuePostFlushCb": () => (/* binding */ queuePostFlushCb),
/* harmony export */   "reactive": () => (/* binding */ reactive),
/* harmony export */   "readonly": () => (/* binding */ readonly),
/* harmony export */   "ref": () => (/* binding */ ref),
/* harmony export */   "registerRuntimeCompiler": () => (/* binding */ registerRuntimeCompiler),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "renderList": () => (/* binding */ renderList),
/* harmony export */   "renderSlot": () => (/* binding */ renderSlot),
/* harmony export */   "resolveComponent": () => (/* binding */ resolveComponent),
/* harmony export */   "resolveDirective": () => (/* binding */ resolveDirective),
/* harmony export */   "resolveDynamicComponent": () => (/* binding */ resolveDynamicComponent),
/* harmony export */   "resolveFilter": () => (/* binding */ resolveFilter$1),
/* harmony export */   "resolveTransitionHooks": () => (/* binding */ resolveTransitionHooks),
/* harmony export */   "setBlockTracking": () => (/* binding */ setBlockTracking),
/* harmony export */   "setDevtoolsHook": () => (/* binding */ setDevtoolsHook),
/* harmony export */   "setTransitionHooks": () => (/* binding */ setTransitionHooks),
/* harmony export */   "shallowReactive": () => (/* binding */ shallowReactive),
/* harmony export */   "shallowReadonly": () => (/* binding */ shallowReadonly),
/* harmony export */   "shallowRef": () => (/* binding */ shallowRef),
/* harmony export */   "ssrContextKey": () => (/* binding */ ssrContextKey),
/* harmony export */   "ssrUtils": () => (/* binding */ ssrUtils),
/* harmony export */   "stop": () => (/* binding */ stop),
/* harmony export */   "toDisplayString": () => (/* binding */ toDisplayString),
/* harmony export */   "toHandlerKey": () => (/* binding */ toHandlerKey),
/* harmony export */   "toHandlers": () => (/* binding */ toHandlers),
/* harmony export */   "toRaw": () => (/* binding */ toRaw),
/* harmony export */   "toRef": () => (/* binding */ toRef),
/* harmony export */   "toRefs": () => (/* binding */ toRefs),
/* harmony export */   "transformVNodeArgs": () => (/* binding */ transformVNodeArgs),
/* harmony export */   "triggerRef": () => (/* binding */ triggerRef),
/* harmony export */   "unref": () => (/* binding */ unref),
/* harmony export */   "useAttrs": () => (/* binding */ useAttrs),
/* harmony export */   "useCssModule": () => (/* binding */ useCssModule),
/* harmony export */   "useCssVars": () => (/* binding */ useCssVars),
/* harmony export */   "useSSRContext": () => (/* binding */ useSSRContext),
/* harmony export */   "useSlots": () => (/* binding */ useSlots),
/* harmony export */   "useTransitionState": () => (/* binding */ useTransitionState),
/* harmony export */   "vModelCheckbox": () => (/* binding */ vModelCheckbox),
/* harmony export */   "vModelDynamic": () => (/* binding */ vModelDynamic),
/* harmony export */   "vModelRadio": () => (/* binding */ vModelRadio),
/* harmony export */   "vModelSelect": () => (/* binding */ vModelSelect),
/* harmony export */   "vModelText": () => (/* binding */ vModelText),
/* harmony export */   "vShow": () => (/* binding */ vShow),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "warn": () => (/* binding */ warn$1),
/* harmony export */   "watch": () => (/* binding */ watch),
/* harmony export */   "watchEffect": () => (/* binding */ watchEffect),
/* harmony export */   "watchPostEffect": () => (/* binding */ watchPostEffect),
/* harmony export */   "watchSyncEffect": () => (/* binding */ watchSyncEffect),
/* harmony export */   "withAsyncContext": () => (/* binding */ withAsyncContext),
/* harmony export */   "withCtx": () => (/* binding */ withCtx),
/* harmony export */   "withDefaults": () => (/* binding */ withDefaults),
/* harmony export */   "withDirectives": () => (/* binding */ withDirectives),
/* harmony export */   "withKeys": () => (/* binding */ withKeys),
/* harmony export */   "withMemo": () => (/* binding */ withMemo),
/* harmony export */   "withModifiers": () => (/* binding */ withModifiers),
/* harmony export */   "withScopeId": () => (/* binding */ withScopeId)
/* harmony export */ });
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];
}

const GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +
    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +
    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';
const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);

/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);
/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */
function includeBooleanAttr(value) {
    return !!value || value === '';
}

function normalizeStyle(value) {
    if (isArray(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            const normalized = isString(item)
                ? parseStringStyle(item)
                : normalizeStyle(item);
            if (normalized) {
                for (const key in normalized) {
                    res[key] = normalized[key];
                }
            }
        }
        return res;
    }
    else if (isString(value)) {
        return value;
    }
    else if (isObject(value)) {
        return value;
    }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach(item => {
        if (item) {
            const tmp = item.split(propertyDelimiterRE);
            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return ret;
}
function normalizeClass(value) {
    let res = '';
    if (isString(value)) {
        res = value;
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            const normalized = normalizeClass(value[i]);
            if (normalized) {
                res += normalized + ' ';
            }
        }
    }
    else if (isObject(value)) {
        for (const name in value) {
            if (value[name]) {
                res += name + ' ';
            }
        }
    }
    return res.trim();
}
function normalizeProps(props) {
    if (!props)
        return null;
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
    }
    if (style) {
        props.style = normalizeStyle(style);
    }
    return props;
}

// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
const HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +
    'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +
    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +
    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +
    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +
    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +
    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +
    'option,output,progress,select,textarea,details,dialog,menu,' +
    'summary,template,blockquote,iframe,tfoot';
// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
const SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +
    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +
    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +
    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +
    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +
    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +
    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +
    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +
    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +
    'text,textPath,title,tspan,unknown,use,view';
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);
/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.
 */
const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);

function looseCompareArrays(a, b) {
    if (a.length !== b.length)
        return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
    }
    return equal;
}
function looseEqual(a, b) {
    if (a === b)
        return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) {
        return a === b;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
        /* istanbul ignore if: this if will probably never be called */
        if (!aValidType || !bValidType) {
            return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
            return false;
        }
        for (const key in a) {
            const aHasKey = a.hasOwnProperty(key);
            const bHasKey = b.hasOwnProperty(key);
            if ((aHasKey && !bHasKey) ||
                (!aHasKey && bHasKey) ||
                !looseEqual(a[key], b[key])) {
                return false;
            }
        }
    }
    return String(a) === String(b);
}
function looseIndexOf(arr, val) {
    return arr.findIndex(item => looseEqual(item, val));
}

/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */
const toDisplayString = (val) => {
    return isString(val)
        ? val
        : val == null
            ? ''
            : isArray(val) ||
                (isObject(val) &&
                    (val.toString === objectToString || !isFunction(val.toString)))
                ? JSON.stringify(val, replacer, 2)
                : String(val);
};
const replacer = (_key, val) => {
    // can't use isRef here since @vue/shared has no deps
    if (val && val.__v_isRef) {
        return replacer(_key, val.value);
    }
    else if (isMap(val)) {
        return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {
                entries[`${key} =>`] = val;
                return entries;
            }, {})
        };
    }
    else if (isSet(val)) {
        return {
            [`Set(${val.size})`]: [...val.values()]
        };
    }
    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
        return String(val);
    }
    return val;
};

const EMPTY_OBJ = ( true)
    ? Object.freeze({})
    : 0;
const EMPTY_ARR = ( true) ? Object.freeze([]) : 0;
const NOOP = () => { };
/**
 * Always return false.
 */
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith('onUpdate:');
const extend = Object.assign;
const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
        arr.splice(i, 1);
    }
};
const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === '[object Map]';
const isSet = (val) => toTypeString(val) === '[object Set]';
const isDate = (val) => toTypeString(val) === '[object Date]';
const isFunction = (val) => typeof val === 'function';
const isString = (val) => typeof val === 'string';
const isSymbol = (val) => typeof val === 'symbol';
const isObject = (val) => val !== null && typeof val === 'object';
const isPromise = (val) => {
    return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === '[object Object]';
const isIntegerKey = (key) => isString(key) &&
    key !== 'NaN' &&
    key[0] !== '-' &&
    '' + parseInt(key, 10) === key;
const isReservedProp = /*#__PURE__*/ makeMap(
// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,' +
    'onVnodeBeforeMount,onVnodeMounted,' +
    'onVnodeBeforeUpdate,onVnodeUpdated,' +
    'onVnodeBeforeUnmount,onVnodeUnmounted');
const isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');
const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return ((str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    });
};
const camelizeRE = /-(\w)/g;
/**
 * @private
 */
const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
const hyphenateRE = /\B([A-Z])/g;
/**
 * @private
 */
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());
/**
 * @private
 */
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
/**
 * @private
 */
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
// compare whether a value has changed, accounting for NaN.
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
    }
};
const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
    });
};
const toNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
    return (_globalThis ||
        (_globalThis =
            typeof globalThis !== 'undefined'
                ? globalThis
                : typeof self !== 'undefined'
                    ? self
                    : typeof window !== 'undefined'
                        ? window
                        : typeof __webpack_require__.g !== 'undefined'
                            ? __webpack_require__.g
                            : {}));
};

function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else if ((true)) {
            warn(`cannot run an inactive effect scope.`);
        }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
        activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].stop();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else if ((true)) {
        warn(`onScopeDispose() is called when there is no active effect scope` +
            ` to be associated with.`);
    }
}

const createDep = (effects) => {
    const dep = new Set(effects);
    dep.w = 0;
    dep.n = 0;
    return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit; // set was tracked
        }
    }
};
const finalizeDepMarkers = (effect) => {
    const { deps } = effect;
    if (deps.length) {
        let ptr = 0;
        for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
                dep.delete(effect);
            }
            else {
                deps[ptr++] = dep;
            }
            // clear bits
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
    }
};

const targetMap = new WeakMap();
// The number of effects currently being tracked recursively.
let effectTrackDepth = 0;
let trackOpBit = 1;
/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(( true) ? 'iterate' : 0);
const MAP_KEY_ITERATE_KEY = Symbol(( true) ? 'Map key iterate' : 0);
class ReactiveEffect {
    constructor(fn, scheduler = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this.parent = undefined;
        recordEffectScope(this, scope);
    }
    run() {
        if (!this.active) {
            return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
            if (parent === this) {
                return;
            }
            parent = parent.parent;
        }
        try {
            this.parent = activeEffect;
            activeEffect = this;
            shouldTrack = true;
            trackOpBit = 1 << ++effectTrackDepth;
            if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
            }
            else {
                cleanupEffect(this);
            }
            return this.fn();
        }
        finally {
            if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
            }
            trackOpBit = 1 << --effectTrackDepth;
            activeEffect = this.parent;
            shouldTrack = lastShouldTrack;
            this.parent = undefined;
            if (this.deferStop) {
                this.stop();
            }
        }
    }
    stop() {
        // stopped while running itself - defer the cleanup
        if (activeEffect === this) {
            this.deferStop = true;
        }
        else if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
                this.onStop();
            }
            this.active = false;
        }
    }
}
function cleanupEffect(effect) {
    const { deps } = effect;
    if (deps.length) {
        for (let i = 0; i < deps.length; i++) {
            deps[i].delete(effect);
        }
        deps.length = 0;
    }
}
function effect(fn, options) {
    if (fn.effect) {
        fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options) {
        extend(_effect, options);
        if (options.scope)
            recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
        _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
}
function stop(runner) {
    runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
}
function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === undefined ? true : last;
}
function track(target, type, key) {
    if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
            targetMap.set(target, (depsMap = new Map()));
        }
        let dep = depsMap.get(key);
        if (!dep) {
            depsMap.set(key, (dep = createDep()));
        }
        const eventInfo = ( true)
            ? { effect: activeEffect, target, type, key }
            : 0;
        trackEffects(dep, eventInfo);
    }
}
function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack = false;
    if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
            dep.n |= trackOpBit; // set newly tracked
            shouldTrack = !wasTracked(dep);
        }
    }
    else {
        // Full cleanup mode.
        shouldTrack = !dep.has(activeEffect);
    }
    if (shouldTrack) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
        if (( true) && activeEffect.onTrack) {
            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
        }
    }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
        // never been tracked
        return;
    }
    let deps = [];
    if (type === "clear" /* CLEAR */) {
        // collection being cleared
        // trigger all effects for target
        deps = [...depsMap.values()];
    }
    else if (key === 'length' && isArray(target)) {
        depsMap.forEach((dep, key) => {
            if (key === 'length' || key >= newValue) {
                deps.push(dep);
            }
        });
    }
    else {
        // schedule runs for SET | ADD | DELETE
        if (key !== void 0) {
            deps.push(depsMap.get(key));
        }
        // also run for iteration key on ADD | DELETE | Map.SET
        switch (type) {
            case "add" /* ADD */:
                if (!isArray(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                else if (isIntegerKey(key)) {
                    // new index added to array -> length changes
                    deps.push(depsMap.get('length'));
                }
                break;
            case "delete" /* DELETE */:
                if (!isArray(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                    if (isMap(target)) {
                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
                    }
                }
                break;
            case "set" /* SET */:
                if (isMap(target)) {
                    deps.push(depsMap.get(ITERATE_KEY));
                }
                break;
        }
    }
    const eventInfo = ( true)
        ? { target, type, key, newValue, oldValue, oldTarget }
        : 0;
    if (deps.length === 1) {
        if (deps[0]) {
            if ((true)) {
                triggerEffects(deps[0], eventInfo);
            }
            else {}
        }
    }
    else {
        const effects = [];
        for (const dep of deps) {
            if (dep) {
                effects.push(...dep);
            }
        }
        if ((true)) {
            triggerEffects(createDep(effects), eventInfo);
        }
        else {}
    }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
    // spread into array for stabilization
    const effects = isArray(dep) ? dep : [...dep];
    for (const effect of effects) {
        if (effect.computed) {
            triggerEffect(effect, debuggerEventExtraInfo);
        }
    }
    for (const effect of effects) {
        if (!effect.computed) {
            triggerEffect(effect, debuggerEventExtraInfo);
        }
    }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
    if (effect !== activeEffect || effect.allowRecurse) {
        if (( true) && effect.onTrigger) {
            effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
        }
        if (effect.scheduler) {
            effect.scheduler();
        }
        else {
            effect.run();
        }
    }
}

const isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
/*#__PURE__*/
Object.getOwnPropertyNames(Symbol)
    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'
    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode
    // function
    .filter(key => key !== 'arguments' && key !== 'caller')
    .map(key => Symbol[key])
    .filter(isSymbol));
const get = /*#__PURE__*/ createGetter();
const shallowGet = /*#__PURE__*/ createGetter(false, true);
const readonlyGet = /*#__PURE__*/ createGetter(true);
const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);
const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();
function createArrayInstrumentations() {
    const instrumentations = {};
    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {
        instrumentations[key] = function (...args) {
            const arr = toRaw(this);
            for (let i = 0, l = this.length; i < l; i++) {
                track(arr, "get" /* GET */, i + '');
            }
            // we run the method using the original args first (which may be reactive)
            const res = arr[key](...args);
            if (res === -1 || res === false) {
                // if that didn't work, run it again using raw values.
                return arr[key](...args.map(toRaw));
            }
            else {
                return res;
            }
        };
    });
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
        instrumentations[key] = function (...args) {
            pauseTracking();
            const res = toRaw(this)[key].apply(this, args);
            resetTracking();
            return res;
        };
    });
    return instrumentations;
}
function createGetter(isReadonly = false, shallow = false) {
    return function get(target, key, receiver) {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_isShallow" /* IS_SHALLOW */) {
            return shallow;
        }
        else if (key === "__v_raw" /* RAW */ &&
            receiver ===
                (isReadonly
                    ? shallow
                        ? shallowReadonlyMap
                        : readonlyMap
                    : shallow
                        ? shallowReactiveMap
                        : reactiveMap).get(target)) {
            return target;
        }
        const targetIsArray = isArray(target);
        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
            return res;
        }
        if (!isReadonly) {
            track(target, "get" /* GET */, key);
        }
        if (shallow) {
            return res;
        }
        if (isRef(res)) {
            // ref unwrapping - skip unwrap for Array + integer key.
            return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject(res)) {
            // Convert returned value into a proxy as well. we do the isObject check
            // here to avoid invalid value warning. Also need to lazy access readonly
            // and reactive here to avoid circular dependency.
            return isReadonly ? readonly(res) : reactive(res);
        }
        return res;
    };
}
const set = /*#__PURE__*/ createSetter();
const shallowSet = /*#__PURE__*/ createSetter(true);
function createSetter(shallow = false) {
    return function set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
            return false;
        }
        if (!shallow && !isReadonly(value)) {
            if (!isShallow(value)) {
                value = toRaw(value);
                oldValue = toRaw(oldValue);
            }
            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
                return true;
            }
        }
        const hadKey = isArray(target) && isIntegerKey(key)
            ? Number(key) < target.length
            : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        // don't trigger if target is something up in the prototype chain of original
        if (target === toRaw(receiver)) {
            if (!hadKey) {
                trigger(target, "add" /* ADD */, key, value);
            }
            else if (hasChanged(value, oldValue)) {
                trigger(target, "set" /* SET */, key, value, oldValue);
            }
        }
        return result;
    };
}
function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has" /* HAS */, key);
    }
    return result;
}
function ownKeys(target) {
    track(target, "iterate" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);
    return Reflect.ownKeys(target);
}
const mutableHandlers = {
    get,
    set,
    deleteProperty,
    has,
    ownKeys
};
const readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
        if ((true)) {
            warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    },
    deleteProperty(target, key) {
        if ((true)) {
            warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
        }
        return true;
    }
};
const shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {
    get: shallowGet,
    set: shallowSet
});
// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
const shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {
    get: shallowReadonlyGet
});

const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1(target, key, isReadonly = false, isShallow = false) {
    // #1772: readonly(reactive(Map)) should return readonly + reactive version
    // of the value
    target = target["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) {
            track(rawTarget, "get" /* GET */, key);
        }
        track(rawTarget, "get" /* GET */, rawKey);
    }
    const { has } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
    }
    else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
    }
    else if (target !== rawTarget) {
        // #3602 readonly(reactive(Map))
        // ensure that the nested reactive `Map` can do tracking for itself
        target.get(key);
    }
}
function has$1(key, isReadonly = false) {
    const target = this["__v_raw" /* RAW */];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
        if (key !== rawKey) {
            track(rawTarget, "has" /* HAS */, key);
        }
        track(rawTarget, "has" /* HAS */, rawKey);
    }
    return key === rawKey
        ? target.has(key)
        : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly = false) {
    target = target["__v_raw" /* RAW */];
    !isReadonly && track(toRaw(target), "iterate" /* ITERATE */, ITERATE_KEY);
    return Reflect.get(target, 'size', target);
}
function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
        target.add(value);
        trigger(target, "add" /* ADD */, value, value);
    }
    return this;
}
function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get.call(target, key);
    target.set(key, value);
    if (!hadKey) {
        trigger(target, "add" /* ADD */, key, value);
    }
    else if (hasChanged(value, oldValue)) {
        trigger(target, "set" /* SET */, key, value, oldValue);
    }
    return this;
}
function deleteEntry(key) {
    const target = toRaw(this);
    const { has, get } = getProto(target);
    let hadKey = has.call(target, key);
    if (!hadKey) {
        key = toRaw(key);
        hadKey = has.call(target, key);
    }
    else if ((true)) {
        checkIdentityKeys(target, has, key);
    }
    const oldValue = get ? get.call(target, key) : undefined;
    // forward the operation before queueing reactions
    const result = target.delete(key);
    if (hadKey) {
        trigger(target, "delete" /* DELETE */, key, undefined, oldValue);
    }
    return result;
}
function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = ( true)
        ? isMap(target)
            ? new Map(target)
            : new Set(target)
        : 0;
    // forward the operation before queueing reactions
    const result = target.clear();
    if (hadItems) {
        trigger(target, "clear" /* CLEAR */, undefined, undefined, oldTarget);
    }
    return result;
}
function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly && track(rawTarget, "iterate" /* ITERATE */, ITERATE_KEY);
        return target.forEach((value, key) => {
            // important: make sure the callback is
            // 1. invoked with the reactive map as `this` and 3rd arg
            // 2. the value received should be a corresponding reactive/readonly.
            return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
    };
}
function createIterableMethod(method, isReadonly, isShallow) {
    return function (...args) {
        const target = this["__v_raw" /* RAW */];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);
        const isKeyOnly = method === 'keys' && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
        !isReadonly &&
            track(rawTarget, "iterate" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
        // return a wrapped iterator which returns observed versions of the
        // values emitted from the real iterator
        return {
            // iterator protocol
            next() {
                const { value, done } = innerIterator.next();
                return done
                    ? { value, done }
                    : {
                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
                        done
                    };
            },
            // iterable protocol
            [Symbol.iterator]() {
                return this;
            }
        };
    };
}
function createReadonlyMethod(type) {
    return function (...args) {
        if ((true)) {
            const key = args[0] ? `on key "${args[0]}" ` : ``;
            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
        }
        return type === "delete" /* DELETE */ ? false : this;
    };
}
function createInstrumentations() {
    const mutableInstrumentations = {
        get(key) {
            return get$1(this, key);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
    };
    const shallowInstrumentations = {
        get(key) {
            return get$1(this, key, false, true);
        },
        get size() {
            return size(this);
        },
        has: has$1,
        add,
        set: set$1,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
    };
    const readonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations = {
        get(key) {
            return get$1(this, key, true, true);
        },
        get size() {
            return size(this, true);
        },
        has(key) {
            return has$1.call(this, key, true);
        },
        add: createReadonlyMethod("add" /* ADD */),
        set: createReadonlyMethod("set" /* SET */),
        delete: createReadonlyMethod("delete" /* DELETE */),
        clear: createReadonlyMethod("clear" /* CLEAR */),
        forEach: createForEach(true, true)
    };
    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];
    iteratorMethods.forEach(method => {
        mutableInstrumentations[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations[method] = createIterableMethod(method, true, false);
        shallowInstrumentations[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);
    });
    return [
        mutableInstrumentations,
        readonlyInstrumentations,
        shallowInstrumentations,
        shallowReadonlyInstrumentations
    ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();
function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow
        ? isReadonly
            ? shallowReadonlyInstrumentations
            : shallowInstrumentations
        : isReadonly
            ? readonlyInstrumentations
            : mutableInstrumentations;
    return (target, key, receiver) => {
        if (key === "__v_isReactive" /* IS_REACTIVE */) {
            return !isReadonly;
        }
        else if (key === "__v_isReadonly" /* IS_READONLY */) {
            return isReadonly;
        }
        else if (key === "__v_raw" /* RAW */) {
            return target;
        }
        return Reflect.get(hasOwn(instrumentations, key) && key in target
            ? instrumentations
            : target, key, receiver);
    };
}
const mutableCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
    get: /*#__PURE__*/ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has.call(target, rawKey)) {
        const type = toRawType(target);
        console.warn(`Reactive ${type} contains both the raw and reactive ` +
            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +
            `which can lead to inconsistencies. ` +
            `Avoid differentiating between the raw and reactive versions ` +
            `of an object and only use the reactive version if possible.`);
    }
}

const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
    switch (rawType) {
        case 'Object':
        case 'Array':
            return 1 /* COMMON */;
        case 'Map':
        case 'Set':
        case 'WeakMap':
        case 'WeakSet':
            return 2 /* COLLECTION */;
        default:
            return 0 /* INVALID */;
    }
}
function getTargetType(value) {
    return value["__v_skip" /* SKIP */] || !Object.isExtensible(value)
        ? 0 /* INVALID */
        : targetTypeMap(toRawType(value));
}
function reactive(target) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (isReadonly(target)) {
        return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */
function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
        if ((true)) {
            console.warn(`value cannot be made reactive: ${String(target)}`);
        }
        return target;
    }
    // target is already a Proxy, return it.
    // exception: calling readonly() on a reactive object
    if (target["__v_raw" /* RAW */] &&
        !(isReadonly && target["__v_isReactive" /* IS_REACTIVE */])) {
        return target;
    }
    // target already has corresponding Proxy
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
        return existingProxy;
    }
    // only specific value types can be observed.
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
        return target;
    }
    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* RAW */]);
    }
    return !!(value && value["__v_isReactive" /* IS_REACTIVE */]);
}
function isReadonly(value) {
    return !!(value && value["__v_isReadonly" /* IS_READONLY */]);
}
function isShallow(value) {
    return !!(value && value["__v_isShallow" /* IS_SHALLOW */]);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    def(value, "__v_skip" /* SKIP */, true);
    return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;

function trackRefValue(ref) {
    if (shouldTrack && activeEffect) {
        ref = toRaw(ref);
        if ((true)) {
            trackEffects(ref.dep || (ref.dep = createDep()), {
                target: ref,
                type: "get" /* GET */,
                key: 'value'
            });
        }
        else {}
    }
}
function triggerRefValue(ref, newVal) {
    ref = toRaw(ref);
    if (ref.dep) {
        if ((true)) {
            triggerEffects(ref.dep, {
                target: ref,
                type: "set" /* SET */,
                key: 'value',
                newValue: newVal
            });
        }
        else {}
    }
}
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    return new RefImpl(rawValue, shallow);
}
class RefImpl {
    constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = undefined;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
        trackRefValue(this);
        return this._value;
    }
    set value(newVal) {
        newVal = this.__v_isShallow ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this.__v_isShallow ? newVal : toReactive(newVal);
            triggerRefValue(this, newVal);
        }
    }
}
function triggerRef(ref) {
    triggerRefValue(ref, ( true) ? ref.value : 0);
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
        }
        else {
            return Reflect.set(target, key, value, receiver);
        }
    }
};
function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs)
        ? objectWithRefs
        : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
    constructor(factory) {
        this.dep = undefined;
        this.__v_isRef = true;
        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));
        this._get = get;
        this._set = set;
    }
    get value() {
        return this._get();
    }
    set value(newVal) {
        this._set(newVal);
    }
}
function customRef(factory) {
    return new CustomRefImpl(factory);
}
function toRefs(object) {
    if (( true) && !isProxy(object)) {
        console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
    }
    get value() {
        const val = this._object[this._key];
        return val === undefined ? this._defaultValue : val;
    }
    set value(newVal) {
        this._object[this._key] = newVal;
    }
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    return isRef(val)
        ? val
        : new ObjectRefImpl(object, key, defaultValue);
}

class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR) {
        this._setter = _setter;
        this.dep = undefined;
        this.__v_isRef = true;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
                this._dirty = true;
                triggerRefValue(this);
            }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly" /* IS_READONLY */] = isReadonly;
    }
    get value() {
        // the computed ref may get wrapped by other proxies e.g. readonly() #3376
        const self = toRaw(this);
        trackRefValue(self);
        if (self._dirty || !self._cacheable) {
            self._dirty = false;
            self._value = self.effect.run();
        }
        return self._value;
    }
    set value(newValue) {
        this._setter(newValue);
    }
}
function computed(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = ( true)
            ? () => {
                console.warn('Write operation failed: computed value is readonly');
            }
            : 0;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    if (( true) && debugOptions && !isSSR) {
        cRef.effect.onTrack = debugOptions.onTrack;
        cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
}

const stack = [];
function pushWarningContext(vnode) {
    stack.push(vnode);
}
function popWarningContext() {
    stack.pop();
}
function warn$1(msg, ...args) {
    // avoid props formatting or warn handler tracking deps that might be mutated
    // during patch, leading to infinite recursion.
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [
            msg + args.join(''),
            instance && instance.proxy,
            trace
                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)
                .join('\n'),
            trace
        ]);
    }
    else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        /* istanbul ignore if */
        if (trace.length &&
            // avoid spamming console during tests
            !false) {
            warnArgs.push(`\n`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
    }
    resetTracking();
}
function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
        return [];
    }
    // we can't just use the stack because it will be incomplete during updates
    // that did not start from the root. Re-construct the parent chain using
    // instance parent pointers.
    const normalizedStack = [];
    while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
            last.recurseCount++;
        }
        else {
            normalizedStack.push({
                vnode: currentVNode,
                recurseCount: 0
            });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
}
/* istanbul ignore next */
function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
        logs.push(...(i === 0 ? [] : [`\n`]), ...formatTraceEntry(entry));
    });
    return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props
        ? [open, ...formatProps(vnode.props), close]
        : [open + close];
}
/* istanbul ignore next */
function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach(key => {
        res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
        res.push(` ...`);
    }
    return res;
}
/* istanbul ignore next */
function formatProp(key, value, raw) {
    if (isString(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
    }
    else if (typeof value === 'number' ||
        typeof value === 'boolean' ||
        value == null) {
        return raw ? value : [`${key}=${value}`];
    }
    else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
    }
    else if (isFunction(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    }
    else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
    }
}

const ErrorTypeStrings = {
    ["sp" /* SERVER_PREFETCH */]: 'serverPrefetch hook',
    ["bc" /* BEFORE_CREATE */]: 'beforeCreate hook',
    ["c" /* CREATED */]: 'created hook',
    ["bm" /* BEFORE_MOUNT */]: 'beforeMount hook',
    ["m" /* MOUNTED */]: 'mounted hook',
    ["bu" /* BEFORE_UPDATE */]: 'beforeUpdate hook',
    ["u" /* UPDATED */]: 'updated',
    ["bum" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',
    ["um" /* UNMOUNTED */]: 'unmounted hook',
    ["a" /* ACTIVATED */]: 'activated hook',
    ["da" /* DEACTIVATED */]: 'deactivated hook',
    ["ec" /* ERROR_CAPTURED */]: 'errorCaptured hook',
    ["rtc" /* RENDER_TRACKED */]: 'renderTracked hook',
    ["rtg" /* RENDER_TRIGGERED */]: 'renderTriggered hook',
    [0 /* SETUP_FUNCTION */]: 'setup function',
    [1 /* RENDER_FUNCTION */]: 'render function',
    [2 /* WATCH_GETTER */]: 'watcher getter',
    [3 /* WATCH_CALLBACK */]: 'watcher callback',
    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',
    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',
    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',
    [7 /* VNODE_HOOK */]: 'vnode hook',
    [8 /* DIRECTIVE_HOOK */]: 'directive hook',
    [9 /* TRANSITION_HOOK */]: 'transition hook',
    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',
    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',
    [12 /* FUNCTION_REF */]: 'ref function',
    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',
    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +
        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'
};
function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
        res = args ? fn(...args) : fn();
    }
    catch (err) {
        handleError(err, instance, type);
    }
    return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && isPromise(res)) {
            res.catch(err => {
                handleError(err, instance, type);
            });
        }
        return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
}
function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
        let cur = instance.parent;
        // the exposed instance is the render proxy to keep it consistent with 2.x
        const exposedInstance = instance.proxy;
        // in production the hook receives only the error code
        const errorInfo = ( true) ? ErrorTypeStrings[type] : 0;
        while (cur) {
            const errorCapturedHooks = cur.ec;
            if (errorCapturedHooks) {
                for (let i = 0; i < errorCapturedHooks.length; i++) {
                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                        return;
                    }
                }
            }
            cur = cur.parent;
        }
        // app-level handling
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);
            return;
        }
    }
    logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
    if ((true)) {
        const info = ErrorTypeStrings[type];
        if (contextVNode) {
            pushWarningContext(contextVNode);
        }
        warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
        if (contextVNode) {
            popWarningContext();
        }
        // crash in dev by default so it's more noticeable
        if (throwInDev) {
            throw err;
        }
        else {
            console.error(err);
        }
    }
    else {}
}

let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /*#__PURE__*/ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
}
// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id) {
    // the start index should be `flushIndex + 1`
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
        const middle = (start + end) >>> 1;
        const middleJobId = getId(queue[middle]);
        middleJobId < id ? (start = middle + 1) : (end = middle);
    }
    return start;
}
function queueJob(job) {
    // the dedupe search uses the startIndex argument of Array.includes()
    // by default the search index includes the current job that is being run
    // so it cannot recursively trigger itself again.
    // if the job is a watch() callback, the search will start with a +1 index to
    // allow it recursively trigger itself - it is the user's responsibility to
    // ensure it doesn't end up in an infinite loop.
    if ((!queue.length ||
        !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) &&
        job !== currentPreFlushParentJob) {
        if (job.id == null) {
            queue.push(job);
        }
        else {
            queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
    }
}
function queueFlush() {
    if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
    }
}
function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
        queue.splice(i, 1);
    }
}
function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!isArray(cb)) {
        if (!activeQueue ||
            !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
            pendingQueue.push(cb);
        }
    }
    else {
        // if cb is an array, it is a component lifecycle hook which can only be
        // triggered by a job, which is already deduped in the main queue, so
        // we can skip duplicate check here to improve perf
        pendingQueue.push(...cb);
    }
    queueFlush();
}
function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
    if (pendingPreFlushCbs.length) {
        currentPreFlushParentJob = parentJob;
        activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
        pendingPreFlushCbs.length = 0;
        if ((true)) {
            seen = seen || new Map();
        }
        for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePreFlushCbs[preFlushIndex])) {
                continue;
            }
            activePreFlushCbs[preFlushIndex]();
        }
        activePreFlushCbs = null;
        preFlushIndex = 0;
        currentPreFlushParentJob = null;
        // recursively flush until it drains
        flushPreFlushCbs(seen, parentJob);
    }
}
function flushPostFlushCbs(seen) {
    // flush any pre cbs queued during the flush (e.g. pre watchers)
    flushPreFlushCbs();
    if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        // #1947 already has active queue, nested flushPostFlushCbs call
        if (activePostFlushCbs) {
            activePostFlushCbs.push(...deduped);
            return;
        }
        activePostFlushCbs = deduped;
        if ((true)) {
            seen = seen || new Map();
        }
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
            if (( true) &&
                checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
                continue;
            }
            activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
    }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if ((true)) {
        seen = seen || new Map();
    }
    flushPreFlushCbs(seen);
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child so its render effect will have smaller
    //    priority number)
    // 2. If a component is unmounted during a parent component's update,
    //    its update can be skipped.
    queue.sort((a, b) => getId(a) - getId(b));
    // conditional usage of checkRecursiveUpdate must be determined out of
    // try ... catch block since Rollup by default de-optimizes treeshaking
    // inside try-catch. This can leave all warning code unshaked. Although
    // they would get eventually shaken by a minifier like terser, some minifiers
    // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
    const check = ( true)
        ? (job) => checkRecursiveUpdates(seen, job)
        : 0;
    try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
            const job = queue[flushIndex];
            if (job && job.active !== false) {
                if (( true) && check(job)) {
                    continue;
                }
                // console.log(`running:`, job.id)
                callWithErrorHandling(job, null, 14 /* SCHEDULER */);
            }
        }
    }
    finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs(seen);
        isFlushing = false;
        currentFlushPromise = null;
        // some postFlushCb queued jobs!
        // keep flushing until it drains.
        if (queue.length ||
            pendingPreFlushCbs.length ||
            pendingPostFlushCbs.length) {
            flushJobs(seen);
        }
    }
}
function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
        seen.set(fn, 1);
    }
    else {
        const count = seen.get(fn);
        if (count > RECURSION_LIMIT) {
            const instance = fn.ownerInstance;
            const componentName = instance && getComponentName(instance.type);
            warn$1(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. ` +
                `This means you have a reactive effect that is mutating its own ` +
                `dependencies and thus recursively triggering itself. Possible sources ` +
                `include component template, render function, updated hook or ` +
                `watcher source function.`);
            return true;
        }
        else {
            seen.set(fn, count + 1);
        }
    }
}

/* eslint-disable no-restricted-globals */
let isHmrUpdating = false;
const hmrDirtyComponents = new Set();
// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
if ((true)) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
        createRecord: tryWrap(createRecord),
        rerender: tryWrap(rerender),
        reload: tryWrap(reload)
    };
}
const map = new Map();
function registerHMR(instance) {
    const id = instance.type.__hmrId;
    let record = map.get(id);
    if (!record) {
        createRecord(id, instance.type);
        record = map.get(id);
    }
    record.instances.add(instance);
}
function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
    if (map.has(id)) {
        return false;
    }
    map.set(id, {
        initialDef: normalizeClassComponent(initialDef),
        instances: new Set()
    });
    return true;
}
function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
    const record = map.get(id);
    if (!record) {
        return;
    }
    // update initial record (for not-yet-rendered component)
    record.initialDef.render = newRender;
    [...record.instances].forEach(instance => {
        if (newRender) {
            instance.render = newRender;
            normalizeClassComponent(instance.type).render = newRender;
        }
        instance.renderCache = [];
        // this flag forces child components with slot content to update
        isHmrUpdating = true;
        instance.update();
        isHmrUpdating = false;
    });
}
function reload(id, newComp) {
    const record = map.get(id);
    if (!record)
        return;
    newComp = normalizeClassComponent(newComp);
    // update initial def (for not-yet-rendered components)
    updateComponentDef(record.initialDef, newComp);
    // create a snapshot which avoids the set being mutated during updates
    const instances = [...record.instances];
    for (const instance of instances) {
        const oldComp = normalizeClassComponent(instance.type);
        if (!hmrDirtyComponents.has(oldComp)) {
            // 1. Update existing comp definition to match new one
            if (oldComp !== record.initialDef) {
                updateComponentDef(oldComp, newComp);
            }
            // 2. mark definition dirty. This forces the renderer to replace the
            // component on patch.
            hmrDirtyComponents.add(oldComp);
        }
        // 3. invalidate options resolution cache
        instance.appContext.optionsCache.delete(instance.type);
        // 4. actually update
        if (instance.ceReload) {
            // custom element
            hmrDirtyComponents.add(oldComp);
            instance.ceReload(newComp.styles);
            hmrDirtyComponents.delete(oldComp);
        }
        else if (instance.parent) {
            // 4. Force the parent instance to re-render. This will cause all updated
            // components to be unmounted and re-mounted. Queue the update so that we
            // don't end up forcing the same parent to re-render multiple times.
            queueJob(instance.parent.update);
            // instance is the inner component of an async custom element
            // invoke to reset styles
            if (instance.parent.type.__asyncLoader &&
                instance.parent.ceReload) {
                instance.parent.ceReload(newComp.styles);
            }
        }
        else if (instance.appContext.reload) {
            // root instance mounted via createApp() has a reload method
            instance.appContext.reload();
        }
        else if (typeof window !== 'undefined') {
            // root instance inside tree created via raw render(). Force reload.
            window.location.reload();
        }
        else {
            console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');
        }
    }
    // 5. make sure to cleanup dirty hmr components after update
    queuePostFlushCb(() => {
        for (const instance of instances) {
            hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
        }
    });
}
function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (const key in oldComp) {
        if (key !== '__file' && !(key in newComp)) {
            delete oldComp[key];
        }
    }
}
function tryWrap(fn) {
    return (id, arg) => {
        try {
            return fn(id, arg);
        }
        catch (e) {
            console.error(e);
            console.warn(`[HMR] Something went wrong during Vue component hot-reload. ` +
                `Full reload required.`);
        }
    };
}

let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit(event, ...args) {
    if (devtools) {
        devtools.emit(event, ...args);
    }
    else if (!devtoolsNotInstalled) {
        buffer.push({ event, args });
    }
}
function setDevtoolsHook(hook, target) {
    var _a, _b;
    devtools = hook;
    if (devtools) {
        devtools.enabled = true;
        buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
        buffer = [];
    }
    else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== 'undefined' &&
        // some envs mock window but not fully
        window.HTMLElement &&
        // also exclude jsdom
        !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes('jsdom'))) {
        const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ || []);
        replay.push((newHook) => {
            setDevtoolsHook(newHook, target);
        });
        // clear buffer after 3s - the user probably doesn't have devtools installed
        // at all, and keeping the buffer will cause memory leaks (#4738)
        setTimeout(() => {
            if (!devtools) {
                target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
                devtoolsNotInstalled = true;
                buffer = [];
            }
        }, 3000);
    }
    else {
        // non-browser env, assume not installed
        devtoolsNotInstalled = true;
        buffer = [];
    }
}
function devtoolsInitApp(app, version) {
    emit("app:init" /* APP_INIT */, app, version, {
        Fragment,
        Text,
        Comment,
        Static
    });
}
function devtoolsUnmountApp(app) {
    emit("app:unmount" /* APP_UNMOUNT */, app);
}
const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook("component:added" /* COMPONENT_ADDED */);
const devtoolsComponentUpdated = 
/*#__PURE__*/ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
const devtoolsComponentRemoved = 
/*#__PURE__*/ createDevtoolsComponentHook("component:removed" /* COMPONENT_REMOVED */);
function createDevtoolsComponentHook(hook) {
    return (component) => {
        emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : undefined, component);
    };
}
const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:start" /* PERFORMANCE_START */);
const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook("perf:end" /* PERFORMANCE_END */);
function createDevtoolsPerformanceHook(hook) {
    return (component, type, time) => {
        emit(hook, component.appContext.app, component.uid, component, type, time);
    };
}
function devtoolsComponentEmit(component, event, params) {
    emit("component:emit" /* COMPONENT_EMIT */, component.appContext.app, component, event, params);
}

const deprecationData = {
    ["GLOBAL_MOUNT" /* GLOBAL_MOUNT */]: {
        message: `The global app bootstrapping API has changed: vm.$mount() and the "el" ` +
            `option have been removed. Use createApp(RootComponent).mount() instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#mounting-app-instance`
    },
    ["GLOBAL_MOUNT_CONTAINER" /* GLOBAL_MOUNT_CONTAINER */]: {
        message: `Vue detected directives on the mount container. ` +
            `In Vue 3, the container is no longer considered part of the template ` +
            `and will not be processed/replaced.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/mount-changes.html`
    },
    ["GLOBAL_EXTEND" /* GLOBAL_EXTEND */]: {
        message: `Vue.extend() has been removed in Vue 3. ` +
            `Use defineComponent() instead.`,
        link: `https://vuejs.org/api/general.html#definecomponent`
    },
    ["GLOBAL_PROTOTYPE" /* GLOBAL_PROTOTYPE */]: {
        message: `Vue.prototype is no longer available in Vue 3. ` +
            `Use app.config.globalProperties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#vue-prototype-replaced-by-config-globalproperties`
    },
    ["GLOBAL_SET" /* GLOBAL_SET */]: {
        message: `Vue.set() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["GLOBAL_DELETE" /* GLOBAL_DELETE */]: {
        message: `Vue.delete() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["GLOBAL_OBSERVABLE" /* GLOBAL_OBSERVABLE */]: {
        message: `Vue.observable() has been removed. ` +
            `Use \`import { reactive } from "vue"\` from Composition API instead.`,
        link: `https://vuejs.org/api/reactivity-core.html#reactive`
    },
    ["GLOBAL_PRIVATE_UTIL" /* GLOBAL_PRIVATE_UTIL */]: {
        message: `Vue.util has been removed. Please refactor to avoid its usage ` +
            `since it was an internal API even in Vue 2.`
    },
    ["CONFIG_SILENT" /* CONFIG_SILENT */]: {
        message: `config.silent has been removed because it is not good practice to ` +
            `intentionally suppress warnings. You can use your browser console's ` +
            `filter features to focus on relevant messages.`
    },
    ["CONFIG_DEVTOOLS" /* CONFIG_DEVTOOLS */]: {
        message: `config.devtools has been removed. To enable devtools for ` +
            `production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,
        link: `https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags`
    },
    ["CONFIG_KEY_CODES" /* CONFIG_KEY_CODES */]: {
        message: `config.keyCodes has been removed. ` +
            `In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`
    },
    ["CONFIG_PRODUCTION_TIP" /* CONFIG_PRODUCTION_TIP */]: {
        message: `config.productionTip has been removed.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-productiontip-removed`
    },
    ["CONFIG_IGNORED_ELEMENTS" /* CONFIG_IGNORED_ELEMENTS */]: {
        message: () => {
            let msg = `config.ignoredElements has been removed.`;
            if (isRuntimeOnly()) {
                msg += ` Pass the "isCustomElement" option to @vue/compiler-dom instead.`;
            }
            else {
                msg += ` Use config.isCustomElement instead.`;
            }
            return msg;
        },
        link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-ignoredelements-is-now-config-iscustomelement`
    },
    ["CONFIG_WHITESPACE" /* CONFIG_WHITESPACE */]: {
        // this warning is only relevant in the full build when using runtime
        // compilation, so it's put in the runtime compatConfig list.
        message: `Vue 3 compiler's whitespace option will default to "condense" instead of ` +
            `"preserve". To suppress this warning, provide an explicit value for ` +
            `\`config.compilerOptions.whitespace\`.`
    },
    ["CONFIG_OPTION_MERGE_STRATS" /* CONFIG_OPTION_MERGE_STRATS */]: {
        message: `config.optionMergeStrategies no longer exposes internal strategies. ` +
            `Use custom merge functions instead.`
    },
    ["INSTANCE_SET" /* INSTANCE_SET */]: {
        message: `vm.$set() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["INSTANCE_DELETE" /* INSTANCE_DELETE */]: {
        message: `vm.$delete() has been removed as it is no longer needed in Vue 3. ` +
            `Simply use native JavaScript mutations.`
    },
    ["INSTANCE_DESTROY" /* INSTANCE_DESTROY */]: {
        message: `vm.$destroy() has been removed. Use app.unmount() instead.`,
        link: `https://vuejs.org/api/application.html#app-unmount`
    },
    ["INSTANCE_EVENT_EMITTER" /* INSTANCE_EVENT_EMITTER */]: {
        message: `vm.$on/$once/$off() have been removed. ` +
            `Use an external event emitter library instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/events-api.html`
    },
    ["INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */]: {
        message: event => `"${event}" lifecycle events are no longer supported. From templates, ` +
            `use the "vnode" prefix instead of "hook:". For example, @${event} ` +
            `should be changed to @vnode-${event.slice(5)}. ` +
            `From JavaScript, use Composition API to dynamically register lifecycle ` +
            `hooks.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/vnode-lifecycle-events.html`
    },
    ["INSTANCE_CHILDREN" /* INSTANCE_CHILDREN */]: {
        message: `vm.$children has been removed. Consider refactoring your logic ` +
            `to avoid relying on direct access to child components.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/children.html`
    },
    ["INSTANCE_LISTENERS" /* INSTANCE_LISTENERS */]: {
        message: `vm.$listeners has been removed. In Vue 3, parent v-on listeners are ` +
            `included in vm.$attrs and it is no longer necessary to separately use ` +
            `v-on="$listeners" if you are already using v-bind="$attrs". ` +
            `(Note: the Vue 3 behavior only applies if this compat config is disabled)`,
        link: `https://v3-migration.vuejs.org/breaking-changes/listeners-removed.html`
    },
    ["INSTANCE_SCOPED_SLOTS" /* INSTANCE_SCOPED_SLOTS */]: {
        message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/slots-unification.html`
    },
    ["INSTANCE_ATTRS_CLASS_STYLE" /* INSTANCE_ATTRS_CLASS_STYLE */]: {
        message: componentName => `Component <${componentName || 'Anonymous'}> has \`inheritAttrs: false\` but is ` +
            `relying on class/style fallthrough from parent. In Vue 3, class/style ` +
            `are now included in $attrs and will no longer fallthrough when ` +
            `inheritAttrs is false. If you are already using v-bind="$attrs" on ` +
            `component root it should render the same end result. ` +
            `If you are binding $attrs to a non-root element and expecting ` +
            `class/style to fallthrough on root, you will need to now manually bind ` +
            `them on root via :class="$attrs.class".`,
        link: `https://v3-migration.vuejs.org/breaking-changes/attrs-includes-class-style.html`
    },
    ["OPTIONS_DATA_FN" /* OPTIONS_DATA_FN */]: {
        message: `The "data" option can no longer be a plain object. ` +
            `Always use a function.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html`
    },
    ["OPTIONS_DATA_MERGE" /* OPTIONS_DATA_MERGE */]: {
        message: (key) => `Detected conflicting key "${key}" when merging data option values. ` +
            `In Vue 3, data keys are merged shallowly and will override one another.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html#mixin-merge-behavior-change`
    },
    ["OPTIONS_BEFORE_DESTROY" /* OPTIONS_BEFORE_DESTROY */]: {
        message: `\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`
    },
    ["OPTIONS_DESTROYED" /* OPTIONS_DESTROYED */]: {
        message: `\`destroyed\` has been renamed to \`unmounted\`.`
    },
    ["WATCH_ARRAY" /* WATCH_ARRAY */]: {
        message: `"watch" option or vm.$watch on an array value will no longer ` +
            `trigger on array mutation unless the "deep" option is specified. ` +
            `If current usage is intended, you can disable the compat behavior and ` +
            `suppress this warning with:` +
            `\n\n  configureCompat({ ${"WATCH_ARRAY" /* WATCH_ARRAY */}: false })\n`,
        link: `https://v3-migration.vuejs.org/breaking-changes/watch.html`
    },
    ["PROPS_DEFAULT_THIS" /* PROPS_DEFAULT_THIS */]: {
        message: (key) => `props default value function no longer has access to "this". The compat ` +
            `build only offers access to this.$options.` +
            `(found in prop "${key}")`,
        link: `https://v3-migration.vuejs.org/breaking-changes/props-default-this.html`
    },
    ["CUSTOM_DIR" /* CUSTOM_DIR */]: {
        message: (legacyHook, newHook) => `Custom directive hook "${legacyHook}" has been removed. ` +
            `Use "${newHook}" instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/custom-directives.html`
    },
    ["V_ON_KEYCODE_MODIFIER" /* V_ON_KEYCODE_MODIFIER */]: {
        message: `Using keyCode as v-on modifier is no longer supported. ` +
            `Use kebab-case key name modifiers instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`
    },
    ["ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */]: {
        message: (name) => `Attribute "${name}" with v-bind value \`false\` will render ` +
            `${name}="false" instead of removing it in Vue 3. To remove the attribute, ` +
            `use \`null\` or \`undefined\` instead. If the usage is intended, ` +
            `you can disable the compat behavior and suppress this warning with:` +
            `\n\n  configureCompat({ ${"ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */}: false })\n`,
        link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`
    },
    ["ATTR_ENUMERATED_COERCION" /* ATTR_ENUMERATED_COERCION */]: {
        message: (name, value, coerced) => `Enumerated attribute "${name}" with v-bind value \`${value}\` will ` +
            `${value === null ? `be removed` : `render the value as-is`} instead of coercing the value to "${coerced}" in Vue 3. ` +
            `Always use explicit "true" or "false" values for enumerated attributes. ` +
            `If the usage is intended, ` +
            `you can disable the compat behavior and suppress this warning with:` +
            `\n\n  configureCompat({ ${"ATTR_ENUMERATED_COERCION" /* ATTR_ENUMERATED_COERCION */}: false })\n`,
        link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`
    },
    ["TRANSITION_CLASSES" /* TRANSITION_CLASSES */]: {
        message: `` // this feature cannot be runtime-detected
    },
    ["TRANSITION_GROUP_ROOT" /* TRANSITION_GROUP_ROOT */]: {
        message: `<TransitionGroup> no longer renders a root <span> element by ` +
            `default if no "tag" prop is specified. If you do not rely on the span ` +
            `for styling, you can disable the compat behavior and suppress this ` +
            `warning with:` +
            `\n\n  configureCompat({ ${"TRANSITION_GROUP_ROOT" /* TRANSITION_GROUP_ROOT */}: false })\n`,
        link: `https://v3-migration.vuejs.org/breaking-changes/transition-group.html`
    },
    ["COMPONENT_ASYNC" /* COMPONENT_ASYNC */]: {
        message: (comp) => {
            const name = getComponentName(comp);
            return (`Async component${name ? ` <${name}>` : `s`} should be explicitly created via \`defineAsyncComponent()\` ` +
                `in Vue 3. Plain functions will be treated as functional components in ` +
                `non-compat build. If you have already migrated all async component ` +
                `usage and intend to use plain functions for functional components, ` +
                `you can disable the compat behavior and suppress this ` +
                `warning with:` +
                `\n\n  configureCompat({ ${"COMPONENT_ASYNC" /* COMPONENT_ASYNC */}: false })\n`);
        },
        link: `https://v3-migration.vuejs.org/breaking-changes/async-components.html`
    },
    ["COMPONENT_FUNCTIONAL" /* COMPONENT_FUNCTIONAL */]: {
        message: (comp) => {
            const name = getComponentName(comp);
            return (`Functional component${name ? ` <${name}>` : `s`} should be defined as a plain function in Vue 3. The "functional" ` +
                `option has been removed. NOTE: Before migrating to use plain ` +
                `functions for functional components, first make sure that all async ` +
                `components usage have been migrated and its compat behavior has ` +
                `been disabled.`);
        },
        link: `https://v3-migration.vuejs.org/breaking-changes/functional-components.html`
    },
    ["COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */]: {
        message: (comp) => {
            const configMsg = `opt-in to ` +
                `Vue 3 behavior on a per-component basis with \`compatConfig: { ${"COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */}: false }\`.`;
            if (comp.props &&
                (isArray(comp.props)
                    ? comp.props.includes('modelValue')
                    : hasOwn(comp.props, 'modelValue'))) {
                return (`Component declares "modelValue" prop, which is Vue 3 usage, but ` +
                    `is running under Vue 2 compat v-model behavior. You can ${configMsg}`);
            }
            return (`v-model usage on component has changed in Vue 3. Component that expects ` +
                `to work with v-model should now use the "modelValue" prop and emit the ` +
                `"update:modelValue" event. You can update the usage and then ${configMsg}`);
        },
        link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`
    },
    ["RENDER_FUNCTION" /* RENDER_FUNCTION */]: {
        message: `Vue 3's render function API has changed. ` +
            `You can opt-in to the new API with:` +
            `\n\n  configureCompat({ ${"RENDER_FUNCTION" /* RENDER_FUNCTION */}: false })\n` +
            `\n  (This can also be done per-component via the "compatConfig" option.)`,
        link: `https://v3-migration.vuejs.org/breaking-changes/render-function-api.html`
    },
    ["FILTERS" /* FILTERS */]: {
        message: `filters have been removed in Vue 3. ` +
            `The "|" symbol will be treated as native JavaScript bitwise OR operator. ` +
            `Use method calls or computed properties instead.`,
        link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`
    },
    ["PRIVATE_APIS" /* PRIVATE_APIS */]: {
        message: name => `"${name}" is a Vue 2 private API that no longer exists in Vue 3. ` +
            `If you are seeing this warning only due to a dependency, you can ` +
            `suppress this warning via { PRIVATE_APIS: 'suppress-warning' }.`
    }
};
const instanceWarned = Object.create(null);
const warnCount = Object.create(null);
function warnDeprecation(key, instance, ...args) {
    if (false) {}
    instance = instance || getCurrentInstance();
    // check user config
    const config = getCompatConfigForKey(key, instance);
    if (config === 'suppress-warning') {
        return;
    }
    const dupKey = key + args.join('');
    let compId = instance && formatComponentName(instance, instance.type);
    if (compId === 'Anonymous' && instance) {
        compId = instance.uid;
    }
    // skip if the same warning is emitted for the same component type
    const componentDupKey = dupKey + compId;
    if (componentDupKey in instanceWarned) {
        return;
    }
    instanceWarned[componentDupKey] = true;
    // same warning, but different component. skip the long message and just
    // log the key and count.
    if (dupKey in warnCount) {
        warn$1(`(deprecation ${key}) (${++warnCount[dupKey] + 1})`);
        return;
    }
    warnCount[dupKey] = 0;
    const { message, link } = deprecationData[key];
    warn$1(`(deprecation ${key}) ${typeof message === 'function' ? message(...args) : message}${link ? `\n  Details: ${link}` : ``}`);
    if (!isCompatEnabled(key, instance, true)) {
        console.error(`^ The above deprecation's compat behavior is disabled and will likely ` +
            `lead to runtime errors.`);
    }
}
const globalCompatConfig = {
    MODE: 2
};
function configureCompat(config) {
    if ((true)) {
        validateCompatConfig(config);
    }
    extend(globalCompatConfig, config);
}
const seenConfigObjects = /*#__PURE__*/ new WeakSet();
const warnedInvalidKeys = {};
// dev only
function validateCompatConfig(config, instance) {
    if (seenConfigObjects.has(config)) {
        return;
    }
    seenConfigObjects.add(config);
    for (const key of Object.keys(config)) {
        if (key !== 'MODE' &&
            !(key in deprecationData) &&
            !(key in warnedInvalidKeys)) {
            if (key.startsWith('COMPILER_')) {
                if (isRuntimeOnly()) {
                    warn$1(`Deprecation config "${key}" is compiler-specific and you are ` +
                        `running a runtime-only build of Vue. This deprecation should be ` +
                        `configured via compiler options in your build setup instead.\n` +
                        `Details: https://v3-migration.vuejs.org/breaking-changes/migration-build.html`);
                }
            }
            else {
                warn$1(`Invalid deprecation config "${key}".`);
            }
            warnedInvalidKeys[key] = true;
        }
    }
    if (instance && config["OPTIONS_DATA_MERGE" /* OPTIONS_DATA_MERGE */] != null) {
        warn$1(`Deprecation config "${"OPTIONS_DATA_MERGE" /* OPTIONS_DATA_MERGE */}" can only be configured globally.`);
    }
}
function getCompatConfigForKey(key, instance) {
    const instanceConfig = instance && instance.type.compatConfig;
    if (instanceConfig && key in instanceConfig) {
        return instanceConfig[key];
    }
    return globalCompatConfig[key];
}
function isCompatEnabled(key, instance, enableForBuiltIn = false) {
    // skip compat for built-in components
    if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
        return false;
    }
    const rawMode = getCompatConfigForKey('MODE', instance) || 2;
    const val = getCompatConfigForKey(key, instance);
    const mode = isFunction(rawMode)
        ? rawMode(instance && instance.type)
        : rawMode;
    if (mode === 2) {
        return val !== false;
    }
    else {
        return val === true || val === 'suppress-warning';
    }
}
/**
 * Use this for features that are completely removed in non-compat build.
 */
function assertCompatEnabled(key, instance, ...args) {
    if (!isCompatEnabled(key, instance)) {
        throw new Error(`${key} compat has been disabled.`);
    }
    else if ((true)) {
        warnDeprecation(key, instance, ...args);
    }
}
/**
 * Use this for features where legacy usage is still possible, but will likely
 * lead to runtime error if compat is disabled. (warn in all cases)
 */
function softAssertCompatEnabled(key, instance, ...args) {
    if ((true)) {
        warnDeprecation(key, instance, ...args);
    }
    return isCompatEnabled(key, instance);
}
/**
 * Use this for features with the same syntax but with mutually exclusive
 * behavior in 2 vs 3. Only warn if compat is enabled.
 * e.g. render function
 */
function checkCompatEnabled(key, instance, ...args) {
    const enabled = isCompatEnabled(key, instance);
    if (( true) && enabled) {
        warnDeprecation(key, instance, ...args);
    }
    return enabled;
}

const eventRegistryMap = /*#__PURE__*/ new WeakMap();
function getRegistry(instance) {
    let events = eventRegistryMap.get(instance);
    if (!events) {
        eventRegistryMap.set(instance, (events = Object.create(null)));
    }
    return events;
}
function on(instance, event, fn) {
    if (isArray(event)) {
        event.forEach(e => on(instance, e, fn));
    }
    else {
        if (event.startsWith('hook:')) {
            assertCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance, event);
        }
        else {
            assertCompatEnabled("INSTANCE_EVENT_EMITTER" /* INSTANCE_EVENT_EMITTER */, instance);
        }
        const events = getRegistry(instance);
        (events[event] || (events[event] = [])).push(fn);
    }
    return instance.proxy;
}
function once(instance, event, fn) {
    const wrapped = (...args) => {
        off(instance, event, wrapped);
        fn.call(instance.proxy, ...args);
    };
    wrapped.fn = fn;
    on(instance, event, wrapped);
    return instance.proxy;
}
function off(instance, event, fn) {
    assertCompatEnabled("INSTANCE_EVENT_EMITTER" /* INSTANCE_EVENT_EMITTER */, instance);
    const vm = instance.proxy;
    // all
    if (!event) {
        eventRegistryMap.set(instance, Object.create(null));
        return vm;
    }
    // array of events
    if (isArray(event)) {
        event.forEach(e => off(instance, e, fn));
        return vm;
    }
    // specific event
    const events = getRegistry(instance);
    const cbs = events[event];
    if (!cbs) {
        return vm;
    }
    if (!fn) {
        events[event] = undefined;
        return vm;
    }
    events[event] = cbs.filter(cb => !(cb === fn || cb.fn === fn));
    return vm;
}
function emit$1(instance, event, args) {
    const cbs = getRegistry(instance)[event];
    if (cbs) {
        callWithAsyncErrorHandling(cbs.map(cb => cb.bind(instance.proxy)), instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    return instance.proxy;
}

const compatModelEventPrefix = `onModelCompat:`;
const warnedTypes = new WeakSet();
function convertLegacyVModelProps(vnode) {
    const { type, shapeFlag, props, dynamicProps } = vnode;
    const comp = type;
    if (shapeFlag & 6 /* COMPONENT */ && props && 'modelValue' in props) {
        if (!isCompatEnabled("COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */, 
        // this is a special case where we want to use the vnode component's
        // compat config instead of the current rendering instance (which is the
        // parent of the component that exposes v-model)
        { type })) {
            return;
        }
        if (( true) && !warnedTypes.has(comp)) {
            pushWarningContext(vnode);
            warnDeprecation("COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */, { type }, comp);
            popWarningContext();
            warnedTypes.add(comp);
        }
        // v3 compiled model code -> v2 compat props
        // modelValue -> value
        // onUpdate:modelValue -> onModelCompat:input
        const model = comp.model || {};
        applyModelFromMixins(model, comp.mixins);
        const { prop = 'value', event = 'input' } = model;
        if (prop !== 'modelValue') {
            props[prop] = props.modelValue;
            delete props.modelValue;
        }
        // important: update dynamic props
        if (dynamicProps) {
            dynamicProps[dynamicProps.indexOf('modelValue')] = prop;
        }
        props[compatModelEventPrefix + event] = props['onUpdate:modelValue'];
        delete props['onUpdate:modelValue'];
    }
}
function applyModelFromMixins(model, mixins) {
    if (mixins) {
        mixins.forEach(m => {
            if (m.model)
                extend(model, m.model);
            if (m.mixins)
                applyModelFromMixins(model, m.mixins);
        });
    }
}
function compatModelEmit(instance, event, args) {
    if (!isCompatEnabled("COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */, instance)) {
        return;
    }
    const props = instance.vnode.props;
    const modelHandler = props && props[compatModelEventPrefix + event];
    if (modelHandler) {
        callWithErrorHandling(modelHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
}

function emit$2(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
        return;
    const props = instance.vnode.props || EMPTY_OBJ;
    if ((true)) {
        const { emitsOptions, propsOptions: [propsOptions] } = instance;
        if (emitsOptions) {
            if (!(event in emitsOptions) &&
                !((event.startsWith('hook:') ||
                        event.startsWith(compatModelEventPrefix)))) {
                if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
                    warn$1(`Component emitted event "${event}" but it is neither declared in ` +
                        `the emits option nor as an "${toHandlerKey(event)}" prop.`);
                }
            }
            else {
                const validator = emitsOptions[event];
                if (isFunction(validator)) {
                    const isValid = validator(...rawArgs);
                    if (!isValid) {
                        warn$1(`Invalid event arguments: event validation failed for event "${event}".`);
                    }
                }
            }
        }
    }
    let args = rawArgs;
    const isModelListener = event.startsWith('update:');
    // for v-model update:xxx events, apply modifiers on args
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
        const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
        if (trim) {
            args = rawArgs.map(a => a.trim());
        }
        if (number) {
            args = rawArgs.map(toNumber);
        }
    }
    if (true) {
        devtoolsComponentEmit(instance, event, args);
    }
    if ((true)) {
        const lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
            warn$1(`Event "${lowerCaseEvent}" is emitted in component ` +
                `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                `Note that HTML attributes are case-insensitive and you cannot use ` +
                `v-on to listen to camelCase events when using in-DOM templates. ` +
                `You should probably use "${hyphenate(event)}" instead of "${event}".`);
        }
    }
    let handlerName;
    let handler = props[(handlerName = toHandlerKey(event))] ||
        // also try camelCase event handler (#2249)
        props[(handlerName = toHandlerKey(camelize(event)))];
    // for v-model update:xxx events, also trigger kebab-case equivalent
    // for props passed via kebab-case
    if (!handler && isModelListener) {
        handler = props[(handlerName = toHandlerKey(hyphenate(event)))];
    }
    if (handler) {
        callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
        if (!instance.emitted) {
            instance.emitted = {};
        }
        else if (instance.emitted[handlerName]) {
            return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
    }
    {
        compatModelEmit(instance, event, args);
        return emit$1(instance, event, args);
    }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== undefined) {
        return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    // apply mixin/extends props
    let hasExtends = false;
    if ( true && !isFunction(comp)) {
        const extendEmits = (raw) => {
            const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
            if (normalizedFromExtend) {
                hasExtends = true;
                extend(normalized, normalizedFromExtend);
            }
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
            extendEmits(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendEmits);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, null);
        return null;
    }
    if (isArray(raw)) {
        raw.forEach(key => (normalized[key] = null));
    }
    else {
        extend(normalized, raw);
    }
    cache.set(comp, normalized);
    return normalized;
}
// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
        return false;
    }
    if (key.startsWith(compatModelEventPrefix)) {
        return true;
    }
    key = key.slice(2).replace(/Once$/, '');
    return (hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||
        hasOwn(options, hyphenate(key)) ||
        hasOwn(options, key));
}

/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */
let currentRenderingInstance = null;
let currentScopeId = null;
/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */
function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = (instance && instance.type.__scopeId) || null;
    // v2 pre-compiled components uses _scopeId instead of __scopeId
    if (!currentScopeId) {
        currentScopeId = (instance && instance.type._scopeId) || null;
    }
    return prev;
}
/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */
function pushScopeId(id) {
    currentScopeId = id;
}
/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */
function popScopeId() {
    currentScopeId = null;
}
/**
 * Only for backwards compat
 * @private
 */
const withScopeId = (_id) => withCtx;
/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // true only
) {
    if (!ctx)
        return fn;
    // already normalized
    if (fn._n) {
        return fn;
    }
    const renderFnWithContext = (...args) => {
        // If a user calls a compiled slot inside a template expression (#1745), it
        // can mess up block tracking, so by default we disable block tracking and
        // force bail out when invoking a compiled slot (indicated by the ._d flag).
        // This isn't necessary if rendering a compiled `<slot>`, so we flip the
        // ._d flag off when invoking the wrapped fn inside `renderSlot`.
        if (renderFnWithContext._d) {
            setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        const res = fn(...args);
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
            setBlockTracking(1);
        }
        if (true) {
            devtoolsComponentUpdated(ctx);
        }
        return res;
    };
    // mark normalized to avoid duplicated wrapping
    renderFnWithContext._n = true;
    // mark this as compiled by default
    // this is used in vnode.ts -> normalizeChildren() to set the slot
    // rendering flag.
    renderFnWithContext._c = true;
    // disable block tracking by default
    renderFnWithContext._d = true;
    // compat build only flag to distinguish scoped slots from non-scoped ones
    if (isNonScopedSlot) {
        renderFnWithContext._ns = true;
    }
    return renderFnWithContext;
}

/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */
let accessedAttrs = false;
function markAttrsAccessed() {
    accessedAttrs = true;
}
function renderComponentRoot(instance) {
    const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    if ((true)) {
        accessedAttrs = false;
    }
    try {
        if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
            // withProxy is a proxy with a different `has` trap only for
            // runtime-compiled render functions using `with` block.
            const proxyToUse = withProxy || proxy;
            result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
            fallthroughAttrs = attrs;
        }
        else {
            // functional
            const render = Component;
            // in dev, mark attrs accessed if optional props (attrs === props)
            if (( true) && attrs === props) {
                markAttrsAccessed();
            }
            result = normalizeVNode(render.length > 1
                ? render(props, ( true)
                    ? {
                        get attrs() {
                            markAttrsAccessed();
                            return attrs;
                        },
                        slots,
                        emit
                    }
                    : 0)
                : render(props, null /* we know it doesn't need it */));
            fallthroughAttrs = Component.props
                ? attrs
                : getFunctionalFallthrough(attrs);
        }
    }
    catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1 /* RENDER_FUNCTION */);
        result = createVNode(Comment);
    }
    // attr merging
    // in dev mode, comments are preserved, and it's possible for a template
    // to have comments along side the root element which makes it a fragment
    let root = result;
    let setRoot = undefined;
    if (( true) &&
        result.patchFlag > 0 &&
        result.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
        [root, setRoot] = getChildRoot(result);
    }
    if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
            if (shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
                if (propsOptions && keys.some(isModelListener)) {
                    // If a v-model listener (onUpdate:xxx) has a corresponding declared
                    // prop, it indicates this component expects to handle v-model and
                    // it should not fallthrough.
                    // related: #1543, #1643, #1989
                    fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                }
                root = cloneVNode(root, fallthroughAttrs);
            }
            else if (( true) && !accessedAttrs && root.type !== Comment) {
                const allAttrs = Object.keys(attrs);
                const eventAttrs = [];
                const extraAttrs = [];
                for (let i = 0, l = allAttrs.length; i < l; i++) {
                    const key = allAttrs[i];
                    if (isOn(key)) {
                        // ignore v-model handlers when they fail to fallthrough
                        if (!isModelListener(key)) {
                            // remove `on`, lowercase first letter to reflect event casing
                            // accurately
                            eventAttrs.push(key[2].toLowerCase() + key.slice(3));
                        }
                    }
                    else {
                        extraAttrs.push(key);
                    }
                }
                if (extraAttrs.length) {
                    warn$1(`Extraneous non-props attributes (` +
                        `${extraAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes.`);
                }
                if (eventAttrs.length) {
                    warn$1(`Extraneous non-emits event listeners (` +
                        `${eventAttrs.join(', ')}) ` +
                        `were passed to component but could not be automatically inherited ` +
                        `because component renders fragment or text root nodes. ` +
                        `If the listener is intended to be a component custom event listener only, ` +
                        `declare it using the "emits" option.`);
                }
            }
        }
    }
    if (isCompatEnabled("INSTANCE_ATTRS_CLASS_STYLE" /* INSTANCE_ATTRS_CLASS_STYLE */, instance) &&
        vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */ &&
        root.shapeFlag & (1 /* ELEMENT */ | 6 /* COMPONENT */)) {
        const { class: cls, style } = vnode.props || {};
        if (cls || style) {
            if (( true) && inheritAttrs === false) {
                warnDeprecation("INSTANCE_ATTRS_CLASS_STYLE" /* INSTANCE_ATTRS_CLASS_STYLE */, instance, getComponentName(instance.type));
            }
            root = cloneVNode(root, {
                class: cls,
                style: style
            });
        }
    }
    // inherit directives
    if (vnode.dirs) {
        if (( true) && !isElementRoot(root)) {
            warn$1(`Runtime directive used on component with non-element root node. ` +
                `The directives will not function as intended.`);
        }
        // clone before mutating since the root may be a hoisted vnode
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    // inherit transition data
    if (vnode.transition) {
        if (( true) && !isElementRoot(root)) {
            warn$1(`Component inside <Transition> renders non-element root node ` +
                `that cannot be animated.`);
        }
        root.transition = vnode.transition;
    }
    if (( true) && setRoot) {
        setRoot(root);
    }
    else {
        result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
}
/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */
const getChildRoot = (vnode) => {
    const rawChildren = vnode.children;
    const dynamicChildren = vnode.dynamicChildren;
    const childRoot = filterSingleRoot(rawChildren);
    if (!childRoot) {
        return [vnode, undefined];
    }
    const index = rawChildren.indexOf(childRoot);
    const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
    const setRoot = (updatedRoot) => {
        rawChildren[index] = updatedRoot;
        if (dynamicChildren) {
            if (dynamicIndex > -1) {
                dynamicChildren[dynamicIndex] = updatedRoot;
            }
            else if (updatedRoot.patchFlag > 0) {
                vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
        }
    };
    return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (isVNode(child)) {
            // ignore user comment
            if (child.type !== Comment || child.children === 'v-if') {
                if (singleRoot) {
                    // has more than 1 non-comment child, return now
                    return;
                }
                else {
                    singleRoot = child;
                }
            }
        }
        else {
            return;
        }
    }
    return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
        if (key === 'class' || key === 'style' || isOn(key)) {
            (res || (res = {}))[key] = attrs[key];
        }
    }
    return res;
};
const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
            res[key] = attrs[key];
        }
    }
    return res;
};
const isElementRoot = (vnode) => {
    return (vnode.shapeFlag & (6 /* COMPONENT */ | 1 /* ELEMENT */) ||
        vnode.type === Comment // potential v-if branch switch
    );
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    // Parent component's render function was hot-updated. Since this may have
    // caused the child component's slots content to have changed, we need to
    // force the child to update as well.
    if (( true) && (prevChildren || nextChildren) && isHmrUpdating) {
        return true;
    }
    // force child update for runtime directive or transition on component vnode.
    if (nextVNode.dirs || nextVNode.transition) {
        return true;
    }
    if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024 /* DYNAMIC_SLOTS */) {
            // slot content that references values that might have changed,
            // e.g. in a v-for
            return true;
        }
        if (patchFlag & 16 /* FULL_PROPS */) {
            if (!prevProps) {
                return !!nextProps;
            }
            // presence of this flag indicates props are always non-null
            return hasPropsChanged(prevProps, nextProps, emits);
        }
        else if (patchFlag & 8 /* PROPS */) {
            const dynamicProps = nextVNode.dynamicProps;
            for (let i = 0; i < dynamicProps.length; i++) {
                const key = dynamicProps[i];
                if (nextProps[key] !== prevProps[key] &&
                    !isEmitListener(emits, key)) {
                    return true;
                }
            }
        }
    }
    else {
        // this path is only taken by manually written render functions
        // so presence of any children leads to a forced update
        if (prevChildren || nextChildren) {
            if (!nextChildren || !nextChildren.$stable) {
                return true;
            }
        }
        if (prevProps === nextProps) {
            return false;
        }
        if (!prevProps) {
            return !!nextProps;
        }
        if (!nextProps) {
            return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] &&
            !isEmitListener(emitsOptions, key)) {
            return true;
        }
    }
    return false;
}
function updateHOCHostEl({ vnode, parent }, el // HostNode
) {
    while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
    }
}

const isSuspense = (type) => type.__isSuspense;
// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
const SuspenseImpl = {
    name: 'Suspense',
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, 
    // platform-specific impl passed from renderer
    rendererInternals) {
        if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
        }
        else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
        }
    },
    hydrate: hydrateSuspense,
    create: createSuspenseBoundary,
    normalize: normalizeSuspenseChildren
};
// Force-casted public typing for h and TSX props inference
const Suspense = (SuspenseImpl );
function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if (isFunction(eventListener)) {
        eventListener();
    }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement('div');
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals));
    // start mounting the content subtree in an off-dom container
    patch(null, (suspense.pendingBranch = vnode.ssContent), hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    // now check if we have encountered any async deps
    if (suspense.deps > 0) {
        // has async
        // invoke @fallback event
        triggerEvent(vnode, 'onPending');
        triggerEvent(vnode, 'onFallback');
        // mount the fallback tree
        patch(null, vnode.ssFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
        isSVG, slotScopeIds);
        setActiveBranch(suspense, vnode.ssFallback);
    }
    else {
        // Suspense has no async deps. Just resolve.
        suspense.resolve();
    }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = (n2.suspense = n1.suspense);
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
            // same root type but content may have changed.
            patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                suspense.resolve();
            }
            else if (isInFallback) {
                patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, newFallback);
            }
        }
        else {
            // toggled before pending tree is resolved
            suspense.pendingId++;
            if (isHydrating) {
                // if toggled before hydration is finished, the current DOM tree is
                // no longer valid. set it as the active branch so it will be unmounted
                // when resolved
                suspense.isHydrating = false;
                suspense.activeBranch = pendingBranch;
            }
            else {
                unmount(pendingBranch, parentComponent, suspense);
            }
            // increment pending ID. this is used to invalidate async callbacks
            // reset suspense state
            suspense.deps = 0;
            // discard effects from pending branch
            suspense.effects.length = 0;
            // discard previous container
            suspense.hiddenContainer = createElement('div');
            if (isInFallback) {
                // already in fallback state
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
                else {
                    patch(activeBranch, newFallback, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                    isSVG, slotScopeIds, optimized);
                    setActiveBranch(suspense, newFallback);
                }
            }
            else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
                // toggled "back" to current active branch
                patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                // force resolve
                suspense.resolve(true);
            }
            else {
                // switched to a 3rd branch
                patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
                if (suspense.deps <= 0) {
                    suspense.resolve();
                }
            }
        }
    }
    else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            // root did not change, just normal patch
            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newBranch);
        }
        else {
            // root node toggled
            // invoke @pending event
            triggerEvent(n2, 'onPending');
            // mount pending branch in off-dom container
            suspense.pendingBranch = newBranch;
            suspense.pendingId++;
            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
            if (suspense.deps <= 0) {
                // incoming branch has no async deps, resolve now.
                suspense.resolve();
            }
            else {
                const { timeout, pendingId } = suspense;
                if (timeout > 0) {
                    setTimeout(() => {
                        if (suspense.pendingId === pendingId) {
                            suspense.fallback(newFallback);
                        }
                    }, timeout);
                }
                else if (timeout === 0) {
                    suspense.fallback(newFallback);
                }
            }
        }
    }
}
let hasWarned = false;
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    /* istanbul ignore if */
    if ( true && !hasWarned) {
        hasWarned = true;
        // @ts-ignore `console.info` cannot be null error
        console[console.info ? 'info' : 'log'](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove } } = rendererInternals;
    const timeout = toNumber(vnode.props && vnode.props.timeout);
    const suspense = {
        vnode,
        parent,
        parentComponent,
        isSVG,
        container,
        hiddenContainer,
        anchor,
        deps: 0,
        pendingId: 0,
        timeout: typeof timeout === 'number' ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: true,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false) {
            if ((true)) {
                if (!resume && !suspense.pendingBranch) {
                    throw new Error(`suspense.resolve() is called without a pending branch.`);
                }
                if (suspense.isUnmounted) {
                    throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
                }
            }
            const { vnode, activeBranch, pendingBranch, pendingId, effects, parentComponent, container } = suspense;
            if (suspense.isHydrating) {
                suspense.isHydrating = false;
            }
            else if (!resume) {
                const delayEnter = activeBranch &&
                    pendingBranch.transition &&
                    pendingBranch.transition.mode === 'out-in';
                if (delayEnter) {
                    activeBranch.transition.afterLeave = () => {
                        if (pendingId === suspense.pendingId) {
                            move(pendingBranch, container, anchor, 0 /* ENTER */);
                        }
                    };
                }
                // this is initial anchor on mount
                let { anchor } = suspense;
                // unmount current active tree
                if (activeBranch) {
                    // if the fallback tree was mounted, it may have been moved
                    // as part of a parent suspense. get the latest anchor for insertion
                    anchor = next(activeBranch);
                    unmount(activeBranch, parentComponent, suspense, true);
                }
                if (!delayEnter) {
                    // move content from off-dom container to actual container
                    move(pendingBranch, container, anchor, 0 /* ENTER */);
                }
            }
            setActiveBranch(suspense, pendingBranch);
            suspense.pendingBranch = null;
            suspense.isInFallback = false;
            // flush buffered effects
            // check if there is a pending parent suspense
            let parent = suspense.parent;
            let hasUnresolvedAncestor = false;
            while (parent) {
                if (parent.pendingBranch) {
                    // found a pending parent suspense, merge buffered post jobs
                    // into that parent
                    parent.effects.push(...effects);
                    hasUnresolvedAncestor = true;
                    break;
                }
                parent = parent.parent;
            }
            // no pending parent suspense, flush all jobs
            if (!hasUnresolvedAncestor) {
                queuePostFlushCb(effects);
            }
            suspense.effects = [];
            // invoke @resolve event
            triggerEvent(vnode, 'onResolve');
        },
        fallback(fallbackVNode) {
            if (!suspense.pendingBranch) {
                return;
            }
            const { vnode, activeBranch, parentComponent, container, isSVG } = suspense;
            // invoke @fallback event
            triggerEvent(vnode, 'onFallback');
            const anchor = next(activeBranch);
            const mountFallback = () => {
                if (!suspense.isInFallback) {
                    return;
                }
                // mount the fallback tree
                patch(null, fallbackVNode, container, anchor, parentComponent, null, // fallback tree will not have suspense context
                isSVG, slotScopeIds, optimized);
                setActiveBranch(suspense, fallbackVNode);
            };
            const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in';
            if (delayEnter) {
                activeBranch.transition.afterLeave = mountFallback;
            }
            suspense.isInFallback = true;
            // unmount current active branch
            unmount(activeBranch, parentComponent, null, // no suspense so unmount hooks fire now
            true // shouldRemove
            );
            if (!delayEnter) {
                mountFallback();
            }
        },
        move(container, anchor, type) {
            suspense.activeBranch &&
                move(suspense.activeBranch, container, anchor, type);
            suspense.container = container;
        },
        next() {
            return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
            const isInPendingSuspense = !!suspense.pendingBranch;
            if (isInPendingSuspense) {
                suspense.deps++;
            }
            const hydratedEl = instance.vnode.el;
            instance
                .asyncDep.catch(err => {
                handleError(err, instance, 0 /* SETUP_FUNCTION */);
            })
                .then(asyncSetupResult => {
                // retry when the setup() promise resolves.
                // component may have been unmounted before resolve.
                if (instance.isUnmounted ||
                    suspense.isUnmounted ||
                    suspense.pendingId !== instance.suspenseId) {
                    return;
                }
                // retry from this component
                instance.asyncResolved = true;
                const { vnode } = instance;
                if ((true)) {
                    pushWarningContext(vnode);
                }
                handleSetupResult(instance, asyncSetupResult, false);
                if (hydratedEl) {
                    // vnode may have been replaced if an update happened before the
                    // async dep is resolved.
                    vnode.el = hydratedEl;
                }
                const placeholder = !hydratedEl && instance.subTree.el;
                setupRenderEffect(instance, vnode, 
                // component may have been moved before resolve.
                // if this is not a hydration, instance.subTree will be the comment
                // placeholder.
                parentNode(hydratedEl || instance.subTree.el), 
                // anchor will not be used if this is hydration, so only need to
                // consider the comment placeholder case.
                hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
                if (placeholder) {
                    remove(placeholder);
                }
                updateHOCHostEl(instance, vnode.el);
                if ((true)) {
                    popWarningContext();
                }
                // only decrease deps count if suspense is not already resolved
                if (isInPendingSuspense && --suspense.deps === 0) {
                    suspense.resolve();
                }
            });
        },
        unmount(parentSuspense, doRemove) {
            suspense.isUnmounted = true;
            if (suspense.activeBranch) {
                unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
            }
            if (suspense.pendingBranch) {
                unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
            }
        }
    };
    return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    /* eslint-disable no-restricted-globals */
    const suspense = (vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement('div'), null, isSVG, slotScopeIds, optimized, rendererInternals, true /* hydrating */));
    // there are two possible scenarios for server-rendered suspense:
    // - success: ssr content should be fully resolved
    // - failure: ssr content should be the fallback branch.
    // however, on the client we don't really know if it has failed or not
    // attempt to hydrate the DOM assuming it has succeeded, but we still
    // need to construct a suspense boundary first
    const result = hydrateNode(node, (suspense.pendingBranch = vnode.ssContent), parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
        suspense.resolve();
    }
    return result;
    /* eslint-enable no-restricted-globals */
}
function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32 /* SLOTS_CHILDREN */;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren
        ? normalizeSuspenseSlot(children.fallback)
        : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
    let block;
    if (isFunction(s)) {
        const trackBlock = isBlockTreeEnabled && s._c;
        if (trackBlock) {
            // disableTracking: false
            // allow block tracking for compiled slots
            // (see ./componentRenderContext.ts)
            s._d = false;
            openBlock();
        }
        s = s();
        if (trackBlock) {
            s._d = true;
            block = currentBlock;
            closeBlock();
        }
    }
    if (isArray(s)) {
        const singleChild = filterSingleRoot(s);
        if (( true) && !singleChild) {
            warn$1(`<Suspense> slots expect a single root node.`);
        }
        s = singleChild;
    }
    s = normalizeVNode(s);
    if (block && !s.dynamicChildren) {
        s.dynamicChildren = block.filter(c => c !== s);
    }
    return s;
}
function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
        if (isArray(fn)) {
            suspense.effects.push(...fn);
        }
        else {
            suspense.effects.push(fn);
        }
    }
    else {
        queuePostFlushCb(fn);
    }
}
function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = (vnode.el = branch.el);
    // in case suspense is the root node of a component,
    // recursively update the HOC el
    if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
    }
}

function provide(key, value) {
    if (!currentInstance) {
        if ((true)) {
            warn$1(`provide() can only be used inside setup().`);
        }
    }
    else {
        let provides = currentInstance.provides;
        // by default an instance inherits its parent's provides object
        // but when it needs to provide values of its own, it creates its
        // own provides object using parent provides object as prototype.
        // this way in `inject` we can simply look up injections from direct
        // parent and let the prototype chain do the work.
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
            provides = currentInstance.provides = Object.create(parentProvides);
        }
        // TS doesn't allow symbol as index type
        provides[key] = value;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.parent == null
            ? instance.vnode.appContext && instance.vnode.appContext.provides
            : instance.parent.provides;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction(defaultValue)
                ? defaultValue.call(instance.proxy)
                : defaultValue;
        }
        else if ((true)) {
            warn$1(`injection "${String(key)}" not found.`);
        }
    }
    else if ((true)) {
        warn$1(`inject() can only be used inside setup() or functional components.`);
    }
}

// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(Object.assign({}, options), { flush: 'post' }) : 0));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (( true)
        ? Object.assign(Object.assign({}, options), { flush: 'sync' }) : 0));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (( true) && !isFunction(cb)) {
        warn$1(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
    if (( true) && !cb) {
        if (immediate !== undefined) {
            warn$1(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn$1(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn$1(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, ` +
            `a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
    }
    else if (isReactive(source)) {
        getter = () => source;
        deep = true;
    }
    else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(s => isReactive(s) || isShallow(s));
        getter = () => source.map(s => {
            if (isRef(s)) {
                return s.value;
            }
            else if (isReactive(s)) {
                return traverse(s);
            }
            else if (isFunction(s)) {
                return callWithErrorHandling(s, instance, 2 /* WATCH_GETTER */);
            }
            else {
                ( true) && warnInvalidSource(s);
            }
        });
    }
    else if (isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = () => callWithErrorHandling(source, instance, 2 /* WATCH_GETTER */);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance.isUnmounted) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return callWithAsyncErrorHandling(source, instance, 3 /* WATCH_CALLBACK */, [onCleanup]);
            };
        }
    }
    else {
        getter = NOOP;
        ( true) && warnInvalidSource(source);
    }
    // 2.x array mutation watch compat
    if (cb && !deep) {
        const baseGetter = getter;
        getter = () => {
            const val = baseGetter();
            if (isArray(val) &&
                checkCompatEnabled("WATCH_ARRAY" /* WATCH_ARRAY */, instance)) {
                traverse(val);
            }
            return val;
        };
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = effect.onStop = () => {
            callWithErrorHandling(fn, instance, 4 /* WATCH_CLEANUP */);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isInSSRComponentSetup) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = NOOP;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return NOOP;
    }
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
        if (!effect.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = effect.run();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
                    : hasChanged(newValue, oldValue)) ||
                (isArray(newValue) &&
                    isCompatEnabled("WATCH_ARRAY" /* WATCH_ARRAY */, instance))) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                callWithAsyncErrorHandling(cb, instance, 3 /* WATCH_CALLBACK */, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            effect.run();
        }
    };
    // important: mark the job as a watcher callback so that scheduler knows
    // it is allowed to self-trigger (#1727)
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === 'sync') {
        scheduler = job; // the scheduler function gets called directly
    }
    else if (flush === 'post') {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    }
    else {
        // default: 'pre'
        scheduler = () => queuePreFlushCb(job);
    }
    const effect = new ReactiveEffect(getter, scheduler);
    if ((true)) {
        effect.onTrack = onTrack;
        effect.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            job();
        }
        else {
            oldValue = effect.run();
        }
    }
    else if (flush === 'post') {
        queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
    }
    else {
        effect.run();
    }
    return () => {
        effect.stop();
        if (instance && instance.scope) {
            remove(instance.scope.effects, effect);
        }
    };
}
// this.$watch
function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source)
        ? source.includes('.')
            ? createPathGetter(publicThis, source)
            : () => publicThis[source]
        : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value)) {
        cb = value;
    }
    else {
        cb = value.handler;
        options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
        setCurrentInstance(cur);
    }
    else {
        unsetCurrentInstance();
    }
    return res;
}
function createPathGetter(ctx, path) {
    const segments = path.split('.');
    return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
            cur = cur[segments[i]];
        }
        return cur;
    };
}
function traverse(value, seen) {
    if (!isObject(value) || value["__v_skip" /* SKIP */]) {
        return value;
    }
    seen = seen || new Set();
    if (seen.has(value)) {
        return value;
    }
    seen.add(value);
    if (isRef(value)) {
        traverse(value.value, seen);
    }
    else if (isArray(value)) {
        for (let i = 0; i < value.length; i++) {
            traverse(value[i], seen);
        }
    }
    else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
            traverse(v, seen);
        });
    }
    else if (isPlainObject(value)) {
        for (const key in value) {
            traverse(value[key], seen);
        }
    }
    return value;
}

function useTransitionState() {
    const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: new Map()
    };
    onMounted(() => {
        state.isMounted = true;
    });
    onBeforeUnmount(() => {
        state.isUnmounting = true;
    });
    return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        // enter
        onBeforeEnter: TransitionHookValidator,
        onEnter: TransitionHookValidator,
        onAfterEnter: TransitionHookValidator,
        onEnterCancelled: TransitionHookValidator,
        // leave
        onBeforeLeave: TransitionHookValidator,
        onLeave: TransitionHookValidator,
        onAfterLeave: TransitionHookValidator,
        onLeaveCancelled: TransitionHookValidator,
        // appear
        onBeforeAppear: TransitionHookValidator,
        onAppear: TransitionHookValidator,
        onAfterAppear: TransitionHookValidator,
        onAppearCancelled: TransitionHookValidator
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
                return;
            }
            let child = children[0];
            if (children.length > 1) {
                let hasFound = false;
                // locate first non-comment child
                for (const c of children) {
                    if (c.type !== Comment) {
                        if (( true) && hasFound) {
                            // warn more than one non-comment child
                            warn$1('<transition> can only be used on a single element or component. ' +
                                'Use <transition-group> for lists.');
                            break;
                        }
                        child = c;
                        hasFound = true;
                        if (false)
                            {}
                    }
                }
            }
            // there's no need to track reactivity for these props so use the raw
            // props for a bit better perf
            const rawProps = toRaw(props);
            const { mode } = rawProps;
            // check mode
            if (( true) &&
                mode &&
                mode !== 'in-out' &&
                mode !== 'out-in' &&
                mode !== 'default') {
                warn$1(`invalid <transition> mode: ${mode}`);
            }
            if (state.isLeaving) {
                return emptyPlaceholder(child);
            }
            // in the case of <transition><keep-alive/></transition>, we need to
            // compare the type of the kept-alive children.
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
                return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
                const key = getTransitionKey();
                if (prevTransitionKey === undefined) {
                    prevTransitionKey = key;
                }
                else if (key !== prevTransitionKey) {
                    prevTransitionKey = key;
                    transitionKeyChanged = true;
                }
            }
            // handle mode
            if (oldInnerChild &&
                oldInnerChild.type !== Comment &&
                (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
                const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                // update old tree's hooks in case of dynamic transition
                setTransitionHooks(oldInnerChild, leavingHooks);
                // switching between different views
                if (mode === 'out-in') {
                    state.isLeaving = true;
                    // return placeholder node and queue update when leave finishes
                    leavingHooks.afterLeave = () => {
                        state.isLeaving = false;
                        instance.update();
                    };
                    return emptyPlaceholder(child);
                }
                else if (mode === 'in-out' && innerChild.type !== Comment) {
                    leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                        const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                        leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                        // early removal callback
                        el._leaveCb = () => {
                            earlyRemove();
                            el._leaveCb = undefined;
                            delete enterHooks.delayedLeave;
                        };
                        enterHooks.delayedLeave = delayedLeave;
                    };
                }
            }
            return child;
        };
    }
};
{
    BaseTransitionImpl.__isBuiltIn = true;
}
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
        leavingVNodesCache = Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
}
// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode, props, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
        hook &&
            callWithAsyncErrorHandling(hook, instance, 9 /* TRANSITION_HOOK */, args);
    };
    const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook(hook, args);
        if (isArray(hook)) {
            if (hook.every(hook => hook.length <= 1))
                done();
        }
        else if (hook.length <= 1) {
            done();
        }
    };
    const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
            let hook = onBeforeEnter;
            if (!state.isMounted) {
                if (appear) {
                    hook = onBeforeAppear || onBeforeEnter;
                }
                else {
                    return;
                }
            }
            // for same element (v-show)
            if (el._leaveCb) {
                el._leaveCb(true /* cancelled */);
            }
            // for toggled element with same key (v-if)
            const leavingVNode = leavingVNodesCache[key];
            if (leavingVNode &&
                isSameVNodeType(vnode, leavingVNode) &&
                leavingVNode.el._leaveCb) {
                // force early removal (not cancelled)
                leavingVNode.el._leaveCb();
            }
            callHook(hook, [el]);
        },
        enter(el) {
            let hook = onEnter;
            let afterHook = onAfterEnter;
            let cancelHook = onEnterCancelled;
            if (!state.isMounted) {
                if (appear) {
                    hook = onAppear || onEnter;
                    afterHook = onAfterAppear || onAfterEnter;
                    cancelHook = onAppearCancelled || onEnterCancelled;
                }
                else {
                    return;
                }
            }
            let called = false;
            const done = (el._enterCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                if (cancelled) {
                    callHook(cancelHook, [el]);
                }
                else {
                    callHook(afterHook, [el]);
                }
                if (hooks.delayedLeave) {
                    hooks.delayedLeave();
                }
                el._enterCb = undefined;
            });
            if (hook) {
                callAsyncHook(hook, [el, done]);
            }
            else {
                done();
            }
        },
        leave(el, remove) {
            const key = String(vnode.key);
            if (el._enterCb) {
                el._enterCb(true /* cancelled */);
            }
            if (state.isUnmounting) {
                return remove();
            }
            callHook(onBeforeLeave, [el]);
            let called = false;
            const done = (el._leaveCb = (cancelled) => {
                if (called)
                    return;
                called = true;
                remove();
                if (cancelled) {
                    callHook(onLeaveCancelled, [el]);
                }
                else {
                    callHook(onAfterLeave, [el]);
                }
                el._leaveCb = undefined;
                if (leavingVNodesCache[key] === vnode) {
                    delete leavingVNodesCache[key];
                }
            });
            leavingVNodesCache[key] = vnode;
            if (onLeave) {
                callAsyncHook(onLeave, [el, done]);
            }
            else {
                done();
            }
        },
        clone(vnode) {
            return resolveTransitionHooks(vnode, props, state, instance);
        }
    };
    return hooks;
}
// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
    }
}
function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode)
        ? vnode.children
            ? vnode.children[0]
            : undefined
        : vnode;
}
function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 /* COMPONENT */ && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
    }
    else if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    }
    else {
        vnode.transition = hooks;
    }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
        let child = children[i];
        // #5360 inherit parent key in case of <template v-for>
        const key = parentKey == null
            ? child.key
            : String(parentKey) + String(child.key != null ? child.key : i);
        // handle fragment children case, e.g. v-for
        if (child.type === Fragment) {
            if (child.patchFlag & 128 /* KEYED_FRAGMENT */)
                keyedFragmentCount++;
            ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
        }
        // comment placeholders should be skipped, e.g. v-if
        else if (keepComment || child.type !== Comment) {
            ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
    }
    // #1126 if a transition children list contains multiple sub fragments, these
    // fragments will be merged into a flat children array. Since each v-for
    // fragment may contain different static bindings inside, we need to de-op
    // these children to force full diffs to ensure correct behavior.
    if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
            ret[i].patchFlag = -2 /* BAIL */;
        }
    }
    return ret;
}

// implementation, close to no-op
function defineComponent(options) {
    return isFunction(options) ? { setup: options, name: options.name } : options;
}

const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
    if (isFunction(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = true, onError: userOnError } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (( true) && !comp) {
                        warn$1(`Async component loader resolved to undefined. ` +
                            `If you are using retry(), make sure to return its return value.`);
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (( true) && comp && !isObject(comp) && !isFunction(comp)) {
                        throw new Error(`Invalid async component load result: ${comp}`);
                    }
                    resolvedComp = comp;
                    return comp;
                })));
    };
    return defineComponent({
        name: 'AsyncComponentWrapper',
        __asyncLoader: load,
        get __asyncResolved() {
            return resolvedComp;
        },
        setup() {
            const instance = currentInstance;
            // already resolved
            if (resolvedComp) {
                return () => createInnerComp(resolvedComp, instance);
            }
            const onError = (err) => {
                pendingRequest = null;
                handleError(err, instance, 13 /* ASYNC_COMPONENT_LOADER */, !errorComponent /* do not throw in dev if user provided error component */);
            };
            // suspense-controlled or SSR.
            if ((suspensible && instance.suspense) ||
                (isInSSRComponentSetup)) {
                return load()
                    .then(comp => {
                    return () => createInnerComp(comp, instance);
                })
                    .catch(err => {
                    onError(err);
                    return () => errorComponent
                        ? createVNode(errorComponent, {
                            error: err
                        })
                        : null;
                });
            }
            const loaded = ref(false);
            const error = ref();
            const delayed = ref(!!delay);
            if (delay) {
                setTimeout(() => {
                    delayed.value = false;
                }, delay);
            }
            if (timeout != null) {
                setTimeout(() => {
                    if (!loaded.value && !error.value) {
                        const err = new Error(`Async component timed out after ${timeout}ms.`);
                        onError(err);
                        error.value = err;
                    }
                }, timeout);
            }
            load()
                .then(() => {
                loaded.value = true;
                if (instance.parent && isKeepAlive(instance.parent.vnode)) {
                    // parent is keep-alive, force update so the loaded component's
                    // name is taken into account
                    queueJob(instance.parent.update);
                }
            })
                .catch(err => {
                onError(err);
                error.value = err;
            });
            return () => {
                if (loaded.value && resolvedComp) {
                    return createInnerComp(resolvedComp, instance);
                }
                else if (error.value && errorComponent) {
                    return createVNode(errorComponent, {
                        error: error.value
                    });
                }
                else if (loadingComponent && !delayed.value) {
                    return createVNode(loadingComponent);
                }
            };
        }
    });
}
function createInnerComp(comp, { vnode: { ref, props, children, shapeFlag }, parent }) {
    const vnode = createVNode(comp, props, children);
    // ensure inner component inherits the async wrapper's ref owner
    vnode.ref = ref;
    return vnode;
}

const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        // KeepAlive communicates with the instantiated renderer via the
        // ctx where the renderer passes in its internals,
        // and the KeepAlive instance exposes activate/deactivate implementations.
        // The whole point of this is to avoid importing KeepAlive directly in the
        // renderer to facilitate tree-shaking.
        const sharedContext = instance.ctx;
        // if the internal renderer is not registered, it indicates that this is server-side rendering,
        // for KeepAlive, we just need to render its children
        if (!sharedContext.renderer) {
            return () => {
                const children = slots.default && slots.default();
                return children && children.length === 1 ? children[0] : children;
            };
        }
        const cache = new Map();
        const keys = new Set();
        let current = null;
        if (true) {
            instance.__v_cache = cache;
        }
        const parentSuspense = instance.suspense;
        const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
        const storageContainer = createElement('div');
        sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance = vnode.component;
            move(vnode, container, anchor, 0 /* ENTER */, parentSuspense);
            // in case props have changed
            patch(instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
                instance.isDeactivated = false;
                if (instance.a) {
                    invokeArrayFns(instance.a);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        sharedContext.deactivate = (vnode) => {
            const instance = vnode.component;
            move(vnode, storageContainer, null, 1 /* LEAVE */, parentSuspense);
            queuePostRenderEffect(() => {
                if (instance.da) {
                    invokeArrayFns(instance.da);
                }
                const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
                if (vnodeHook) {
                    invokeVNodeHook(vnodeHook, instance.parent, vnode);
                }
                instance.isDeactivated = true;
            }, parentSuspense);
            if (true) {
                // Update components tree
                devtoolsComponentAdded(instance);
            }
        };
        function unmount(vnode) {
            // reset the shapeFlag so it can be properly unmounted
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter) {
            cache.forEach((vnode, key) => {
                const name = getComponentName(vnode.type);
                if (name && (!filter || !filter(name))) {
                    pruneCacheEntry(key);
                }
            });
        }
        function pruneCacheEntry(key) {
            const cached = cache.get(key);
            if (!current || cached.type !== current.type) {
                unmount(cached);
            }
            else if (current) {
                // current active instance should no longer be kept-alive.
                // we can't unmount it now but it might be later, so reset its flag now.
                resetShapeFlag(current);
            }
            cache.delete(key);
            keys.delete(key);
        }
        // prune cache on include/exclude prop change
        watch(() => [props.include, props.exclude], ([include, exclude]) => {
            include && pruneCache(name => matches(include, name));
            exclude && pruneCache(name => !matches(exclude, name));
        }, 
        // prune post-render after `current` has been updated
        { flush: 'post', deep: true });
        // cache sub tree after render
        let pendingCacheKey = null;
        const cacheSubtree = () => {
            // fix #1621, the pendingCacheKey could be 0
            if (pendingCacheKey != null) {
                cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
            cache.forEach(cached => {
                const { subTree, suspense } = instance;
                const vnode = getInnerChild(subTree);
                if (cached.type === vnode.type) {
                    // current instance will be unmounted as part of keep-alive's unmount
                    resetShapeFlag(vnode);
                    // but invoke its deactivated hook here
                    const da = vnode.component.da;
                    da && queuePostRenderEffect(da, suspense);
                    return;
                }
                unmount(cached);
            });
        });
        return () => {
            pendingCacheKey = null;
            if (!slots.default) {
                return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
                if ((true)) {
                    warn$1(`KeepAlive should contain exactly one component child.`);
                }
                current = null;
                return children;
            }
            else if (!isVNode(rawVNode) ||
                (!(rawVNode.shapeFlag & 4 /* STATEFUL_COMPONENT */) &&
                    !(rawVNode.shapeFlag & 128 /* SUSPENSE */))) {
                current = null;
                return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            // for async components, name check should be based in its loaded
            // inner component if available
            const name = getComponentName(isAsyncWrapper(vnode)
                ? vnode.type.__asyncResolved || {}
                : comp);
            const { include, exclude, max } = props;
            if ((include && (!name || !matches(include, name))) ||
                (exclude && name && matches(exclude, name))) {
                current = vnode;
                return rawVNode;
            }
            const key = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key);
            // clone vnode if it's reused because we are going to mutate it
            if (vnode.el) {
                vnode = cloneVNode(vnode);
                if (rawVNode.shapeFlag & 128 /* SUSPENSE */) {
                    rawVNode.ssContent = vnode;
                }
            }
            // #1513 it's possible for the returned vnode to be cloned due to attr
            // fallthrough or scopeId, so the vnode here may not be the final vnode
            // that is mounted. Instead of caching it directly, we store the pending
            // key and cache `instance.subTree` (the normalized vnode) in
            // beforeMount/beforeUpdate hooks.
            pendingCacheKey = key;
            if (cachedVNode) {
                // copy over mounted state
                vnode.el = cachedVNode.el;
                vnode.component = cachedVNode.component;
                if (vnode.transition) {
                    // recursively update transition hooks on subTree
                    setTransitionHooks(vnode, vnode.transition);
                }
                // avoid vnode being mounted as fresh
                vnode.shapeFlag |= 512 /* COMPONENT_KEPT_ALIVE */;
                // make this key the freshest
                keys.delete(key);
                keys.add(key);
            }
            else {
                keys.add(key);
                // prune oldest entry
                if (max && keys.size > parseInt(max, 10)) {
                    pruneCacheEntry(keys.values().next().value);
                }
            }
            // avoid vnode being unmounted
            vnode.shapeFlag |= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
            current = vnode;
            return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
    }
};
{
    KeepAliveImpl.__isBuildIn = true;
}
// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
    if (isArray(pattern)) {
        return pattern.some((p) => matches(p, name));
    }
    else if (isString(pattern)) {
        return pattern.split(',').includes(name);
    }
    else if (pattern.test) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a" /* ACTIVATED */, target);
}
function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da" /* DEACTIVATED */, target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
    // cache the deactivate branch check wrapper for injected hooks so the same
    // hook can be properly deduped by the scheduler. "__wdc" stands for "with
    // deactivation check".
    const wrappedHook = hook.__wdc ||
        (hook.__wdc = () => {
            // only fire the hook if the target instance is NOT in a deactivated branch.
            let current = target;
            while (current) {
                if (current.isDeactivated) {
                    return;
                }
                current = current.parent;
            }
            return hook();
        });
    injectHook(type, wrappedHook, target);
    // In addition to registering it on the target instance, we walk up the parent
    // chain and register it on all ancestor instances that are keep-alive roots.
    // This avoids the need to walk the entire component tree when invoking these
    // hooks, and more importantly, avoids the need to track child components in
    // arrays.
    if (target) {
        let current = target.parent;
        while (current && current.parent) {
            if (isKeepAlive(current.parent.vnode)) {
                injectToKeepAliveRoot(wrappedHook, type, target, current);
            }
            current = current.parent;
        }
    }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    // injectHook wraps the original for error handling, so make sure to remove
    // the wrapped version.
    const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */);
    onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
    }, target);
}
function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
        shapeFlag -= 256 /* COMPONENT_SHOULD_KEEP_ALIVE */;
    }
    if (shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
        shapeFlag -= 512 /* COMPONENT_KEPT_ALIVE */;
    }
    vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 /* SUSPENSE */ ? vnode.ssContent : vnode;
}

function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
        const hooks = target[type] || (target[type] = []);
        // cache the error handling wrapper for injected hooks so the same hook
        // can be properly deduped by the scheduler. "__weh" stands for "with error
        // handling".
        const wrappedHook = hook.__weh ||
            (hook.__weh = (...args) => {
                if (target.isUnmounted) {
                    return;
                }
                // disable tracking inside all lifecycle hooks
                // since they can potentially be called inside effects.
                pauseTracking();
                // Set currentInstance during hook invocation.
                // This assumes the hook does not synchronously trigger other hooks, which
                // can only be false when the user does something really funky.
                setCurrentInstance(target);
                const res = callWithAsyncErrorHandling(hook, target, type, args);
                unsetCurrentInstance();
                resetTracking();
                return res;
            });
        if (prepend) {
            hooks.unshift(wrappedHook);
        }
        else {
            hooks.push(wrappedHook);
        }
        return wrappedHook;
    }
    else if ((true)) {
        const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''));
        warn$1(`${apiName} is called when there is no active component instance to be ` +
            `associated with. ` +
            `Lifecycle injection APIs can only be used during execution of setup().` +
            (` If you are using async setup(), make sure to register lifecycle ` +
                    `hooks before the first await statement.`
                ));
    }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => 
// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup || lifecycle === "sp" /* SERVER_PREFETCH */) &&
    injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm" /* BEFORE_MOUNT */);
const onMounted = createHook("m" /* MOUNTED */);
const onBeforeUpdate = createHook("bu" /* BEFORE_UPDATE */);
const onUpdated = createHook("u" /* UPDATED */);
const onBeforeUnmount = createHook("bum" /* BEFORE_UNMOUNT */);
const onUnmounted = createHook("um" /* UNMOUNTED */);
const onServerPrefetch = createHook("sp" /* SERVER_PREFETCH */);
const onRenderTriggered = createHook("rtg" /* RENDER_TRIGGERED */);
const onRenderTracked = createHook("rtc" /* RENDER_TRACKED */);
function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec" /* ERROR_CAPTURED */, hook, target);
}

function getCompatChildren(instance) {
    assertCompatEnabled("INSTANCE_CHILDREN" /* INSTANCE_CHILDREN */, instance);
    const root = instance.subTree;
    const children = [];
    if (root) {
        walk(root, children);
    }
    return children;
}
function walk(vnode, children) {
    if (vnode.component) {
        children.push(vnode.component.proxy);
    }
    else if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
        const vnodes = vnode.children;
        for (let i = 0; i < vnodes.length; i++) {
            walk(vnodes[i], children);
        }
    }
}

function getCompatListeners(instance) {
    assertCompatEnabled("INSTANCE_LISTENERS" /* INSTANCE_LISTENERS */, instance);
    const listeners = {};
    const rawProps = instance.vnode.props;
    if (!rawProps) {
        return listeners;
    }
    for (const key in rawProps) {
        if (isOn(key)) {
            listeners[key[2].toLowerCase() + key.slice(3)] = rawProps[key];
        }
    }
    return listeners;
}

const legacyDirectiveHookMap = {
    beforeMount: 'bind',
    mounted: 'inserted',
    updated: ['update', 'componentUpdated'],
    unmounted: 'unbind'
};
function mapCompatDirectiveHook(name, dir, instance) {
    const mappedName = legacyDirectiveHookMap[name];
    if (mappedName) {
        if (isArray(mappedName)) {
            const hook = [];
            mappedName.forEach(mapped => {
                const mappedHook = dir[mapped];
                if (mappedHook) {
                    softAssertCompatEnabled("CUSTOM_DIR" /* CUSTOM_DIR */, instance, mapped, name);
                    hook.push(mappedHook);
                }
            });
            return hook.length ? hook : undefined;
        }
        else {
            if (dir[mappedName]) {
                softAssertCompatEnabled("CUSTOM_DIR" /* CUSTOM_DIR */, instance, mappedName, name);
            }
            return dir[mappedName];
        }
    }
}

/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/
function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
        warn$1('Do not use built-in directive ids as custom directive id: ' + name);
    }
}
/**
 * Adds directives to a VNode.
 */
function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
        ( true) && warn$1(`withDirectives can only be used inside render functions.`);
        return vnode;
    }
    const instance = getExposeProxy(internalInstance) ||
        internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (isFunction(dir)) {
            dir = {
                mounted: dir,
                updated: dir
            };
        }
        if (dir.deep) {
            traverse(value);
        }
        bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
        });
    }
    return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
            binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (!hook) {
            hook = mapCompatDirectiveHook(name, binding.dir, instance);
        }
        if (hook) {
            // disable tracking inside all lifecycle hooks
            // since they can potentially be called inside effects.
            pauseTracking();
            callWithAsyncErrorHandling(hook, instance, 8 /* DIRECTIVE_HOOK */, [
                vnode.el,
                binding,
                vnode,
                prevVNode
            ]);
            resetTracking();
        }
    }
}

const COMPONENTS = 'components';
const DIRECTIVES = 'directives';
const FILTERS = 'filters';
/**
 * @private
 */
function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
/**
 * @private
 */
function resolveDynamicComponent(component) {
    if (isString(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
    }
    else {
        // invalid types will fallthrough to createVNode and raise warning
        return (component || NULL_DYNAMIC_COMPONENT);
    }
}
/**
 * @private
 */
function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
}
/**
 * v2 compat only
 * @internal
 */
function resolveFilter(name) {
    return resolveAsset(FILTERS, name);
}
// implementation
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
        const Component = instance.type;
        // explicit self name has highest priority
        if (type === COMPONENTS) {
            const selfName = getComponentName(Component, false /* do not include inferred name to avoid breaking existing code */);
            if (selfName &&
                (selfName === name ||
                    selfName === camelize(name) ||
                    selfName === capitalize(camelize(name)))) {
                return Component;
            }
        }
        const res = 
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) ||
            // global registration
            resolve(instance.appContext[type], name);
        if (!res && maybeSelfReference) {
            // fallback to implicit self-reference
            return Component;
        }
        if (( true) && warnMissing && !res) {
            const extra = type === COMPONENTS
                ? `\nIf this is a native custom element, make sure to exclude it from ` +
                    `component resolution via compilerOptions.isCustomElement.`
                : ``;
            warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);
        }
        return res;
    }
    else if ((true)) {
        warn$1(`resolve${capitalize(type.slice(0, -1))} ` +
            `can only be used in render() or setup().`);
    }
}
function resolve(registry, name) {
    return (registry &&
        (registry[name] ||
            registry[camelize(name)] ||
            registry[capitalize(camelize(name))]));
}

function convertLegacyRenderFn(instance) {
    const Component = instance.type;
    const render = Component.render;
    // v3 runtime compiled, or already checked / wrapped
    if (!render || render._rc || render._compatChecked || render._compatWrapped) {
        return;
    }
    if (render.length >= 2) {
        // v3 pre-compiled function, since v2 render functions never need more than
        // 2 arguments, and v2 functional render functions would have already been
        // normalized into v3 functional components
        render._compatChecked = true;
        return;
    }
    // v2 render function, try to provide compat
    if (checkCompatEnabled("RENDER_FUNCTION" /* RENDER_FUNCTION */, instance)) {
        const wrapped = (Component.render = function compatRender() {
            // @ts-ignore
            return render.call(this, compatH);
        });
        // @ts-ignore
        wrapped._compatWrapped = true;
    }
}
function compatH(type, propsOrChildren, children) {
    if (!type) {
        type = Comment;
    }
    // to support v2 string component name look!up
    if (typeof type === 'string') {
        const t = hyphenate(type);
        if (t === 'transition' || t === 'transition-group' || t === 'keep-alive') {
            // since transition and transition-group are runtime-dom-specific,
            // we cannot import them directly here. Instead they are registered using
            // special keys in @vue/compat entry.
            type = `__compat__${t}`;
        }
        type = resolveDynamicComponent(type);
    }
    const l = arguments.length;
    const is2ndArgArrayChildren = isArray(propsOrChildren);
    if (l === 2 || is2ndArgArrayChildren) {
        if (isObject(propsOrChildren) && !is2ndArgArrayChildren) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return convertLegacySlots(createVNode(type, null, [propsOrChildren]));
            }
            // props without children
            return convertLegacySlots(convertLegacyDirectives(createVNode(type, convertLegacyProps(propsOrChildren, type)), propsOrChildren));
        }
        else {
            // omit props
            return convertLegacySlots(createVNode(type, null, propsOrChildren));
        }
    }
    else {
        if (isVNode(children)) {
            children = [children];
        }
        return convertLegacySlots(convertLegacyDirectives(createVNode(type, convertLegacyProps(propsOrChildren, type), children), propsOrChildren));
    }
}
const skipLegacyRootLevelProps = /*#__PURE__*/ makeMap('staticStyle,staticClass,directives,model,hook');
function convertLegacyProps(legacyProps, type) {
    if (!legacyProps) {
        return null;
    }
    const converted = {};
    for (const key in legacyProps) {
        if (key === 'attrs' || key === 'domProps' || key === 'props') {
            extend(converted, legacyProps[key]);
        }
        else if (key === 'on' || key === 'nativeOn') {
            const listeners = legacyProps[key];
            for (const event in listeners) {
                let handlerKey = convertLegacyEventKey(event);
                if (key === 'nativeOn')
                    handlerKey += `Native`;
                const existing = converted[handlerKey];
                const incoming = listeners[event];
                if (existing !== incoming) {
                    if (existing) {
                        converted[handlerKey] = [].concat(existing, incoming);
                    }
                    else {
                        converted[handlerKey] = incoming;
                    }
                }
            }
        }
        else if (!skipLegacyRootLevelProps(key)) {
            converted[key] = legacyProps[key];
        }
    }
    if (legacyProps.staticClass) {
        converted.class = normalizeClass([legacyProps.staticClass, converted.class]);
    }
    if (legacyProps.staticStyle) {
        converted.style = normalizeStyle([legacyProps.staticStyle, converted.style]);
    }
    if (legacyProps.model && isObject(type)) {
        // v2 compiled component v-model
        const { prop = 'value', event = 'input' } = type.model || {};
        converted[prop] = legacyProps.model.value;
        converted[compatModelEventPrefix + event] = legacyProps.model.callback;
    }
    return converted;
}
function convertLegacyEventKey(event) {
    // normalize v2 event prefixes
    if (event[0] === '&') {
        event = event.slice(1) + 'Passive';
    }
    if (event[0] === '~') {
        event = event.slice(1) + 'Once';
    }
    if (event[0] === '!') {
        event = event.slice(1) + 'Capture';
    }
    return toHandlerKey(event);
}
function convertLegacyDirectives(vnode, props) {
    if (props && props.directives) {
        return withDirectives(vnode, props.directives.map(({ name, value, arg, modifiers }) => {
            return [
                resolveDirective(name),
                value,
                arg,
                modifiers
            ];
        }));
    }
    return vnode;
}
function convertLegacySlots(vnode) {
    const { props, children } = vnode;
    let slots;
    if (vnode.shapeFlag & 6 /* COMPONENT */ && isArray(children)) {
        slots = {};
        // check "slot" property on vnodes and turn them into v3 function slots
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const slotName = (isVNode(child) && child.props && child.props.slot) || 'default';
            const slot = slots[slotName] || (slots[slotName] = []);
            if (isVNode(child) && child.type === 'template') {
                slot.push(child.children);
            }
            else {
                slot.push(child);
            }
        }
        if (slots) {
            for (const key in slots) {
                const slotChildren = slots[key];
                slots[key] = () => slotChildren;
                slots[key]._ns = true; /* non-scoped slot */
            }
        }
    }
    const scopedSlots = props && props.scopedSlots;
    if (scopedSlots) {
        delete props.scopedSlots;
        if (slots) {
            extend(slots, scopedSlots);
        }
        else {
            slots = scopedSlots;
        }
    }
    if (slots) {
        normalizeChildren(vnode, slots);
    }
    return vnode;
}
function defineLegacyVNodeProperties(vnode) {
    /* istanbul ignore if */
    if (isCompatEnabled("RENDER_FUNCTION" /* RENDER_FUNCTION */, currentRenderingInstance, true /* enable for built-ins */) &&
        isCompatEnabled("PRIVATE_APIS" /* PRIVATE_APIS */, currentRenderingInstance, true /* enable for built-ins */)) {
        const context = currentRenderingInstance;
        const getInstance = () => vnode.component && vnode.component.proxy;
        let componentOptions;
        Object.defineProperties(vnode, {
            tag: { get: () => vnode.type },
            data: { get: () => vnode.props || {}, set: p => (vnode.props = p) },
            elm: { get: () => vnode.el },
            componentInstance: { get: getInstance },
            child: { get: getInstance },
            text: { get: () => (isString(vnode.children) ? vnode.children : null) },
            context: { get: () => context && context.proxy },
            componentOptions: {
                get: () => {
                    if (vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */) {
                        if (componentOptions) {
                            return componentOptions;
                        }
                        return (componentOptions = {
                            Ctor: vnode.type,
                            propsData: vnode.props,
                            children: vnode.children
                        });
                    }
                }
            }
        });
    }
}

const normalizedFunctionalComponentMap = new Map();
const legacySlotProxyHandlers = {
    get(target, key) {
        const slot = target[key];
        return slot && slot();
    }
};
function convertLegacyFunctionalComponent(comp) {
    if (normalizedFunctionalComponentMap.has(comp)) {
        return normalizedFunctionalComponentMap.get(comp);
    }
    const legacyFn = comp.render;
    const Func = (props, ctx) => {
        const instance = getCurrentInstance();
        const legacyCtx = {
            props,
            children: instance.vnode.children || [],
            data: instance.vnode.props || {},
            scopedSlots: ctx.slots,
            parent: instance.parent && instance.parent.proxy,
            slots() {
                return new Proxy(ctx.slots, legacySlotProxyHandlers);
            },
            get listeners() {
                return getCompatListeners(instance);
            },
            get injections() {
                if (comp.inject) {
                    const injections = {};
                    resolveInjections(comp.inject, injections);
                    return injections;
                }
                return {};
            }
        };
        return legacyFn(compatH, legacyCtx);
    };
    Func.props = comp.props;
    Func.displayName = comp.name;
    Func.compatConfig = comp.compatConfig;
    // v2 functional components do not inherit attrs
    Func.inheritAttrs = false;
    normalizedFunctionalComponentMap.set(comp, Func);
    return Func;
}

/**
 * Actual implementation
 */
function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = (cache && cache[index]);
    if (isArray(source) || isString(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
            ret[i] = renderItem(source[i], i, undefined, cached && cached[i]);
        }
    }
    else if (typeof source === 'number') {
        if (( true) && !Number.isInteger(source)) {
            warn$1(`The v-for range expect an integer value but got ${source}.`);
        }
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
            ret[i] = renderItem(i + 1, i, undefined, cached && cached[i]);
        }
    }
    else if (isObject(source)) {
        if (source[Symbol.iterator]) {
            ret = Array.from(source, (item, i) => renderItem(item, i, undefined, cached && cached[i]));
        }
        else {
            const keys = Object.keys(source);
            ret = new Array(keys.length);
            for (let i = 0, l = keys.length; i < l; i++) {
                const key = keys[i];
                ret[i] = renderItem(source[key], key, i, cached && cached[i]);
            }
        }
    }
    else {
        ret = [];
    }
    if (cache) {
        cache[index] = ret;
    }
    return ret;
}

/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */
function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
        const slot = dynamicSlots[i];
        // array of dynamic slot generated by <template v-for="..." #[...]>
        if (isArray(slot)) {
            for (let j = 0; j < slot.length; j++) {
                slots[slot[j].name] = slot[j].fn;
            }
        }
        else if (slot) {
            // conditional single slot generated by <template v-if="..." #foo>
            slots[slot.name] = slot.fn;
        }
    }
    return slots;
}

/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */
function renderSlot(slots, name, props = {}, 
// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback, noSlotted) {
    if (currentRenderingInstance.isCE ||
        (currentRenderingInstance.parent &&
            isAsyncWrapper(currentRenderingInstance.parent) &&
            currentRenderingInstance.parent.isCE)) {
        return createVNode('slot', name === 'default' ? null : { name }, fallback && fallback());
    }
    let slot = slots[name];
    if (( true) && slot && slot.length > 1) {
        warn$1(`SSR-optimized slot function detected in a non-SSR-optimized render ` +
            `function. You need to mark this component with $dynamic-slots in the ` +
            `parent template.`);
        slot = () => [];
    }
    // a compiled slot disables block tracking by default to avoid manual
    // invocation interfering with template-based block tracking, but in
    // `renderSlot` we can be sure that it's template-based so we can force
    // enable it.
    if (slot && slot._c) {
        slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 /* STABLE */
        ? 64 /* STABLE_FRAGMENT */
        : -2 /* BAIL */);
    if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + '-s'];
    }
    if (slot && slot._c) {
        slot._d = true;
    }
    return rendered;
}
function ensureValidVNode(vnodes) {
    return vnodes.some(child => {
        if (!isVNode(child))
            return true;
        if (child.type === Comment)
            return false;
        if (child.type === Fragment &&
            !ensureValidVNode(child.children))
            return false;
        return true;
    })
        ? vnodes
        : null;
}

/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */
function toHandlers(obj) {
    const ret = {};
    if (( true) && !isObject(obj)) {
        warn$1(`v-on with no argument expects an object value.`);
        return ret;
    }
    for (const key in obj) {
        ret[toHandlerKey(key)] = obj[key];
    }
    return ret;
}

function toObject(arr) {
    const res = {};
    for (let i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend(res, arr[i]);
        }
    }
    return res;
}
function legacyBindObjectProps(data, _tag, value, _asProp, isSync) {
    if (value && isObject(value)) {
        if (isArray(value)) {
            value = toObject(value);
        }
        for (const key in value) {
            if (isReservedProp(key)) {
                data[key] = value[key];
            }
            else if (key === 'class') {
                data.class = normalizeClass([data.class, value.class]);
            }
            else if (key === 'style') {
                data.style = normalizeClass([data.style, value.style]);
            }
            else {
                const attrs = data.attrs || (data.attrs = {});
                const camelizedKey = camelize(key);
                const hyphenatedKey = hyphenate(key);
                if (!(camelizedKey in attrs) && !(hyphenatedKey in attrs)) {
                    attrs[key] = value[key];
                    if (isSync) {
                        const on = data.on || (data.on = {});
                        on[`update:${key}`] = function ($event) {
                            value[key] = $event;
                        };
                    }
                }
            }
        }
    }
    return data;
}
function legacyBindObjectListeners(props, listeners) {
    return mergeProps(props, toHandlers(listeners));
}
function legacyRenderSlot(instance, name, fallback, props, bindObject) {
    if (bindObject) {
        props = mergeProps(props, bindObject);
    }
    return renderSlot(instance.slots, name, props, fallback && (() => fallback));
}
function legacyresolveScopedSlots(fns, raw, 
// the following are added in 2.6
hasDynamicKeys) {
    // v2 default slot doesn't have name
    return createSlots(raw || { $stable: !hasDynamicKeys }, mapKeyToName(fns));
}
function mapKeyToName(slots) {
    for (let i = 0; i < slots.length; i++) {
        const fn = slots[i];
        if (fn) {
            if (isArray(fn)) {
                mapKeyToName(fn);
            }
            else {
                fn.name = fn.key || 'default';
            }
        }
    }
    return slots;
}
const staticCacheMap = /*#__PURE__*/ new WeakMap();
function legacyRenderStatic(instance, index) {
    let cache = staticCacheMap.get(instance);
    if (!cache) {
        staticCacheMap.set(instance, (cache = []));
    }
    if (cache[index]) {
        return cache[index];
    }
    const fn = instance.type.staticRenderFns[index];
    const ctx = instance.proxy;
    return (cache[index] = fn.call(ctx, null, ctx));
}
function legacyCheckKeyCodes(instance, eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    const config = instance.appContext.config;
    const configKeyCodes = config.keyCodes || {};
    const mappedKeyCode = configKeyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !configKeyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
    }
    else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    }
    else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key;
    }
}
function isKeyNotMatch(expect, actual) {
    if (isArray(expect)) {
        return !expect.includes(actual);
    }
    else {
        return expect !== actual;
    }
}
function legacyMarkOnce(tree) {
    return tree;
}
function legacyBindDynamicKeys(props, values) {
    for (let i = 0; i < values.length; i += 2) {
        const key = values[i];
        if (typeof key === 'string' && key) {
            props[values[i]] = values[i + 1];
        }
    }
    return props;
}
function legacyPrependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
}

function installCompatInstanceProperties(map) {
    const set = (target, key, val) => {
        target[key] = val;
    };
    const del = (target, key) => {
        delete target[key];
    };
    extend(map, {
        $set: i => {
            assertCompatEnabled("INSTANCE_SET" /* INSTANCE_SET */, i);
            return set;
        },
        $delete: i => {
            assertCompatEnabled("INSTANCE_DELETE" /* INSTANCE_DELETE */, i);
            return del;
        },
        $mount: i => {
            assertCompatEnabled("GLOBAL_MOUNT" /* GLOBAL_MOUNT */, null /* this warning is global */);
            // root mount override from ./global.ts in installCompatMount
            return i.ctx._compat_mount || NOOP;
        },
        $destroy: i => {
            assertCompatEnabled("INSTANCE_DESTROY" /* INSTANCE_DESTROY */, i);
            // root destroy override from ./global.ts in installCompatMount
            return i.ctx._compat_destroy || NOOP;
        },
        // overrides existing accessor
        $slots: i => {
            if (isCompatEnabled("RENDER_FUNCTION" /* RENDER_FUNCTION */, i) &&
                i.render &&
                i.render._compatWrapped) {
                return new Proxy(i.slots, legacySlotProxyHandlers);
            }
            return ( true) ? shallowReadonly(i.slots) : 0;
        },
        $scopedSlots: i => {
            assertCompatEnabled("INSTANCE_SCOPED_SLOTS" /* INSTANCE_SCOPED_SLOTS */, i);
            const res = {};
            for (const key in i.slots) {
                const fn = i.slots[key];
                if (!fn._ns /* non-scoped slot */) {
                    res[key] = fn;
                }
            }
            return res;
        },
        $on: i => on.bind(null, i),
        $once: i => once.bind(null, i),
        $off: i => off.bind(null, i),
        $children: getCompatChildren,
        $listeners: getCompatListeners
    });
    /* istanbul ignore if */
    if (isCompatEnabled("PRIVATE_APIS" /* PRIVATE_APIS */, null)) {
        extend(map, {
            // needed by many libs / render fns
            $vnode: i => i.vnode,
            // inject additional properties into $options for compat
            // e.g. vuex needs this.$options.parent
            $options: i => {
                const res = extend({}, resolveMergedOptions(i));
                res.parent = i.proxy.$parent;
                res.propsData = i.vnode.props;
                return res;
            },
            // some private properties that are likely accessed...
            _self: i => i.proxy,
            _uid: i => i.uid,
            _data: i => i.data,
            _isMounted: i => i.isMounted,
            _isDestroyed: i => i.isUnmounted,
            // v2 render helpers
            $createElement: () => compatH,
            _c: () => compatH,
            _o: () => legacyMarkOnce,
            _n: () => toNumber,
            _s: () => toDisplayString,
            _l: () => renderList,
            _t: i => legacyRenderSlot.bind(null, i),
            _q: () => looseEqual,
            _i: () => looseIndexOf,
            _m: i => legacyRenderStatic.bind(null, i),
            _f: () => resolveFilter,
            _k: i => legacyCheckKeyCodes.bind(null, i),
            _b: () => legacyBindObjectProps,
            _v: () => createTextVNode,
            _e: () => createCommentVNode,
            _u: () => legacyresolveScopedSlots,
            _g: () => legacyBindObjectListeners,
            _d: () => legacyBindDynamicKeys,
            _p: () => legacyPrependModifier
        });
    }
}

/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */
const getPublicInstance = (i) => {
    if (!i)
        return null;
    if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
};
const publicPropertiesMap = 
// Move PURE marker to new line to workaround compiler discarding it
// due to type annotation
/*#__PURE__*/ extend(Object.create(null), {
    $: i => i,
    $el: i => i.vnode.el,
    $data: i => i.data,
    $props: i => (( true) ? shallowReadonly(i.props) : 0),
    $attrs: i => (( true) ? shallowReadonly(i.attrs) : 0),
    $slots: i => (( true) ? shallowReadonly(i.slots) : 0),
    $refs: i => (( true) ? shallowReadonly(i.refs) : 0),
    $parent: i => getPublicInstance(i.parent),
    $root: i => getPublicInstance(i.root),
    $emit: i => i.emit,
    $options: i => ( true ? resolveMergedOptions(i) : 0),
    $forceUpdate: i => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: i => ( true ? instanceWatch.bind(i) : 0)
});
{
    installCompatInstanceProperties(publicPropertiesMap);
}
const isReservedPrefix = (key) => key === '_' || key === '$';
const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        // for internal formatters to know that this is a Vue instance
        if (( true) && key === '__isVue') {
            return true;
        }
        // prioritize <script setup> bindings during dev.
        // this allows even properties that start with _ or $ to be used - so that
        // it aligns with the production behavior where the render fn is inlined and
        // indeed has access to all declared variables.
        if (( true) &&
            setupState !== EMPTY_OBJ &&
            setupState.__isScriptSetup &&
            hasOwn(setupState, key)) {
            return setupState[key];
        }
        // data / props / ctx
        // This getter gets called for every property access on the render context
        // during render and is a major hotspot. The most expensive part of this
        // is the multiple hasOwn() calls. It's much faster to do a simple property
        // access on a plain object, so we use an accessCache object (with null
        // prototype) to memoize what access type a key corresponds to.
        let normalizedProps;
        if (key[0] !== '$') {
            const n = accessCache[key];
            if (n !== undefined) {
                switch (n) {
                    case 1 /* SETUP */:
                        return setupState[key];
                    case 2 /* DATA */:
                        return data[key];
                    case 4 /* CONTEXT */:
                        return ctx[key];
                    case 3 /* PROPS */:
                        return props[key];
                    // default: just fallthrough
                }
            }
            else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
                accessCache[key] = 1 /* SETUP */;
                return setupState[key];
            }
            else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                accessCache[key] = 2 /* DATA */;
                return data[key];
            }
            else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) &&
                hasOwn(normalizedProps, key)) {
                accessCache[key] = 3 /* PROPS */;
                return props[key];
            }
            else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                accessCache[key] = 4 /* CONTEXT */;
                return ctx[key];
            }
            else if ( false || shouldCacheAccess) {
                accessCache[key] = 0 /* OTHER */;
            }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        // public $xxx properties
        if (publicGetter) {
            if (key === '$attrs') {
                track(instance, "get" /* GET */, key);
                ( true) && markAttrsAccessed();
            }
            return publicGetter(instance);
        }
        else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) &&
            (cssModule = cssModule[key])) {
            return cssModule;
        }
        else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            // user may set custom properties to `this` that start with `$`
            accessCache[key] = 4 /* CONTEXT */;
            return ctx[key];
        }
        else if (
        // global properties
        ((globalProperties = appContext.config.globalProperties),
            hasOwn(globalProperties, key))) {
            {
                const desc = Object.getOwnPropertyDescriptor(globalProperties, key);
                if (desc.get) {
                    return desc.get.call(instance.proxy);
                }
                else {
                    const val = globalProperties[key];
                    return isFunction(val)
                        ? Object.assign(val.bind(instance.proxy), val)
                        : val;
                }
            }
        }
        else if (( true) &&
            currentRenderingInstance &&
            (!isString(key) ||
                // #1091 avoid internal isRef/isVNode checks on component instance leading
                // to infinite warning loop
                key.indexOf('__v') !== 0)) {
            if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
                warn$1(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
                    `character ("$" or "_") and is not proxied on the render context.`);
            }
            else if (instance === currentRenderingInstance) {
                warn$1(`Property ${JSON.stringify(key)} was accessed during render ` +
                    `but is not defined on instance.`);
            }
        }
    },
    set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
            setupState[key] = value;
            return true;
        }
        else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            data[key] = value;
            return true;
        }
        else if (hasOwn(instance.props, key)) {
            ( true) &&
                warn$1(`Attempting to mutate prop "${key}". Props are readonly.`, instance);
            return false;
        }
        if (key[0] === '$' && key.slice(1) in instance) {
            ( true) &&
                warn$1(`Attempting to mutate public property "${key}". ` +
                    `Properties starting with $ are reserved and readonly.`, instance);
            return false;
        }
        else {
            if (( true) && key in instance.appContext.config.globalProperties) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    value
                });
            }
            else {
                ctx[key] = value;
            }
        }
        return true;
    },
    has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
        let normalizedProps;
        return (!!accessCache[key] ||
            (data !== EMPTY_OBJ && hasOwn(data, key)) ||
            (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||
            ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||
            hasOwn(ctx, key) ||
            hasOwn(publicPropertiesMap, key) ||
            hasOwn(appContext.config.globalProperties, key));
    },
    defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
            // invalidate key cache of a getter based property #5417
            target._.accessCache[key] = 0;
        }
        else if (hasOwn(descriptor, 'value')) {
            this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
    }
};
if (true) {
    PublicInstanceProxyHandlers.ownKeys = (target) => {
        warn$1(`Avoid app logic that relies on enumerating keys on a component instance. ` +
            `The keys will be empty in production mode to avoid performance overhead.`);
        return Reflect.ownKeys(target);
    };
}
const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend({}, PublicInstanceProxyHandlers, {
    get(target, key) {
        // fast path for unscopables when using `with` block
        if (key === Symbol.unscopables) {
            return;
        }
        return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
        const has = key[0] !== '_' && !isGloballyWhitelisted(key);
        if (( true) && !has && PublicInstanceProxyHandlers.has(_, key)) {
            warn$1(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix for Vue internals.`);
        }
        return has;
    }
});
// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance) {
    const target = {};
    // expose internal instance for proxy handlers
    Object.defineProperty(target, `_`, {
        configurable: true,
        enumerable: false,
        get: () => instance
    });
    // expose public properties
    Object.keys(publicPropertiesMap).forEach(key => {
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: false,
            get: () => publicPropertiesMap[key](instance),
            // intercepted by the proxy so no need for implementation,
            // but needed to prevent set errors
            set: NOOP
        });
    });
    return target;
}
// dev only
function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
        Object.keys(propsOptions).forEach(key => {
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => instance.props[key],
                set: NOOP
            });
        });
    }
}
// dev only
function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach(key => {
        if (!setupState.__isScriptSetup) {
            if (isReservedPrefix(key[0])) {
                warn$1(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" ` +
                    `which are reserved prefixes for Vue internals.`);
                return;
            }
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => setupState[key],
                set: NOOP
            });
        }
    });
}

function deepMergeData(to, from) {
    for (const key in from) {
        const toVal = to[key];
        const fromVal = from[key];
        if (key in to && isPlainObject(toVal) && isPlainObject(fromVal)) {
            ( true) && warnDeprecation("OPTIONS_DATA_MERGE" /* OPTIONS_DATA_MERGE */, null, key);
            deepMergeData(toVal, fromVal);
        }
        else {
            to[key] = fromVal;
        }
    }
    return to;
}

function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type, key) => {
        if (cache[key]) {
            warn$1(`${type} property "${key}" is already defined in ${cache[key]}.`);
        }
        else {
            cache[key] = type;
        }
    };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    // do not cache property access on public proxy during state initialization
    shouldCacheAccess = false;
    // call beforeCreate first before accessing other options since
    // the hook may mutate resolved options (#2791)
    if (options.beforeCreate) {
        callHook(options.beforeCreate, instance, "bc" /* BEFORE_CREATE */);
    }
    const { 
    // state
    data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, 
    // lifecycle
    created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render, renderTracked, renderTriggered, errorCaptured, serverPrefetch, 
    // public API
    expose, inheritAttrs, 
    // assets
    components, directives, filters } = options;
    const checkDuplicateProperties = ( true) ? createDuplicateChecker() : 0;
    if ((true)) {
        const [propsOptions] = instance.propsOptions;
        if (propsOptions) {
            for (const key in propsOptions) {
                checkDuplicateProperties("Props" /* PROPS */, key);
            }
        }
    }
    // options initialization order (to be consistent with Vue 2):
    // - props (already done outside of this function)
    // - inject
    // - methods
    // - data (deferred since it relies on `this` access)
    // - computed
    // - watch (deferred since it relies on `this` access)
    if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
        for (const key in methods) {
            const methodHandler = methods[key];
            if (isFunction(methodHandler)) {
                // In dev mode, we use the `createRenderContext` function to define
                // methods to the proxy target, and those are read-only but
                // reconfigurable, so it needs to be redefined here
                if ((true)) {
                    Object.defineProperty(ctx, key, {
                        value: methodHandler.bind(publicThis),
                        configurable: true,
                        enumerable: true,
                        writable: true
                    });
                }
                else {}
                if ((true)) {
                    checkDuplicateProperties("Methods" /* METHODS */, key);
                }
            }
            else if ((true)) {
                warn$1(`Method "${key}" has type "${typeof methodHandler}" in the component definition. ` +
                    `Did you reference the function correctly?`);
            }
        }
    }
    if (dataOptions) {
        if (( true) && !isFunction(dataOptions)) {
            warn$1(`The data option must be a function. ` +
                `Plain object usage is no longer supported.`);
        }
        const data = dataOptions.call(publicThis, publicThis);
        if (( true) && isPromise(data)) {
            warn$1(`data() returned a Promise - note data() cannot be async; If you ` +
                `intend to perform data fetching before component renders, use ` +
                `async setup() + <Suspense>.`);
        }
        if (!isObject(data)) {
            ( true) && warn$1(`data() should return an object.`);
        }
        else {
            instance.data = reactive(data);
            if ((true)) {
                for (const key in data) {
                    checkDuplicateProperties("Data" /* DATA */, key);
                    // expose data on ctx during dev
                    if (!isReservedPrefix(key[0])) {
                        Object.defineProperty(ctx, key, {
                            configurable: true,
                            enumerable: true,
                            get: () => data[key],
                            set: NOOP
                        });
                    }
                }
            }
        }
    }
    // state initialization complete at this point - start caching access
    shouldCacheAccess = true;
    if (computedOptions) {
        for (const key in computedOptions) {
            const opt = computedOptions[key];
            const get = isFunction(opt)
                ? opt.bind(publicThis, publicThis)
                : isFunction(opt.get)
                    ? opt.get.bind(publicThis, publicThis)
                    : NOOP;
            if (( true) && get === NOOP) {
                warn$1(`Computed property "${key}" has no getter.`);
            }
            const set = !isFunction(opt) && isFunction(opt.set)
                ? opt.set.bind(publicThis)
                : ( true)
                    ? () => {
                        warn$1(`Write operation failed: computed property "${key}" is readonly.`);
                    }
                    : 0;
            const c = computed$1({
                get,
                set
            });
            Object.defineProperty(ctx, key, {
                enumerable: true,
                configurable: true,
                get: () => c.value,
                set: v => (c.value = v)
            });
            if ((true)) {
                checkDuplicateProperties("Computed" /* COMPUTED */, key);
            }
        }
    }
    if (watchOptions) {
        for (const key in watchOptions) {
            createWatcher(watchOptions[key], ctx, publicThis, key);
        }
    }
    if (provideOptions) {
        const provides = isFunction(provideOptions)
            ? provideOptions.call(publicThis)
            : provideOptions;
        Reflect.ownKeys(provides).forEach(key => {
            provide(key, provides[key]);
        });
    }
    if (created) {
        callHook(created, instance, "c" /* CREATED */);
    }
    function registerLifecycleHook(register, hook) {
        if (isArray(hook)) {
            hook.forEach(_hook => register(_hook.bind(publicThis)));
        }
        else if (hook) {
            register(hook.bind(publicThis));
        }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    {
        if (beforeDestroy &&
            softAssertCompatEnabled("OPTIONS_BEFORE_DESTROY" /* OPTIONS_BEFORE_DESTROY */, instance)) {
            registerLifecycleHook(onBeforeUnmount, beforeDestroy);
        }
        if (destroyed &&
            softAssertCompatEnabled("OPTIONS_DESTROYED" /* OPTIONS_DESTROYED */, instance)) {
            registerLifecycleHook(onUnmounted, destroyed);
        }
    }
    if (isArray(expose)) {
        if (expose.length) {
            const exposed = instance.exposed || (instance.exposed = {});
            expose.forEach(key => {
                Object.defineProperty(exposed, key, {
                    get: () => publicThis[key],
                    set: val => (publicThis[key] = val)
                });
            });
        }
        else if (!instance.exposed) {
            instance.exposed = {};
        }
    }
    // options that are handled when creating the instance but also need to be
    // applied from mixins
    if (render && instance.render === NOOP) {
        instance.render = render;
    }
    if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
    }
    // asset options.
    if (components)
        instance.components = components;
    if (directives)
        instance.directives = directives;
    if (filters &&
        isCompatEnabled("FILTERS" /* FILTERS */, instance)) {
        instance.filters = filters;
    }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
    if (isArray(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject(opt)) {
            if ('default' in opt) {
                injected = inject(opt.from || key, opt.default, true /* treat default function as factory */);
            }
            else {
                injected = inject(opt.from || key);
            }
        }
        else {
            injected = inject(opt);
        }
        if (isRef(injected)) {
            // TODO remove the check in 3.3
            if (unwrapRef) {
                Object.defineProperty(ctx, key, {
                    enumerable: true,
                    configurable: true,
                    get: () => injected.value,
                    set: v => (injected.value = v)
                });
            }
            else {
                if ((true)) {
                    warn$1(`injected property "${key}" is a ref and will be auto-unwrapped ` +
                        `and no longer needs \`.value\` in the next minor release. ` +
                        `To opt-in to the new behavior now, ` +
                        `set \`app.config.unwrapInjectedRef = true\` (this config is ` +
                        `temporary and will not be needed in the future.)`);
                }
                ctx[key] = injected;
            }
        }
        else {
            ctx[key] = injected;
        }
        if ((true)) {
            checkDuplicateProperties("Inject" /* INJECT */, key);
        }
    }
}
function callHook(hook, instance, type) {
    callWithAsyncErrorHandling(isArray(hook)
        ? hook.map(h => h.bind(instance.proxy))
        : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes('.')
        ? createPathGetter(publicThis, key)
        : () => publicThis[key];
    if (isString(raw)) {
        const handler = ctx[raw];
        if (isFunction(handler)) {
            watch(getter, handler);
        }
        else if ((true)) {
            warn$1(`Invalid watch handler specified by key "${raw}"`, handler);
        }
    }
    else if (isFunction(raw)) {
        watch(getter, raw.bind(publicThis));
    }
    else if (isObject(raw)) {
        if (isArray(raw)) {
            raw.forEach(r => createWatcher(r, ctx, publicThis, key));
        }
        else {
            const handler = isFunction(raw.handler)
                ? raw.handler.bind(publicThis)
                : ctx[raw.handler];
            if (isFunction(handler)) {
                watch(getter, handler, raw);
            }
            else if ((true)) {
                warn$1(`Invalid watch handler specified by key "${raw.handler}"`, handler);
            }
        }
    }
    else if ((true)) {
        warn$1(`Invalid watch option: "${key}"`, raw);
    }
}
/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */
function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
        resolved = cached;
    }
    else if (!globalMixins.length && !mixins && !extendsOptions) {
        if (isCompatEnabled("PRIVATE_APIS" /* PRIVATE_APIS */, instance)) {
            resolved = extend({}, base);
            resolved.parent = instance.parent && instance.parent.proxy;
            resolved.propsData = instance.vnode.props;
        }
        else {
            resolved = base;
        }
    }
    else {
        resolved = {};
        if (globalMixins.length) {
            globalMixins.forEach(m => mergeOptions(resolved, m, optionMergeStrategies, true));
        }
        mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
    if (isFunction(from)) {
        from = from.options;
    }
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
        mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
        mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key in from) {
        if (asMixin && key === 'expose') {
            ( true) &&
                warn$1(`"expose" option is ignored when declared in mixins or extends. ` +
                    `It should only be declared in the base component itself.`);
        }
        else {
            const strat = internalOptionMergeStrats[key] || (strats && strats[key]);
            to[key] = strat ? strat(to[key], from[key]) : from[key];
        }
    }
    return to;
}
const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeObjectOptions,
    emits: mergeObjectOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
};
{
    internalOptionMergeStrats.filters = mergeObjectOptions;
}
function mergeDataFn(to, from) {
    if (!from) {
        return to;
    }
    if (!to) {
        return from;
    }
    return function mergedDataFn() {
        return (isCompatEnabled("OPTIONS_DATA_MERGE" /* OPTIONS_DATA_MERGE */, null)
            ? deepMergeData
            : extend)(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
    };
}
function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
    if (isArray(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
            res[raw[i]] = raw[i];
        }
        return res;
    }
    return raw;
}
function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
    return to ? extend(extend(Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
    if (!to)
        return from;
    if (!from)
        return to;
    const merged = extend(Object.create(null), to);
    for (const key in from) {
        merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
}

function createPropsDefaultThis(instance, rawProps, propKey) {
    return new Proxy({}, {
        get(_, key) {
            ( true) &&
                warnDeprecation("PROPS_DEFAULT_THIS" /* PROPS_DEFAULT_THIS */, null, propKey);
            // $options
            if (key === '$options') {
                return resolveMergedOptions(instance);
            }
            // props
            if (key in rawProps) {
                return rawProps[key];
            }
            // injections
            const injections = instance.type.inject;
            if (injections) {
                if (isArray(injections)) {
                    if (injections.includes(key)) {
                        return inject(key);
                    }
                }
                else if (key in injections) {
                    return inject(key);
                }
            }
        }
    });
}

function shouldSkipAttr(key, instance) {
    if (key === 'is') {
        return true;
    }
    if ((key === 'class' || key === 'style') &&
        isCompatEnabled("INSTANCE_ATTRS_CLASS_STYLE" /* INSTANCE_ATTRS_CLASS_STYLE */, instance)) {
        return true;
    }
    if (isOn(key) &&
        isCompatEnabled("INSTANCE_LISTENERS" /* INSTANCE_LISTENERS */, instance)) {
        return true;
    }
    // vue-router
    if (key.startsWith('routerView') || key === 'registerRouteInstance') {
        return true;
    }
    return false;
}

function initProps(instance, rawProps, isStateful, // result of bitwise flag comparison
isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    // ensure all declared prop keys are present
    for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
            props[key] = undefined;
        }
    }
    // validation
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
    if (isStateful) {
        // stateful
        instance.props = isSSR ? props : shallowReactive(props);
    }
    else {
        if (!instance.type.props) {
            // functional w/ optional props, props === attrs
            instance.props = attrs;
        }
        else {
            // functional w/ declared props
            instance.props = props;
        }
    }
    instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(( true) &&
        (instance.type.__hmrId ||
            (instance.parent && instance.parent.type.__hmrId))) &&
        (optimized || patchFlag > 0) &&
        !(patchFlag & 16 /* FULL_PROPS */)) {
        if (patchFlag & 8 /* PROPS */) {
            // Compiler-generated props & no keys change, just set the updated
            // the props.
            const propsToUpdate = instance.vnode.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
                let key = propsToUpdate[i];
                // skip if the prop key is a declared emit event listener
                if (isEmitListener(instance.emitsOptions, key)) {
                    continue;
                }
                // PROPS flag guarantees rawProps to be non-null
                const value = rawProps[key];
                if (options) {
                    // attr / props separation was done on init and will be consistent
                    // in this code path, so just check if attrs have it.
                    if (hasOwn(attrs, key)) {
                        if (value !== attrs[key]) {
                            attrs[key] = value;
                            hasAttrsChanged = true;
                        }
                    }
                    else {
                        const camelizedKey = camelize(key);
                        props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false /* isAbsent */);
                    }
                }
                else {
                    {
                        if (isOn(key) && key.endsWith('Native')) {
                            key = key.slice(0, -6); // remove Native postfix
                        }
                        else if (shouldSkipAttr(key, instance)) {
                            continue;
                        }
                    }
                    if (value !== attrs[key]) {
                        attrs[key] = value;
                        hasAttrsChanged = true;
                    }
                }
            }
        }
    }
    else {
        // full props update.
        if (setFullProps(instance, rawProps, props, attrs)) {
            hasAttrsChanged = true;
        }
        // in case of dynamic props, check if we need to delete keys from
        // the props object
        let kebabKey;
        for (const key in rawCurrentProps) {
            if (!rawProps ||
                // for camelCase
                (!hasOwn(rawProps, key) &&
                    // it's possible the original props was passed in as kebab-case
                    // and converted to camelCase (#955)
                    ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))) {
                if (options) {
                    if (rawPrevProps &&
                        // for camelCase
                        (rawPrevProps[key] !== undefined ||
                            // for kebab-case
                            rawPrevProps[kebabKey] !== undefined)) {
                        props[key] = resolvePropValue(options, rawCurrentProps, key, undefined, instance, true /* isAbsent */);
                    }
                }
                else {
                    delete props[key];
                }
            }
        }
        // in the case of functional component w/o props declaration, props and
        // attrs point to the same object so it should already have been updated.
        if (attrs !== rawCurrentProps) {
            for (const key in attrs) {
                if (!rawProps ||
                    (!hasOwn(rawProps, key) &&
                        (!hasOwn(rawProps, key + 'Native')))) {
                    delete attrs[key];
                    hasAttrsChanged = true;
                }
            }
        }
    }
    // trigger updates for $attrs in case it's used in component slots
    if (hasAttrsChanged) {
        trigger(instance, "set" /* SET */, '$attrs');
    }
    if ((true)) {
        validateProps(rawProps || {}, props, instance);
    }
}
function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
        for (let key in rawProps) {
            // key, ref are reserved and never passed down
            if (isReservedProp(key)) {
                continue;
            }
            {
                if (key.startsWith('onHook:')) {
                    softAssertCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance, key.slice(2).toLowerCase());
                }
                if (key === 'inline-template') {
                    continue;
                }
            }
            const value = rawProps[key];
            // prop option names are camelized during normalization, so to support
            // kebab -> camel conversion here we need to camelize the key.
            let camelKey;
            if (options && hasOwn(options, (camelKey = camelize(key)))) {
                if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                    props[camelKey] = value;
                }
                else {
                    (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                }
            }
            else if (!isEmitListener(instance.emitsOptions, key)) {
                // Any non-declared (either as a prop or an emitted event) props are put
                // into a separate `attrs` object for spreading. Make sure to preserve
                // original key casing
                {
                    if (isOn(key) && key.endsWith('Native')) {
                        key = key.slice(0, -6); // remove Native postfix
                    }
                    else if (shouldSkipAttr(key, instance)) {
                        continue;
                    }
                }
                if (!(key in attrs) || value !== attrs[key]) {
                    attrs[key] = value;
                    hasAttrsChanged = true;
                }
            }
        }
    }
    if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
            const key = needCastKeys[i];
            props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
        }
    }
    return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
        const hasDefault = hasOwn(opt, 'default');
        // default values
        if (hasDefault && value === undefined) {
            const defaultValue = opt.default;
            if (opt.type !== Function && isFunction(defaultValue)) {
                const { propsDefaults } = instance;
                if (key in propsDefaults) {
                    value = propsDefaults[key];
                }
                else {
                    setCurrentInstance(instance);
                    value = propsDefaults[key] = defaultValue.call(isCompatEnabled("PROPS_DEFAULT_THIS" /* PROPS_DEFAULT_THIS */, instance)
                        ? createPropsDefaultThis(instance, props, key)
                        : null, props);
                    unsetCurrentInstance();
                }
            }
            else {
                value = defaultValue;
            }
        }
        // boolean casting
        if (opt[0 /* shouldCast */]) {
            if (isAbsent && !hasDefault) {
                value = false;
            }
            else if (opt[1 /* shouldCastTrue */] &&
                (value === '' || value === hyphenate(key))) {
                value = true;
            }
        }
    }
    return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
        return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    // apply mixin/extends props
    let hasExtends = false;
    if ( true && !isFunction(comp)) {
        const extendProps = (raw) => {
            if (isFunction(raw)) {
                raw = raw.options;
            }
            hasExtends = true;
            const [props, keys] = normalizePropsOptions(raw, appContext, true);
            extend(normalized, props);
            if (keys)
                needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
            appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
            extendProps(comp.extends);
        }
        if (comp.mixins) {
            comp.mixins.forEach(extendProps);
        }
    }
    if (!raw && !hasExtends) {
        cache.set(comp, EMPTY_ARR);
        return EMPTY_ARR;
    }
    if (isArray(raw)) {
        for (let i = 0; i < raw.length; i++) {
            if (( true) && !isString(raw[i])) {
                warn$1(`props must be strings when using array syntax.`, raw[i]);
            }
            const normalizedKey = camelize(raw[i]);
            if (validatePropName(normalizedKey)) {
                normalized[normalizedKey] = EMPTY_OBJ;
            }
        }
    }
    else if (raw) {
        if (( true) && !isObject(raw)) {
            warn$1(`invalid props options`, raw);
        }
        for (const key in raw) {
            const normalizedKey = camelize(key);
            if (validatePropName(normalizedKey)) {
                const opt = raw[key];
                const prop = (normalized[normalizedKey] =
                    isArray(opt) || isFunction(opt) ? { type: opt } : opt);
                if (prop) {
                    const booleanIndex = getTypeIndex(Boolean, prop.type);
                    const stringIndex = getTypeIndex(String, prop.type);
                    prop[0 /* shouldCast */] = booleanIndex > -1;
                    prop[1 /* shouldCastTrue */] =
                        stringIndex < 0 || booleanIndex < stringIndex;
                    // if the prop needs boolean casting or default value
                    if (booleanIndex > -1 || hasOwn(prop, 'default')) {
                        needCastKeys.push(normalizedKey);
                    }
                }
            }
        }
    }
    const res = [normalized, needCastKeys];
    cache.set(comp, res);
    return res;
}
function validatePropName(key) {
    if (key[0] !== '$') {
        return true;
    }
    else if ((true)) {
        warn$1(`Invalid prop name: "${key}" is a reserved property.`);
    }
    return false;
}
// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? 'null' : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (isArray(expectedTypes)) {
        return expectedTypes.findIndex(t => isSameType(t, type));
    }
    else if (isFunction(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
}
/**
 * dev only
 */
function validateProps(rawProps, props, instance) {
    const resolvedValues = toRaw(props);
    const options = instance.propsOptions[0];
    for (const key in options) {
        let opt = options[key];
        if (opt == null)
            continue;
        validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
    }
}
/**
 * dev only
 */
function validateProp(name, value, prop, isAbsent) {
    const { type, required, validator } = prop;
    // required!
    if (required && isAbsent) {
        warn$1('Missing required prop: "' + name + '"');
        return;
    }
    // missing but optional
    if (value == null && !prop.required) {
        return;
    }
    // type check
    if (type != null && type !== true) {
        let isValid = false;
        const types = isArray(type) ? type : [type];
        const expectedTypes = [];
        // value is valid as long as one of the specified types match
        for (let i = 0; i < types.length && !isValid; i++) {
            const { valid, expectedType } = assertType(value, types[i]);
            expectedTypes.push(expectedType || '');
            isValid = valid;
        }
        if (!isValid) {
            warn$1(getInvalidTypeMessage(name, value, expectedTypes));
            return;
        }
    }
    // custom validator
    if (validator && !validator(value)) {
        warn$1('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
}
const isSimpleType = /*#__PURE__*/ makeMap('String,Number,Boolean,Function,Symbol,BigInt');
/**
 * dev only
 */
function assertType(value, type) {
    let valid;
    const expectedType = getType(type);
    if (isSimpleType(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = isObject(value);
    }
    else if (expectedType === 'Array') {
        valid = isArray(value);
    }
    else if (expectedType === 'null') {
        valid = value === null;
    }
    else {
        valid = value instanceof type;
    }
    return {
        valid,
        expectedType
    };
}
/**
 * dev only
 */
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(capitalize).join(' | ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    const expectedValue = styleValue(value, expectedType);
    const receivedValue = styleValue(value, receivedType);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${receivedValue}.`;
    }
    return message;
}
/**
 * dev only
 */
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
/**
 * dev only
 */
function isExplicable(type) {
    const explicitTypes = ['string', 'number', 'boolean'];
    return explicitTypes.some(elem => type.toLowerCase() === elem);
}
/**
 * dev only
 */
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

const isInternalKey = (key) => key[0] === '_' || key === '$stable';
const normalizeSlotValue = (value) => isArray(value)
    ? value.map(normalizeVNode)
    : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
        // already normalized - #5353
        return rawSlot;
    }
    const normalized = withCtx((...args) => {
        if (( true) && currentInstance) {
            warn$1(`Slot "${key}" invoked outside of the render function: ` +
                `this will not track dependencies used in the slot. ` +
                `Invoke the slot function inside the render function instead.`);
        }
        return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
        if (isInternalKey(key))
            continue;
        const value = rawSlots[key];
        if (isFunction(value)) {
            slots[key] = normalizeSlot(key, value, ctx);
        }
        else if (value != null) {
            if (( true) &&
                !(isCompatEnabled("RENDER_FUNCTION" /* RENDER_FUNCTION */, instance))) {
                warn$1(`Non-function value encountered for slot "${key}". ` +
                    `Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value);
            slots[key] = () => normalized;
        }
    }
};
const normalizeVNodeSlots = (instance, children) => {
    if (( true) &&
        !isKeepAlive(instance.vnode) &&
        !(isCompatEnabled("RENDER_FUNCTION" /* RENDER_FUNCTION */, instance))) {
        warn$1(`Non-function value encountered for default slot. ` +
            `Prefer function slots for better performance.`);
    }
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // users can get the shallow readonly version of the slots object through `this.$slots`,
            // we should avoid the proxy object polluting the slots of the internal instance
            instance.slots = toRaw(children);
            // make compiler marker non-enumerable
            def(children, '_', type);
        }
        else {
            normalizeObjectSlots(children, (instance.slots = {}), instance);
        }
    }
    else {
        instance.slots = {};
        if (children) {
            normalizeVNodeSlots(instance, children);
        }
    }
    def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32 /* SLOTS_CHILDREN */) {
        const type = children._;
        if (type) {
            // compiled slots.
            if (( true) && isHmrUpdating) {
                // Parent was HMR updated so slot content may have changed.
                // force update slots and mark instance for hmr as well
                extend(slots, children);
            }
            else if (optimized && type === 1 /* STABLE */) {
                // compiled AND stable.
                // no need to update, and skip stale slots removal.
                needDeletionCheck = false;
            }
            else {
                // compiled but dynamic (v-if/v-for on slots) - update slots, but skip
                // normalization.
                extend(slots, children);
                // #2893
                // when rendering the optimized slots by manually written render function,
                // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
                // i.e. let the `renderSlot` create the bailed Fragment
                if (!optimized && type === 1 /* STABLE */) {
                    delete slots._;
                }
            }
        }
        else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots, instance);
        }
        deletionComparisonTarget = children;
    }
    else if (children) {
        // non slot object children (direct value) passed to a component
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
    }
    // delete stale slots
    if (needDeletionCheck) {
        for (const key in slots) {
            if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
                delete slots[key];
            }
        }
    }
};

// dev only
function installLegacyConfigWarnings(config) {
    const legacyConfigOptions = {
        silent: "CONFIG_SILENT" /* CONFIG_SILENT */,
        devtools: "CONFIG_DEVTOOLS" /* CONFIG_DEVTOOLS */,
        ignoredElements: "CONFIG_IGNORED_ELEMENTS" /* CONFIG_IGNORED_ELEMENTS */,
        keyCodes: "CONFIG_KEY_CODES" /* CONFIG_KEY_CODES */,
        productionTip: "CONFIG_PRODUCTION_TIP" /* CONFIG_PRODUCTION_TIP */
    };
    Object.keys(legacyConfigOptions).forEach(key => {
        let val = config[key];
        Object.defineProperty(config, key, {
            enumerable: true,
            get() {
                return val;
            },
            set(newVal) {
                if (!isCopyingConfig) {
                    warnDeprecation(legacyConfigOptions[key], null);
                }
                val = newVal;
            }
        });
    });
}
function installLegacyOptionMergeStrats(config) {
    config.optionMergeStrategies = new Proxy({}, {
        get(target, key) {
            if (key in target) {
                return target[key];
            }
            if (key in internalOptionMergeStrats &&
                softAssertCompatEnabled("CONFIG_OPTION_MERGE_STRATS" /* CONFIG_OPTION_MERGE_STRATS */, null)) {
                return internalOptionMergeStrats[key];
            }
        }
    });
}

let isCopyingConfig = false;
// exported only for test
let singletonApp;
let singletonCtor;
// Legacy global Vue constructor
function createCompatVue(createApp, createSingletonApp) {
    singletonApp = createSingletonApp({});
    const Vue = (singletonCtor = function Vue(options = {}) {
        return createCompatApp(options, Vue);
    });
    function createCompatApp(options = {}, Ctor) {
        assertCompatEnabled("GLOBAL_MOUNT" /* GLOBAL_MOUNT */, null);
        const { data } = options;
        if (data &&
            !isFunction(data) &&
            softAssertCompatEnabled("OPTIONS_DATA_FN" /* OPTIONS_DATA_FN */, null)) {
            options.data = () => data;
        }
        const app = createApp(options);
        if (Ctor !== Vue) {
            applySingletonPrototype(app, Ctor);
        }
        const vm = app._createRoot(options);
        if (options.el) {
            return vm.$mount(options.el);
        }
        else {
            return vm;
        }
    }
    Vue.version = `2.6.14-compat:${"3.2.37"}`;
    Vue.config = singletonApp.config;
    Vue.use = (p, ...options) => {
        if (p && isFunction(p.install)) {
            p.install(Vue, ...options);
        }
        else if (isFunction(p)) {
            p(Vue, ...options);
        }
        return Vue;
    };
    Vue.mixin = m => {
        singletonApp.mixin(m);
        return Vue;
    };
    Vue.component = ((name, comp) => {
        if (comp) {
            singletonApp.component(name, comp);
            return Vue;
        }
        else {
            return singletonApp.component(name);
        }
    });
    Vue.directive = ((name, dir) => {
        if (dir) {
            singletonApp.directive(name, dir);
            return Vue;
        }
        else {
            return singletonApp.directive(name);
        }
    });
    Vue.options = { _base: Vue };
    let cid = 1;
    Vue.cid = cid;
    Vue.nextTick = nextTick;
    const extendCache = new WeakMap();
    function extendCtor(extendOptions = {}) {
        assertCompatEnabled("GLOBAL_EXTEND" /* GLOBAL_EXTEND */, null);
        if (isFunction(extendOptions)) {
            extendOptions = extendOptions.options;
        }
        if (extendCache.has(extendOptions)) {
            return extendCache.get(extendOptions);
        }
        const Super = this;
        function SubVue(inlineOptions) {
            if (!inlineOptions) {
                return createCompatApp(SubVue.options, SubVue);
            }
            else {
                return createCompatApp(mergeOptions(extend({}, SubVue.options), inlineOptions, internalOptionMergeStrats), SubVue);
            }
        }
        SubVue.super = Super;
        SubVue.prototype = Object.create(Vue.prototype);
        SubVue.prototype.constructor = SubVue;
        // clone non-primitive base option values for edge case of mutating
        // extended options
        const mergeBase = {};
        for (const key in Super.options) {
            const superValue = Super.options[key];
            mergeBase[key] = isArray(superValue)
                ? superValue.slice()
                : isObject(superValue)
                    ? extend(Object.create(null), superValue)
                    : superValue;
        }
        SubVue.options = mergeOptions(mergeBase, extendOptions, internalOptionMergeStrats);
        SubVue.options._base = SubVue;
        SubVue.extend = extendCtor.bind(SubVue);
        SubVue.mixin = Super.mixin;
        SubVue.use = Super.use;
        SubVue.cid = ++cid;
        extendCache.set(extendOptions, SubVue);
        return SubVue;
    }
    Vue.extend = extendCtor.bind(Vue);
    Vue.set = (target, key, value) => {
        assertCompatEnabled("GLOBAL_SET" /* GLOBAL_SET */, null);
        target[key] = value;
    };
    Vue.delete = (target, key) => {
        assertCompatEnabled("GLOBAL_DELETE" /* GLOBAL_DELETE */, null);
        delete target[key];
    };
    Vue.observable = (target) => {
        assertCompatEnabled("GLOBAL_OBSERVABLE" /* GLOBAL_OBSERVABLE */, null);
        return reactive(target);
    };
    Vue.filter = ((name, filter) => {
        if (filter) {
            singletonApp.filter(name, filter);
            return Vue;
        }
        else {
            return singletonApp.filter(name);
        }
    });
    // internal utils - these are technically internal but some plugins use it.
    const util = {
        warn: ( true) ? warn$1 : 0,
        extend,
        mergeOptions: (parent, child, vm) => mergeOptions(parent, child, vm ? undefined : internalOptionMergeStrats),
        defineReactive
    };
    Object.defineProperty(Vue, 'util', {
        get() {
            assertCompatEnabled("GLOBAL_PRIVATE_UTIL" /* GLOBAL_PRIVATE_UTIL */, null);
            return util;
        }
    });
    Vue.configureCompat = configureCompat;
    return Vue;
}
function installAppCompatProperties(app, context, render) {
    installFilterMethod(app, context);
    installLegacyOptionMergeStrats(app.config);
    if (!singletonApp) {
        // this is the call of creating the singleton itself so the rest is
        // unnecessary
        return;
    }
    installCompatMount(app, context, render);
    installLegacyAPIs(app);
    applySingletonAppMutations(app);
    if ((true))
        installLegacyConfigWarnings(app.config);
}
function installFilterMethod(app, context) {
    context.filters = {};
    app.filter = (name, filter) => {
        assertCompatEnabled("FILTERS" /* FILTERS */, null);
        if (!filter) {
            return context.filters[name];
        }
        if (( true) && context.filters[name]) {
            warn$1(`Filter "${name}" has already been registered.`);
        }
        context.filters[name] = filter;
        return app;
    };
}
function installLegacyAPIs(app) {
    // expose global API on app instance for legacy plugins
    Object.defineProperties(app, {
        // so that app.use() can work with legacy plugins that extend prototypes
        prototype: {
            get() {
                ( true) && warnDeprecation("GLOBAL_PROTOTYPE" /* GLOBAL_PROTOTYPE */, null);
                return app.config.globalProperties;
            }
        },
        nextTick: { value: nextTick },
        extend: { value: singletonCtor.extend },
        set: { value: singletonCtor.set },
        delete: { value: singletonCtor.delete },
        observable: { value: singletonCtor.observable },
        util: {
            get() {
                return singletonCtor.util;
            }
        }
    });
}
function applySingletonAppMutations(app) {
    // copy over asset registries and deopt flag
    app._context.mixins = [...singletonApp._context.mixins];
    ['components', 'directives', 'filters'].forEach(key => {
        // @ts-ignore
        app._context[key] = Object.create(singletonApp._context[key]);
    });
    // copy over global config mutations
    isCopyingConfig = true;
    for (const key in singletonApp.config) {
        if (key === 'isNativeTag')
            continue;
        if (isRuntimeOnly() &&
            (key === 'isCustomElement' || key === 'compilerOptions')) {
            continue;
        }
        const val = singletonApp.config[key];
        // @ts-ignore
        app.config[key] = isObject(val) ? Object.create(val) : val;
        // compat for runtime ignoredElements -> isCustomElement
        if (key === 'ignoredElements' &&
            isCompatEnabled("CONFIG_IGNORED_ELEMENTS" /* CONFIG_IGNORED_ELEMENTS */, null) &&
            !isRuntimeOnly() &&
            isArray(val)) {
            app.config.compilerOptions.isCustomElement = tag => {
                return val.some(v => (isString(v) ? v === tag : v.test(tag)));
            };
        }
    }
    isCopyingConfig = false;
    applySingletonPrototype(app, singletonCtor);
}
function applySingletonPrototype(app, Ctor) {
    // copy prototype augmentations as config.globalProperties
    const enabled = isCompatEnabled("GLOBAL_PROTOTYPE" /* GLOBAL_PROTOTYPE */, null);
    if (enabled) {
        app.config.globalProperties = Object.create(Ctor.prototype);
    }
    let hasPrototypeAugmentations = false;
    const descriptors = Object.getOwnPropertyDescriptors(Ctor.prototype);
    for (const key in descriptors) {
        if (key !== 'constructor') {
            hasPrototypeAugmentations = true;
            if (enabled) {
                Object.defineProperty(app.config.globalProperties, key, descriptors[key]);
            }
        }
    }
    if (( true) && hasPrototypeAugmentations) {
        warnDeprecation("GLOBAL_PROTOTYPE" /* GLOBAL_PROTOTYPE */, null);
    }
}
function installCompatMount(app, context, render) {
    let isMounted = false;
    /**
     * Vue 2 supports the behavior of creating a component instance but not
     * mounting it, which is no longer possible in Vue 3 - this internal
     * function simulates that behavior.
     */
    app._createRoot = options => {
        const component = app._component;
        const vnode = createVNode(component, options.propsData || null);
        vnode.appContext = context;
        const hasNoRender = !isFunction(component) && !component.render && !component.template;
        const emptyRender = () => { };
        // create root instance
        const instance = createComponentInstance(vnode, null, null);
        // suppress "missing render fn" warning since it can't be determined
        // until $mount is called
        if (hasNoRender) {
            instance.render = emptyRender;
        }
        setupComponent(instance);
        vnode.component = instance;
        vnode.isCompatRoot = true;
        // $mount & $destroy
        // these are defined on ctx and picked up by the $mount/$destroy
        // public property getters on the instance proxy.
        // Note: the following assumes DOM environment since the compat build
        // only targets web. It essentially includes logic for app.mount from
        // both runtime-core AND runtime-dom.
        instance.ctx._compat_mount = (selectorOrEl) => {
            if (isMounted) {
                ( true) && warn$1(`Root instance is already mounted.`);
                return;
            }
            let container;
            if (typeof selectorOrEl === 'string') {
                // eslint-disable-next-line
                const result = document.querySelector(selectorOrEl);
                if (!result) {
                    ( true) &&
                        warn$1(`Failed to mount root instance: selector "${selectorOrEl}" returned null.`);
                    return;
                }
                container = result;
            }
            else {
                // eslint-disable-next-line
                container = selectorOrEl || document.createElement('div');
            }
            const isSVG = container instanceof SVGElement;
            // HMR root reload
            if ((true)) {
                context.reload = () => {
                    const cloned = cloneVNode(vnode);
                    // compat mode will use instance if not reset to null
                    cloned.component = null;
                    render(cloned, container, isSVG);
                };
            }
            // resolve in-DOM template if component did not provide render
            // and no setup/mixin render functions are provided (by checking
            // that the instance is still using the placeholder render fn)
            if (hasNoRender && instance.render === emptyRender) {
                // root directives check
                if ((true)) {
                    for (let i = 0; i < container.attributes.length; i++) {
                        const attr = container.attributes[i];
                        if (attr.name !== 'v-cloak' && /^(v-|:|@)/.test(attr.name)) {
                            warnDeprecation("GLOBAL_MOUNT_CONTAINER" /* GLOBAL_MOUNT_CONTAINER */, null);
                            break;
                        }
                    }
                }
                instance.render = null;
                component.template = container.innerHTML;
                finishComponentSetup(instance, false, true /* skip options */);
            }
            // clear content before mounting
            container.innerHTML = '';
            // TODO hydration
            render(vnode, container, isSVG);
            if (container instanceof Element) {
                container.removeAttribute('v-cloak');
                container.setAttribute('data-v-app', '');
            }
            isMounted = true;
            app._container = container;
            container.__vue_app__ = app;
            if (true) {
                devtoolsInitApp(app, version);
            }
            return instance.proxy;
        };
        instance.ctx._compat_destroy = () => {
            if (isMounted) {
                render(null, app._container);
                if (true) {
                    devtoolsUnmountApp(app);
                }
                delete app._container.__vue_app__;
            }
            else {
                const { bum, scope, um } = instance;
                // beforeDestroy hooks
                if (bum) {
                    invokeArrayFns(bum);
                }
                if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
                    instance.emit('hook:beforeDestroy');
                }
                // stop effects
                if (scope) {
                    scope.stop();
                }
                // unmounted hook
                if (um) {
                    invokeArrayFns(um);
                }
                if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
                    instance.emit('hook:destroyed');
                }
            }
        };
        return instance.proxy;
    };
}
const methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
const patched = new WeakSet();
function defineReactive(obj, key, val) {
    // it's possible for the original object to be mutated after being defined
    // and expecting reactivity... we are covering it here because this seems to
    // be a bit more common.
    if (isObject(val) && !isReactive(val) && !patched.has(val)) {
        const reactiveVal = reactive(val);
        if (isArray(val)) {
            methodsToPatch.forEach(m => {
                // @ts-ignore
                val[m] = (...args) => {
                    // @ts-ignore
                    Array.prototype[m].call(reactiveVal, ...args);
                };
            });
        }
        else {
            Object.keys(val).forEach(key => {
                try {
                    defineReactiveSimple(val, key, val[key]);
                }
                catch (e) { }
            });
        }
    }
    const i = obj.$;
    if (i && obj === i.proxy) {
        // target is a Vue instance - define on instance.ctx
        defineReactiveSimple(i.ctx, key, val);
        i.accessCache = Object.create(null);
    }
    else if (isReactive(obj)) {
        obj[key] = val;
    }
    else {
        defineReactiveSimple(obj, key, val);
    }
}
function defineReactiveSimple(obj, key, val) {
    val = isObject(val) ? reactive(val) : val;
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get() {
            track(obj, "get" /* GET */, key);
            return val;
        },
        set(newVal) {
            val = isObject(newVal) ? reactive(newVal) : newVal;
            trigger(obj, "set" /* SET */, key, newVal);
        }
    });
}

function createAppContext() {
    return {
        app: null,
        config: {
            isNativeTag: NO,
            performance: false,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: undefined,
            warnHandler: undefined,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap(),
        propsCache: new WeakMap(),
        emitsCache: new WeakMap()
    };
}
let uid = 0;
function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
        if (!isFunction(rootComponent)) {
            rootComponent = Object.assign({}, rootComponent);
        }
        if (rootProps != null && !isObject(rootProps)) {
            ( true) && warn$1(`root props passed to app.mount() must be an object.`);
            rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = new Set();
        let isMounted = false;
        const app = (context.app = {
            _uid: uid++,
            _component: rootComponent,
            _props: rootProps,
            _container: null,
            _context: context,
            _instance: null,
            version,
            get config() {
                return context.config;
            },
            set config(v) {
                if ((true)) {
                    warn$1(`app.config cannot be replaced. Modify individual options instead.`);
                }
            },
            use(plugin, ...options) {
                if (installedPlugins.has(plugin)) {
                    ( true) && warn$1(`Plugin has already been applied to target app.`);
                }
                else if (plugin && isFunction(plugin.install)) {
                    installedPlugins.add(plugin);
                    plugin.install(app, ...options);
                }
                else if (isFunction(plugin)) {
                    installedPlugins.add(plugin);
                    plugin(app, ...options);
                }
                else if ((true)) {
                    warn$1(`A plugin must either be a function or an object with an "install" ` +
                        `function.`);
                }
                return app;
            },
            mixin(mixin) {
                if (true) {
                    if (!context.mixins.includes(mixin)) {
                        context.mixins.push(mixin);
                    }
                    else if ((true)) {
                        warn$1('Mixin has already been applied to target app' +
                            (mixin.name ? `: ${mixin.name}` : ''));
                    }
                }
                else {}
                return app;
            },
            component(name, component) {
                if ((true)) {
                    validateComponentName(name, context.config);
                }
                if (!component) {
                    return context.components[name];
                }
                if (( true) && context.components[name]) {
                    warn$1(`Component "${name}" has already been registered in target app.`);
                }
                context.components[name] = component;
                return app;
            },
            directive(name, directive) {
                if ((true)) {
                    validateDirectiveName(name);
                }
                if (!directive) {
                    return context.directives[name];
                }
                if (( true) && context.directives[name]) {
                    warn$1(`Directive "${name}" has already been registered in target app.`);
                }
                context.directives[name] = directive;
                return app;
            },
            mount(rootContainer, isHydrate, isSVG) {
                if (!isMounted) {
                    // #5571
                    if (( true) && rootContainer.__vue_app__) {
                        warn$1(`There is already an app instance mounted on the host container.\n` +
                            ` If you want to mount another app on the same host container,` +
                            ` you need to unmount the previous app by calling \`app.unmount()\` first.`);
                    }
                    const vnode = createVNode(rootComponent, rootProps);
                    // store app context on the root VNode.
                    // this will be set on the root instance on initial mount.
                    vnode.appContext = context;
                    // HMR root reload
                    if ((true)) {
                        context.reload = () => {
                            render(cloneVNode(vnode), rootContainer, isSVG);
                        };
                    }
                    if (isHydrate && hydrate) {
                        hydrate(vnode, rootContainer);
                    }
                    else {
                        render(vnode, rootContainer, isSVG);
                    }
                    isMounted = true;
                    app._container = rootContainer;
                    rootContainer.__vue_app__ = app;
                    if (true) {
                        app._instance = vnode.component;
                        devtoolsInitApp(app, version);
                    }
                    return getExposeProxy(vnode.component) || vnode.component.proxy;
                }
                else if ((true)) {
                    warn$1(`App has already been mounted.\n` +
                        `If you want to remount the same app, move your app creation logic ` +
                        `into a factory function and create fresh app instances for each ` +
                        `mount - e.g. \`const createMyApp = () => createApp(App)\``);
                }
            },
            unmount() {
                if (isMounted) {
                    render(null, app._container);
                    if (true) {
                        app._instance = null;
                        devtoolsUnmountApp(app);
                    }
                    delete app._container.__vue_app__;
                }
                else if ((true)) {
                    warn$1(`Cannot unmount an app that is not mounted.`);
                }
            },
            provide(key, value) {
                if (( true) && key in context.provides) {
                    warn$1(`App already provides property with key "${String(key)}". ` +
                        `It will be overwritten with the new value.`);
                }
                context.provides[key] = value;
                return app;
            }
        });
        {
            installAppCompatProperties(app, context, render);
        }
        return app;
    };
}

/**
 * Function for handling a template ref
 */
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
        rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
        return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
        // when mounting async components, nothing needs to be done,
        // because the template ref is forwarded to inner component
        return;
    }
    const refValue = vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */
        ? getExposeProxy(vnode.component) || vnode.component.proxy
        : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    if (( true) && !owner) {
        warn$1(`Missing ref owner context. ref cannot be used on hoisted vnodes. ` +
            `A vnode with ref must be created inside the render function.`);
        return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs;
    const setupState = owner.setupState;
    // dynamic ref changed. unset old ref
    if (oldRef != null && oldRef !== ref) {
        if (isString(oldRef)) {
            refs[oldRef] = null;
            if (hasOwn(setupState, oldRef)) {
                setupState[oldRef] = null;
            }
        }
        else if (isRef(oldRef)) {
            oldRef.value = null;
        }
    }
    if (isFunction(ref)) {
        callWithErrorHandling(ref, owner, 12 /* FUNCTION_REF */, [value, refs]);
    }
    else {
        const _isString = isString(ref);
        const _isRef = isRef(ref);
        if (_isString || _isRef) {
            const doSet = () => {
                if (rawRef.f) {
                    const existing = _isString ? refs[ref] : ref.value;
                    if (isUnmount) {
                        isArray(existing) && remove(existing, refValue);
                    }
                    else {
                        if (!isArray(existing)) {
                            if (_isString) {
                                refs[ref] = [refValue];
                                if (hasOwn(setupState, ref)) {
                                    setupState[ref] = refs[ref];
                                }
                            }
                            else {
                                ref.value = [refValue];
                                if (rawRef.k)
                                    refs[rawRef.k] = ref.value;
                            }
                        }
                        else if (!existing.includes(refValue)) {
                            existing.push(refValue);
                        }
                    }
                }
                else if (_isString) {
                    refs[ref] = value;
                    if (hasOwn(setupState, ref)) {
                        setupState[ref] = value;
                    }
                }
                else if (_isRef) {
                    ref.value = value;
                    if (rawRef.k)
                        refs[rawRef.k] = value;
                }
                else if ((true)) {
                    warn$1('Invalid template ref type:', ref, `(${typeof ref})`);
                }
            };
            if (value) {
                doSet.id = -1;
                queuePostRenderEffect(doSet, parentSuspense);
            }
            else {
                doSet();
            }
        }
        else if ((true)) {
            warn$1('Invalid template ref type:', ref, `(${typeof ref})`);
        }
    }
}

let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== 'foreignObject';
const isComment = (node) => node.nodeType === 8 /* COMMENT */;
// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp, createText, nextSibling, parentNode, remove, insert, createComment } } = rendererInternals;
    const hydrate = (vnode, container) => {
        if (!container.hasChildNodes()) {
            ( true) &&
                warn$1(`Attempting to hydrate existing markup but container is empty. ` +
                    `Performing full mount instead.`);
            patch(null, vnode, container);
            flushPostFlushCbs();
            container._vnode = vnode;
            return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && !false) {
            // this error should show up in production
            console.error(`Hydration completed but contains mismatches.`);
        }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        const isFragmentStart = isComment(node) && node.data === '[';
        const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
        const { type, ref, shapeFlag, patchFlag } = vnode;
        const domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2 /* BAIL */) {
            optimized = false;
            vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch (type) {
            case Text:
                if (domType !== 3 /* TEXT */) {
                    // #5728 empty text node inside a slot can cause hydration failure
                    // because the server rendered HTML won't contain a text node
                    if (vnode.children === '') {
                        insert((vnode.el = createText('')), parentNode(node), node);
                        nextNode = node;
                    }
                    else {
                        nextNode = onMismatch();
                    }
                }
                else {
                    if (node.data !== vnode.children) {
                        hasMismatch = true;
                        ( true) &&
                            warn$1(`Hydration text mismatch:` +
                                `\n- Client: ${JSON.stringify(node.data)}` +
                                `\n- Server: ${JSON.stringify(vnode.children)}`);
                        node.data = vnode.children;
                    }
                    nextNode = nextSibling(node);
                }
                break;
            case Comment:
                if (domType !== 8 /* COMMENT */ || isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = nextSibling(node);
                }
                break;
            case Static:
                if (domType !== 1 /* ELEMENT */ && domType !== 3 /* TEXT */) {
                    nextNode = onMismatch();
                }
                else {
                    // determine anchor, adopt content
                    nextNode = node;
                    // if the static vnode has its content stripped during build,
                    // adopt it from the server-rendered HTML.
                    const needToAdoptContent = !vnode.children.length;
                    for (let i = 0; i < vnode.staticCount; i++) {
                        if (needToAdoptContent)
                            vnode.children +=
                                nextNode.nodeType === 1 /* ELEMENT */
                                    ? nextNode.outerHTML
                                    : nextNode.data;
                        if (i === vnode.staticCount - 1) {
                            vnode.anchor = nextNode;
                        }
                        nextNode = nextSibling(nextNode);
                    }
                    return nextNode;
                }
                break;
            case Fragment:
                if (!isFragmentStart) {
                    nextNode = onMismatch();
                }
                else {
                    nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                }
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    if (domType !== 1 /* ELEMENT */ ||
                        vnode.type.toLowerCase() !==
                            node.tagName.toLowerCase()) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
                    }
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    // when setting up the render effect, if the initial vnode already
                    // has .el set, the component will perform hydration instead of mount
                    // on its sub-tree.
                    vnode.slotScopeIds = slotScopeIds;
                    const container = parentNode(node);
                    mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
                    // component may be async, so in the case of fragments we cannot rely
                    // on component's rendered output to determine the end of the fragment
                    // instead, we do a lookahead to find the end anchor node.
                    nextNode = isFragmentStart
                        ? locateClosingAsyncAnchor(node)
                        : nextSibling(node);
                    // #4293 teleport as component root
                    if (nextNode &&
                        isComment(nextNode) &&
                        nextNode.data === 'teleport end') {
                        nextNode = nextSibling(nextNode);
                    }
                    // #3787
                    // if component is async, it may get moved / unmounted before its
                    // inner component is loaded, so we need to give it a placeholder
                    // vnode that matches its adopted DOM.
                    if (isAsyncWrapper(vnode)) {
                        let subTree;
                        if (isFragmentStart) {
                            subTree = createVNode(Fragment);
                            subTree.anchor = nextNode
                                ? nextNode.previousSibling
                                : container.lastChild;
                        }
                        else {
                            subTree =
                                node.nodeType === 3 ? createTextVNode('') : createVNode('div');
                        }
                        subTree.el = node;
                        vnode.component.subTree = subTree;
                    }
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    if (domType !== 8 /* COMMENT */) {
                        nextNode = onMismatch();
                    }
                    else {
                        nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
                    }
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
                }
                else if ((true)) {
                    warn$1('Invalid HostVNode type:', type, `(${typeof type})`);
                }
        }
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode);
        }
        return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs } = vnode;
        // #4006 for form elements with non-string v-model value bindings
        // e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
        const forcePatchValue = (type === 'input' && dirs) || type === 'option';
        // skip props & children if this is hoisted static nodes
        // #5405 in dev, always hydrate children for HMR
        if (true /* HOISTED */) {
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                if (forcePatchValue ||
                    !optimized ||
                    patchFlag & (16 /* FULL_PROPS */ | 32 /* HYDRATE_EVENTS */)) {
                    for (const key in props) {
                        if ((forcePatchValue && key.endsWith('value')) ||
                            (isOn(key) && !isReservedProp(key))) {
                            patchProp(el, key, null, props[key], false, undefined, parentComponent);
                        }
                    }
                }
                else if (props.onClick) {
                    // Fast path for click listeners (which is most often) to avoid
                    // iterating through props.
                    patchProp(el, 'onClick', null, props.onClick, false, undefined, parentComponent);
                }
            }
            // vnode / directive hooks
            let vnodeHooks;
            if ((vnodeHooks = props && props.onVnodeBeforeMount)) {
                invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
            }
            if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
                queueEffectWithSuspense(() => {
                    vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
                    dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
                }, parentSuspense);
            }
            // children
            if (shapeFlag & 16 /* ARRAY_CHILDREN */ &&
                // skip if element has innerHTML / textContent
                !(props && (props.innerHTML || props.textContent))) {
                let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
                let hasWarned = false;
                while (next) {
                    hasMismatch = true;
                    if (( true) && !hasWarned) {
                        warn$1(`Hydration children mismatch in <${vnode.type}>: ` +
                            `server rendered element contains more child nodes than client vdom.`);
                        hasWarned = true;
                    }
                    // The SSRed DOM contains more nodes than it should. Remove them.
                    const cur = next;
                    next = next.nextSibling;
                    remove(cur);
                }
            }
            else if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                if (el.textContent !== vnode.children) {
                    hasMismatch = true;
                    ( true) &&
                        warn$1(`Hydration text content mismatch in <${vnode.type}>:\n` +
                            `- Client: ${el.textContent}\n` +
                            `- Server: ${vnode.children}`);
                    el.textContent = vnode.children;
                }
            }
        }
        return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l = children.length;
        let hasWarned = false;
        for (let i = 0; i < l; i++) {
            const vnode = optimized
                ? children[i]
                : (children[i] = normalizeVNode(children[i]));
            if (node) {
                node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
            else if (vnode.type === Text && !vnode.children) {
                continue;
            }
            else {
                hasMismatch = true;
                if (( true) && !hasWarned) {
                    warn$1(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +
                        `server rendered element contains fewer child nodes than client vdom.`);
                    hasWarned = true;
                }
                // the SSRed DOM didn't contain enough nodes. Mount the missing ones.
                patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
            }
        }
        return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
        if (next && isComment(next) && next.data === ']') {
            return nextSibling((vnode.anchor = next));
        }
        else {
            // fragment didn't hydrate successfully, since we didn't get a end anchor
            // back. This should have led to node/children mismatch warnings.
            hasMismatch = true;
            // since the anchor is missing, we need to create one and insert it
            insert((vnode.anchor = createComment(`]`)), container, next);
            return next;
        }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        ( true) &&
            warn$1(`Hydration node mismatch:\n- Client vnode:`, vnode.type, `\n- Server rendered DOM:`, node, node.nodeType === 3 /* TEXT */
                ? `(text)`
                : isComment(node) && node.data === '['
                    ? `(start of fragment)`
                    : ``);
        vnode.el = null;
        if (isFragment) {
            // remove excessive fragment nodes
            const end = locateClosingAsyncAnchor(node);
            while (true) {
                const next = nextSibling(node);
                if (next && next !== end) {
                    remove(next);
                }
                else {
                    break;
                }
            }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove(node);
        patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        return next;
    };
    const locateClosingAsyncAnchor = (node) => {
        let match = 0;
        while (node) {
            node = nextSibling(node);
            if (node && isComment(node)) {
                if (node.data === '[')
                    match++;
                if (node.data === ']') {
                    if (match === 0) {
                        return nextSibling(node);
                    }
                    else {
                        match--;
                    }
                }
            }
        }
        return node;
    };
    return [hydrate, hydrateNode];
}

/* eslint-disable no-restricted-globals */
let supported;
let perf;
function startMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        perf.mark(`vue-${type}-${instance.uid}`);
    }
    if (true) {
        devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
    }
}
function endMeasure(instance, type) {
    if (instance.appContext.config.performance && isSupported()) {
        const startTag = `vue-${type}-${instance.uid}`;
        const endTag = startTag + `:end`;
        perf.mark(endTag);
        perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
    }
    if (true) {
        devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
    }
}
function isSupported() {
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else {
        supported = false;
    }
    return supported;
}

/**
 * This is only called in esm-bundler builds.
 * It is called when a renderer is created, in `baseCreateRenderer` so that
 * importing runtime-core is side-effects free.
 *
 * istanbul-ignore-next
 */
function initFeatureFlags() {
    const needWarn = [];
    if (false) {}
    if (false) {}
    if (( true) && needWarn.length) {
        const multi = needWarn.length > 1;
        console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(', ')} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, ` +
            `which expects these compile-time feature flags to be globally injected ` +
            `via the bundler config in order to get better tree-shaking in the ` +
            `production bundle.\n\n` +
            `For more details, see https://link.vuejs.org/feature-flags.`);
    }
}

const queuePostRenderEffect = queueEffectWithSuspense
    ;
/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */
function createRenderer(options) {
    return baseCreateRenderer(options);
}
// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
}
// implementation
function baseCreateRenderer(options, createHydrationFns) {
    // compile-time feature flags check
    {
        initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    if (true) {
        setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    // Note: functions inside this closure should use `const xxx = () => {}`
    // style in order to prevent being inlined by minifiers.
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = ( true) && isHmrUpdating ? false : !!n2.dynamicChildren) => {
        if (n1 === n2) {
            return;
        }
        // patching & not same type, unmount old tree
        if (n1 && !isSameVNodeType(n1, n2)) {
            anchor = getNextHostNode(n1);
            unmount(n1, parentComponent, parentSuspense, true);
            n1 = null;
        }
        if (n2.patchFlag === -2 /* BAIL */) {
            optimized = false;
            n2.dynamicChildren = null;
        }
        const { type, ref, shapeFlag } = n2;
        switch (type) {
            case Text:
                processText(n1, n2, container, anchor);
                break;
            case Comment:
                processCommentNode(n1, n2, container, anchor);
                break;
            case Static:
                if (n1 == null) {
                    mountStaticNode(n2, container, anchor, isSVG);
                }
                else if ((true)) {
                    patchStaticNode(n1, n2, container, isSVG);
                }
                break;
            case Fragment:
                processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                break;
            default:
                if (shapeFlag & 1 /* ELEMENT */) {
                    processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 6 /* COMPONENT */) {
                    processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (shapeFlag & 64 /* TELEPORT */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if (shapeFlag & 128 /* SUSPENSE */) {
                    type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
                }
                else if ((true)) {
                    warn$1('Invalid VNode type:', type, `(${typeof type})`);
                }
        }
        // set ref
        if (ref != null && parentComponent) {
            setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
    };
    const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateText(n2.children)), container, anchor);
        }
        else {
            const el = (n2.el = n1.el);
            if (n2.children !== n1.children) {
                hostSetText(el, n2.children);
            }
        }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
            hostInsert((n2.el = hostCreateComment(n2.children || '')), container, anchor);
        }
        else {
            // there's no support for dynamic comments
            n2.el = n1.el;
        }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
    };
    /**
     * Dev / HMR only
     */
    const patchStaticNode = (n1, n2, container, isSVG) => {
        // static nodes are only patched during dev for HMR
        if (n2.children !== n1.children) {
            const anchor = hostNextSibling(n1.anchor);
            // remove existing
            removeStaticNode(n1);
            [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
        }
        else {
            n2.el = n1.el;
            n2.anchor = n1.anchor;
        }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostInsert(el, container, nextSibling);
            el = next;
        }
        hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
            next = hostNextSibling(el);
            hostRemove(el);
            el = next;
        }
        hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === 'svg';
        if (n1 == null) {
            mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
        if (false /* HOISTED */) {}
        else {
            el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
            // mount children first, since some props may rely on child content
            // being already rendered, e.g. `<select value>`
            if (shapeFlag & 8 /* TEXT_CHILDREN */) {
                hostSetElementText(el, vnode.children);
            }
            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== 'foreignObject', slotScopeIds, optimized);
            }
            if (dirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'created');
            }
            // props
            if (props) {
                for (const key in props) {
                    if (key !== 'value' && !isReservedProp(key)) {
                        hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
                /**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */
                if ('value' in props) {
                    hostPatchProp(el, 'value', null, props.value);
                }
                if ((vnodeHook = props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parentComponent, vnode);
                }
            }
            // scopeId
            setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        }
        if (true) {
            Object.defineProperty(el, '__vnode', {
                value: vnode,
                enumerable: false
            });
            Object.defineProperty(el, '__vueParentComponent', {
                value: parentComponent,
                enumerable: false
            });
        }
        if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount');
        }
        // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
        // #1689 For inside suspense + suspense resolved case, just call it
        const needCallTransitionHooks = (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&
            transition &&
            !transition.persisted;
        if (needCallTransitionHooks) {
            transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) ||
            needCallTransitionHooks ||
            dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                needCallTransitionHooks && transition.enter(el);
                dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted');
            }, parentSuspense);
        }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
            hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
            for (let i = 0; i < slotScopeIds.length; i++) {
                hostSetScopeId(el, slotScopeIds[i]);
            }
        }
        if (parentComponent) {
            let subTree = parentComponent.subTree;
            if (( true) &&
                subTree.patchFlag > 0 &&
                subTree.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */) {
                subTree =
                    filterSingleRoot(subTree.children) || subTree;
            }
            if (vnode === subTree) {
                const parentVNode = parentComponent.vnode;
                setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
            }
        }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
        for (let i = start; i < children.length; i++) {
            const child = (children[i] = optimized
                ? cloneIfMounted(children[i])
                : normalizeVNode(children[i]));
            patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = (n2.el = n1.el);
        let { patchFlag, dynamicChildren, dirs } = n2;
        // #1426 take the old vnode's patch flag into account since user may clone a
        // compiler-generated vnode, which de-opts to FULL_PROPS
        patchFlag |= n1.patchFlag & 16 /* FULL_PROPS */;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        // disable recurse in beforeUpdate hooks
        parentComponent && toggleRecurse(parentComponent, false);
        if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {
            invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
            invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate');
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (( true) && isHmrUpdating) {
            // HMR updated, force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        const areChildrenSVG = isSVG && n2.type !== 'foreignObject';
        if (dynamicChildren) {
            patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
            if (( true) && parentComponent && parentComponent.type.__hmrId) {
                traverseStaticChildren(n1, n2);
            }
        }
        else if (!optimized) {
            // full diff
            patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
        }
        if (patchFlag > 0) {
            // the presence of a patchFlag means this element's render code was
            // generated by the compiler and can take the fast path.
            // in this path old node and new node are guaranteed to have the same shape
            // (i.e. at the exact same position in the source template)
            if (patchFlag & 16 /* FULL_PROPS */) {
                // element props contain dynamic keys, full diff needed
                patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
            }
            else {
                // class
                // this flag is matched when the element has dynamic class bindings.
                if (patchFlag & 2 /* CLASS */) {
                    if (oldProps.class !== newProps.class) {
                        hostPatchProp(el, 'class', null, newProps.class, isSVG);
                    }
                }
                // style
                // this flag is matched when the element has dynamic style bindings
                if (patchFlag & 4 /* STYLE */) {
                    hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG);
                }
                // props
                // This flag is matched when the element has dynamic prop/attr bindings
                // other than class and style. The keys of dynamic prop/attrs are saved for
                // faster iteration.
                // Note dynamic keys like :[foo]="bar" will cause this optimization to
                // bail out and go through a full diff because we need to unset the old key
                if (patchFlag & 8 /* PROPS */) {
                    // if the flag is present then dynamicProps must be non-null
                    const propsToUpdate = n2.dynamicProps;
                    for (let i = 0; i < propsToUpdate.length; i++) {
                        const key = propsToUpdate[i];
                        const prev = oldProps[key];
                        const next = newProps[key];
                        // #1471 force patch value
                        if (next !== prev || key === 'value') {
                            hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
                        }
                    }
                }
            }
            // text
            // This flag is matched when the element has only dynamic text children.
            if (patchFlag & 1 /* TEXT */) {
                if (n1.children !== n2.children) {
                    hostSetElementText(el, n2.children);
                }
            }
        }
        else if (!optimized && dynamicChildren == null) {
            // unoptimized, full diff
            patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated');
            }, parentSuspense);
        }
    };
    // The fast path for blocks.
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
            const oldVNode = oldChildren[i];
            const newVNode = newChildren[i];
            // Determine the container (parent element) for the patch.
            const container = 
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el &&
                // - In the case of a Fragment, we need to provide the actual parent
                // of the Fragment itself so it can move its children.
                (oldVNode.type === Fragment ||
                    // - In the case of different nodes, there is going to be a replacement
                    // which also requires the correct parent container
                    !isSameVNodeType(oldVNode, newVNode) ||
                    // - In the case of a component, it could contain anything.
                    oldVNode.shapeFlag & (6 /* COMPONENT */ | 64 /* TELEPORT */))
                ? hostParentNode(oldVNode.el)
                : // In other cases, the parent container is not actually used so we
                    // just pass the block element here to avoid a DOM parentNode call.
                    fallbackContainer;
            patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
        }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
            for (const key in newProps) {
                // empty string is not valid prop
                if (isReservedProp(key))
                    continue;
                const next = newProps[key];
                const prev = oldProps[key];
                // defer patching value
                if (next !== prev && key !== 'value') {
                    hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                }
            }
            if (oldProps !== EMPTY_OBJ) {
                for (const key in oldProps) {
                    if (!isReservedProp(key) && !(key in newProps)) {
                        hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
                    }
                }
            }
            if ('value' in newProps) {
                hostPatchProp(el, 'value', oldProps.value, newProps.value);
            }
        }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''));
        const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''));
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (( true) &&
            // #5523 dev root fragment may inherit directives
            (isHmrUpdating || patchFlag & 2048 /* DEV_ROOT_FRAGMENT */)) {
            // HMR updated / Dev root fragment (w/ comments), force full diff
            patchFlag = 0;
            optimized = false;
            dynamicChildren = null;
        }
        // check if this is a slot fragment with :slotted scope ids
        if (fragmentSlotScopeIds) {
            slotScopeIds = slotScopeIds
                ? slotScopeIds.concat(fragmentSlotScopeIds)
                : fragmentSlotScopeIds;
        }
        if (n1 == null) {
            hostInsert(fragmentStartAnchor, container, anchor);
            hostInsert(fragmentEndAnchor, container, anchor);
            // a fragment can only have array children
            // since they are either generated by the compiler, or implicitly created
            // from arrays.
            mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        else {
            if (patchFlag > 0 &&
                patchFlag & 64 /* STABLE_FRAGMENT */ &&
                dynamicChildren &&
                // #2715 the previous fragment could've been a BAILed one as a result
                // of renderSlot() with no valid children
                n1.dynamicChildren) {
                // a stable fragment (template root or <template v-for>) doesn't need to
                // patch children order, but it may contain dynamicChildren.
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
                if (( true) && parentComponent && parentComponent.type.__hmrId) {
                    traverseStaticChildren(n1, n2);
                }
                else if (
                // #2080 if the stable fragment has a key, it's a <template v-for> that may
                //  get moved around. Make sure all root level vnodes inherit el.
                // #2134 or if it's a component root, it may also get moved around
                // as the component is being moved.
                n2.key != null ||
                    (parentComponent && n2 === parentComponent.subTree)) {
                    traverseStaticChildren(n1, n2, true /* shallow */);
                }
            }
            else {
                // keyed / unkeyed, or manual fragments.
                // for keyed & unkeyed, since they are compiler generated from v-for,
                // each child is guaranteed to be a block so the fragment will never
                // have dynamicChildren.
                patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
        }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
            if (n2.shapeFlag & 512 /* COMPONENT_KEPT_ALIVE */) {
                parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
            }
            else {
                mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
            }
        }
        else {
            updateComponent(n1, n2, optimized);
        }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        // 2.x compat may pre-create the component instance before actually
        // mounting
        const compatMountInstance = initialVNode.isCompatRoot && initialVNode.component;
        const instance = compatMountInstance ||
            (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense));
        if (( true) && instance.type.__hmrId) {
            registerHMR(instance);
        }
        if ((true)) {
            pushWarningContext(initialVNode);
            startMeasure(instance, `mount`);
        }
        // inject renderer internals for keepAlive
        if (isKeepAlive(initialVNode)) {
            instance.ctx.renderer = internals;
        }
        // resolve props and slots for setup context
        if (!(compatMountInstance)) {
            if ((true)) {
                startMeasure(instance, `init`);
            }
            setupComponent(instance);
            if ((true)) {
                endMeasure(instance, `init`);
            }
        }
        // setup() is async. This component relies on async logic to be resolved
        // before proceeding
        if (instance.asyncDep) {
            parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
            // Give it a placeholder if this is not hydration
            // TODO handle self-defined fallback
            if (!initialVNode.el) {
                const placeholder = (instance.subTree = createVNode(Comment));
                processCommentNode(null, placeholder, container, anchor);
            }
            return;
        }
        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
        if ((true)) {
            popWarningContext();
            endMeasure(instance, `mount`);
        }
    };
    const updateComponent = (n1, n2, optimized) => {
        const instance = (n2.component = n1.component);
        if (shouldUpdateComponent(n1, n2, optimized)) {
            if (instance.asyncDep &&
                !instance.asyncResolved) {
                // async & still pending - just update props and slots
                // since the component's reactive effect for render isn't set-up yet
                if ((true)) {
                    pushWarningContext(n2);
                }
                updateComponentPreRender(instance, n2, optimized);
                if ((true)) {
                    popWarningContext();
                }
                return;
            }
            else {
                // normal update
                instance.next = n2;
                // in case the child component is also queued, remove it to avoid
                // double updating the same child component in the same flush.
                invalidateJob(instance.update);
                // instance.update is the reactive effect.
                instance.update();
            }
        }
        else {
            // no update needed. just copy over properties
            n2.el = n1.el;
            instance.vnode = n2;
        }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
            if (!instance.isMounted) {
                let vnodeHook;
                const { el, props } = initialVNode;
                const { bm, m, parent } = instance;
                const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                toggleRecurse(instance, false);
                // beforeMount hook
                if (bm) {
                    invokeArrayFns(bm);
                }
                // onVnodeBeforeMount
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeBeforeMount)) {
                    invokeVNodeHook(vnodeHook, parent, initialVNode);
                }
                if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
                    instance.emit('hook:beforeMount');
                }
                toggleRecurse(instance, true);
                if (el && hydrateNode) {
                    // vnode has adopted host node - perform hydration instead of mount.
                    const hydrateSubTree = () => {
                        if ((true)) {
                            startMeasure(instance, `render`);
                        }
                        instance.subTree = renderComponentRoot(instance);
                        if ((true)) {
                            endMeasure(instance, `render`);
                        }
                        if ((true)) {
                            startMeasure(instance, `hydrate`);
                        }
                        hydrateNode(el, instance.subTree, instance, parentSuspense, null);
                        if ((true)) {
                            endMeasure(instance, `hydrate`);
                        }
                    };
                    if (isAsyncWrapperVNode) {
                        initialVNode.type.__asyncLoader().then(
                        // note: we are moving the render call into an async callback,
                        // which means it won't track dependencies - but it's ok because
                        // a server-rendered async wrapper is already in resolved state
                        // and it will never need to change.
                        () => !instance.isUnmounted && hydrateSubTree());
                    }
                    else {
                        hydrateSubTree();
                    }
                }
                else {
                    if ((true)) {
                        startMeasure(instance, `render`);
                    }
                    const subTree = (instance.subTree = renderComponentRoot(instance));
                    if ((true)) {
                        endMeasure(instance, `render`);
                    }
                    if ((true)) {
                        startMeasure(instance, `patch`);
                    }
                    patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
                    if ((true)) {
                        endMeasure(instance, `patch`);
                    }
                    initialVNode.el = subTree.el;
                }
                // mounted hook
                if (m) {
                    queuePostRenderEffect(m, parentSuspense);
                }
                // onVnodeMounted
                if (!isAsyncWrapperVNode &&
                    (vnodeHook = props && props.onVnodeMounted)) {
                    const scopedInitialVNode = initialVNode;
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                }
                if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
                    queuePostRenderEffect(() => instance.emit('hook:mounted'), parentSuspense);
                }
                // activated hook for keep-alive roots.
                // #1742 activated hook must be accessed after first render
                // since the hook may be injected by a child keep-alive
                if (initialVNode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */ ||
                    (parent &&
                        isAsyncWrapper(parent.vnode) &&
                        parent.vnode.shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */)) {
                    instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                    if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
                        queuePostRenderEffect(() => instance.emit('hook:activated'), parentSuspense);
                    }
                }
                instance.isMounted = true;
                if (true) {
                    devtoolsComponentAdded(instance);
                }
                // #2458: deference mount-only object parameters to prevent memleaks
                initialVNode = container = anchor = null;
            }
            else {
                // updateComponent
                // This is triggered by mutation of component's own state (next: null)
                // OR parent calling processComponent (next: VNode)
                let { next, bu, u, parent, vnode } = instance;
                let originNext = next;
                let vnodeHook;
                if ((true)) {
                    pushWarningContext(next || instance.vnode);
                }
                // Disallow component effect recursion during pre-lifecycle hooks.
                toggleRecurse(instance, false);
                if (next) {
                    next.el = vnode.el;
                    updateComponentPreRender(instance, next, optimized);
                }
                else {
                    next = vnode;
                }
                // beforeUpdate hook
                if (bu) {
                    invokeArrayFns(bu);
                }
                // onVnodeBeforeUpdate
                if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
                    invokeVNodeHook(vnodeHook, parent, next, vnode);
                }
                if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
                    instance.emit('hook:beforeUpdate');
                }
                toggleRecurse(instance, true);
                // render
                if ((true)) {
                    startMeasure(instance, `render`);
                }
                const nextTree = renderComponentRoot(instance);
                if ((true)) {
                    endMeasure(instance, `render`);
                }
                const prevTree = instance.subTree;
                instance.subTree = nextTree;
                if ((true)) {
                    startMeasure(instance, `patch`);
                }
                patch(prevTree, nextTree, 
                // parent may have changed if it's in a teleport
                hostParentNode(prevTree.el), 
                // anchor may have changed if it's in a fragment
                getNextHostNode(prevTree), instance, parentSuspense, isSVG);
                if ((true)) {
                    endMeasure(instance, `patch`);
                }
                next.el = nextTree.el;
                if (originNext === null) {
                    // self-triggered update. In case of HOC, update parent component
                    // vnode el. HOC is indicated by parent instance's subTree pointing
                    // to child component's vnode
                    updateHOCHostEl(instance, nextTree.el);
                }
                // updated hook
                if (u) {
                    queuePostRenderEffect(u, parentSuspense);
                }
                // onVnodeUpdated
                if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
                    queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                }
                if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
                    queuePostRenderEffect(() => instance.emit('hook:updated'), parentSuspense);
                }
                if (true) {
                    devtoolsComponentUpdated(instance);
                }
                if ((true)) {
                    popWarningContext();
                }
            }
        };
        // create reactive effect for rendering
        const effect = (instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope // track it in component's effect scope
        ));
        const update = (instance.update = () => effect.run());
        update.id = instance.uid;
        // allowRecurse
        // #1801, #2043 component render effects should allow recursive updates
        toggleRecurse(instance, true);
        if ((true)) {
            effect.onTrack = instance.rtc
                ? e => invokeArrayFns(instance.rtc, e)
                : void 0;
            effect.onTrigger = instance.rtg
                ? e => invokeArrayFns(instance.rtg, e)
                : void 0;
            update.ownerInstance = instance;
        }
        update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        // props update may have triggered pre-flush watchers.
        // flush them before the render update.
        flushPreFlushCbs(undefined, instance.update);
        resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        // fast path
        if (patchFlag > 0) {
            if (patchFlag & 128 /* KEYED_FRAGMENT */) {
                // this could be either fully-keyed or mixed (some keyed some not)
                // presence of patchFlag means children are guaranteed to be arrays
                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
            else if (patchFlag & 256 /* UNKEYED_FRAGMENT */) {
                // unkeyed
                patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                return;
            }
        }
        // children has 3 possibilities: text, array or no children.
        if (shapeFlag & 8 /* TEXT_CHILDREN */) {
            // text children fast path
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                unmountChildren(c1, parentComponent, parentSuspense);
            }
            if (c2 !== c1) {
                hostSetElementText(container, c2);
            }
        }
        else {
            if (prevShapeFlag & 16 /* ARRAY_CHILDREN */) {
                // prev children was array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    // two arrays, cannot assume anything, do full diff
                    patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else {
                    // no new children, just unmount old
                    unmountChildren(c1, parentComponent, parentSuspense, true);
                }
            }
            else {
                // prev children was text OR null
                // new children is array OR null
                if (prevShapeFlag & 8 /* TEXT_CHILDREN */) {
                    hostSetElementText(container, '');
                }
                // mount new if array
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            }
        }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
            const nextChild = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
        if (oldLength > newLength) {
            // remove old
            unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
        }
        else {
            // mount new
            mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
        }
    };
    // can be all-keyed or mixed
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1; // prev ending index
        let e2 = l2 - 1; // next ending index
        // 1. sync from start
        // (a b) c
        // (a b) d e
        while (i <= e1 && i <= e2) {
            const n1 = c1[i];
            const n2 = (c2[i] = optimized
                ? cloneIfMounted(c2[i])
                : normalizeVNode(c2[i]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            i++;
        }
        // 2. sync from end
        // a (b c)
        // d e (b c)
        while (i <= e1 && i <= e2) {
            const n1 = c1[e1];
            const n2 = (c2[e2] = optimized
                ? cloneIfMounted(c2[e2])
                : normalizeVNode(c2[e2]));
            if (isSameVNodeType(n1, n2)) {
                patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            }
            else {
                break;
            }
            e1--;
            e2--;
        }
        // 3. common sequence + mount
        // (a b)
        // (a b) c
        // i = 2, e1 = 1, e2 = 2
        // (a b)
        // c (a b)
        // i = 0, e1 = -1, e2 = 0
        if (i > e1) {
            if (i <= e2) {
                const nextPos = e2 + 1;
                const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                while (i <= e2) {
                    patch(null, (c2[i] = optimized
                        ? cloneIfMounted(c2[i])
                        : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    i++;
                }
            }
        }
        // 4. common sequence + unmount
        // (a b) c
        // (a b)
        // i = 2, e1 = 2, e2 = 1
        // a (b c)
        // (b c)
        // i = 0, e1 = 0, e2 = -1
        else if (i > e2) {
            while (i <= e1) {
                unmount(c1[i], parentComponent, parentSuspense, true);
                i++;
            }
        }
        // 5. unknown sequence
        // [i ... e1 + 1]: a b [c d e] f g
        // [i ... e2 + 1]: a b [e d c h] f g
        // i = 2, e1 = 4, e2 = 5
        else {
            const s1 = i; // prev starting index
            const s2 = i; // next starting index
            // 5.1 build key:index map for newChildren
            const keyToNewIndexMap = new Map();
            for (i = s2; i <= e2; i++) {
                const nextChild = (c2[i] = optimized
                    ? cloneIfMounted(c2[i])
                    : normalizeVNode(c2[i]));
                if (nextChild.key != null) {
                    if (( true) && keyToNewIndexMap.has(nextChild.key)) {
                        warn$1(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
                    }
                    keyToNewIndexMap.set(nextChild.key, i);
                }
            }
            // 5.2 loop through old children left to be patched and try to patch
            // matching nodes & remove nodes that are no longer present
            let j;
            let patched = 0;
            const toBePatched = e2 - s2 + 1;
            let moved = false;
            // used to track whether any node has moved
            let maxNewIndexSoFar = 0;
            // works as Map<newIndex, oldIndex>
            // Note that oldIndex is offset by +1
            // and oldIndex = 0 is a special value indicating the new node has
            // no corresponding old node.
            // used for determining longest stable subsequence
            const newIndexToOldIndexMap = new Array(toBePatched);
            for (i = 0; i < toBePatched; i++)
                newIndexToOldIndexMap[i] = 0;
            for (i = s1; i <= e1; i++) {
                const prevChild = c1[i];
                if (patched >= toBePatched) {
                    // all new children have been patched so this can only be a removal
                    unmount(prevChild, parentComponent, parentSuspense, true);
                    continue;
                }
                let newIndex;
                if (prevChild.key != null) {
                    newIndex = keyToNewIndexMap.get(prevChild.key);
                }
                else {
                    // key-less node, try to locate a key-less node of the same type
                    for (j = s2; j <= e2; j++) {
                        if (newIndexToOldIndexMap[j - s2] === 0 &&
                            isSameVNodeType(prevChild, c2[j])) {
                            newIndex = j;
                            break;
                        }
                    }
                }
                if (newIndex === undefined) {
                    unmount(prevChild, parentComponent, parentSuspense, true);
                }
                else {
                    newIndexToOldIndexMap[newIndex - s2] = i + 1;
                    if (newIndex >= maxNewIndexSoFar) {
                        maxNewIndexSoFar = newIndex;
                    }
                    else {
                        moved = true;
                    }
                    patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                    patched++;
                }
            }
            // 5.3 move and mount
            // generate longest stable subsequence only when nodes have moved
            const increasingNewIndexSequence = moved
                ? getSequence(newIndexToOldIndexMap)
                : EMPTY_ARR;
            j = increasingNewIndexSequence.length - 1;
            // looping backwards so that we can use last patched node as anchor
            for (i = toBePatched - 1; i >= 0; i--) {
                const nextIndex = s2 + i;
                const nextChild = c2[nextIndex];
                const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
                if (newIndexToOldIndexMap[i] === 0) {
                    // mount new
                    patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
                else if (moved) {
                    // move if:
                    // There is no stable subsequence (e.g. a reverse)
                    // OR current node is not among the stable sequence
                    if (j < 0 || i !== increasingNewIndexSequence[j]) {
                        move(nextChild, container, anchor, 2 /* REORDER */);
                    }
                    else {
                        j--;
                    }
                }
            }
        }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6 /* COMPONENT */) {
            move(vnode.component.subTree, container, anchor, moveType);
            return;
        }
        if (shapeFlag & 128 /* SUSPENSE */) {
            vnode.suspense.move(container, anchor, moveType);
            return;
        }
        if (shapeFlag & 64 /* TELEPORT */) {
            type.move(vnode, container, anchor, internals);
            return;
        }
        if (type === Fragment) {
            hostInsert(el, container, anchor);
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, anchor, moveType);
            }
            hostInsert(vnode.anchor, container, anchor);
            return;
        }
        if (type === Static) {
            moveStaticNode(vnode, container, anchor);
            return;
        }
        // single nodes
        const needTransition = moveType !== 2 /* REORDER */ &&
            shapeFlag & 1 /* ELEMENT */ &&
            transition;
        if (needTransition) {
            if (moveType === 0 /* ENTER */) {
                transition.beforeEnter(el);
                hostInsert(el, container, anchor);
                queuePostRenderEffect(() => transition.enter(el), parentSuspense);
            }
            else {
                const { leave, delayLeave, afterLeave } = transition;
                const remove = () => hostInsert(el, container, anchor);
                const performLeave = () => {
                    leave(el, () => {
                        remove();
                        afterLeave && afterLeave();
                    });
                };
                if (delayLeave) {
                    delayLeave(el, remove, performLeave);
                }
                else {
                    performLeave();
                }
            }
        }
        else {
            hostInsert(el, container, anchor);
        }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
        // unset ref
        if (ref != null) {
            setRef(ref, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256 /* COMPONENT_SHOULD_KEEP_ALIVE */) {
            parentComponent.ctx.deactivate(vnode);
            return;
        }
        const shouldInvokeDirs = shapeFlag & 1 /* ELEMENT */ && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeBeforeUnmount)) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6 /* COMPONENT */) {
            unmountComponent(vnode.component, parentSuspense, doRemove);
        }
        else {
            if (shapeFlag & 128 /* SUSPENSE */) {
                vnode.suspense.unmount(parentSuspense, doRemove);
                return;
            }
            if (shouldInvokeDirs) {
                invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount');
            }
            if (shapeFlag & 64 /* TELEPORT */) {
                vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
            }
            else if (dynamicChildren &&
                // #1153: fast path should not be taken for non-stable (v-for) fragments
                (type !== Fragment ||
                    (patchFlag > 0 && patchFlag & 64 /* STABLE_FRAGMENT */))) {
                // fast path for block nodes: only need to unmount dynamic children.
                unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
            }
            else if ((type === Fragment &&
                patchFlag &
                    (128 /* KEYED_FRAGMENT */ | 256 /* UNKEYED_FRAGMENT */)) ||
                (!optimized && shapeFlag & 16 /* ARRAY_CHILDREN */)) {
                unmountChildren(children, parentComponent, parentSuspense);
            }
            if (doRemove) {
                remove(vnode);
            }
        }
        if ((shouldInvokeVnodeHook &&
            (vnodeHook = props && props.onVnodeUnmounted)) ||
            shouldInvokeDirs) {
            queuePostRenderEffect(() => {
                vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                shouldInvokeDirs &&
                    invokeDirectiveHook(vnode, null, parentComponent, 'unmounted');
            }, parentSuspense);
        }
    };
    const remove = vnode => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
            if (( true) &&
                vnode.patchFlag > 0 &&
                vnode.patchFlag & 2048 /* DEV_ROOT_FRAGMENT */ &&
                transition &&
                !transition.persisted) {
                vnode.children.forEach(child => {
                    if (child.type === Comment) {
                        hostRemove(child.el);
                    }
                    else {
                        remove(child);
                    }
                });
            }
            else {
                removeFragment(el, anchor);
            }
            return;
        }
        if (type === Static) {
            removeStaticNode(vnode);
            return;
        }
        const performRemove = () => {
            hostRemove(el);
            if (transition && !transition.persisted && transition.afterLeave) {
                transition.afterLeave();
            }
        };
        if (vnode.shapeFlag & 1 /* ELEMENT */ &&
            transition &&
            !transition.persisted) {
            const { leave, delayLeave } = transition;
            const performLeave = () => leave(el, performRemove);
            if (delayLeave) {
                delayLeave(vnode.el, performRemove, performLeave);
            }
            else {
                performLeave();
            }
        }
        else {
            performRemove();
        }
    };
    const removeFragment = (cur, end) => {
        // For fragments, directly remove all contained DOM nodes.
        // (fragment child nodes cannot have transition)
        let next;
        while (cur !== end) {
            next = hostNextSibling(cur);
            hostRemove(cur);
            cur = next;
        }
        hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
        if (( true) && instance.type.__hmrId) {
            unregisterHMR(instance);
        }
        const { bum, scope, update, subTree, um } = instance;
        // beforeUnmount hook
        if (bum) {
            invokeArrayFns(bum);
        }
        if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
            instance.emit('hook:beforeDestroy');
        }
        // stop effects in component scope
        scope.stop();
        // update may be null if a component is unmounted before its async
        // setup has resolved.
        if (update) {
            // so that scheduler will no longer invoke it
            update.active = false;
            unmount(subTree, instance, parentSuspense, doRemove);
        }
        // unmounted hook
        if (um) {
            queuePostRenderEffect(um, parentSuspense);
        }
        if (isCompatEnabled("INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */, instance)) {
            queuePostRenderEffect(() => instance.emit('hook:destroyed'), parentSuspense);
        }
        queuePostRenderEffect(() => {
            instance.isUnmounted = true;
        }, parentSuspense);
        // A component with async dep inside a pending suspense is unmounted before
        // its async dep resolves. This should remove the dep from the suspense, and
        // cause the suspense to resolve immediately if that was the last dep.
        if (parentSuspense &&
            parentSuspense.pendingBranch &&
            !parentSuspense.isUnmounted &&
            instance.asyncDep &&
            !instance.asyncResolved &&
            instance.suspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0) {
                parentSuspense.resolve();
            }
        }
        if (true) {
            devtoolsComponentRemoved(instance);
        }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
        for (let i = start; i < children.length; i++) {
            unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
    };
    const getNextHostNode = vnode => {
        if (vnode.shapeFlag & 6 /* COMPONENT */) {
            return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128 /* SUSPENSE */) {
            return vnode.suspense.next();
        }
        return hostNextSibling((vnode.anchor || vnode.el));
    };
    const render = (vnode, container, isSVG) => {
        if (vnode == null) {
            if (container._vnode) {
                unmount(container._vnode, null, null, true);
            }
        }
        else {
            patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPostFlushCbs();
        container._vnode = vnode;
    };
    const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(internals);
    }
    return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
    };
}
function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
}
/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */
function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
            // this is only called in the optimized path so array children are
            // guaranteed to be vnodes
            const c1 = ch1[i];
            let c2 = ch2[i];
            if (c2.shapeFlag & 1 /* ELEMENT */ && !c2.dynamicChildren) {
                if (c2.patchFlag <= 0 || c2.patchFlag === 32 /* HYDRATE_EVENTS */) {
                    c2 = ch2[i] = cloneIfMounted(ch2[i]);
                    c2.el = c1.el;
                }
                if (!shallow)
                    traverseStaticChildren(c1, c2);
            }
            // also inherit for comment nodes, but not placeholders (e.g. v-if which
            // would have received .el during block patch)
            if (( true) && c2.type === Comment && !c2.el) {
                c2.el = c1.el;
            }
        }
    }
}
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
            j = result[result.length - 1];
            if (arr[j] < arrI) {
                p[i] = j;
                result.push(i);
                continue;
            }
            u = 0;
            v = result.length - 1;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
        result[u] = v;
        v = p[v];
    }
    return result;
}

const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === '');
const isTargetSVG = (target) => typeof SVGElement !== 'undefined' && target instanceof SVGElement;
const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString(targetSelector)) {
        if (!select) {
            ( true) &&
                warn$1(`Current renderer does not support string target for Teleports. ` +
                    `(missing querySelector renderer option)`);
            return null;
        }
        else {
            const target = select(targetSelector);
            if (!target) {
                ( true) &&
                    warn$1(`Failed to locate Teleport target with selector "${targetSelector}". ` +
                        `Note the target element must exist before the component is mounted - ` +
                        `i.e. the target cannot be rendered by the component itself, and ` +
                        `ideally should be outside of the entire Vue component tree.`);
            }
            return target;
        }
    }
    else {
        if (( true) && !targetSelector && !isTeleportDisabled(props)) {
            warn$1(`Invalid Teleport target: ${targetSelector}`);
        }
        return targetSelector;
    }
};
const TeleportImpl = {
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        // #3302
        // HMR updated, force full diff
        if (( true) && isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
        }
        if (n1 == null) {
            // insert anchors in the main view
            const placeholder = (n2.el = ( true)
                ? createComment('teleport start')
                : 0);
            const mainAnchor = (n2.anchor = ( true)
                ? createComment('teleport end')
                : 0);
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target = (n2.target = resolveTarget(n2.props, querySelector));
            const targetAnchor = (n2.targetAnchor = createText(''));
            if (target) {
                insert(targetAnchor, target);
                // #2652 we could be teleporting from a non-SVG tree into an SVG tree
                isSVG = isSVG || isTargetSVG(target);
            }
            else if (( true) && !disabled) {
                warn$1('Invalid Teleport target on mount:', target, `(${typeof target})`);
            }
            const mount = (container, anchor) => {
                // Teleport *always* has Array children. This is enforced in both the
                // compiler and vnode children normalization.
                if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                    mountChildren(children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
                }
            };
            if (disabled) {
                mount(container, mainAnchor);
            }
            else if (target) {
                mount(target, targetAnchor);
            }
        }
        else {
            // update content
            n2.el = n1.el;
            const mainAnchor = (n2.anchor = n1.anchor);
            const target = (n2.target = n1.target);
            const targetAnchor = (n2.targetAnchor = n1.targetAnchor);
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target);
            if (dynamicChildren) {
                // fast path when the teleport happens to be a block root
                patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
                // even in block tree mode we need to make sure all root-level nodes
                // in the teleport inherit previous DOM references so that they can
                // be moved in future patches.
                traverseStaticChildren(n1, n2, true);
            }
            else if (!optimized) {
                patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
                if (!wasDisabled) {
                    // enabled -> disabled
                    // move into main container
                    moveTeleport(n2, container, mainAnchor, internals, 1 /* TOGGLE */);
                }
            }
            else {
                // target changed
                if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                    const nextTarget = (n2.target = resolveTarget(n2.props, querySelector));
                    if (nextTarget) {
                        moveTeleport(n2, nextTarget, null, internals, 0 /* TARGET_CHANGE */);
                    }
                    else if ((true)) {
                        warn$1('Invalid Teleport target on update:', target, `(${typeof target})`);
                    }
                }
                else if (wasDisabled) {
                    // disabled -> enabled
                    // move into teleport target
                    moveTeleport(n2, target, targetAnchor, internals, 1 /* TOGGLE */);
                }
            }
        }
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
            hostRemove(targetAnchor);
        }
        // an unmounted teleport should always remove its children if not disabled
        if (doRemove || !isTeleportDisabled(props)) {
            hostRemove(anchor);
            if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
                for (let i = 0; i < children.length; i++) {
                    const child = children[i];
                    unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
                }
            }
        }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2 /* REORDER */) {
    // move target anchor if this is a target change.
    if (moveType === 0 /* TARGET_CHANGE */) {
        insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2 /* REORDER */;
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(el, container, parentAnchor);
    }
    // if this is a re-order and teleport is enabled (content is in target)
    // do not move children. So the opposite is: only move children if this
    // is not a reorder, or the teleport is disabled
    if (!isReorder || isTeleportDisabled(props)) {
        // Teleport has either Array children or no children.
        if (shapeFlag & 16 /* ARRAY_CHILDREN */) {
            for (let i = 0; i < children.length; i++) {
                move(children[i], container, parentAnchor, 2 /* REORDER */);
            }
        }
    }
    // move main view anchor if this is a re-order.
    if (isReorder) {
        insert(anchor, container, parentAnchor);
    }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target = (vnode.target = resolveTarget(vnode.props, querySelector));
    if (target) {
        // if multiple teleports rendered to the same target element, we need to
        // pick up from where the last teleport finished instead of the first node
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16 /* ARRAY_CHILDREN */) {
            if (isTeleportDisabled(vnode.props)) {
                vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
                vnode.targetAnchor = targetNode;
            }
            else {
                vnode.anchor = nextSibling(node);
                // lookahead until we find the target anchor
                // we cannot rely on return value of hydrateChildren() because there
                // could be nested teleports
                let targetAnchor = targetNode;
                while (targetAnchor) {
                    targetAnchor = nextSibling(targetAnchor);
                    if (targetAnchor &&
                        targetAnchor.nodeType === 8 &&
                        targetAnchor.data === 'teleport anchor') {
                        vnode.targetAnchor = targetAnchor;
                        target._lpa =
                            vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                        break;
                    }
                }
                hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
        }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
}
// Force-casted public typing for h and TSX props inference
const Teleport = TeleportImpl;

const normalizedAsyncComponentMap = new Map();
function convertLegacyAsyncComponent(comp) {
    if (normalizedAsyncComponentMap.has(comp)) {
        return normalizedAsyncComponentMap.get(comp);
    }
    // we have to call the function here due to how v2's API won't expose the
    // options until we call it
    let resolve;
    let reject;
    const fallbackPromise = new Promise((r, rj) => {
        (resolve = r), (reject = rj);
    });
    const res = comp(resolve, reject);
    let converted;
    if (isPromise(res)) {
        converted = defineAsyncComponent(() => res);
    }
    else if (isObject(res) && !isVNode(res) && !isArray(res)) {
        converted = defineAsyncComponent({
            loader: () => res.component,
            loadingComponent: res.loading,
            errorComponent: res.error,
            delay: res.delay,
            timeout: res.timeout
        });
    }
    else if (res == null) {
        converted = defineAsyncComponent(() => fallbackPromise);
    }
    else {
        converted = comp; // probably a v3 functional comp
    }
    normalizedAsyncComponentMap.set(comp, converted);
    return converted;
}

function convertLegacyComponent(comp, instance) {
    if (comp.__isBuiltIn) {
        return comp;
    }
    // 2.x constructor
    if (isFunction(comp) && comp.cid) {
        comp = comp.options;
    }
    // 2.x async component
    if (isFunction(comp) &&
        checkCompatEnabled("COMPONENT_ASYNC" /* COMPONENT_ASYNC */, instance, comp)) {
        // since after disabling this, plain functions are still valid usage, do not
        // use softAssert here.
        return convertLegacyAsyncComponent(comp);
    }
    // 2.x functional component
    if (isObject(comp) &&
        comp.functional &&
        softAssertCompatEnabled("COMPONENT_FUNCTIONAL" /* COMPONENT_FUNCTIONAL */, instance, comp)) {
        return convertLegacyFunctionalComponent(comp);
    }
    return comp;
}

const Fragment = Symbol(( true) ? 'Fragment' : 0);
const Text = Symbol(( true) ? 'Text' : 0);
const Comment = Symbol(( true) ? 'Comment' : 0);
const Static = Symbol(( true) ? 'Static' : 0);
// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
const blockStack = [];
let currentBlock = null;
/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */
function openBlock(disableTracking = false) {
    blockStack.push((currentBlock = disableTracking ? null : []));
}
function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
}
// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
let isBlockTreeEnabled = 1;
/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */
function setBlockTracking(value) {
    isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
    // save current block children on the block vnode
    vnode.dynamicChildren =
        isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    // close block
    closeBlock();
    // a block is always going to be patched, so track it as a child of its
    // parent block
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
    }
    return vnode;
}
/**
 * @private
 */
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */));
}
/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */
function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true /* isBlock: prevent a block from tracking itself */));
}
function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
    if (( true) &&
        n2.shapeFlag & 6 /* COMPONENT */ &&
        hmrDirtyComponents.has(n2.type)) {
        // HMR only: if the component has been hot-updated, force a reload.
        return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
}
let vnodeArgsTransformer;
/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */
function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
}
const createVNodeWithArgsTransform = (...args) => {
    return _createVNode(...(vnodeArgsTransformer
        ? vnodeArgsTransformer(args, currentRenderingInstance)
        : args));
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref, ref_key, ref_for }) => {
    return (ref != null
        ? isString(ref) || isRef(ref) || isFunction(ref)
            ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }
            : ref
        : null);
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1 /* ELEMENT */, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null
    };
    if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        // normalize suspense children
        if (shapeFlag & 128 /* SUSPENSE */) {
            type.normalize(vnode);
        }
    }
    else if (children) {
        // compiled element vnode - if children is passed, only possible types are
        // string or Array.
        vnode.shapeFlag |= isString(children)
            ? 8 /* TEXT_CHILDREN */
            : 16 /* ARRAY_CHILDREN */;
    }
    // validate key
    if (( true) && vnode.key !== vnode.key) {
        warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    // track vnode for block tree
    if (isBlockTreeEnabled > 0 &&
        // avoid a block node from tracking itself
        !isBlockNode &&
        // has current parent block
        currentBlock &&
        // presence of a patch flag indicates this node needs patching on updates.
        // component nodes also should always be patched, because even if the
        // component doesn't need to update, it needs to persist the instance on to
        // the next vnode so that it can be properly unmounted later.
        (vnode.patchFlag > 0 || shapeFlag & 6 /* COMPONENT */) &&
        // the EVENTS flag is only for hydration and if it is the only flag, the
        // vnode should not be considered dynamic due to handler caching.
        vnode.patchFlag !== 32 /* HYDRATE_EVENTS */) {
        currentBlock.push(vnode);
    }
    {
        convertLegacyVModelProps(vnode);
        defineLegacyVNodeProperties(vnode);
    }
    return vnode;
}
const createVNode = (( true) ? createVNodeWithArgsTransform : 0);
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
        if (( true) && !type) {
            warn$1(`Invalid vnode type when creating vnode: ${type}.`);
        }
        type = Comment;
    }
    if (isVNode(type)) {
        // createVNode receiving an existing vnode. This happens in cases like
        // <component :is="vnode"/>
        // #2078 make sure to merge refs during the clone instead of overwriting it
        const cloned = cloneVNode(type, props, true /* mergeRef: true */);
        if (children) {
            normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
            if (cloned.shapeFlag & 6 /* COMPONENT */) {
                currentBlock[currentBlock.indexOf(type)] = cloned;
            }
            else {
                currentBlock.push(cloned);
            }
        }
        cloned.patchFlag |= -2 /* BAIL */;
        return cloned;
    }
    // class component normalization.
    if (isClassComponent(type)) {
        type = type.__vccOpts;
    }
    // 2.x async/functional component compat
    {
        type = convertLegacyComponent(type, currentRenderingInstance);
    }
    // class & style normalization.
    if (props) {
        // for reactive or proxy objects, we need to clone it to enable mutation.
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString(klass)) {
            props.class = normalizeClass(klass);
        }
        if (isObject(style)) {
            // reactive state objects need to be cloned since they are likely to be
            // mutated
            if (isProxy(style) && !isArray(style)) {
                style = extend({}, style);
            }
            props.style = normalizeStyle(style);
        }
    }
    // encode the vnode type information into a bitmap
    const shapeFlag = isString(type)
        ? 1 /* ELEMENT */
        : isSuspense(type)
            ? 128 /* SUSPENSE */
            : isTeleport(type)
                ? 64 /* TELEPORT */
                : isObject(type)
                    ? 4 /* STATEFUL_COMPONENT */
                    : isFunction(type)
                        ? 2 /* FUNCTIONAL_COMPONENT */
                        : 0;
    if (( true) && shapeFlag & 4 /* STATEFUL_COMPONENT */ && isProxy(type)) {
        type = toRaw(type);
        warn$1(`Vue received a Component which was made a reactive object. This can ` +
            `lead to unnecessary performance overhead, and should be avoided by ` +
            `marking the component with \`markRaw\` or using \`shallowRef\` ` +
            `instead of \`ref\`.`, `\nComponent that was made reactive: `, type);
    }
    return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
    if (!props)
        return null;
    return isProxy(props) || InternalObjectKey in props
        ? extend({}, props)
        : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
    // This is intentionally NOT using spread or extend to avoid the runtime
    // key enumeration cost.
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref
            ? // #2078 in the case of <component :is="vnode" ref="extra"/>
                // if the vnode itself already has a ref, cloneVNode will need to merge
                // the refs so the single vnode can be set on multiple refs
                mergeRef && ref
                    ? isArray(ref)
                        ? ref.concat(normalizeRef(extraProps))
                        : [ref, normalizeRef(extraProps)]
                    : normalizeRef(extraProps)
            : ref,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: ( true) && patchFlag === -1 /* HOISTED */ && isArray(children)
            ? children.map(deepCloneVNode)
            : children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment
            ? patchFlag === -1 // hoisted node
                ? 16 /* FULL_PROPS */
                : patchFlag | 16 /* FULL_PROPS */
            : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor
    };
    {
        defineLegacyVNodeProperties(cloned);
    }
    return cloned;
}
/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */
function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
        cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
}
/**
 * @private
 */
function createTextVNode(text = ' ', flag = 0) {
    return createVNode(Text, null, text, flag);
}
/**
 * @private
 */
function createStaticVNode(content, numberOfNodes) {
    // A static vnode can contain multiple stringified elements, and the number
    // of elements is necessary for hydration.
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
}
/**
 * @private
 */
function createCommentVNode(text = '', 
// when used as the v-else branch, the comment node must be created as a
// block to ensure correct updates.
asBlock = false) {
    return asBlock
        ? (openBlock(), createBlock(Comment, null, text))
        : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
    if (child == null || typeof child === 'boolean') {
        // empty placeholder
        return createVNode(Comment);
    }
    else if (isArray(child)) {
        // fragment
        return createVNode(Fragment, null, 
        // #3666, avoid reference pollution when reusing vnode
        child.slice());
    }
    else if (typeof child === 'object') {
        // already vnode, this should be the most common since compiled templates
        // always produce all-vnode children arrays
        return cloneIfMounted(child);
    }
    else {
        // strings and numbers
        return createVNode(Text, null, String(child));
    }
}
// optimized normalization for template-compiled render fns
function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
        children = null;
    }
    else if (isArray(children)) {
        type = 16 /* ARRAY_CHILDREN */;
    }
    else if (typeof children === 'object') {
        if (shapeFlag & (1 /* ELEMENT */ | 64 /* TELEPORT */)) {
            // Normalize slot to plain children for plain element and Teleport
            const slot = children.default;
            if (slot) {
                // _c marker is added by withCtx() indicating this is a compiled slot
                slot._c && (slot._d = false);
                normalizeChildren(vnode, slot());
                slot._c && (slot._d = true);
            }
            return;
        }
        else {
            type = 32 /* SLOTS_CHILDREN */;
            const slotFlag = children._;
            if (!slotFlag && !(InternalObjectKey in children)) {
                children._ctx = currentRenderingInstance;
            }
            else if (slotFlag === 3 /* FORWARDED */ && currentRenderingInstance) {
                // a child component receives forwarded slots from the parent.
                // its slot type is determined by its parent's slot type.
                if (currentRenderingInstance.slots._ === 1 /* STABLE */) {
                    children._ = 1 /* STABLE */;
                }
                else {
                    children._ = 2 /* DYNAMIC */;
                    vnode.patchFlag |= 1024 /* DYNAMIC_SLOTS */;
                }
            }
        }
    }
    else if (isFunction(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32 /* SLOTS_CHILDREN */;
    }
    else {
        children = String(children);
        // force teleport children to array so it can be moved around
        if (shapeFlag & 64 /* TELEPORT */) {
            type = 16 /* ARRAY_CHILDREN */;
            children = [createTextVNode(children)];
        }
        else {
            type = 8 /* TEXT_CHILDREN */;
        }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
}
function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
            if (key === 'class') {
                if (ret.class !== toMerge.class) {
                    ret.class = normalizeClass([ret.class, toMerge.class]);
                }
            }
            else if (key === 'style') {
                ret.style = normalizeStyle([ret.style, toMerge.style]);
            }
            else if (isOn(key)) {
                const existing = ret[key];
                const incoming = toMerge[key];
                if (incoming &&
                    existing !== incoming &&
                    !(isArray(existing) && existing.includes(incoming))) {
                    ret[key] = existing
                        ? [].concat(existing, incoming)
                        : incoming;
                }
            }
            else if (key !== '') {
                ret[key] = toMerge[key];
            }
        }
    }
    return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7 /* VNODE_HOOK */, [
        vnode,
        prevVNode
    ]);
}

const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    // inherit parent app context - or - if root, adopt from root vnode
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
        uid: uid$1++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        scope: new EffectScope(true /* detached */),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    if ((true)) {
        instance.ctx = createDevRenderContext(instance);
    }
    else {}
    instance.root = parent ? parent.root : instance;
    instance.emit = emit$2.bind(null, instance);
    // apply custom element special handling
    if (vnode.ce) {
        vnode.ce(instance);
    }
    return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
    currentInstance = instance;
    instance.scope.on();
};
const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    currentInstance = null;
};
const isBuiltInTag = /*#__PURE__*/ makeMap('slot,component');
function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
        warn$1('Do not use built-in or reserved HTML elements as component id: ' + name);
    }
}
function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4 /* STATEFUL_COMPONENT */;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful
        ? setupStatefulComponent(instance, isSSR)
        : undefined;
    isInSSRComponentSetup = false;
    return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
    var _a;
    const Component = instance.type;
    if ((true)) {
        if (Component.name) {
            validateComponentName(Component.name, instance.appContext.config);
        }
        if (Component.components) {
            const names = Object.keys(Component.components);
            for (let i = 0; i < names.length; i++) {
                validateComponentName(names[i], instance.appContext.config);
            }
        }
        if (Component.directives) {
            const names = Object.keys(Component.directives);
            for (let i = 0; i < names.length; i++) {
                validateDirectiveName(names[i]);
            }
        }
        if (Component.compilerOptions && isRuntimeOnly()) {
            warn$1(`"compilerOptions" is only supported when using a build of Vue that ` +
                `includes the runtime compiler. Since you are using a runtime-only ` +
                `build, the options should be passed via your build tool config instead.`);
        }
    }
    // 0. create render proxy property access cache
    instance.accessCache = Object.create(null);
    // 1. create public instance / render proxy
    // also mark it raw so it's never observed
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if ((true)) {
        exposePropsOnRenderContext(instance);
    }
    // 2. call setup()
    const { setup } = Component;
    if (setup) {
        const setupContext = (instance.setupContext =
            setup.length > 1 ? createSetupContext(instance) : null);
        setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(setup, instance, 0 /* SETUP_FUNCTION */, [( true) ? shallowReadonly(instance.props) : 0, setupContext]);
        resetTracking();
        unsetCurrentInstance();
        if (isPromise(setupResult)) {
            setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
            if (isSSR) {
                // return the promise so server-renderer can wait on it
                return setupResult
                    .then((resolvedResult) => {
                    handleSetupResult(instance, resolvedResult, isSSR);
                })
                    .catch(e => {
                    handleError(e, instance, 0 /* SETUP_FUNCTION */);
                });
            }
            else {
                // async setup returned Promise.
                // bail here and wait for re-entry.
                instance.asyncDep = setupResult;
                if (( true) && !instance.suspense) {
                    const name = (_a = Component.name) !== null && _a !== void 0 ? _a : 'Anonymous';
                    warn$1(`Component <${name}>: setup function returned a promise, but no ` +
                        `<Suspense> boundary was found in the parent component tree. ` +
                        `A component with async setup() must be nested in a <Suspense> ` +
                        `in order to be rendered.`);
                }
            }
        }
        else {
            handleSetupResult(instance, setupResult, isSSR);
        }
    }
    else {
        finishComponentSetup(instance, isSSR);
    }
}
function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
        // setup returned an inline render function
        if (instance.type.__ssrInlineRender) {
            // when the function's name is `ssrRender` (compiled by SFC inline mode),
            // set it as ssrRender instead.
            instance.ssrRender = setupResult;
        }
        else {
            instance.render = setupResult;
        }
    }
    else if (isObject(setupResult)) {
        if (( true) && isVNode(setupResult)) {
            warn$1(`setup() should not return VNodes directly - ` +
                `return a render function instead.`);
        }
        // setup returned bindings.
        // assuming a render function compiled from template is present.
        if (true) {
            instance.devtoolsRawSetupState = setupResult;
        }
        instance.setupState = proxyRefs(setupResult);
        if ((true)) {
            exposeSetupStateOnRenderContext(instance);
        }
    }
    else if (( true) && setupResult !== undefined) {
        warn$1(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
}
let compile;
let installWithProxy;
/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */
function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = i => {
        if (i.render._rc) {
            i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
    };
}
// dev only
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    {
        convertLegacyRenderFn(instance);
        if (( true) && Component.compatConfig) {
            validateCompatConfig(Component.compatConfig);
        }
    }
    // template / render function normalization
    // could be already set when returned from setup()
    if (!instance.render) {
        // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
        // is done by server-renderer
        if (!isSSR && compile && !Component.render) {
            const template = (instance.vnode.props &&
                instance.vnode.props['inline-template']) ||
                Component.template;
            if (template) {
                if ((true)) {
                    startMeasure(instance, `compile`);
                }
                const { isCustomElement, compilerOptions } = instance.appContext.config;
                const { delimiters, compilerOptions: componentCompilerOptions } = Component;
                const finalCompilerOptions = extend(extend({
                    isCustomElement,
                    delimiters
                }, compilerOptions), componentCompilerOptions);
                {
                    // pass runtime compat config into the compiler
                    finalCompilerOptions.compatConfig = Object.create(globalCompatConfig);
                    if (Component.compatConfig) {
                        extend(finalCompilerOptions.compatConfig, Component.compatConfig);
                    }
                }
                Component.render = compile(template, finalCompilerOptions);
                if ((true)) {
                    endMeasure(instance, `compile`);
                }
            }
        }
        instance.render = (Component.render || NOOP);
        // for runtime-compiled render functions using `with` blocks, the render
        // proxy used needs a different `has` handler which is more performant and
        // also only allows a whitelist of globals to fallthrough.
        if (installWithProxy) {
            installWithProxy(instance);
        }
    }
    // support for 2.x options
    if ( true && !(skipOptions)) {
        setCurrentInstance(instance);
        pauseTracking();
        applyOptions(instance);
        resetTracking();
        unsetCurrentInstance();
    }
    // warn missing template/render
    // the runtime compilation of template in SSR is done by server-render
    if (( true) && !Component.render && instance.render === NOOP && !isSSR) {
        /* istanbul ignore if */
        if (!compile && Component.template) {
            warn$1(`Component provided template option but ` +
                `runtime compilation is not supported in this build of Vue.` +
                (` Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
                    ) /* should not happen */);
        }
        else {
            warn$1(`Component is missing template or render function.`);
        }
    }
}
function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, ( true)
        ? {
            get(target, key) {
                markAttrsAccessed();
                track(instance, "get" /* GET */, '$attrs');
                return target[key];
            },
            set() {
                warn$1(`setupContext.attrs is readonly.`);
                return false;
            },
            deleteProperty() {
                warn$1(`setupContext.attrs is readonly.`);
                return false;
            }
        }
        : 0);
}
function createSetupContext(instance) {
    const expose = exposed => {
        if (( true) && instance.exposed) {
            warn$1(`expose() should be called only once per setup().`);
        }
        instance.exposed = exposed || {};
    };
    let attrs;
    if ((true)) {
        // We use getters in dev in case libs like test-utils overwrite instance
        // properties (overwrites should not be done in prod)
        return Object.freeze({
            get attrs() {
                return attrs || (attrs = createAttrsProxy(instance));
            },
            get slots() {
                return shallowReadonly(instance.slots);
            },
            get emit() {
                return (event, ...args) => instance.emit(event, ...args);
            },
            expose
        });
    }
    else {}
}
function getExposeProxy(instance) {
    if (instance.exposed) {
        return (instance.exposeProxy ||
            (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
                get(target, key) {
                    if (key in target) {
                        return target[key];
                    }
                    else if (key in publicPropertiesMap) {
                        return publicPropertiesMap[key](instance);
                    }
                }
            })));
    }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
function getComponentName(Component, includeInferred = true) {
    return isFunction(Component)
        ? Component.displayName || Component.name
        : Component.name || (includeInferred && Component.__name);
}
/* istanbul ignore next */
function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
            name = match[1];
        }
    }
    if (!name && instance && instance.parent) {
        // try to infer the name based on reverse resolution
        const inferFromRegistry = (registry) => {
            for (const key in registry) {
                if (registry[key] === Component) {
                    return key;
                }
            }
        };
        name =
            inferFromRegistry(instance.components ||
                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
    return isFunction(value) && '__vccOpts' in value;
}

const computed$1 = ((getterOrOptions, debugOptions) => {
    // @ts-ignore
    return computed(getterOrOptions, debugOptions, isInSSRComponentSetup);
});

// dev only
const warnRuntimeUsage = (method) => warn$1(`${method}() is a compiler-hint helper that is only usable inside ` +
    `<script setup> of a single file component. Its arguments should be ` +
    `compiled away and passing it at runtime has no effect.`);
// implementation
function defineProps() {
    if ((true)) {
        warnRuntimeUsage(`defineProps`);
    }
    return null;
}
// implementation
function defineEmits() {
    if ((true)) {
        warnRuntimeUsage(`defineEmits`);
    }
    return null;
}
/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */
function defineExpose(exposed) {
    if ((true)) {
        warnRuntimeUsage(`defineExpose`);
    }
}
/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */
function withDefaults(props, defaults) {
    if ((true)) {
        warnRuntimeUsage(`withDefaults`);
    }
    return null;
}
function useSlots() {
    return getContext().slots;
}
function useAttrs() {
    return getContext().attrs;
}
function getContext() {
    const i = getCurrentInstance();
    if (( true) && !i) {
        warn$1(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = isArray(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if (isArray(opt) || isFunction(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else if ((true)) {
            warn$1(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}
/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */
function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
        if (!excludedKeys.includes(key)) {
            Object.defineProperty(ret, key, {
                enumerable: true,
                get: () => props[key]
            });
        }
    }
    return ret;
}
/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */
function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (( true) && !ctx) {
        warn$1(`withAsyncContext called without active current instance. ` +
            `This is likely a bug.`);
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (isPromise(awaitable)) {
        awaitable = awaitable.catch(e => {
            setCurrentInstance(ctx);
            throw e;
        });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
}

// Actual implementation
function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
        if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
            // single vnode without props
            if (isVNode(propsOrChildren)) {
                return createVNode(type, null, [propsOrChildren]);
            }
            // props without children
            return createVNode(type, propsOrChildren);
        }
        else {
            // omit props
            return createVNode(type, null, propsOrChildren);
        }
    }
    else {
        if (l > 3) {
            children = Array.prototype.slice.call(arguments, 2);
        }
        else if (l === 3 && isVNode(children)) {
            children = [children];
        }
        return createVNode(type, propsOrChildren, children);
    }
}

const ssrContextKey = Symbol(( true) ? `ssrContext` : 0);
const useSSRContext = () => {
    {
        const ctx = inject(ssrContextKey);
        if (!ctx) {
            warn$1(`Server rendering context not provided. Make sure to only call ` +
                `useSSRContext() conditionally in the server build.`);
        }
        return ctx;
    }
};

function initCustomFormatter() {
    /* eslint-disable no-restricted-globals */
    if ( false || typeof window === 'undefined') {
        return;
    }
    const vueStyle = { style: 'color:#3ba776' };
    const numberStyle = { style: 'color:#0b1bc9' };
    const stringStyle = { style: 'color:#b62e24' };
    const keywordStyle = { style: 'color:#9d288c' };
    // custom formatter for Chrome
    // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
    const formatter = {
        header(obj) {
            // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
            if (!isObject(obj)) {
                return null;
            }
            if (obj.__isVue) {
                return ['div', vueStyle, `VueInstance`];
            }
            else if (isRef(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, genRefFlag(obj)],
                    '<',
                    formatValue(obj.value),
                    `>`
                ];
            }
            else if (isReactive(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],
                    '<',
                    formatValue(obj),
                    `>${isReadonly(obj) ? ` (readonly)` : ``}`
                ];
            }
            else if (isReadonly(obj)) {
                return [
                    'div',
                    {},
                    ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],
                    '<',
                    formatValue(obj),
                    '>'
                ];
            }
            return null;
        },
        hasBody(obj) {
            return obj && obj.__isVue;
        },
        body(obj) {
            if (obj && obj.__isVue) {
                return [
                    'div',
                    {},
                    ...formatInstance(obj.$)
                ];
            }
        }
    };
    function formatInstance(instance) {
        const blocks = [];
        if (instance.type.props && instance.props) {
            blocks.push(createInstanceBlock('props', toRaw(instance.props)));
        }
        if (instance.setupState !== EMPTY_OBJ) {
            blocks.push(createInstanceBlock('setup', instance.setupState));
        }
        if (instance.data !== EMPTY_OBJ) {
            blocks.push(createInstanceBlock('data', toRaw(instance.data)));
        }
        const computed = extractKeys(instance, 'computed');
        if (computed) {
            blocks.push(createInstanceBlock('computed', computed));
        }
        const injected = extractKeys(instance, 'inject');
        if (injected) {
            blocks.push(createInstanceBlock('injected', injected));
        }
        blocks.push([
            'div',
            {},
            [
                'span',
                {
                    style: keywordStyle.style + ';opacity:0.66'
                },
                '$ (internal): '
            ],
            ['object', { object: instance }]
        ]);
        return blocks;
    }
    function createInstanceBlock(type, target) {
        target = extend({}, target);
        if (!Object.keys(target).length) {
            return ['span', {}];
        }
        return [
            'div',
            { style: 'line-height:1.25em;margin-bottom:0.6em' },
            [
                'div',
                {
                    style: 'color:#476582'
                },
                type
            ],
            [
                'div',
                {
                    style: 'padding-left:1.25em'
                },
                ...Object.keys(target).map(key => {
                    return [
                        'div',
                        {},
                        ['span', keywordStyle, key + ': '],
                        formatValue(target[key], false)
                    ];
                })
            ]
        ];
    }
    function formatValue(v, asRaw = true) {
        if (typeof v === 'number') {
            return ['span', numberStyle, v];
        }
        else if (typeof v === 'string') {
            return ['span', stringStyle, JSON.stringify(v)];
        }
        else if (typeof v === 'boolean') {
            return ['span', keywordStyle, v];
        }
        else if (isObject(v)) {
            return ['object', { object: asRaw ? toRaw(v) : v }];
        }
        else {
            return ['span', stringStyle, String(v)];
        }
    }
    function extractKeys(instance, type) {
        const Comp = instance.type;
        if (isFunction(Comp)) {
            return;
        }
        const extracted = {};
        for (const key in instance.ctx) {
            if (isKeyOfType(Comp, key, type)) {
                extracted[key] = instance.ctx[key];
            }
        }
        return extracted;
    }
    function isKeyOfType(Comp, key, type) {
        const opts = Comp[type];
        if ((isArray(opts) && opts.includes(key)) ||
            (isObject(opts) && key in opts)) {
            return true;
        }
        if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
            return true;
        }
        if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {
            return true;
        }
    }
    function genRefFlag(v) {
        if (isShallow(v)) {
            return `ShallowRef`;
        }
        if (v.effect) {
            return `ComputedRef`;
        }
        return `Ref`;
    }
    if (window.devtoolsFormatters) {
        window.devtoolsFormatters.push(formatter);
    }
    else {
        window.devtoolsFormatters = [formatter];
    }
}

function withMemo(memo, render, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
        return cached;
    }
    const ret = render();
    // shallow clone
    ret.memo = memo.slice();
    return (cache[index] = ret);
}
function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
        return false;
    }
    for (let i = 0; i < prev.length; i++) {
        if (hasChanged(prev[i], memo[i])) {
            return false;
        }
    }
    // make sure to let parent block track it when returning cached
    if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
    }
    return true;
}

// Core API ------------------------------------------------------------------
const version = "3.2.37";
const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode
};
/**
 * SSR utils for \@vue/server-renderer. Only exposed in ssr-possible builds.
 * @internal
 */
const ssrUtils = (_ssrUtils );
/**
 * @internal only exposed in compat builds
 */
const resolveFilter$1 = resolveFilter ;
const _compatUtils = {
    warnDeprecation,
    createCompatVue,
    isCompatEnabled,
    checkCompatEnabled,
    softAssertCompatEnabled
};
/**
 * @internal only exposed in compat builds.
 */
const compatUtils = (_compatUtils );

const svgNS = 'http://www.w3.org/2000/svg';
const doc = (typeof document !== 'undefined' ? document : null);
const templateContainer = doc && /*#__PURE__*/ doc.createElement('template');
const nodeOps = {
    insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
    },
    remove: child => {
        const parent = child.parentNode;
        if (parent) {
            parent.removeChild(child);
        }
    },
    createElement: (tag, isSVG, is, props) => {
        const el = isSVG
            ? doc.createElementNS(svgNS, tag)
            : doc.createElement(tag, is ? { is } : undefined);
        if (tag === 'select' && props && props.multiple != null) {
            el.setAttribute('multiple', props.multiple);
        }
        return el;
    },
    createText: text => doc.createTextNode(text),
    createComment: text => doc.createComment(text),
    setText: (node, text) => {
        node.nodeValue = text;
    },
    setElementText: (el, text) => {
        el.textContent = text;
    },
    parentNode: node => node.parentNode,
    nextSibling: node => node.nextSibling,
    querySelector: selector => doc.querySelector(selector),
    setScopeId(el, id) {
        el.setAttribute(id, '');
    },
    cloneNode(el) {
        const cloned = el.cloneNode(true);
        // #3072
        // - in `patchDOMProp`, we store the actual value in the `el._value` property.
        // - normally, elements using `:value` bindings will not be hoisted, but if
        //   the bound value is a constant, e.g. `:value="true"` - they do get
        //   hoisted.
        // - in production, hoisted nodes are cloned when subsequent inserts, but
        //   cloneNode() does not copy the custom property we attached.
        // - This may need to account for other custom DOM properties we attach to
        //   elements in addition to `_value` in the future.
        if (`_value` in el) {
            cloned._value = el._value;
        }
        return cloned;
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, isSVG, start, end) {
        // <parent> before | first ... last | anchor </parent>
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        // #5308 can only take cached path if:
        // - has a single root node
        // - nextSibling info is still available
        if (start && (start === end || start.nextSibling)) {
            // cached
            while (true) {
                parent.insertBefore(start.cloneNode(true), anchor);
                if (start === end || !(start = start.nextSibling))
                    break;
            }
        }
        else {
            // fresh insert
            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            const template = templateContainer.content;
            if (isSVG) {
                // remove outer svg wrapper
                const wrapper = template.firstChild;
                while (wrapper.firstChild) {
                    template.appendChild(wrapper.firstChild);
                }
                template.removeChild(wrapper);
            }
            parent.insertBefore(template, anchor);
        }
        return [
            // first
            before ? before.nextSibling : parent.firstChild,
            // last
            anchor ? anchor.previousSibling : parent.lastChild
        ];
    }
};

// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el, value, isSVG) {
    // directly setting className should be faster than setAttribute in theory
    // if this is an element during a transition, take the temporary transition
    // classes into account.
    const transitionClasses = el._vtc;
    if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');
    }
    if (value == null) {
        el.removeAttribute('class');
    }
    else if (isSVG) {
        el.setAttribute('class', value);
    }
    else {
        el.className = value;
    }
}

function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    if (next && !isCssString) {
        for (const key in next) {
            setStyle(style, key, next[key]);
        }
        if (prev && !isString(prev)) {
            for (const key in prev) {
                if (next[key] == null) {
                    setStyle(style, key, '');
                }
            }
        }
    }
    else {
        const currentDisplay = style.display;
        if (isCssString) {
            if (prev !== next) {
                style.cssText = next;
            }
        }
        else if (prev) {
            el.removeAttribute('style');
        }
        // indicates that the `display` of the element is controlled by `v-show`,
        // so we always keep the current `display` value regardless of the `style`
        // value, thus handing over control to `v-show`.
        if ('_vod' in el) {
            style.display = currentDisplay;
        }
    }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
    if (isArray(val)) {
        val.forEach(v => setStyle(style, name, v));
    }
    else {
        if (val == null)
            val = '';
        if (name.startsWith('--')) {
            // custom property definition
            style.setProperty(name, val);
        }
        else {
            const prefixed = autoPrefix(style, name);
            if (importantRE.test(val)) {
                // !important
                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');
            }
            else {
                style[prefixed] = val;
            }
        }
    }
}
const prefixes = ['Webkit', 'Moz', 'ms'];
const prefixCache = {};
function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
        return cached;
    }
    let name = camelize(rawName);
    if (name !== 'filter' && name in style) {
        return (prefixCache[rawName] = name);
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
            return (prefixCache[rawName] = prefixed);
        }
    }
    return rawName;
}

const xlinkNS = 'http://www.w3.org/1999/xlink';
function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith('xlink:')) {
        if (value == null) {
            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        if (compatCoerceAttr(el, key, value, instance)) {
            return;
        }
        // note we are only checking boolean attributes that don't have a
        // corresponding dom prop of the same name here.
        const isBoolean = isSpecialBooleanAttr(key);
        if (value == null || (isBoolean && !includeBooleanAttr(value))) {
            el.removeAttribute(key);
        }
        else {
            el.setAttribute(key, isBoolean ? '' : value);
        }
    }
}
// 2.x compat
const isEnumeratedAttr = /*#__PURE__*/ makeMap('contenteditable,draggable,spellcheck')
    ;
function compatCoerceAttr(el, key, value, instance = null) {
    if (isEnumeratedAttr(key)) {
        const v2CocercedValue = value === null
            ? 'false'
            : typeof value !== 'boolean' && value !== undefined
                ? 'true'
                : null;
        if (v2CocercedValue &&
            compatUtils.softAssertCompatEnabled("ATTR_ENUMERATED_COERCION" /* ATTR_ENUMERATED_COERCION */, instance, key, value, v2CocercedValue)) {
            el.setAttribute(key, v2CocercedValue);
            return true;
        }
    }
    else if (value === false &&
        !isSpecialBooleanAttr(key) &&
        compatUtils.softAssertCompatEnabled("ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */, instance, key)) {
        el.removeAttribute(key);
        return true;
    }
    return false;
}

// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el, key, value, 
// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === 'innerHTML' || key === 'textContent') {
        if (prevChildren) {
            unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? '' : value;
        return;
    }
    if (key === 'value' &&
        el.tagName !== 'PROGRESS' &&
        // custom elements may use _value internally
        !el.tagName.includes('-')) {
        // store value as _value as well since
        // non-string values will be stringified.
        el._value = value;
        const newValue = value == null ? '' : value;
        if (el.value !== newValue ||
            // #4956: always set for OPTION elements because its value falls back to
            // textContent if no value attribute is present. And setting .value for
            // OPTION has no side effect
            el.tagName === 'OPTION') {
            el.value = newValue;
        }
        if (value == null) {
            el.removeAttribute(key);
        }
        return;
    }
    let needRemove = false;
    if (value === '' || value == null) {
        const type = typeof el[key];
        if (type === 'boolean') {
            // e.g. <select multiple> compiles to { multiple: '' }
            value = includeBooleanAttr(value);
        }
        else if (value == null && type === 'string') {
            // e.g. <div :id="null">
            value = '';
            needRemove = true;
        }
        else if (type === 'number') {
            // e.g. <img :width="null">
            // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
            value = 0;
            needRemove = true;
        }
    }
    else {
        if (value === false &&
            compatUtils.isCompatEnabled("ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */, parentComponent)) {
            const type = typeof el[key];
            if (type === 'string' || type === 'number') {
                ( true) &&
                    compatUtils.warnDeprecation("ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */, parentComponent, key);
                value = type === 'number' ? 0 : '';
                needRemove = true;
            }
        }
    }
    // some properties perform value validation and throw,
    // some properties has getter, no setter, will error in 'use strict'
    // eg. <select :type="null"></select> <select :willValidate="null"></select>
    try {
        el[key] = value;
    }
    catch (e) {
        if ((true)) {
            warn$1(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: ` +
                `value ${value} is invalid.`, e);
        }
    }
    needRemove && el.removeAttribute(key);
}

// Async edge case fix requires storing an event listener's attach timestamp.
const [_getNow, skipTimestampCheck] = /*#__PURE__*/ (() => {
    let _getNow = Date.now;
    let skipTimestampCheck = false;
    if (typeof window !== 'undefined') {
        // Determine what event timestamp the browser is using. Annoyingly, the
        // timestamp can either be hi-res (relative to page load) or low-res
        // (relative to UNIX epoch), so in order to compare time we have to use the
        // same timestamp type when saving the flush timestamp.
        if (Date.now() > document.createEvent('Event').timeStamp) {
            // if the low-res timestamp which is bigger than the event timestamp
            // (which is evaluated AFTER) it means the event is using a hi-res timestamp,
            // and we need to use the hi-res version for event listeners as well.
            _getNow = performance.now.bind(performance);
        }
        // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
        // and does not fire microtasks in between event propagation, so safe to exclude.
        const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
        skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
    }
    return [_getNow, skipTimestampCheck];
})();
// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
let cachedNow = 0;
const p = /*#__PURE__*/ Promise.resolve();
const reset = () => {
    cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()));
function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    // vei = vue event invokers
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
        // patch
        existingInvoker.value = nextValue;
    }
    else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
            // add
            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));
            addEventListener(el, name, invoker, options);
        }
        else if (existingInvoker) {
            // remove
            removeEventListener(el, name, existingInvoker, options);
            invokers[rawName] = undefined;
        }
    }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while ((m = name.match(optionsModifierRE))) {
            name = name.slice(0, name.length - m[0].length);
            options[m[0].toLowerCase()] = true;
        }
    }
    return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
    const invoker = (e) => {
        // async edge case #6566: inner click event triggers patch, event handler
        // attached to outer element during patch, and triggered again. This
        // happens because browsers fire microtask ticks between event propagation.
        // the solution is simple: we save the timestamp when a handler is attached,
        // and the handler would only fire if the event passed to it was fired
        // AFTER it was attached.
        const timeStamp = e.timeStamp || _getNow();
        if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
            callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* NATIVE_EVENT_HANDLER */, [e]);
        }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
}
function patchStopImmediatePropagation(e, value) {
    if (isArray(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
            originalStop.call(e);
            e._stopped = true;
        };
        return value.map(fn => (e) => !e._stopped && fn && fn(e));
    }
    else {
        return value;
    }
}

const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    if (key === 'class') {
        patchClass(el, nextValue, isSVG);
    }
    else if (key === 'style') {
        patchStyle(el, prevValue, nextValue);
    }
    else if (isOn(key)) {
        // ignore v-model listeners
        if (!isModelListener(key)) {
            patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
    }
    else if (key[0] === '.'
        ? ((key = key.slice(1)), true)
        : key[0] === '^'
            ? ((key = key.slice(1)), false)
            : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
    }
    else {
        // special case for <input v-model type="checkbox"> with
        // :true-value & :false-value
        // store value as dom properties since non-string values will be
        // stringified.
        if (key === 'true-value') {
            el._trueValue = nextValue;
        }
        else if (key === 'false-value') {
            el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG, parentComponent);
    }
};
function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
        // most keys must be set as attribute on svg elements to work
        // ...except innerHTML & textContent
        if (key === 'innerHTML' || key === 'textContent') {
            return true;
        }
        // or native onclick with function values
        if (key in el && nativeOnRE.test(key) && isFunction(value)) {
            return true;
        }
        return false;
    }
    // these are enumerated attrs, however their corresponding DOM properties
    // are actually booleans - this leads to setting it with a string "false"
    // value leading it to be coerced to `true`, so we need to always treat
    // them as attributes.
    // Note that `contentEditable` doesn't have this problem: its DOM
    // property is also enumerated string values.
    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {
        return false;
    }
    // #1787, #2840 form property on form elements is readonly and must be set as
    // attribute.
    if (key === 'form') {
        return false;
    }
    // #1526 <input list> must be set as attribute
    if (key === 'list' && el.tagName === 'INPUT') {
        return false;
    }
    // #2766 <textarea type> must be set as attribute
    if (key === 'type' && el.tagName === 'TEXTAREA') {
        return false;
    }
    // native onclick with string value, must be set as attribute
    if (nativeOnRE.test(key) && isString(value)) {
        return false;
    }
    return key in el;
}

function defineCustomElement(options, hydrate) {
    const Comp = defineComponent(options);
    class VueCustomElement extends VueElement {
        constructor(initialProps) {
            super(Comp, initialProps, hydrate);
        }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
}
const defineSSRCustomElement = ((options) => {
    // @ts-ignore
    return defineCustomElement(options, hydrate);
});
const BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {
});
class VueElement extends BaseClass {
    constructor(_def, _props = {}, hydrate) {
        super();
        this._def = _def;
        this._props = _props;
        /**
         * @internal
         */
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        if (this.shadowRoot && hydrate) {
            hydrate(this._createVNode(), this.shadowRoot);
        }
        else {
            if (( true) && this.shadowRoot) {
                warn$1(`Custom element has pre-rendered declarative shadow root but is not ` +
                    `defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: 'open' });
        }
    }
    connectedCallback() {
        this._connected = true;
        if (!this._instance) {
            this._resolveDef();
        }
    }
    disconnectedCallback() {
        this._connected = false;
        nextTick(() => {
            if (!this._connected) {
                render(null, this.shadowRoot);
                this._instance = null;
            }
        });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
        if (this._resolved) {
            return;
        }
        this._resolved = true;
        // set initial attrs
        for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
        }
        // watch future attr changes
        new MutationObserver(mutations => {
            for (const m of mutations) {
                this._setAttr(m.attributeName);
            }
        }).observe(this, { attributes: true });
        const resolve = (def) => {
            const { props, styles } = def;
            const hasOptions = !isArray(props);
            const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : [];
            // cast Number-type props set before resolve
            let numberProps;
            if (hasOptions) {
                for (const key in this._props) {
                    const opt = props[key];
                    if (opt === Number || (opt && opt.type === Number)) {
                        this._props[key] = toNumber(this._props[key]);
                        (numberProps || (numberProps = Object.create(null)))[key] = true;
                    }
                }
            }
            this._numberProps = numberProps;
            // check if there are props set pre-upgrade or connect
            for (const key of Object.keys(this)) {
                if (key[0] !== '_') {
                    this._setProp(key, this[key], true, false);
                }
            }
            // defining getter/setters on prototype
            for (const key of rawKeys.map(camelize)) {
                Object.defineProperty(this, key, {
                    get() {
                        return this._getProp(key);
                    },
                    set(val) {
                        this._setProp(key, val);
                    }
                });
            }
            // apply CSS
            this._applyStyles(styles);
            // initial render
            this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
            asyncDef().then(resolve);
        }
        else {
            resolve(this._def);
        }
    }
    _setAttr(key) {
        let value = this.getAttribute(key);
        if (this._numberProps && this._numberProps[key]) {
            value = toNumber(value);
        }
        this._setProp(camelize(key), value, false);
    }
    /**
     * @internal
     */
    _getProp(key) {
        return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key]) {
            this._props[key] = val;
            if (shouldUpdate && this._instance) {
                this._update();
            }
            // reflect
            if (shouldReflect) {
                if (val === true) {
                    this.setAttribute(hyphenate(key), '');
                }
                else if (typeof val === 'string' || typeof val === 'number') {
                    this.setAttribute(hyphenate(key), val + '');
                }
                else if (!val) {
                    this.removeAttribute(hyphenate(key));
                }
            }
        }
    }
    _update() {
        render(this._createVNode(), this.shadowRoot);
    }
    _createVNode() {
        const vnode = createVNode(this._def, extend({}, this._props));
        if (!this._instance) {
            vnode.ce = instance => {
                this._instance = instance;
                instance.isCE = true;
                // HMR
                if ((true)) {
                    instance.ceReload = newStyles => {
                        // always reset styles
                        if (this._styles) {
                            this._styles.forEach(s => this.shadowRoot.removeChild(s));
                            this._styles.length = 0;
                        }
                        this._applyStyles(newStyles);
                        // if this is an async component, ceReload is called from the inner
                        // component so no need to reload the async wrapper
                        if (!this._def.__asyncLoader) {
                            // reload
                            this._instance = null;
                            this._update();
                        }
                    };
                }
                // intercept emit
                instance.emit = (event, ...args) => {
                    this.dispatchEvent(new CustomEvent(event, {
                        detail: args
                    }));
                };
                // locate nearest Vue custom element parent for provide/inject
                let parent = this;
                while ((parent =
                    parent && (parent.parentNode || parent.host))) {
                    if (parent instanceof VueElement) {
                        instance.parent = parent._instance;
                        break;
                    }
                }
            };
        }
        return vnode;
    }
    _applyStyles(styles) {
        if (styles) {
            styles.forEach(css => {
                const s = document.createElement('style');
                s.textContent = css;
                this.shadowRoot.appendChild(s);
                // record for HMR
                if ((true)) {
                    (this._styles || (this._styles = [])).push(s);
                }
            });
        }
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        const instance = getCurrentInstance();
        if (!instance) {
            ( true) && warn$1(`useCssModule must be called inside setup()`);
            return EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
            ( true) && warn$1(`Current instance does not have CSS modules injected.`);
            return EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
            ( true) &&
                warn$1(`Current instance does not have CSS module named "${name}".`);
            return EMPTY_OBJ;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    const instance = getCurrentInstance();
    /* istanbul ignore next */
    if (!instance) {
        ( true) &&
            warn$1(`useCssVars is called without current active component instance.`);
        return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    watchPostEffect(setVars);
    onMounted(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
    });
}
function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128 /* SUSPENSE */) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
            suspense.effects.push(() => {
                setVarsOnVNode(suspense.activeBranch, vars);
            });
        }
    }
    // drill down HOCs until it's a non-component vnode
    while (vnode.component) {
        vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 /* ELEMENT */ && vnode.el) {
        setVarsOnNode(vnode.el, vars);
    }
    else if (vnode.type === Fragment) {
        vnode.children.forEach(c => setVarsOnVNode(c, vars));
    }
    else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
            setVarsOnNode(el, vars);
            if (el === anchor)
                break;
            el = el.nextSibling;
        }
    }
}
function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
            style.setProperty(`--${key}`, vars[key]);
        }
    }
}

const TRANSITION = 'transition';
const ANIMATION = 'animation';
// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = 'Transition';
{
    Transition.__isBuiltIn = true;
}
const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
const TransitionPropsValidators = (Transition.props =
    /*#__PURE__*/ extend({}, BaseTransition.props, DOMTransitionPropsValidators));
/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */
const callHook$1 = (hook, args = []) => {
    if (isArray(hook)) {
        hook.forEach(h => h(...args));
    }
    else if (hook) {
        hook(...args);
    }
};
/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */
const hasExplicitCallback = (hook) => {
    return hook
        ? isArray(hook)
            ? hook.some(h => h.length > 1)
            : hook.length > 1
        : false;
};
function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
            baseProps[key] = rawProps[key];
        }
    }
    if (rawProps.css === false) {
        return baseProps;
    }
    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    // legacy transition class compat
    const legacyClassEnabled = compatUtils.isCompatEnabled("TRANSITION_CLASSES" /* TRANSITION_CLASSES */, null);
    let legacyEnterFromClass;
    let legacyAppearFromClass;
    let legacyLeaveFromClass;
    if (legacyClassEnabled) {
        const toLegacyClass = (cls) => cls.replace(/-from$/, '');
        if (!rawProps.enterFromClass) {
            legacyEnterFromClass = toLegacyClass(enterFromClass);
        }
        if (!rawProps.appearFromClass) {
            legacyAppearFromClass = toLegacyClass(appearFromClass);
        }
        if (!rawProps.leaveFromClass) {
            legacyLeaveFromClass = toLegacyClass(leaveFromClass);
        }
    }
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
    };
    const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
    };
    const makeEnterHook = (isAppear) => {
        return (el, done) => {
            const hook = isAppear ? onAppear : onEnter;
            const resolve = () => finishEnter(el, isAppear, done);
            callHook$1(hook, [el, resolve]);
            nextFrame(() => {
                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                if (legacyClassEnabled) {
                    removeTransitionClass(el, isAppear ? legacyAppearFromClass : legacyEnterFromClass);
                }
                addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                if (!hasExplicitCallback(hook)) {
                    whenTransitionEnds(el, type, enterDuration, resolve);
                }
            });
        };
    };
    return extend(baseProps, {
        onBeforeEnter(el) {
            callHook$1(onBeforeEnter, [el]);
            addTransitionClass(el, enterFromClass);
            if (legacyClassEnabled) {
                addTransitionClass(el, legacyEnterFromClass);
            }
            addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
            callHook$1(onBeforeAppear, [el]);
            addTransitionClass(el, appearFromClass);
            if (legacyClassEnabled) {
                addTransitionClass(el, legacyAppearFromClass);
            }
            addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
            el._isLeaving = true;
            const resolve = () => finishLeave(el, done);
            addTransitionClass(el, leaveFromClass);
            if (legacyClassEnabled) {
                addTransitionClass(el, legacyLeaveFromClass);
            }
            // force reflow so *-leave-from classes immediately take effect (#2593)
            forceReflow();
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                if (!el._isLeaving) {
                    // cancelled
                    return;
                }
                removeTransitionClass(el, leaveFromClass);
                if (legacyClassEnabled) {
                    removeTransitionClass(el, legacyLeaveFromClass);
                }
                addTransitionClass(el, leaveToClass);
                if (!hasExplicitCallback(onLeave)) {
                    whenTransitionEnds(el, type, leaveDuration, resolve);
                }
            });
            callHook$1(onLeave, [el, resolve]);
        },
        onEnterCancelled(el) {
            finishEnter(el, false);
            callHook$1(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
            finishEnter(el, true);
            callHook$1(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
            finishLeave(el);
            callHook$1(onLeaveCancelled, [el]);
        }
    });
}
function normalizeDuration(duration) {
    if (duration == null) {
        return null;
    }
    else if (isObject(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
    }
    else {
        const n = NumberOf(duration);
        return [n, n];
    }
}
function NumberOf(val) {
    const res = toNumber(val);
    if ((true))
        validateDuration(res);
    return res;
}
function validateDuration(val) {
    if (typeof val !== 'number') {
        warn$1(`<transition> explicit duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`);
    }
    else if (isNaN(val)) {
        warn$1(`<transition> explicit duration is NaN - ` +
            'the duration expression might be incorrect.');
    }
}
function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.add(c));
    (el._vtc ||
        (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach(c => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
            el._vtc = undefined;
        }
    }
}
function nextFrame(cb) {
    requestAnimationFrame(() => {
        requestAnimationFrame(cb);
    });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = (el._endId = ++endId);
    const resolveIfNotStale = () => {
        if (id === el._endId) {
            resolve();
        }
    };
    if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
        return resolve();
    }
    const endEvent = type + 'end';
    let ended = 0;
    const end = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
    };
    const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
            end();
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const getStyleProperties = (key) => (styles[key] || '').split(', ');
    const transitionDelays = getStyleProperties(TRANSITION + 'Delay');
    const transitionDurations = getStyleProperties(TRANSITION + 'Duration');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + 'Delay');
    const animationDurations = getStyleProperties(ANIMATION + 'Duration');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION &&
        /\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}
// synchronously force layout to put elements into a certain state
function forceReflow() {
    return document.body.offsetHeight;
}

const positionMap = new WeakMap();
const newPositionMap = new WeakMap();
const TransitionGroupImpl = {
    name: 'TransitionGroup',
    props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
    }),
    setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
            // children is guaranteed to exist after initial render
            if (!prevChildren.length) {
                return;
            }
            const moveClass = props.moveClass || `${props.name || 'v'}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
                return;
            }
            // we divide the work into three loops to avoid mixing DOM reads and writes
            // in each iteration - which helps prevent layout thrashing.
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            // force reflow to put everything in position
            forceReflow();
            movedChildren.forEach(c => {
                const el = c.el;
                const style = el.style;
                addTransitionClass(el, moveClass);
                style.transform = style.webkitTransform = style.transitionDuration = '';
                const cb = (el._moveCb = (e) => {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener('transitionend', cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                });
                el.addEventListener('transitionend', cb);
            });
        });
        return () => {
            const rawProps = toRaw(props);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || Fragment;
            if (!rawProps.tag &&
                compatUtils.checkCompatEnabled("TRANSITION_GROUP_ROOT" /* TRANSITION_GROUP_ROOT */, instance.parent)) {
                tag = 'span';
            }
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child.key != null) {
                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                }
                else if ((true)) {
                    warn$1(`<TransitionGroup> children must be keyed.`);
                }
            }
            if (prevChildren) {
                for (let i = 0; i < prevChildren.length; i++) {
                    const child = prevChildren[i];
                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                    positionMap.set(child, child.el.getBoundingClientRect());
                }
            }
            return createVNode(tag, null, children);
        };
    }
};
{
    TransitionGroupImpl.__isBuiltIn = true;
}
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
        el._moveCb();
    }
    if (el._enterCb) {
        el._enterCb();
    }
}
function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
        return c;
    }
}
function hasCSSTransform(el, root, moveClass) {
    // Detect whether an element with the move class applied has
    // CSS transitions. Since the element may be inside an entering
    // transition at this very moment, we make a clone of it and remove
    // all other transition classes applied to ensure only the move class
    // is applied.
    const clone = el.cloneNode();
    if (el._vtc) {
        el._vtc.forEach(cls => {
            cls.split(/\s+/).forEach(c => c && clone.classList.remove(c));
        });
    }
    moveClass.split(/\s+/).forEach(c => c && clone.classList.add(c));
    clone.style.display = 'none';
    const container = (root.nodeType === 1 ? root : root.parentNode);
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
}

const getModelAssigner = (vnode) => {
    const fn = vnode.props['onUpdate:modelValue'] ||
        (vnode.props['onModelCompat:input']);
    return isArray(fn) ? value => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    const target = e.target;
    if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event('input'));
    }
}
// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        const castToNumber = number || (vnode.props && vnode.props.type === 'number');
        addEventListener(el, lazy ? 'change' : 'input', e => {
            if (e.target.composing)
                return;
            let domValue = el.value;
            if (trim) {
                domValue = domValue.trim();
            }
            if (castToNumber) {
                domValue = toNumber(domValue);
            }
            el._assign(domValue);
        });
        if (trim) {
            addEventListener(el, 'change', () => {
                el.value = el.value.trim();
            });
        }
        if (!lazy) {
            addEventListener(el, 'compositionstart', onCompositionStart);
            addEventListener(el, 'compositionend', onCompositionEnd);
            // Safari < 10.2 & UIWebView doesn't fire compositionend when
            // switching focus before confirming composition choice
            // this also fixes the issue where some browsers e.g. iOS Chrome
            // fires "change" instead of "input" on autocomplete.
            addEventListener(el, 'change', onCompositionEnd);
        }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
        el.value = value == null ? '' : value;
    },
    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
        el._assign = getModelAssigner(vnode);
        // avoid clearing unresolved text. #2302
        if (el.composing)
            return;
        if (document.activeElement === el && el.type !== 'range') {
            if (lazy) {
                return;
            }
            if (trim && el.value.trim() === value) {
                return;
            }
            if ((number || el.type === 'number') && toNumber(el.value) === value) {
                return;
            }
        }
        const newValue = value == null ? '' : value;
        if (el.value !== newValue) {
            el.value = newValue;
        }
    }
};
const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _, vnode) {
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked = el.checked;
            const assign = el._assign;
            if (isArray(modelValue)) {
                const index = looseIndexOf(modelValue, elementValue);
                const found = index !== -1;
                if (checked && !found) {
                    assign(modelValue.concat(elementValue));
                }
                else if (!checked && found) {
                    const filtered = [...modelValue];
                    filtered.splice(index, 1);
                    assign(filtered);
                }
            }
            else if (isSet(modelValue)) {
                const cloned = new Set(modelValue);
                if (checked) {
                    cloned.add(elementValue);
                }
                else {
                    cloned.delete(elementValue);
                }
                assign(cloned);
            }
            else {
                assign(getCheckboxValue(el, checked));
            }
        });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
        el._assign = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
    }
};
function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    if (isArray(value)) {
        el.checked = looseIndexOf(value, vnode.props.value) > -1;
    }
    else if (isSet(value)) {
        el.checked = value.has(vnode.props.value);
    }
    else if (value !== oldValue) {
        el.checked = looseEqual(value, getCheckboxValue(el, true));
    }
}
const vModelRadio = {
    created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el._assign = getModelAssigner(vnode);
        addEventListener(el, 'change', () => {
            el._assign(getValue(el));
        });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
        el._assign = getModelAssigner(vnode);
        if (value !== oldValue) {
            el.checked = looseEqual(value, vnode.props.value);
        }
    }
};
const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
        const isSetModel = isSet(value);
        addEventListener(el, 'change', () => {
            const selectedVal = Array.prototype.filter
                .call(el.options, (o) => o.selected)
                .map((o) => number ? toNumber(getValue(o)) : getValue(o));
            el._assign(el.multiple
                ? isSetModel
                    ? new Set(selectedVal)
                    : selectedVal
                : selectedVal[0]);
        });
        el._assign = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
        setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
        el._assign = getModelAssigner(vnode);
    },
    updated(el, { value }) {
        setSelected(el, value);
    }
};
function setSelected(el, value) {
    const isMultiple = el.multiple;
    if (isMultiple && !isArray(value) && !isSet(value)) {
        ( true) &&
            warn$1(`<select multiple v-model> expects an Array or Set value for its binding, ` +
                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);
        return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
        const option = el.options[i];
        const optionValue = getValue(option);
        if (isMultiple) {
            if (isArray(value)) {
                option.selected = looseIndexOf(value, optionValue) > -1;
            }
            else {
                option.selected = value.has(optionValue);
            }
        }
        else {
            if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i)
                    el.selectedIndex = i;
                return;
            }
        }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
    }
}
// retrieve raw value set via :value bindings
function getValue(el) {
    return '_value' in el ? el._value : el.value;
}
// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el, checked) {
    const key = checked ? '_trueValue' : '_falseValue';
    return key in el ? el[key] : checked;
}
const vModelDynamic = {
    created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'created');
    },
    mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, 'mounted');
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');
    },
    updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, 'updated');
    }
};
function resolveDynamicModel(tagName, type) {
    switch (tagName) {
        case 'SELECT':
            return vModelSelect;
        case 'TEXTAREA':
            return vModelText;
        default:
            switch (type) {
                case 'checkbox':
                    return vModelCheckbox;
                case 'radio':
                    return vModelRadio;
                default:
                    return vModelText;
            }
    }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && looseEqual(vnode.props.value, value)) {
            return { checked: true };
        }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if (isArray(value)) {
            if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
                return { checked: true };
            }
        }
        else if (isSet(value)) {
            if (vnode.props && value.has(vnode.props.value)) {
                return { checked: true };
            }
        }
        else if (value) {
            return { checked: true };
        }
    };
    vModelDynamic.getSSRProps = (binding, vnode) => {
        if (typeof vnode.type !== 'string') {
            return;
        }
        const modelToUse = resolveDynamicModel(
        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(), vnode.props && vnode.props.type);
        if (modelToUse.getSSRProps) {
            return modelToUse.getSSRProps(binding, vnode);
        }
    };
}

const systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];
const modifierGuards = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => 'button' in e && e.button !== 0,
    middle: e => 'button' in e && e.button !== 1,
    right: e => 'button' in e && e.button !== 2,
    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))
};
/**
 * @private
 */
const withModifiers = (fn, modifiers) => {
    return (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event, modifiers))
                return;
        }
        return fn(event, ...args);
    };
};
// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
const keyNames = {
    esc: 'escape',
    space: ' ',
    up: 'arrow-up',
    left: 'arrow-left',
    right: 'arrow-right',
    down: 'arrow-down',
    delete: 'backspace'
};
/**
 * @private
 */
const withKeys = (fn, modifiers) => {
    let globalKeyCodes;
    let instance = null;
    {
        instance = getCurrentInstance();
        if (compatUtils.isCompatEnabled("CONFIG_KEY_CODES" /* CONFIG_KEY_CODES */, instance)) {
            if (instance) {
                globalKeyCodes = instance.appContext.config.keyCodes;
            }
        }
        if (( true) && modifiers.some(m => /^\d+$/.test(m))) {
            compatUtils.warnDeprecation("V_ON_KEYCODE_MODIFIER" /* V_ON_KEYCODE_MODIFIER */, instance);
        }
    }
    return (event) => {
        if (!('key' in event)) {
            return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {
            return fn(event);
        }
        {
            const keyCode = String(event.keyCode);
            if (compatUtils.isCompatEnabled("V_ON_KEYCODE_MODIFIER" /* V_ON_KEYCODE_MODIFIER */, instance) &&
                modifiers.some(mod => mod == keyCode)) {
                return fn(event);
            }
            if (globalKeyCodes) {
                for (const mod of modifiers) {
                    const codes = globalKeyCodes[mod];
                    if (codes) {
                        const matches = isArray(codes)
                            ? codes.some(code => String(code) === keyCode)
                            : String(codes) === keyCode;
                        if (matches) {
                            return fn(event);
                        }
                    }
                }
            }
        }
    };
};

const vShow = {
    beforeMount(el, { value }, { transition }) {
        el._vod = el.style.display === 'none' ? '' : el.style.display;
        if (transition && value) {
            transition.beforeEnter(el);
        }
        else {
            setDisplay(el, value);
        }
    },
    mounted(el, { value }, { transition }) {
        if (transition && value) {
            transition.enter(el);
        }
    },
    updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
            return;
        if (transition) {
            if (value) {
                transition.beforeEnter(el);
                setDisplay(el, true);
                transition.enter(el);
            }
            else {
                transition.leave(el, () => {
                    setDisplay(el, false);
                });
            }
        }
        else {
            setDisplay(el, value);
        }
    },
    beforeUnmount(el, { value }) {
        setDisplay(el, value);
    }
};
function setDisplay(el, value) {
    el.style.display = value ? el._vod : 'none';
}
// SSR vnode transforms, only used when user includes client-oriented render
// function in SSR
function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
        if (!value) {
            return { style: { display: 'none' } };
        }
    };
}

const rendererOptions = /*#__PURE__*/ extend({ patchProp }, nodeOps);
// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
let renderer;
let enabledHydration = false;
function ensureRenderer() {
    return (renderer ||
        (renderer = createRenderer(rendererOptions)));
}
function ensureHydrationRenderer() {
    renderer = enabledHydration
        ? renderer
        : createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
}
// use explicit type casts here to avoid import() calls in rolled-up d.ts
const render = ((...args) => {
    ensureRenderer().render(...args);
});
const hydrate = ((...args) => {
    ensureHydrationRenderer().hydrate(...args);
});
const createApp = ((...args) => {
    const app = ensureRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
            return;
        const component = app._component;
        if (!isFunction(component) && !component.render && !component.template) {
            // __UNSAFE__
            // Reason: potential execution of JS expressions in in-DOM template.
            // The user must make sure the in-DOM template is trusted. If it's
            // rendered by the server, the template should not contain any user data.
            component.template = container.innerHTML;
            // 2.x compat check
            if ((true)) {
                for (let i = 0; i < container.attributes.length; i++) {
                    const attr = container.attributes[i];
                    if (attr.name !== 'v-cloak' && /^(v-|:|@)/.test(attr.name)) {
                        compatUtils.warnDeprecation("GLOBAL_MOUNT_CONTAINER" /* GLOBAL_MOUNT_CONTAINER */, null);
                        break;
                    }
                }
            }
        }
        // clear content before mounting
        container.innerHTML = '';
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
            container.removeAttribute('v-cloak');
            container.setAttribute('data-v-app', '');
        }
        return proxy;
    };
    return app;
});
const createSSRApp = ((...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    if ((true)) {
        injectNativeTagCheck(app);
        injectCompilerOptionsCheck(app);
    }
    const { mount } = app;
    app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
            return mount(container, true, container instanceof SVGElement);
        }
    };
    return app;
});
function injectNativeTagCheck(app) {
    // Inject `isNativeTag`
    // this is used for component name validation (dev only)
    Object.defineProperty(app.config, 'isNativeTag', {
        value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
        writable: false
    });
}
// dev only
function injectCompilerOptionsCheck(app) {
    if (isRuntimeOnly()) {
        const isCustomElement = app.config.isCustomElement;
        Object.defineProperty(app.config, 'isCustomElement', {
            get() {
                return isCustomElement;
            },
            set() {
                warn$1(`The \`isCustomElement\` config option is deprecated. Use ` +
                    `\`compilerOptions.isCustomElement\` instead.`);
            }
        });
        const compilerOptions = app.config.compilerOptions;
        const msg = `The \`compilerOptions\` config option is only respected when using ` +
            `a build of Vue.js that includes the runtime compiler (aka "full build"). ` +
            `Since you are using the runtime-only build, \`compilerOptions\` ` +
            `must be passed to \`@vue/compiler-dom\` in the build setup instead.\n` +
            `- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.\n` +
            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
        Object.defineProperty(app.config, 'compilerOptions', {
            get() {
                warn$1(msg);
                return compilerOptions;
            },
            set() {
                warn$1(msg);
            }
        });
    }
}
function normalizeContainer(container) {
    if (isString(container)) {
        const res = document.querySelector(container);
        if (( true) && !res) {
            warn$1(`Failed to mount app: mount target selector "${container}" returned null.`);
        }
        return res;
    }
    if (( true) &&
        window.ShadowRoot &&
        container instanceof window.ShadowRoot &&
        container.mode === 'closed') {
        warn$1(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
}
let ssrDirectiveInitialized = false;
/**
 * @internal
 */
const initDirectivesForSSR = () => {
        if (!ssrDirectiveInitialized) {
            ssrDirectiveInitialized = true;
            initVModelForSSR();
            initVShowForSSR();
        }
    }
    ;

var runtimeDom = /*#__PURE__*/Object.freeze({
  __proto__: null,
  render: render,
  hydrate: hydrate,
  createApp: createApp,
  createSSRApp: createSSRApp,
  initDirectivesForSSR: initDirectivesForSSR,
  defineCustomElement: defineCustomElement,
  defineSSRCustomElement: defineSSRCustomElement,
  VueElement: VueElement,
  useCssModule: useCssModule,
  useCssVars: useCssVars,
  Transition: Transition,
  TransitionGroup: TransitionGroup,
  vModelText: vModelText,
  vModelCheckbox: vModelCheckbox,
  vModelRadio: vModelRadio,
  vModelSelect: vModelSelect,
  vModelDynamic: vModelDynamic,
  withModifiers: withModifiers,
  withKeys: withKeys,
  vShow: vShow,
  reactive: reactive,
  ref: ref,
  readonly: readonly,
  unref: unref,
  proxyRefs: proxyRefs,
  isRef: isRef,
  toRef: toRef,
  toRefs: toRefs,
  isProxy: isProxy,
  isReactive: isReactive,
  isReadonly: isReadonly,
  isShallow: isShallow,
  customRef: customRef,
  triggerRef: triggerRef,
  shallowRef: shallowRef,
  shallowReactive: shallowReactive,
  shallowReadonly: shallowReadonly,
  markRaw: markRaw,
  toRaw: toRaw,
  effect: effect,
  stop: stop,
  ReactiveEffect: ReactiveEffect,
  effectScope: effectScope,
  EffectScope: EffectScope,
  getCurrentScope: getCurrentScope,
  onScopeDispose: onScopeDispose,
  computed: computed$1,
  watch: watch,
  watchEffect: watchEffect,
  watchPostEffect: watchPostEffect,
  watchSyncEffect: watchSyncEffect,
  onBeforeMount: onBeforeMount,
  onMounted: onMounted,
  onBeforeUpdate: onBeforeUpdate,
  onUpdated: onUpdated,
  onBeforeUnmount: onBeforeUnmount,
  onUnmounted: onUnmounted,
  onActivated: onActivated,
  onDeactivated: onDeactivated,
  onRenderTracked: onRenderTracked,
  onRenderTriggered: onRenderTriggered,
  onErrorCaptured: onErrorCaptured,
  onServerPrefetch: onServerPrefetch,
  provide: provide,
  inject: inject,
  nextTick: nextTick,
  defineComponent: defineComponent,
  defineAsyncComponent: defineAsyncComponent,
  useAttrs: useAttrs,
  useSlots: useSlots,
  defineProps: defineProps,
  defineEmits: defineEmits,
  defineExpose: defineExpose,
  withDefaults: withDefaults,
  mergeDefaults: mergeDefaults,
  createPropsRestProxy: createPropsRestProxy,
  withAsyncContext: withAsyncContext,
  getCurrentInstance: getCurrentInstance,
  h: h,
  createVNode: createVNode,
  cloneVNode: cloneVNode,
  mergeProps: mergeProps,
  isVNode: isVNode,
  Fragment: Fragment,
  Text: Text,
  Comment: Comment,
  Static: Static,
  Teleport: Teleport,
  Suspense: Suspense,
  KeepAlive: KeepAlive,
  BaseTransition: BaseTransition,
  withDirectives: withDirectives,
  useSSRContext: useSSRContext,
  ssrContextKey: ssrContextKey,
  createRenderer: createRenderer,
  createHydrationRenderer: createHydrationRenderer,
  queuePostFlushCb: queuePostFlushCb,
  warn: warn$1,
  handleError: handleError,
  callWithErrorHandling: callWithErrorHandling,
  callWithAsyncErrorHandling: callWithAsyncErrorHandling,
  resolveComponent: resolveComponent,
  resolveDirective: resolveDirective,
  resolveDynamicComponent: resolveDynamicComponent,
  registerRuntimeCompiler: registerRuntimeCompiler,
  isRuntimeOnly: isRuntimeOnly,
  useTransitionState: useTransitionState,
  resolveTransitionHooks: resolveTransitionHooks,
  setTransitionHooks: setTransitionHooks,
  getTransitionRawChildren: getTransitionRawChildren,
  initCustomFormatter: initCustomFormatter,
  get devtools () { return devtools; },
  setDevtoolsHook: setDevtoolsHook,
  withCtx: withCtx,
  pushScopeId: pushScopeId,
  popScopeId: popScopeId,
  withScopeId: withScopeId,
  renderList: renderList,
  toHandlers: toHandlers,
  renderSlot: renderSlot,
  createSlots: createSlots,
  withMemo: withMemo,
  isMemoSame: isMemoSame,
  openBlock: openBlock,
  createBlock: createBlock,
  setBlockTracking: setBlockTracking,
  createTextVNode: createTextVNode,
  createCommentVNode: createCommentVNode,
  createStaticVNode: createStaticVNode,
  createElementVNode: createBaseVNode,
  createElementBlock: createElementBlock,
  guardReactiveProps: guardReactiveProps,
  toDisplayString: toDisplayString,
  camelize: camelize,
  capitalize: capitalize,
  toHandlerKey: toHandlerKey,
  normalizeProps: normalizeProps,
  normalizeClass: normalizeClass,
  normalizeStyle: normalizeStyle,
  transformVNodeArgs: transformVNodeArgs,
  version: version,
  ssrUtils: ssrUtils,
  resolveFilter: resolveFilter$1,
  compatUtils: compatUtils
});

function initDev() {
    {
        initCustomFormatter();
    }
}

// This entry exports the runtime only, and is built as
if ((true)) {
    initDev();
}
function wrappedCreateApp(...args) {
    // @ts-ignore
    const app = createApp(...args);
    if (compatUtils.isCompatEnabled("RENDER_FUNCTION" /* RENDER_FUNCTION */, null)) {
        // register built-in components so that they can be resolved via strings
        // in the legacy h() call. The __compat__ prefix is to ensure that v3 h()
        // doesn't get affected.
        app.component('__compat__transition', Transition);
        app.component('__compat__transition-group', TransitionGroup);
        app.component('__compat__keep-alive', KeepAlive);
        // built-in directives. No need for prefix since there's no render fn API
        // for resolving directives via string in v3.
        app._context.directives.show = vShow;
        app._context.directives.model = vModelDynamic;
    }
    return app;
}
function createCompatVue$1() {
    const Vue = compatUtils.createCompatVue(createApp, wrappedCreateApp);
    extend(Vue, runtimeDom);
    return Vue;
}

// This entry exports the runtime only, and is built as
const Vue = createCompatVue$1();
Vue.compile = (() => {
    if ((true)) {
        warn$1(`Runtime compilation is not supported in this build of Vue.` +
            (` Configure your bundler to alias "vue" to "@vue/compat/dist/vue.esm-bundler.js".`
                ) /* should not happen */);
    }
});

const { configureCompat: configureCompat$1 } = Vue;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);



/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addStylesClient)
/* harmony export */ });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ "./node_modules/vue-style-loader/lib/listToStyles.js");
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__["default"])(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listToStyles)
/* harmony export */ });
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),

/***/ "./node_modules/mitt/dist/mitt.mjs":
/*!*****************************************!*\
  !*** ./node_modules/mitt/dist/mitt.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e)})}}}
//# sourceMappingURL=mitt.mjs.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRCwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsYUFBYSxJQUFxQztBQUNsRCw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQXFDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsQ0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQXFDO0FBQ2xELDZDQUE2QyxRQUFRO0FBQ3JELDRCQUE0QixrQkFBa0IsWUFBWSxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkMsMENBQTBDLGlDQUFpQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxpQ0FBaUMsK0JBQStCLEtBQUssT0FBTztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFQUdKO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0EsZ0NBQWdDLDBDQUEwQztBQUMxRSxpQkFBaUIsS0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFLGlCQUFpQixLQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBcUM7QUFDeEQ7QUFDQSxVQUFVLENBQUk7QUFDZDtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQ0FBa0MsY0FBYyxRQUFRO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBcUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0EsS0FBSztB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQXFDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQXdDO0FBQ3BFLDRCQUE0QixFQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4TUFBOE07QUFDMU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6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QUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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NkUsSUFBSTtBQUNqRjtBQUNBLHNCQUFzQixDQUFJO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQixJQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EscUJBQXFCLElBQXFDO0FBQzFELGlEQUFpRCxJQUFJO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFxQztBQUN2RCw4REFBOEQsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFxQztBQUMzRCxrRUFBa0UsWUFBWTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQXFDO0FBQ25ELHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDLFlBQVkscURBQXFELDBCQUEwQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtDQUFrQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFxQztBQUM5QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUIsY0FBYztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sS0FBcUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQXFDO0FBQzlDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QyxpQkFBaUIsS0FBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRCxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RCxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEtBQUs7QUFDcEUscUJBQXFCLDBDQUEwQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRCw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFxQztBQUN0RDtBQUNBLG1FQUFtRSxJQUFJO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywwREFBMEQ7QUFDMUQ7QUFDQSxLQUFLO0FBQ0wseUNBQXlDO0FBQ3pDO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLEtBQXFDLGFBQWEsQ0FBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRCw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsb0JBQW9CLGlCQUFpQjtBQUNyQyxrQkFBa0IsNkJBQTZCO0FBQy9DLGVBQWUsMEJBQTBCO0FBQ3pDLGtCQUFrQiw2QkFBNkI7QUFDL0Msc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQXFDO0FBQzFELDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFxQztBQUMxRCxvQ0FBb0MsaUNBQWlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQWdFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQWdFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxxQkFBcUIsS0FBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CLElBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFxQztBQUNuRTtBQUNBLCtDQUErQyxXQUFXO0FBQzFEO0FBQ0E7QUFDQSxxQkFBcUIsRUFFSjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQXFDO0FBQzFELHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQXFDO0FBQzFELHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQWdFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBcUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBZ0U7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCLEtBQXFDO0FBQzFELHNFQUFzRSxZQUFZO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRCxrRUFBa0UsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFxQztBQUN2RCwwREFBMEQsV0FBVztBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUMsa0ZBQWtGO0FBQ2pJO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQXFDO0FBQzlEO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RSwrQ0FBK0MsK0JBQStCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLElBQXFDO0FBQy9ELGdFQUFnRSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwQ0FBMEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBOEU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFxQztBQUM5RCxrRUFBa0UsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBcUM7QUFDMUQsc0VBQXNFLFdBQVc7QUFDakYseUNBQXlDLGVBQWU7QUFDeEQseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBcUM7QUFDMUQsOERBQThELGdDQUFnQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQ0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUssR0FBRyxhQUFhO0FBQzlDO0FBQ0EsUUFBUSxJQUFnRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEtBQUssR0FBRyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQSx5QkFBeUIsNkNBQTZDLElBQUksS0FBSztBQUMvRTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQWdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBd0MsRUFBRSxFQUc3QztBQUNMLFFBQVEsS0FBMEMsRUFBRSxFQUcvQztBQUNMLFNBQVMsS0FBcUM7QUFDOUM7QUFDQSxvQ0FBb0Msa0JBQWtCLEVBQUUscUJBQXFCLEVBQUUsc0JBQXNCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBZ0U7QUFDeEU7QUFDQTtBQUNBLFlBQVksa1lBQWtZO0FBQzlZLDJFQUEyRTtBQUMzRTtBQUNBLHFKQUFxSixLQUFxQztBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFxQztBQUMvRCw0REFBNEQsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFzRDtBQUN0RSxZQUFZLEtBR2dCLGdCQUFnQixFQU1uQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBZ0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBCQUEwQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0UsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBcUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBcUM7QUFDbEU7QUFDQTtBQUNBLDZCQUE2QixJQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBcUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQXFDO0FBQzlEO0FBQ0E7QUFDQSx5QkFBeUIsSUFBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFnRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQXFDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQWdFO0FBQ3BGO0FBQ0E7QUFDQSxxQkFBcUIsSUFBcUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQTRDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNB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RixxQkFBcUIsS0FBcUMsYUFBYSxDQUFTO0FBQ2hGLHdCQUF3QixLQUFxQyxnQkFBZ0IsQ0FBUztBQUN0Rix1QkFBdUIsS0FBcUMsZUFBZSxDQUFTO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQXFDLG1DQUFtQyxDQUFZO0FBQzFHO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xELDhEQUE4RCxLQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUMsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFxQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBcUM7QUFDOUM7QUFDQTtBQUNBLFNBQVMsRUFFSjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRCwyQ0FBMkMsSUFBSSxRQUFRLHlCQUF5QjtBQUNoRix5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQXFDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QW9DLEtBQUssa0NBQWtDLEtBQUssYUFBYTtBQUN6WDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnS0FBZ0s7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQXFDO0FBQ2xELGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTZCLEtBQUssNENBQTRDLE9BQU87QUFDdFQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5pcmFkaW8vLi9ub2RlX21vZHVsZXMvQGRhdmxhbmQ3L3JwbGF5ZXIvZGlzdC9ycGxheWVyLmpzIiwid2VicGFjazovL21pbmlyYWRpby8uL25vZGVfbW9kdWxlcy9AdnVlL2NvbXBhdC9kaXN0L3Z1ZS5ydW50aW1lLmVzbS1idW5kbGVyLmpzIiwid2VicGFjazovL21pbmlyYWRpby8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vbWluaXJhZGlvLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL25vU291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9taW5pcmFkaW8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2V4cG9ydEhlbHBlci5qcyIsIndlYnBhY2s6Ly9taW5pcmFkaW8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzIiwid2VicGFjazovL21pbmlyYWRpby8uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vbWluaXJhZGlvLy4vbm9kZV9tb2R1bGVzL21pdHQvZGlzdC9taXR0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnJQbGF5ZXI9ZSgpOnQuclBsYXllcj1lKCl9KHNlbGYsKCgpPT4oKCk9Pnt2YXIgdD17MTgyOmZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJih0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9e307ZnVuY3Rpb24gcihpKXtpZihlW2ldKXJldHVybiBlW2ldLmV4cG9ydHM7dmFyIGE9ZVtpXT17aSxsOiExLGV4cG9ydHM6e319O3JldHVybiB0W2ldLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLHIpLGEubD0hMCxhLmV4cG9ydHN9cmV0dXJuIHIubT10LHIuYz1lLHIuZD1mdW5jdGlvbih0LGUsaSl7ci5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0Oml9KX0sci5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIudD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9cih0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihpKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIGEgaW4gdClyLmQoaSxhLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsYSkpO3JldHVybiBpfSxyLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIHIuZChlLFwiYVwiLGUpLGV9LHIubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sci5wPVwiL2Rpc3QvXCIscihyLnM9MTkpfShbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLGZ1bmN0aW9uKHQpe3QuTUVESUFfQVRUQUNISU5HPVwiaGxzTWVkaWFBdHRhY2hpbmdcIix0Lk1FRElBX0FUVEFDSEVEPVwiaGxzTWVkaWFBdHRhY2hlZFwiLHQuTUVESUFfREVUQUNISU5HPVwiaGxzTWVkaWFEZXRhY2hpbmdcIix0Lk1FRElBX0RFVEFDSEVEPVwiaGxzTWVkaWFEZXRhY2hlZFwiLHQuQlVGRkVSX1JFU0VUPVwiaGxzQnVmZmVyUmVzZXRcIix0LkJVRkZFUl9DT0RFQ1M9XCJobHNCdWZmZXJDb2RlY3NcIix0LkJVRkZFUl9DUkVBVEVEPVwiaGxzQnVmZmVyQ3JlYXRlZFwiLHQuQlVGRkVSX0FQUEVORElORz1cImhsc0J1ZmZlckFwcGVuZGluZ1wiLHQuQlVGRkVSX0FQUEVOREVEPVwiaGxzQnVmZmVyQXBwZW5kZWRcIix0LkJVRkZFUl9FT1M9XCJobHNCdWZmZXJFb3NcIix0LkJVRkZFUl9GTFVTSElORz1cImhsc0J1ZmZlckZsdXNoaW5nXCIsdC5CVUZGRVJfRkxVU0hFRD1cImhsc0J1ZmZlckZsdXNoZWRcIix0Lk1BTklGRVNUX0xPQURJTkc9XCJobHNNYW5pZmVzdExvYWRpbmdcIix0Lk1BTklGRVNUX0xPQURFRD1cImhsc01hbmlmZXN0TG9hZGVkXCIsdC5NQU5JRkVTVF9QQVJTRUQ9XCJobHNNYW5pZmVzdFBhcnNlZFwiLHQuTEVWRUxfU1dJVENISU5HPVwiaGxzTGV2ZWxTd2l0Y2hpbmdcIix0LkxFVkVMX1NXSVRDSEVEPVwiaGxzTGV2ZWxTd2l0Y2hlZFwiLHQuTEVWRUxfTE9BRElORz1cImhsc0xldmVsTG9hZGluZ1wiLHQuTEVWRUxfTE9BREVEPVwiaGxzTGV2ZWxMb2FkZWRcIix0LkxFVkVMX1VQREFURUQ9XCJobHNMZXZlbFVwZGF0ZWRcIix0LkxFVkVMX1BUU19VUERBVEVEPVwiaGxzTGV2ZWxQdHNVcGRhdGVkXCIsdC5MRVZFTFNfVVBEQVRFRD1cImhsc0xldmVsc1VwZGF0ZWRcIix0LkFVRElPX1RSQUNLU19VUERBVEVEPVwiaGxzQXVkaW9UcmFja3NVcGRhdGVkXCIsdC5BVURJT19UUkFDS19TV0lUQ0hJTkc9XCJobHNBdWRpb1RyYWNrU3dpdGNoaW5nXCIsdC5BVURJT19UUkFDS19TV0lUQ0hFRD1cImhsc0F1ZGlvVHJhY2tTd2l0Y2hlZFwiLHQuQVVESU9fVFJBQ0tfTE9BRElORz1cImhsc0F1ZGlvVHJhY2tMb2FkaW5nXCIsdC5BVURJT19UUkFDS19MT0FERUQ9XCJobHNBdWRpb1RyYWNrTG9hZGVkXCIsdC5TVUJUSVRMRV9UUkFDS1NfVVBEQVRFRD1cImhsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZFwiLHQuU1VCVElUTEVfVFJBQ0tTX0NMRUFSRUQ9XCJobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWRcIix0LlNVQlRJVExFX1RSQUNLX1NXSVRDSD1cImhsc1N1YnRpdGxlVHJhY2tTd2l0Y2hcIix0LlNVQlRJVExFX1RSQUNLX0xPQURJTkc9XCJobHNTdWJ0aXRsZVRyYWNrTG9hZGluZ1wiLHQuU1VCVElUTEVfVFJBQ0tfTE9BREVEPVwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiLHQuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQ9XCJobHNTdWJ0aXRsZUZyYWdQcm9jZXNzZWRcIix0LkNVRVNfUEFSU0VEPVwiaGxzQ3Vlc1BhcnNlZFwiLHQuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORD1cImhsc05vbk5hdGl2ZVRleHRUcmFja3NGb3VuZFwiLHQuSU5JVF9QVFNfRk9VTkQ9XCJobHNJbml0UHRzRm91bmRcIix0LkZSQUdfTE9BRElORz1cImhsc0ZyYWdMb2FkaW5nXCIsdC5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQ9XCJobHNGcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWRcIix0LkZSQUdfTE9BREVEPVwiaGxzRnJhZ0xvYWRlZFwiLHQuRlJBR19ERUNSWVBURUQ9XCJobHNGcmFnRGVjcnlwdGVkXCIsdC5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UPVwiaGxzRnJhZ1BhcnNpbmdJbml0U2VnbWVudFwiLHQuRlJBR19QQVJTSU5HX1VTRVJEQVRBPVwiaGxzRnJhZ1BhcnNpbmdVc2VyZGF0YVwiLHQuRlJBR19QQVJTSU5HX01FVEFEQVRBPVwiaGxzRnJhZ1BhcnNpbmdNZXRhZGF0YVwiLHQuRlJBR19QQVJTRUQ9XCJobHNGcmFnUGFyc2VkXCIsdC5GUkFHX0JVRkZFUkVEPVwiaGxzRnJhZ0J1ZmZlcmVkXCIsdC5GUkFHX0NIQU5HRUQ9XCJobHNGcmFnQ2hhbmdlZFwiLHQuRlBTX0RST1A9XCJobHNGcHNEcm9wXCIsdC5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HPVwiaGxzRnBzRHJvcExldmVsQ2FwcGluZ1wiLHQuRVJST1I9XCJobHNFcnJvclwiLHQuREVTVFJPWUlORz1cImhsc0Rlc3Ryb3lpbmdcIix0LktFWV9MT0FESU5HPVwiaGxzS2V5TG9hZGluZ1wiLHQuS0VZX0xPQURFRD1cImhsc0tleUxvYWRlZFwiLHQuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVEPVwiaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkXCIsdC5CQUNLX0JVRkZFUl9SRUFDSEVEPVwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIn0oaXx8KGk9e30pKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBvfSkpLHIuZChlLFwiYlwiLChmdW5jdGlvbigpe3JldHVybiBsfSkpO3ZhciBpPWZ1bmN0aW9uKCl7fSxhPXt0cmFjZTppLGRlYnVnOmksbG9nOmksd2FybjppLGluZm86aSxlcnJvcjppfSxuPWE7ZnVuY3Rpb24gcyh0KXt2YXIgZT1zZWxmLmNvbnNvbGVbdF07cmV0dXJuIGU/ZS5iaW5kKHNlbGYuY29uc29sZSxcIltcIit0K1wiXSA+XCIpOml9ZnVuY3Rpb24gbyh0KXtpZihzZWxmLmNvbnNvbGUmJiEwPT09dHx8XCJvYmplY3RcIj09dHlwZW9mIHQpeyFmdW5jdGlvbih0KXtmb3IodmFyIGU9YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShlPjE/ZS0xOjApLGk9MTtpPGU7aSsrKXJbaS0xXT1hcmd1bWVudHNbaV07ci5mb3JFYWNoKChmdW5jdGlvbihlKXtuW2VdPXRbZV0/dFtlXS5iaW5kKHQpOnMoZSl9KSl9KHQsXCJkZWJ1Z1wiLFwibG9nXCIsXCJpbmZvXCIsXCJ3YXJuXCIsXCJlcnJvclwiKTt0cnl7bi5sb2coKX1jYXRjaCh0KXtuPWF9fWVsc2Ugbj1hfXZhciBsPWF9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaSxhO3IuZChlLFwiYlwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLHIuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBhfSkpLGZ1bmN0aW9uKHQpe3QuTkVUV09SS19FUlJPUj1cIm5ldHdvcmtFcnJvclwiLHQuTUVESUFfRVJST1I9XCJtZWRpYUVycm9yXCIsdC5LRVlfU1lTVEVNX0VSUk9SPVwia2V5U3lzdGVtRXJyb3JcIix0Lk1VWF9FUlJPUj1cIm11eEVycm9yXCIsdC5PVEhFUl9FUlJPUj1cIm90aGVyRXJyb3JcIn0oaXx8KGk9e30pKSxmdW5jdGlvbih0KXt0LktFWV9TWVNURU1fTk9fS0VZUz1cImtleVN5c3RlbU5vS2V5c1wiLHQuS0VZX1NZU1RFTV9OT19BQ0NFU1M9XCJrZXlTeXN0ZW1Ob0FjY2Vzc1wiLHQuS0VZX1NZU1RFTV9OT19TRVNTSU9OPVwia2V5U3lzdGVtTm9TZXNzaW9uXCIsdC5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQ9XCJrZXlTeXN0ZW1MaWNlbnNlUmVxdWVzdEZhaWxlZFwiLHQuS0VZX1NZU1RFTV9OT19JTklUX0RBVEE9XCJrZXlTeXN0ZW1Ob0luaXREYXRhXCIsdC5NQU5JRkVTVF9MT0FEX0VSUk9SPVwibWFuaWZlc3RMb2FkRXJyb3JcIix0Lk1BTklGRVNUX0xPQURfVElNRU9VVD1cIm1hbmlmZXN0TG9hZFRpbWVPdXRcIix0Lk1BTklGRVNUX1BBUlNJTkdfRVJST1I9XCJtYW5pZmVzdFBhcnNpbmdFcnJvclwiLHQuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUj1cIm1hbmlmZXN0SW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIix0LkxFVkVMX0VNUFRZX0VSUk9SPVwibGV2ZWxFbXB0eUVycm9yXCIsdC5MRVZFTF9MT0FEX0VSUk9SPVwibGV2ZWxMb2FkRXJyb3JcIix0LkxFVkVMX0xPQURfVElNRU9VVD1cImxldmVsTG9hZFRpbWVPdXRcIix0LkxFVkVMX1NXSVRDSF9FUlJPUj1cImxldmVsU3dpdGNoRXJyb3JcIix0LkFVRElPX1RSQUNLX0xPQURfRVJST1I9XCJhdWRpb1RyYWNrTG9hZEVycm9yXCIsdC5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ9XCJhdWRpb1RyYWNrTG9hZFRpbWVPdXRcIix0LlNVQlRJVExFX0xPQURfRVJST1I9XCJzdWJ0aXRsZVRyYWNrTG9hZEVycm9yXCIsdC5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ9XCJzdWJ0aXRsZVRyYWNrTG9hZFRpbWVPdXRcIix0LkZSQUdfTE9BRF9FUlJPUj1cImZyYWdMb2FkRXJyb3JcIix0LkZSQUdfTE9BRF9USU1FT1VUPVwiZnJhZ0xvYWRUaW1lT3V0XCIsdC5GUkFHX0RFQ1JZUFRfRVJST1I9XCJmcmFnRGVjcnlwdEVycm9yXCIsdC5GUkFHX1BBUlNJTkdfRVJST1I9XCJmcmFnUGFyc2luZ0Vycm9yXCIsdC5SRU1VWF9BTExPQ19FUlJPUj1cInJlbXV4QWxsb2NFcnJvclwiLHQuS0VZX0xPQURfRVJST1I9XCJrZXlMb2FkRXJyb3JcIix0LktFWV9MT0FEX1RJTUVPVVQ9XCJrZXlMb2FkVGltZU91dFwiLHQuQlVGRkVSX0FERF9DT0RFQ19FUlJPUj1cImJ1ZmZlckFkZENvZGVjRXJyb3JcIix0LkJVRkZFUl9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SPVwiYnVmZmVySW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIix0LkJVRkZFUl9BUFBFTkRfRVJST1I9XCJidWZmZXJBcHBlbmRFcnJvclwiLHQuQlVGRkVSX0FQUEVORElOR19FUlJPUj1cImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCIsdC5CVUZGRVJfU1RBTExFRF9FUlJPUj1cImJ1ZmZlclN0YWxsZWRFcnJvclwiLHQuQlVGRkVSX0ZVTExfRVJST1I9XCJidWZmZXJGdWxsRXJyb3JcIix0LkJVRkZFUl9TRUVLX09WRVJfSE9MRT1cImJ1ZmZlclNlZWtPdmVySG9sZVwiLHQuQlVGRkVSX05VREdFX09OX1NUQUxMPVwiYnVmZmVyTnVkZ2VPblN0YWxsXCIsdC5JTlRFUk5BTF9FWENFUFRJT049XCJpbnRlcm5hbEV4Y2VwdGlvblwiLHQuSU5URVJOQUxfQUJPUlRFRD1cImFib3J0ZWRcIix0LlVOS05PV049XCJ1bmtub3duXCJ9KGF8fChhPXt9KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKTt2YXIgaT1OdW1iZXIuaXNGaW5pdGV8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KX07TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaSxhO3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpLHIuZChlLFwiYlwiLChmdW5jdGlvbigpe3JldHVybiBhfSkpLGZ1bmN0aW9uKHQpe3QuTUFOSUZFU1Q9XCJtYW5pZmVzdFwiLHQuTEVWRUw9XCJsZXZlbFwiLHQuQVVESU9fVFJBQ0s9XCJhdWRpb1RyYWNrXCIsdC5TVUJUSVRMRV9UUkFDSz1cInN1YnRpdGxlVHJhY2tcIn0oaXx8KGk9e30pKSxmdW5jdGlvbih0KXt0Lk1BSU49XCJtYWluXCIsdC5BVURJTz1cImF1ZGlvXCIsdC5TVUJUSVRMRT1cInN1YnRpdGxlXCJ9KGF8fChhPXt9KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKSxyLmQoZSxcImJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdn0pKSxyLmQoZSxcImNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZ30pKTt2YXIgaSxhPXIoMyksbj1yKDExKSxzPXIoMSksbz1yKDE1KSxsPXIoMTIpO2Z1bmN0aW9uIHUodCxlKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10LGQodCxlKX1mdW5jdGlvbiBkKHQsZSl7cmV0dXJuKGQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIGgodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fWZ1bmN0aW9uIGYodCxlLHIpe3JldHVybiBlJiZoKHQucHJvdG90eXBlLGUpLHImJmgodCxyKSx0fSFmdW5jdGlvbih0KXt0LkFVRElPPVwiYXVkaW9cIix0LlZJREVPPVwidmlkZW9cIix0LkFVRElPVklERU89XCJhdWRpb3ZpZGVvXCJ9KGl8fChpPXt9KSk7dmFyIGM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBlO3RoaXMuX2J5dGVSYW5nZT1udWxsLHRoaXMuX3VybD1udWxsLHRoaXMuYmFzZXVybD12b2lkIDAsdGhpcy5yZWx1cmw9dm9pZCAwLHRoaXMuZWxlbWVudGFyeVN0cmVhbXM9KChlPXt9KVtpLkFVRElPXT1udWxsLGVbaS5WSURFT109bnVsbCxlW2kuQVVESU9WSURFT109bnVsbCxlKSx0aGlzLmJhc2V1cmw9dH1yZXR1cm4gdC5wcm90b3R5cGUuc2V0Qnl0ZVJhbmdlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5zcGxpdChcIkBcIiwyKSxpPVtdOzE9PT1yLmxlbmd0aD9pWzBdPWU/ZS5ieXRlUmFuZ2VFbmRPZmZzZXQ6MDppWzBdPXBhcnNlSW50KHJbMV0pLGlbMV09cGFyc2VJbnQoclswXSkraVswXSx0aGlzLl9ieXRlUmFuZ2U9aX0sZih0LFt7a2V5OlwiYnl0ZVJhbmdlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2J5dGVSYW5nZT90aGlzLl9ieXRlUmFuZ2U6W119fSx7a2V5OlwiYnl0ZVJhbmdlU3RhcnRPZmZzZXRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ieXRlUmFuZ2VbMF19fSx7a2V5OlwiYnl0ZVJhbmdlRW5kT2Zmc2V0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnl0ZVJhbmdlWzFdfX0se2tleTpcInVybFwiLGdldDpmdW5jdGlvbigpe3JldHVybiF0aGlzLl91cmwmJnRoaXMuYmFzZXVybCYmdGhpcy5yZWx1cmwmJih0aGlzLl91cmw9T2JqZWN0KG4uYnVpbGRBYnNvbHV0ZVVSTCkodGhpcy5iYXNldXJsLHRoaXMucmVsdXJsLHthbHdheXNOb3JtYWxpemU6ITB9KSksdGhpcy5fdXJsfHxcIlwifSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fdXJsPXR9fV0pLHR9KCksdj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKGUscil7dmFyIGk7cmV0dXJuKGk9dC5jYWxsKHRoaXMscil8fHRoaXMpLl9kZWNyeXB0ZGF0YT1udWxsLGkucmF3UHJvZ3JhbURhdGVUaW1lPW51bGwsaS5wcm9ncmFtRGF0ZVRpbWU9bnVsbCxpLnRhZ0xpc3Q9W10saS5kdXJhdGlvbj0wLGkuc249MCxpLmxldmVsa2V5PXZvaWQgMCxpLnR5cGU9dm9pZCAwLGkubG9hZGVyPW51bGwsaS5sZXZlbD0tMSxpLmNjPTAsaS5zdGFydFBUUz12b2lkIDAsaS5lbmRQVFM9dm9pZCAwLGkuYXBwZW5kZWRQVFM9dm9pZCAwLGkuc3RhcnREVFM9dm9pZCAwLGkuZW5kRFRTPXZvaWQgMCxpLnN0YXJ0PTAsaS5kZWx0YVBUUz12b2lkIDAsaS5tYXhTdGFydFBUUz12b2lkIDAsaS5taW5FbmRQVFM9dm9pZCAwLGkuc3RhdHM9bmV3IGwuYSxpLnVybElkPTAsaS5kYXRhPXZvaWQgMCxpLmJpdHJhdGVUZXN0PSExLGkudGl0bGU9bnVsbCxpLmluaXRTZWdtZW50PW51bGwsaS50eXBlPWUsaX11KGUsdCk7dmFyIHI9ZS5wcm90b3R5cGU7cmV0dXJuIHIuY3JlYXRlSW5pdGlhbGl6YXRpb25WZWN0b3I9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBVaW50OEFycmF5KDE2KSxyPTEyO3I8MTY7cisrKWVbcl09dD4+OCooMTUtcikmMjU1O3JldHVybiBlfSxyLnNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5PWZ1bmN0aW9uKHQsZSl7dmFyIHI9dDtyZXR1cm5cIkFFUy0xMjhcIj09PShudWxsPT10P3ZvaWQgMDp0Lm1ldGhvZCkmJnQudXJpJiYhdC5pdiYmKChyPW8uYS5mcm9tVVJJKHQudXJpKSkubWV0aG9kPXQubWV0aG9kLHIuaXY9dGhpcy5jcmVhdGVJbml0aWFsaXphdGlvblZlY3RvcihlKSxyLmtleUZvcm1hdD1cImlkZW50aXR5XCIpLHJ9LHIuc2V0RWxlbWVudGFyeVN0cmVhbUluZm89ZnVuY3Rpb24odCxlLHIsaSxhLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgcz10aGlzLmVsZW1lbnRhcnlTdHJlYW1zLG89c1t0XTtvPyhvLnN0YXJ0UFRTPU1hdGgubWluKG8uc3RhcnRQVFMsZSksby5lbmRQVFM9TWF0aC5tYXgoby5lbmRQVFMsciksby5zdGFydERUUz1NYXRoLm1pbihvLnN0YXJ0RFRTLGkpLG8uZW5kRFRTPU1hdGgubWF4KG8uZW5kRFRTLGEpKTpzW3RdPXtzdGFydFBUUzplLGVuZFBUUzpyLHN0YXJ0RFRTOmksZW5kRFRTOmEscGFydGlhbDpufX0sci5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbGVtZW50YXJ5U3RyZWFtczt0W2kuQVVESU9dPW51bGwsdFtpLlZJREVPXT1udWxsLHRbaS5BVURJT1ZJREVPXT1udWxsfSxmKGUsW3trZXk6XCJkZWNyeXB0ZGF0YVwiLGdldDpmdW5jdGlvbigpe2lmKCF0aGlzLmxldmVsa2V5JiYhdGhpcy5fZGVjcnlwdGRhdGEpcmV0dXJuIG51bGw7aWYoIXRoaXMuX2RlY3J5cHRkYXRhJiZ0aGlzLmxldmVsa2V5KXt2YXIgdD10aGlzLnNuO1wibnVtYmVyXCIhPXR5cGVvZiB0JiYodGhpcy5sZXZlbGtleSYmXCJBRVMtMTI4XCI9PT10aGlzLmxldmVsa2V5Lm1ldGhvZCYmIXRoaXMubGV2ZWxrZXkuaXYmJnMuYi53YXJuKCdtaXNzaW5nIElWIGZvciBpbml0aWFsaXphdGlvbiBzZWdtZW50IHdpdGggbWV0aG9kPVwiJyt0aGlzLmxldmVsa2V5Lm1ldGhvZCsnXCIgLSBjb21wbGlhbmNlIGlzc3VlJyksdD0wKSx0aGlzLl9kZWNyeXB0ZGF0YT10aGlzLnNldERlY3J5cHREYXRhRnJvbUxldmVsS2V5KHRoaXMubGV2ZWxrZXksdCl9cmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhfX0se2tleTpcImVuZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0K3RoaXMuZHVyYXRpb259fSx7a2V5OlwiZW5kUHJvZ3JhbURhdGVUaW1lXCIsZ2V0OmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMucHJvZ3JhbURhdGVUaW1lKXJldHVybiBudWxsO2lmKCFPYmplY3QoYS5hKSh0aGlzLnByb2dyYW1EYXRlVGltZSkpcmV0dXJuIG51bGw7dmFyIHQ9T2JqZWN0KGEuYSkodGhpcy5kdXJhdGlvbik/dGhpcy5kdXJhdGlvbjowO3JldHVybiB0aGlzLnByb2dyYW1EYXRlVGltZSsxZTMqdH19LHtrZXk6XCJlbmNyeXB0ZWRcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4hKG51bGw9PT0odD10aGlzLmRlY3J5cHRkYXRhKXx8dm9pZCAwPT09dHx8IXQua2V5Rm9ybWF0fHwhdGhpcy5kZWNyeXB0ZGF0YS51cmkpfX1dKSxlfShjKSxnPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoZSxyLGksYSxuKXt2YXIgczsocz10LmNhbGwodGhpcyxpKXx8dGhpcykuZnJhZ09mZnNldD0wLHMuZHVyYXRpb249MCxzLmdhcD0hMSxzLmluZGVwZW5kZW50PSExLHMucmVsdXJsPXZvaWQgMCxzLmZyYWdtZW50PXZvaWQgMCxzLmluZGV4PXZvaWQgMCxzLnN0YXRzPW5ldyBsLmEscy5kdXJhdGlvbj1lLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIikscy5nYXA9ZS5ib29sKFwiR0FQXCIpLHMuaW5kZXBlbmRlbnQ9ZS5ib29sKFwiSU5ERVBFTkRFTlRcIikscy5yZWx1cmw9ZS5lbnVtZXJhdGVkU3RyaW5nKFwiVVJJXCIpLHMuZnJhZ21lbnQ9cixzLmluZGV4PWE7dmFyIG89ZS5lbnVtZXJhdGVkU3RyaW5nKFwiQllURVJBTkdFXCIpO3JldHVybiBvJiZzLnNldEJ5dGVSYW5nZShvLG4pLG4mJihzLmZyYWdPZmZzZXQ9bi5mcmFnT2Zmc2V0K24uZHVyYXRpb24pLHN9cmV0dXJuIHUoZSx0KSxmKGUsW3trZXk6XCJzdGFydFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZyYWdtZW50LnN0YXJ0K3RoaXMuZnJhZ09mZnNldH19LHtrZXk6XCJlbmRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydCt0aGlzLmR1cmF0aW9ufX0se2tleTpcImxvYWRlZFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWxlbWVudGFyeVN0cmVhbXM7cmV0dXJuISEodC5hdWRpb3x8dC52aWRlb3x8dC5hdWRpb3ZpZGVvKX19XSksZX0oYyl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImJcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZH0pKSxyLmQoZSxcImdcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaH0pKSxyLmQoZSxcImZcIiwoZnVuY3Rpb24oKXtyZXR1cm4gZn0pKSxyLmQoZSxcImRcIiwoZnVuY3Rpb24oKXtyZXR1cm4gY30pKSxyLmQoZSxcImNcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdn0pKSxyLmQoZSxcImVcIiwoZnVuY3Rpb24oKXtyZXR1cm4gcH0pKSxyLmQoZSxcImhcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbX0pKSxyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4geX0pKTt2YXIgaT1yKDgpLGE9cig1KSxuPU1hdGgucG93KDIsMzIpLTEscz1bXS5wdXNoO2Z1bmN0aW9uIG8odCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCx0KX1mdW5jdGlvbiBsKHQsZSl7XCJkYXRhXCJpbiB0JiYoZSs9dC5zdGFydCx0PXQuZGF0YSk7dmFyIHI9dFtlXTw8MjR8dFtlKzFdPDwxNnx0W2UrMl08PDh8dFtlKzNdO3JldHVybiByPDA/NDI5NDk2NzI5NityOnJ9ZnVuY3Rpb24gdSh0LGUscil7XCJkYXRhXCJpbiB0JiYoZSs9dC5zdGFydCx0PXQuZGF0YSksdFtlXT1yPj4yNCx0W2UrMV09cj4+MTYmMjU1LHRbZSsyXT1yPj44JjI1NSx0W2UrM109MjU1JnJ9ZnVuY3Rpb24gZCh0LGUpe3ZhciByLGksYSxuPVtdO2lmKCFlLmxlbmd0aClyZXR1cm4gbjtcImRhdGFcImluIHQ/KHI9dC5kYXRhLGk9dC5zdGFydCxhPXQuZW5kKTooaT0wLGE9KHI9dCkuYnl0ZUxlbmd0aCk7Zm9yKHZhciB1PWk7dTxhOyl7dmFyIGg9bChyLHUpLGY9aD4xP3UraDphO2lmKG8oci5zdWJhcnJheSh1KzQsdSs4KSk9PT1lWzBdKWlmKDE9PT1lLmxlbmd0aCluLnB1c2goe2RhdGE6cixzdGFydDp1KzgsZW5kOmZ9KTtlbHNle3ZhciBjPWQoe2RhdGE6cixzdGFydDp1KzgsZW5kOmZ9LGUuc2xpY2UoMSkpO2MubGVuZ3RoJiZzLmFwcGx5KG4sYyl9dT1mfXJldHVybiBufWZ1bmN0aW9uIGgodCl7dmFyIGU9ZCh0LFtcIm1vb3ZcIl0pWzBdLHI9ZT9lLmVuZDpudWxsLGk9ZCh0LFtcInNpZHhcIl0pO2lmKCFpfHwhaVswXSlyZXR1cm4gbnVsbDt2YXIgYT1bXSxuPWlbMF0scz1uLmRhdGFbMF0sbz0wPT09cz84OjE2LHU9bChuLG8pO28rPTQsbys9MD09PXM/ODoxNixvKz0yO3ZhciBoPW4uZW5kKzAsZj1mdW5jdGlvbih0LGUpe1wiZGF0YVwiaW4gdCYmKGUrPXQuc3RhcnQsdD10LmRhdGEpO3ZhciByPXRbZV08PDh8dFtlKzFdO3JldHVybiByPDA/NjU1MzYrcjpyfShuLG8pO28rPTI7Zm9yKHZhciBjPTA7YzxmO2MrKyl7dmFyIHY9byxnPWwobix2KTt2Kz00O3ZhciBwPTIxNDc0ODM2NDcmZztpZigxPT0oMjE0NzQ4MzY0OCZnKT4+PjMxKXJldHVybiBjb25zb2xlLndhcm4oXCJTSURYIGhhcyBoaWVyYXJjaGljYWwgcmVmZXJlbmNlcyAobm90IHN1cHBvcnRlZClcIiksbnVsbDt2YXIgbT1sKG4sdik7dis9NCxhLnB1c2goe3JlZmVyZW5jZVNpemU6cCxzdWJzZWdtZW50RHVyYXRpb246bSxpbmZvOntkdXJhdGlvbjptL3Usc3RhcnQ6aCxlbmQ6aCtwLTF9fSksaCs9cCxvPXYrPTR9cmV0dXJue2VhcmxpZXN0UHJlc2VudGF0aW9uVGltZTowLHRpbWVzY2FsZTp1LHZlcnNpb246cyxyZWZlcmVuY2VzQ291bnQ6ZixyZWZlcmVuY2VzOmEsbW9vdkVuZE9mZnNldDpyfX1mdW5jdGlvbiBmKHQpe2Zvcih2YXIgZT1bXSxyPWQodCxbXCJtb292XCIsXCJ0cmFrXCJdKSxpPTA7aTxyLmxlbmd0aDtpKyspe3ZhciBuPXJbaV0scz1kKG4sW1widGtoZFwiXSlbMF07aWYocyl7dmFyIHU9cy5kYXRhW3Muc3RhcnRdLGg9MD09PXU/MTI6MjAsZj1sKHMsaCksYz1kKG4sW1wibWRpYVwiLFwibWRoZFwiXSlbMF07aWYoYyl7dmFyIHY9bChjLGg9MD09PSh1PWMuZGF0YVtjLnN0YXJ0XSk/MTI6MjApLGc9ZChuLFtcIm1kaWFcIixcImhkbHJcIl0pWzBdO2lmKGcpe3ZhciBwPW8oZy5kYXRhLnN1YmFycmF5KGcuc3RhcnQrOCxnLnN0YXJ0KzEyKSksbT17c291bjphLmEuQVVESU8sdmlkZTphLmEuVklERU99W3BdO2lmKG0pe3ZhciB5PWQobixbXCJtZGlhXCIsXCJtaW5mXCIsXCJzdGJsXCIsXCJzdHNkXCJdKVswXSxiPXZvaWQgMDt5JiYoYj1vKHkuZGF0YS5zdWJhcnJheSh5LnN0YXJ0KzEyLHkuc3RhcnQrMTYpKSksZVtmXT17dGltZXNjYWxlOnYsdHlwZTptfSxlW21dPXt0aW1lc2NhbGU6dixpZDpmLGNvZGVjOmJ9fX19fX1yZXR1cm4gZCh0LFtcIm1vb3ZcIixcIm12ZXhcIixcInRyZXhcIl0pLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPWwodCw0KSxpPWVbcl07aSYmKGkuZGVmYXVsdD17ZHVyYXRpb246bCh0LDEyKSxmbGFnczpsKHQsMjApfSl9KSksZX1mdW5jdGlvbiBjKHQsZSl7cmV0dXJuIGQoZSxbXCJtb29mXCIsXCJ0cmFmXCJdKS5yZWR1Y2UoKGZ1bmN0aW9uKGUscil7dmFyIGk9ZChyLFtcInRmZHRcIl0pWzBdLGE9aS5kYXRhW2kuc3RhcnRdLG49ZChyLFtcInRmaGRcIl0pLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXt2YXIgbj1sKHIsNCkscz10W25dO2lmKHMpe3ZhciBvPWwoaSw0KTsxPT09YSYmKG8qPU1hdGgucG93KDIsMzIpLG8rPWwoaSw4KSk7dmFyIHU9by8ocy50aW1lc2NhbGV8fDllNCk7aWYoaXNGaW5pdGUodSkmJihudWxsPT09ZXx8dTxlKSlyZXR1cm4gdX1yZXR1cm4gZX0pLG51bGwpO3JldHVybiBudWxsIT09biYmaXNGaW5pdGUobikmJihudWxsPT09ZXx8bjxlKT9uOmV9KSxudWxsKXx8MH1mdW5jdGlvbiB2KHQsZSl7Zm9yKHZhciByPTAsaT0wLG49MCxzPWQodCxbXCJtb29mXCIsXCJ0cmFmXCJdKSxvPTA7bzxzLmxlbmd0aDtvKyspe3ZhciB1PXNbb10sZj1kKHUsW1widGZoZFwiXSlbMF0sYz1lW2woZiw0KV07aWYoYyl7dmFyIHY9Yy5kZWZhdWx0LHA9bChmLDApfChudWxsPT12P3ZvaWQgMDp2LmZsYWdzKSxtPW51bGw9PXY/dm9pZCAwOnYuZHVyYXRpb247OCZwJiYobT1sKGYsMiZwPzEyOjgpKTtmb3IodmFyIHk9Yy50aW1lc2NhbGV8fDllNCxiPWQodSxbXCJ0cnVuXCJdKSxUPTA7VDxiLmxlbmd0aDtUKyspIShyPWcoYltUXSkpJiZtJiYocj1tKmwoYltUXSw0KSksYy50eXBlPT09YS5hLlZJREVPP2krPXIveTpjLnR5cGU9PT1hLmEuQVVESU8mJihuKz1yL3kpfX1pZigwPT09aSYmMD09PW4pe3ZhciBFPWgodCk7aWYobnVsbCE9RSYmRS5yZWZlcmVuY2VzKXJldHVybiBFLnJlZmVyZW5jZXMucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2UuaW5mby5kdXJhdGlvbnx8MH0pLDApfXJldHVybiBpfHxufWZ1bmN0aW9uIGcodCl7dmFyIGU9bCh0LDApLHI9ODsxJmUmJihyKz00KSw0JmUmJihyKz00KTtmb3IodmFyIGk9MCxhPWwodCw0KSxuPTA7bjxhO24rKykyNTYmZSYmKGkrPWwodCxyKSxyKz00KSw1MTImZSYmKHIrPTQpLDEwMjQmZSYmKHIrPTQpLDIwNDgmZSYmKHIrPTQpO3JldHVybiBpfWZ1bmN0aW9uIHAodCxlLHIpe2QoZSxbXCJtb29mXCIsXCJ0cmFmXCJdKS5mb3JFYWNoKChmdW5jdGlvbihlKXtkKGUsW1widGZoZFwiXSkuZm9yRWFjaCgoZnVuY3Rpb24oaSl7dmFyIGE9bChpLDQpLHM9dFthXTtpZihzKXt2YXIgbz1zLnRpbWVzY2FsZXx8OWU0O2QoZSxbXCJ0ZmR0XCJdKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LmRhdGFbdC5zdGFydF0saT1sKHQsNCk7aWYoMD09PWUpdSh0LDQsaS1yKm8pO2Vsc2V7aSo9TWF0aC5wb3coMiwzMiksaSs9bCh0LDgpLGktPXIqbyxpPU1hdGgubWF4KGksMCk7dmFyIGE9TWF0aC5mbG9vcihpLyhuKzEpKSxzPU1hdGguZmxvb3IoaSUobisxKSk7dSh0LDQsYSksdSh0LDgscyl9fSkpfX0pKX0pKX1mdW5jdGlvbiBtKHQpe3ZhciBlPXt2YWxpZDpudWxsLHJlbWFpbmRlcjpudWxsfSxyPWQodCxbXCJtb29mXCJdKTtpZighcilyZXR1cm4gZTtpZihyLmxlbmd0aDwyKXJldHVybiBlLnJlbWFpbmRlcj10LGU7dmFyIGE9cltyLmxlbmd0aC0xXTtyZXR1cm4gZS52YWxpZD1PYmplY3QoaS5hKSh0LDAsYS5zdGFydC04KSxlLnJlbWFpbmRlcj1PYmplY3QoaS5hKSh0LGEuc3RhcnQtOCksZX1mdW5jdGlvbiB5KHQsZSl7dmFyIHI9bmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgrZS5sZW5ndGgpO3JldHVybiByLnNldCh0KSxyLnNldChlLHQubGVuZ3RoKSxyfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuZChlLFwiYlwiLChmdW5jdGlvbigpe3JldHVybiBzfSkpLHIuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBsfSkpLHIuZChlLFwiZFwiLChmdW5jdGlvbigpe3JldHVybiB1fSkpLHIuZChlLFwiZVwiLChmdW5jdGlvbigpe3JldHVybiBkfSkpLHIuZChlLFwiY1wiLChmdW5jdGlvbigpe3JldHVybiBmfSkpLHIuZChlLFwiZlwiLChmdW5jdGlvbigpe3JldHVybiB5fSkpO3ZhciBpLGE9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSsxMDw9dC5sZW5ndGgmJjczPT09dFtlXSYmNjg9PT10W2UrMV0mJjUxPT09dFtlKzJdJiZ0W2UrM108MjU1JiZ0W2UrNF08MjU1JiZ0W2UrNl08MTI4JiZ0W2UrN108MTI4JiZ0W2UrOF08MTI4JiZ0W2UrOV08MTI4fSxuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUrMTA8PXQubGVuZ3RoJiY1MT09PXRbZV0mJjY4PT09dFtlKzFdJiY3Mz09PXRbZSsyXSYmdFtlKzNdPDI1NSYmdFtlKzRdPDI1NSYmdFtlKzZdPDEyOCYmdFtlKzddPDEyOCYmdFtlKzhdPDEyOCYmdFtlKzldPDEyOH0scz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1lLGk9MDthKHQsZSk7KWkrPTEwLGkrPW8odCxlKzYpLG4odCxlKzEwKSYmKGkrPTEwKSxlKz1pO2lmKGk+MClyZXR1cm4gdC5zdWJhcnJheShyLHIraSl9LG89ZnVuY3Rpb24odCxlKXt2YXIgcj0wO3JldHVybiByPSgxMjcmdFtlXSk8PDIxLHJ8PSgxMjcmdFtlKzFdKTw8MTQsKHJ8PSgxMjcmdFtlKzJdKTw8Nyl8MTI3JnRbZSszXX0sbD1mdW5jdGlvbih0LGUpe3JldHVybiBhKHQsZSkmJm8odCxlKzYpKzEwPD10Lmxlbmd0aC1lfSx1PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1mKHQpLHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpZihkKGkpKXJldHVybiBtKGkpfX0sZD1mdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJQUklWXCI9PT10LmtleSYmXCJjb20uYXBwbGUuc3RyZWFtaW5nLnRyYW5zcG9ydFN0cmVhbVRpbWVzdGFtcFwiPT09dC5pbmZvfSxoPWZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZy5mcm9tQ2hhckNvZGUodFswXSx0WzFdLHRbMl0sdFszXSkscj1vKHQsNCk7cmV0dXJue3R5cGU6ZSxzaXplOnIsZGF0YTp0LnN1YmFycmF5KDEwLDEwK3IpfX0sZj1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxyPVtdO2EodCxlKTspe2Zvcih2YXIgaT1vKHQsZSs2KSxzPShlKz0xMCkraTtlKzg8czspe3ZhciBsPWgodC5zdWJhcnJheShlKSksdT1jKGwpO3UmJnIucHVzaCh1KSxlKz1sLnNpemUrMTB9bih0LGUpJiYoZSs9MTApfXJldHVybiByfSxjPWZ1bmN0aW9uKHQpe3JldHVyblwiUFJJVlwiPT09dC50eXBlP3YodCk6XCJXXCI9PT10LnR5cGVbMF0/cCh0KTpnKHQpfSx2PWZ1bmN0aW9uKHQpe2lmKCEodC5zaXplPDIpKXt2YXIgZT15KHQuZGF0YSwhMCkscj1uZXcgVWludDhBcnJheSh0LmRhdGEuc3ViYXJyYXkoZS5sZW5ndGgrMSkpO3JldHVybntrZXk6dC50eXBlLGluZm86ZSxkYXRhOnIuYnVmZmVyfX19LGc9ZnVuY3Rpb24odCl7aWYoISh0LnNpemU8Mikpe2lmKFwiVFhYWFwiPT09dC50eXBlKXt2YXIgZT0xLHI9eSh0LmRhdGEuc3ViYXJyYXkoZSksITApO2UrPXIubGVuZ3RoKzE7dmFyIGk9eSh0LmRhdGEuc3ViYXJyYXkoZSkpO3JldHVybntrZXk6dC50eXBlLGluZm86cixkYXRhOml9fXZhciBhPXkodC5kYXRhLnN1YmFycmF5KDEpKTtyZXR1cm57a2V5OnQudHlwZSxkYXRhOmF9fX0scD1mdW5jdGlvbih0KXtpZihcIldYWFhcIj09PXQudHlwZSl7aWYodC5zaXplPDIpcmV0dXJuO3ZhciBlPTEscj15KHQuZGF0YS5zdWJhcnJheShlKSwhMCk7ZSs9ci5sZW5ndGgrMTt2YXIgaT15KHQuZGF0YS5zdWJhcnJheShlKSk7cmV0dXJue2tleTp0LnR5cGUsaW5mbzpyLGRhdGE6aX19dmFyIGE9eSh0LmRhdGEpO3JldHVybntrZXk6dC50eXBlLGRhdGE6YX19LG09ZnVuY3Rpb24odCl7aWYoOD09PXQuZGF0YS5ieXRlTGVuZ3RoKXt2YXIgZT1uZXcgVWludDhBcnJheSh0LmRhdGEpLHI9MSZlWzNdLGk9KGVbNF08PDIzKSsoZVs1XTw8MTUpKyhlWzZdPDw3KStlWzddO3JldHVybiBpLz00NSxyJiYoaSs9NDc3MjE4NTguODQpLE1hdGgucm91bmQoaSl9fSx5PWZ1bmN0aW9uKHQsZSl7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciByPWIoKTtpZihyKXt2YXIgaT1yLmRlY29kZSh0KTtpZihlKXt2YXIgYT1pLmluZGV4T2YoXCJcXDBcIik7cmV0dXJuLTEhPT1hP2kuc3Vic3RyaW5nKDAsYSk6aX1yZXR1cm4gaS5yZXBsYWNlKC9cXDAvZyxcIlwiKX1mb3IodmFyIG4scyxvLGw9dC5sZW5ndGgsdT1cIlwiLGQ9MDtkPGw7KXtpZigwPT09KG49dFtkKytdKSYmZSlyZXR1cm4gdTtpZigwIT09biYmMyE9PW4pc3dpdGNoKG4+PjQpe2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgMzpjYXNlIDQ6Y2FzZSA1OmNhc2UgNjpjYXNlIDc6dSs9U3RyaW5nLmZyb21DaGFyQ29kZShuKTticmVhaztjYXNlIDEyOmNhc2UgMTM6cz10W2QrK10sdSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmbik8PDZ8NjMmcyk7YnJlYWs7Y2FzZSAxNDpzPXRbZCsrXSxvPXRbZCsrXSx1Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgxNSZuKTw8MTJ8KDYzJnMpPDw2fCg2MyZvKTw8MCl9fXJldHVybiB1fTtmdW5jdGlvbiBiKCl7cmV0dXJuIGl8fHZvaWQgMD09PXNlbGYuVGV4dERlY29kZXJ8fChpPW5ldyBzZWxmLlRleHREZWNvZGVyKFwidXRmLThcIikpLGl9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSh0LGUscil7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlP3Quc2xpY2UoZSxyKTpuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0LGUscikpfXIuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBpfSkpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ci5kKGUsXCJjXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEV0fSkpLHIuZChlLFwiZFwiLChmdW5jdGlvbigpe3JldHVybiBMdH0pKSxyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gQXR9KSksci5kKGUsXCJiXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIFJ0fSkpO3ZhciBpPXIoMCksYT1yKDIpLG49cigxNCkscz1yKDMpLG89cig3KSxsPXIoNiksdT1yKDgpLGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5fYXVkaW9UcmFjaz12b2lkIDAsdGhpcy5faWQzVHJhY2s9dm9pZCAwLHRoaXMuZnJhbWVJbmRleD0wLHRoaXMuY2FjaGVkRGF0YT1udWxsLHRoaXMuaW5pdFBUUz1udWxsfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnJlc2V0SW5pdFNlZ21lbnQ9ZnVuY3Rpb24odCxlLHIpe3RoaXMuX2lkM1RyYWNrPXt0eXBlOlwiaWQzXCIsaWQ6MyxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOjAsc2FtcGxlczpbXSxkcm9wcGVkOjB9fSxlLnJlc2V0VGltZVN0YW1wPWZ1bmN0aW9uKCl7fSxlLnJlc2V0Q29udGlndWl0eT1mdW5jdGlvbigpe30sZS5jYW5QYXJzZT1mdW5jdGlvbih0LGUpe3JldHVybiExfSxlLmFwcGVuZEZyYW1lPWZ1bmN0aW9uKHQsZSxyKXt9LGUuZGVtdXg9ZnVuY3Rpb24odCxlKXt0aGlzLmNhY2hlZERhdGEmJih0PU9iamVjdChsLmEpKHRoaXMuY2FjaGVkRGF0YSx0KSx0aGlzLmNhY2hlZERhdGE9bnVsbCk7dmFyIHIsaSxhPW8uYih0LDApLG49YT9hLmxlbmd0aDowLHM9dGhpcy5fYXVkaW9UcmFjayxkPXRoaXMuX2lkM1RyYWNrLGY9YT9vLmQoYSk6dm9pZCAwLGM9dC5sZW5ndGg7Zm9yKDAhPT10aGlzLmZyYW1lSW5kZXgmJm51bGwhPT10aGlzLmluaXRQVFN8fCh0aGlzLmluaXRQVFM9aChmLGUpKSxhJiZhLmxlbmd0aD4wJiZkLnNhbXBsZXMucHVzaCh7cHRzOnRoaXMuaW5pdFBUUyxkdHM6dGhpcy5pbml0UFRTLGRhdGE6YX0pLGk9dGhpcy5pbml0UFRTO248Yzspe2lmKHRoaXMuY2FuUGFyc2UodCxuKSl7dmFyIHY9dGhpcy5hcHBlbmRGcmFtZShzLHQsbik7dj8odGhpcy5mcmFtZUluZGV4KyssaT12LnNhbXBsZS5wdHMscj1uKz12Lmxlbmd0aCk6bj1jfWVsc2Ugby5hKHQsbik/KGE9by5iKHQsbiksZC5zYW1wbGVzLnB1c2goe3B0czppLGR0czppLGRhdGE6YX0pLHI9bis9YS5sZW5ndGgpOm4rKztpZihuPT09YyYmciE9PWMpe3ZhciBnPU9iamVjdCh1LmEpKHQscik7dGhpcy5jYWNoZWREYXRhP3RoaXMuY2FjaGVkRGF0YT1PYmplY3QobC5hKSh0aGlzLmNhY2hlZERhdGEsZyk6dGhpcy5jYWNoZWREYXRhPWd9fXJldHVybnthdWRpb1RyYWNrOnMsYXZjVHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfSxpZDNUcmFjazpkLHRleHRUcmFjazp7dHlwZTpcIlwiLGlkOi0xLHBpZDotMSxpbnB1dFRpbWVTY2FsZTo5ZTQsc2VxdWVuY2VOdW1iZXI6LTEsc2FtcGxlczpbXSxkcm9wcGVkOjB9fX0sZS5kZW11eFNhbXBsZUFlcz1mdW5jdGlvbih0LGUscil7cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIltcIit0aGlzK1wiXSBUaGlzIGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTYW1wbGUtQUVTIGRlY3J5cHRpb25cIikpfSxlLmZsdXNoPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY2FjaGVkRGF0YTtyZXR1cm4gZSYmKHRoaXMuY2FjaGVkRGF0YT1udWxsLHRoaXMuZGVtdXgoZSwwKSksdGhpcy5mcmFtZUluZGV4PTAse2F1ZGlvVHJhY2s6dGhpcy5fYXVkaW9UcmFjayxhdmNUcmFjazp7dHlwZTpcIlwiLGlkOi0xLHBpZDotMSxpbnB1dFRpbWVTY2FsZTo5ZTQsc2VxdWVuY2VOdW1iZXI6LTEsc2FtcGxlczpbXSxkcm9wcGVkOjB9LGlkM1RyYWNrOnRoaXMuX2lkM1RyYWNrLHRleHRUcmFjazp7dHlwZTpcIlwiLGlkOi0xLHBpZDotMSxpbnB1dFRpbWVTY2FsZTo5ZTQsc2VxdWVuY2VOdW1iZXI6LTEsc2FtcGxlczpbXSxkcm9wcGVkOjB9fX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7fSx0fSgpLGg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gT2JqZWN0KHMuYSkodCk/OTAqdDo5ZTQqZX0sZj1kLGM9cigxKTtmdW5jdGlvbiB2KHQsZSl7cmV0dXJuIDI1NT09PXRbZV0mJjI0MD09KDI0NiZ0W2UrMV0pfWZ1bmN0aW9uIGcodCxlKXtyZXR1cm4gMSZ0W2UrMV0/Nzo5fWZ1bmN0aW9uIHAodCxlKXtyZXR1cm4oMyZ0W2UrM10pPDwxMXx0W2UrNF08PDN8KDIyNCZ0W2UrNV0pPj4+NX1mdW5jdGlvbiBtKHQsZSl7cmV0dXJuIGUrMTx0Lmxlbmd0aCYmdih0LGUpfWZ1bmN0aW9uIHkodCxlKXtpZihtKHQsZSkpe3ZhciByPWcodCxlKTtpZihlK3I+PXQubGVuZ3RoKXJldHVybiExO3ZhciBpPXAodCxlKTtpZihpPD1yKXJldHVybiExO3ZhciBhPWUraTtyZXR1cm4gYT09PXQubGVuZ3RofHxtKHQsYSl9cmV0dXJuITF9ZnVuY3Rpb24gYih0LGUscixuLHMpe2lmKCF0LnNhbXBsZXJhdGUpe3ZhciBvPWZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBzLG8sbCx1LGQ9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLGg9bixmPVs5NmUzLDg4MjAwLDY0ZTMsNDhlMyw0NDEwMCwzMmUzLDI0ZTMsMjIwNTAsMTZlMywxMmUzLDExMDI1LDhlMyw3MzUwXTtzPTErKCgxOTImZVtyKzJdKT4+PjYpO3ZhciB2PSg2MCZlW3IrMl0pPj4+MjtpZighKHY+Zi5sZW5ndGgtMSkpcmV0dXJuIGw9KDEmZVtyKzJdKTw8MixsfD0oMTkyJmVbciszXSk+Pj42LGMuYi5sb2coXCJtYW5pZmVzdCBjb2RlYzpcIituK1wiLCBBRFRTIHR5cGU6XCIrcytcIiwgc2FtcGxpbmdJbmRleDpcIit2KSwvZmlyZWZveC9pLnRlc3QoZCk/dj49Nj8ocz01LHU9bmV3IEFycmF5KDQpLG89di0zKToocz0yLHU9bmV3IEFycmF5KDIpLG89dik6LTEhPT1kLmluZGV4T2YoXCJhbmRyb2lkXCIpPyhzPTIsdT1uZXcgQXJyYXkoMiksbz12KToocz01LHU9bmV3IEFycmF5KDQpLG4mJigtMSE9PW4uaW5kZXhPZihcIm1wNGEuNDAuMjlcIil8fC0xIT09bi5pbmRleE9mKFwibXA0YS40MC41XCIpKXx8IW4mJnY+PTY/bz12LTM6KChuJiYtMSE9PW4uaW5kZXhPZihcIm1wNGEuNDAuMlwiKSYmKHY+PTYmJjE9PT1sfHwvdml2YWxkaS9pLnRlc3QoZCkpfHwhbiYmMT09PWwpJiYocz0yLHU9bmV3IEFycmF5KDIpKSxvPXYpKSx1WzBdPXM8PDMsdVswXXw9KDE0JnYpPj4xLHVbMV18PSgxJnYpPDw3LHVbMV18PWw8PDMsNT09PXMmJih1WzFdfD0oMTQmbyk+PjEsdVsyXT0oMSZvKTw8Nyx1WzJdfD04LHVbM109MCkse2NvbmZpZzp1LHNhbXBsZXJhdGU6Zlt2XSxjaGFubmVsQ291bnQ6bCxjb2RlYzpcIm1wNGEuNDAuXCIrcyxtYW5pZmVzdENvZGVjOmh9O3QudHJpZ2dlcihpLmEuRVJST1Ise3R5cGU6YS5iLk1FRElBX0VSUk9SLGRldGFpbHM6YS5hLkZSQUdfUEFSU0lOR19FUlJPUixmYXRhbDohMCxyZWFzb246XCJpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6XCIrdn0pfShlLHIsbixzKTtpZighbylyZXR1cm47dC5jb25maWc9by5jb25maWcsdC5zYW1wbGVyYXRlPW8uc2FtcGxlcmF0ZSx0LmNoYW5uZWxDb3VudD1vLmNoYW5uZWxDb3VudCx0LmNvZGVjPW8uY29kZWMsdC5tYW5pZmVzdENvZGVjPW8ubWFuaWZlc3RDb2RlYyxjLmIubG9nKFwicGFyc2VkIGNvZGVjOlwiK3QuY29kZWMrXCIsIHJhdGU6XCIrby5zYW1wbGVyYXRlK1wiLCBjaGFubmVsczpcIitvLmNoYW5uZWxDb3VudCl9fWZ1bmN0aW9uIFQodCl7cmV0dXJuIDkyMTZlNC90fWZ1bmN0aW9uIEUodCxlLHIsaSxhKXt2YXIgbj1mdW5jdGlvbih0LGUscixpLGEpe3ZhciBuPWcodCxlKSxzPXAodCxlKTtpZigocy09bik+MClyZXR1cm57aGVhZGVyTGVuZ3RoOm4sZnJhbWVMZW5ndGg6cyxzdGFtcDpyK2kqYX19KGUscixpLGEsVCh0LnNhbXBsZXJhdGUpKTtpZihuKXt2YXIgcyxvPW4uZnJhbWVMZW5ndGgsbD1uLmhlYWRlckxlbmd0aCx1PW4uc3RhbXAsZD1sK28saD1NYXRoLm1heCgwLHIrZC1lLmxlbmd0aCk7aD8ocz1uZXcgVWludDhBcnJheShkLWwpKS5zZXQoZS5zdWJhcnJheShyK2wsZS5sZW5ndGgpLDApOnM9ZS5zdWJhcnJheShyK2wscitkKTt2YXIgZj17dW5pdDpzLHB0czp1fTtyZXR1cm4gaHx8dC5zYW1wbGVzLnB1c2goZikse3NhbXBsZTpmLGxlbmd0aDpkLG1pc3Npbmc6aH19fWZ1bmN0aW9uIFModCxlKXtyZXR1cm4oUz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWUsdH0pKHQsZSl9dmFyIEw9ZnVuY3Rpb24odCl7dmFyIGUscjtmdW5jdGlvbiBpKGUscil7dmFyIGk7cmV0dXJuKGk9dC5jYWxsKHRoaXMpfHx0aGlzKS5vYnNlcnZlcj12b2lkIDAsaS5jb25maWc9dm9pZCAwLGkub2JzZXJ2ZXI9ZSxpLmNvbmZpZz1yLGl9cj10LChlPWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLFMoZSxyKTt2YXIgYT1pLnByb3RvdHlwZTtyZXR1cm4gYS5yZXNldEluaXRTZWdtZW50PWZ1bmN0aW9uKGUscixpKXt0LnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcyxlLHIsaSksdGhpcy5fYXVkaW9UcmFjaz17Y29udGFpbmVyOlwiYXVkaW8vYWR0c1wiLHR5cGU6XCJhdWRpb1wiLGlkOjIscGlkOi0xLHNlcXVlbmNlTnVtYmVyOjAsaXNBQUM6ITAsc2FtcGxlczpbXSxtYW5pZmVzdENvZGVjOmUsZHVyYXRpb246aSxpbnB1dFRpbWVTY2FsZTo5ZTQsZHJvcHBlZDowfX0saS5wcm9iZT1mdW5jdGlvbih0KXtpZighdClyZXR1cm4hMTtmb3IodmFyIGU9KG8uYih0LDApfHxbXSkubGVuZ3RoLHI9dC5sZW5ndGg7ZTxyO2UrKylpZih5KHQsZSkpcmV0dXJuIGMuYi5sb2coXCJBRFRTIHN5bmMgd29yZCBmb3VuZCAhXCIpLCEwO3JldHVybiExfSxhLmNhblBhcnNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUrNTx0Lmxlbmd0aH0odCxlKSYmdih0LGUpJiZwKHQsZSk8PXQubGVuZ3RoLWV9KHQsZSl9LGEuYXBwZW5kRnJhbWU9ZnVuY3Rpb24odCxlLHIpe2IodCx0aGlzLm9ic2VydmVyLGUscix0Lm1hbmlmZXN0Q29kZWMpO3ZhciBpPUUodCxlLHIsdGhpcy5pbml0UFRTLHRoaXMuZnJhbWVJbmRleCk7aWYoaSYmMD09PWkubWlzc2luZylyZXR1cm4gaX0saX0oZik7TC5taW5Qcm9iZUJ5dGVMZW5ndGg9OTt2YXIgQT1MLFI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5yZW1haW5kZXJEYXRhPW51bGwsdGhpcy5jb25maWc9dm9pZCAwLHRoaXMuY29uZmlnPWV9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUucmVzZXRUaW1lU3RhbXA9ZnVuY3Rpb24oKXt9LGUucmVzZXRJbml0U2VnbWVudD1mdW5jdGlvbigpe30sZS5yZXNldENvbnRpZ3VpdHk9ZnVuY3Rpb24oKXt9LHQucHJvYmU9ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdChsLmIpKHtkYXRhOnQsc3RhcnQ6MCxlbmQ6TWF0aC5taW4odC5sZW5ndGgsMTYzODQpfSxbXCJtb29mXCJdKS5sZW5ndGg+MH0sZS5kZW11eD1mdW5jdGlvbih0KXt2YXIgZT10LHI9e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfTtpZih0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSl7dGhpcy5yZW1haW5kZXJEYXRhJiYoZT1PYmplY3QobC5hKSh0aGlzLnJlbWFpbmRlckRhdGEsdCkpO3ZhciBpPU9iamVjdChsLmgpKGUpO3RoaXMucmVtYWluZGVyRGF0YT1pLnJlbWFpbmRlcixyLnNhbXBsZXM9aS52YWxpZHx8bmV3IFVpbnQ4QXJyYXl9ZWxzZSByLnNhbXBsZXM9ZTtyZXR1cm57YXVkaW9UcmFjazp7dHlwZTpcIlwiLGlkOi0xLHBpZDotMSxpbnB1dFRpbWVTY2FsZTo5ZTQsc2VxdWVuY2VOdW1iZXI6LTEsc2FtcGxlczpbXSxkcm9wcGVkOjB9LGF2Y1RyYWNrOnIsaWQzVHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfSx0ZXh0VHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfX19LGUuZmx1c2g9ZnVuY3Rpb24oKXt2YXIgdD17dHlwZTpcIlwiLGlkOi0xLHBpZDotMSxpbnB1dFRpbWVTY2FsZTo5ZTQsc2VxdWVuY2VOdW1iZXI6LTEsc2FtcGxlczpbXSxkcm9wcGVkOjB9O3JldHVybiB0LnNhbXBsZXM9dGhpcy5yZW1haW5kZXJEYXRhfHxuZXcgVWludDhBcnJheSx0aGlzLnJlbWFpbmRlckRhdGE9bnVsbCx7YXVkaW9UcmFjazp7dHlwZTpcIlwiLGlkOi0xLHBpZDotMSxpbnB1dFRpbWVTY2FsZTo5ZTQsc2VxdWVuY2VOdW1iZXI6LTEsc2FtcGxlczpbXSxkcm9wcGVkOjB9LGF2Y1RyYWNrOnQsaWQzVHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfSx0ZXh0VHJhY2s6e3R5cGU6XCJcIixpZDotMSxwaWQ6LTEsaW5wdXRUaW1lU2NhbGU6OWU0LHNlcXVlbmNlTnVtYmVyOi0xLHNhbXBsZXM6W10sZHJvcHBlZDowfX19LGUuZGVtdXhTYW1wbGVBZXM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJUaGUgTVA0IGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTQU1QTEUtQUVTIGRlY3J5cHRpb25cIikpfSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt9LHR9KCk7Ui5taW5Qcm9iZUJ5dGVMZW5ndGg9MTAyNDt2YXIgRD1SLF89bnVsbCxrPVszMiw2NCw5NiwxMjgsMTYwLDE5MiwyMjQsMjU2LDI4OCwzMjAsMzUyLDM4NCw0MTYsNDQ4LDMyLDQ4LDU2LDY0LDgwLDk2LDExMiwxMjgsMTYwLDE5MiwyMjQsMjU2LDMyMCwzODQsMzIsNDAsNDgsNTYsNjQsODAsOTYsMTEyLDEyOCwxNjAsMTkyLDIyNCwyNTYsMzIwLDMyLDQ4LDU2LDY0LDgwLDk2LDExMiwxMjgsMTQ0LDE2MCwxNzYsMTkyLDIyNCwyNTYsOCwxNiwyNCwzMiw0MCw0OCw1Niw2NCw4MCw5NiwxMTIsMTI4LDE0NCwxNjBdLHg9WzQ0MTAwLDQ4ZTMsMzJlMywyMjA1MCwyNGUzLDE2ZTMsMTEwMjUsMTJlMyw4ZTNdLHc9W1swLDcyLDE0NCwxMl0sWzAsMCwwLDBdLFswLDcyLDE0NCwxMl0sWzAsMTQ0LDE0NCwxMl1dLEM9WzAsMSwxLDRdO2Z1bmN0aW9uIE8odCxlLHIsaSxhKXtpZighKHIrMjQ+ZS5sZW5ndGgpKXt2YXIgbj1JKGUscik7aWYobiYmcituLmZyYW1lTGVuZ3RoPD1lLmxlbmd0aCl7dmFyIHM9aSthKig5ZTQqbi5zYW1wbGVzUGVyRnJhbWUvbi5zYW1wbGVSYXRlKSxvPXt1bml0OmUuc3ViYXJyYXkocixyK24uZnJhbWVMZW5ndGgpLHB0czpzLGR0czpzfTtyZXR1cm4gdC5jb25maWc9W10sdC5jaGFubmVsQ291bnQ9bi5jaGFubmVsQ291bnQsdC5zYW1wbGVyYXRlPW4uc2FtcGxlUmF0ZSx0LnNhbXBsZXMucHVzaChvKSx7c2FtcGxlOm8sbGVuZ3RoOm4uZnJhbWVMZW5ndGgsbWlzc2luZzowfX19fWZ1bmN0aW9uIEkodCxlKXt2YXIgcj10W2UrMV0+PjMmMyxpPXRbZSsxXT4+MSYzLGE9dFtlKzJdPj40JjE1LG49dFtlKzJdPj4yJjM7aWYoMSE9PXImJjAhPT1hJiYxNSE9PWEmJjMhPT1uKXt2YXIgcz10W2UrMl0+PjEmMSxvPXRbZSszXT4+NixsPTFlMyprWzE0KigzPT09cj8zLWk6Mz09PWk/Mzo0KSthLTFdLHU9eFszKigzPT09cj8wOjI9PT1yPzE6Mikrbl0sZD0zPT09bz8xOjIsaD13W3JdW2ldLGY9Q1tpXSxjPTgqaCpmLHY9TWF0aC5mbG9vcihoKmwvdStzKSpmO2lmKG51bGw9PT1fKXt2YXIgZz0obmF2aWdhdG9yLnVzZXJBZ2VudHx8XCJcIikubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS9pKTtfPWc/cGFyc2VJbnQoZ1sxXSk6MH1yZXR1cm4hIV8mJl88PTg3JiYyPT09aSYmbD49MjI0ZTMmJjA9PT1vJiYodFtlKzNdPTEyOHx0W2UrM10pLHtzYW1wbGVSYXRlOnUsY2hhbm5lbENvdW50OmQsZnJhbWVMZW5ndGg6dixzYW1wbGVzUGVyRnJhbWU6Y319fWZ1bmN0aW9uIFAodCxlKXtyZXR1cm4gMjU1PT09dFtlXSYmMjI0PT0oMjI0JnRbZSsxXSkmJjAhPSg2JnRbZSsxXSl9ZnVuY3Rpb24gRih0LGUpe3JldHVybiBlKzE8dC5sZW5ndGgmJlAodCxlKX1mdW5jdGlvbiBNKHQsZSl7aWYoZSsxPHQubGVuZ3RoJiZQKHQsZSkpe3ZhciByPUkodCxlKSxpPTQ7bnVsbCE9ciYmci5mcmFtZUxlbmd0aCYmKGk9ci5mcmFtZUxlbmd0aCk7dmFyIGE9ZStpO3JldHVybiBhPT09dC5sZW5ndGh8fEYodCxhKX1yZXR1cm4hMX12YXIgTj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5kYXRhPXZvaWQgMCx0aGlzLmJ5dGVzQXZhaWxhYmxlPXZvaWQgMCx0aGlzLndvcmQ9dm9pZCAwLHRoaXMuYml0c0F2YWlsYWJsZT12b2lkIDAsdGhpcy5kYXRhPXQsdGhpcy5ieXRlc0F2YWlsYWJsZT10LmJ5dGVMZW5ndGgsdGhpcy53b3JkPTAsdGhpcy5iaXRzQXZhaWxhYmxlPTB9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUubG9hZFdvcmQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmRhdGEsZT10aGlzLmJ5dGVzQXZhaWxhYmxlLHI9dC5ieXRlTGVuZ3RoLWUsaT1uZXcgVWludDhBcnJheSg0KSxhPU1hdGgubWluKDQsZSk7aWYoMD09PWEpdGhyb3cgbmV3IEVycm9yKFwibm8gYnl0ZXMgYXZhaWxhYmxlXCIpO2kuc2V0KHQuc3ViYXJyYXkocixyK2EpKSx0aGlzLndvcmQ9bmV3IERhdGFWaWV3KGkuYnVmZmVyKS5nZXRVaW50MzIoMCksdGhpcy5iaXRzQXZhaWxhYmxlPTgqYSx0aGlzLmJ5dGVzQXZhaWxhYmxlLT1hfSxlLnNraXBCaXRzPWZ1bmN0aW9uKHQpe3ZhciBlO3RoaXMuYml0c0F2YWlsYWJsZT50Pyh0aGlzLndvcmQ8PD10LHRoaXMuYml0c0F2YWlsYWJsZS09dCk6KHQtPXRoaXMuYml0c0F2YWlsYWJsZSx0LT0oZT10Pj4zKT4+Myx0aGlzLmJ5dGVzQXZhaWxhYmxlLT1lLHRoaXMubG9hZFdvcmQoKSx0aGlzLndvcmQ8PD10LHRoaXMuYml0c0F2YWlsYWJsZS09dCl9LGUucmVhZEJpdHM9ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5taW4odGhpcy5iaXRzQXZhaWxhYmxlLHQpLHI9dGhpcy53b3JkPj4+MzItZTtyZXR1cm4gdD4zMiYmYy5iLmVycm9yKFwiQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lXCIpLHRoaXMuYml0c0F2YWlsYWJsZS09ZSx0aGlzLmJpdHNBdmFpbGFibGU+MD90aGlzLndvcmQ8PD1lOnRoaXMuYnl0ZXNBdmFpbGFibGU+MCYmdGhpcy5sb2FkV29yZCgpLChlPXQtZSk+MCYmdGhpcy5iaXRzQXZhaWxhYmxlP3I8PGV8dGhpcy5yZWFkQml0cyhlKTpyfSxlLnNraXBMWj1mdW5jdGlvbigpe3ZhciB0O2Zvcih0PTA7dDx0aGlzLmJpdHNBdmFpbGFibGU7Kyt0KWlmKDAhPSh0aGlzLndvcmQmMjE0NzQ4MzY0OD4+PnQpKXJldHVybiB0aGlzLndvcmQ8PD10LHRoaXMuYml0c0F2YWlsYWJsZS09dCx0O3JldHVybiB0aGlzLmxvYWRXb3JkKCksdCt0aGlzLnNraXBMWigpfSxlLnNraXBVRUc9ZnVuY3Rpb24oKXt0aGlzLnNraXBCaXRzKDErdGhpcy5za2lwTFooKSl9LGUuc2tpcEVHPWZ1bmN0aW9uKCl7dGhpcy5za2lwQml0cygxK3RoaXMuc2tpcExaKCkpfSxlLnJlYWRVRUc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNraXBMWigpO3JldHVybiB0aGlzLnJlYWRCaXRzKHQrMSktMX0sZS5yZWFkRUc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJlYWRVRUcoKTtyZXR1cm4gMSZ0PzErdD4+PjE6LTEqKHQ+Pj4xKX0sZS5yZWFkQm9vbGVhbj1mdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5yZWFkQml0cygxKX0sZS5yZWFkVUJ5dGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkQml0cyg4KX0sZS5yZWFkVVNob3J0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZEJpdHMoMTYpfSxlLnJlYWRVSW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpfSxlLnNraXBTY2FsaW5nTGlzdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9OCxyPTgsaT0wO2k8dDtpKyspMCE9PXImJihyPShlK3RoaXMucmVhZEVHKCkrMjU2KSUyNTYpLGU9MD09PXI/ZTpyfSxlLnJlYWRTUFM9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsaT0wLGE9MCxuPTAscz0wLG89dGhpcy5yZWFkVUJ5dGUuYmluZCh0aGlzKSxsPXRoaXMucmVhZEJpdHMuYmluZCh0aGlzKSx1PXRoaXMucmVhZFVFRy5iaW5kKHRoaXMpLGQ9dGhpcy5yZWFkQm9vbGVhbi5iaW5kKHRoaXMpLGg9dGhpcy5za2lwQml0cy5iaW5kKHRoaXMpLGY9dGhpcy5za2lwRUcuYmluZCh0aGlzKSxjPXRoaXMuc2tpcFVFRy5iaW5kKHRoaXMpLHY9dGhpcy5za2lwU2NhbGluZ0xpc3QuYmluZCh0aGlzKTtvKCk7dmFyIGc9bygpO2lmKGwoNSksaCgzKSxvKCksYygpLDEwMD09PWd8fDExMD09PWd8fDEyMj09PWd8fDI0ND09PWd8fDQ0PT09Z3x8ODM9PT1nfHw4Nj09PWd8fDExOD09PWd8fDEyOD09PWcpe3ZhciBwPXUoKTtpZigzPT09cCYmaCgxKSxjKCksYygpLGgoMSksZCgpKWZvcihlPTMhPT1wPzg6MTIscj0wO3I8ZTtyKyspZCgpJiZ2KHI8Nj8xNjo2NCl9YygpO3ZhciBtPXUoKTtpZigwPT09bSl1KCk7ZWxzZSBpZigxPT09bSlmb3IoaCgxKSxmKCksZigpLHQ9dSgpLHI9MDtyPHQ7cisrKWYoKTtjKCksaCgxKTt2YXIgeT11KCksYj11KCksVD1sKDEpOzA9PT1UJiZoKDEpLGgoMSksZCgpJiYoaT11KCksYT11KCksbj11KCkscz11KCkpO3ZhciBFPVsxLDFdO2lmKGQoKSYmZCgpKXN3aXRjaChvKCkpe2Nhc2UgMTpFPVsxLDFdO2JyZWFrO2Nhc2UgMjpFPVsxMiwxMV07YnJlYWs7Y2FzZSAzOkU9WzEwLDExXTticmVhaztjYXNlIDQ6RT1bMTYsMTFdO2JyZWFrO2Nhc2UgNTpFPVs0MCwzM107YnJlYWs7Y2FzZSA2OkU9WzI0LDExXTticmVhaztjYXNlIDc6RT1bMjAsMTFdO2JyZWFrO2Nhc2UgODpFPVszMiwxMV07YnJlYWs7Y2FzZSA5OkU9WzgwLDMzXTticmVhaztjYXNlIDEwOkU9WzE4LDExXTticmVhaztjYXNlIDExOkU9WzE1LDExXTticmVhaztjYXNlIDEyOkU9WzY0LDMzXTticmVhaztjYXNlIDEzOkU9WzE2MCw5OV07YnJlYWs7Y2FzZSAxNDpFPVs0LDNdO2JyZWFrO2Nhc2UgMTU6RT1bMywyXTticmVhaztjYXNlIDE2OkU9WzIsMV07YnJlYWs7Y2FzZSAyNTU6RT1bbygpPDw4fG8oKSxvKCk8PDh8bygpXX1yZXR1cm57d2lkdGg6TWF0aC5jZWlsKDE2Kih5KzEpLTIqaS0yKmEpLGhlaWdodDooMi1UKSooYisxKSoxNi0oVD8yOjQpKihuK3MpLHBpeGVsUmF0aW86RX19LGUucmVhZFNsaWNlVHlwZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlYWRVQnl0ZSgpLHRoaXMucmVhZFVFRygpLHRoaXMucmVhZFVFRygpfSx0fSgpLEI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyKXt0aGlzLmtleURhdGE9dm9pZCAwLHRoaXMuZGVjcnlwdGVyPXZvaWQgMCx0aGlzLmtleURhdGE9cix0aGlzLmRlY3J5cHRlcj1uZXcgbi5hKHQsZSx7cmVtb3ZlUEtDUzdQYWRkaW5nOiExfSl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVjcnlwdEJ1ZmZlcj1mdW5jdGlvbih0LGUpe3RoaXMuZGVjcnlwdGVyLmRlY3J5cHQodCx0aGlzLmtleURhdGEua2V5LmJ1ZmZlcix0aGlzLmtleURhdGEuaXYuYnVmZmVyLGUpfSxlLmRlY3J5cHRBYWNTYW1wbGU9ZnVuY3Rpb24odCxlLHIsaSl7dmFyIGE9dFtlXS51bml0LG49YS5zdWJhcnJheSgxNixhLmxlbmd0aC1hLmxlbmd0aCUxNikscz1uLmJ1ZmZlci5zbGljZShuLmJ5dGVPZmZzZXQsbi5ieXRlT2Zmc2V0K24ubGVuZ3RoKSxvPXRoaXM7dGhpcy5kZWNyeXB0QnVmZmVyKHMsKGZ1bmN0aW9uKG4pe3ZhciBzPW5ldyBVaW50OEFycmF5KG4pO2Euc2V0KHMsMTYpLGl8fG8uZGVjcnlwdEFhY1NhbXBsZXModCxlKzEscil9KSl9LGUuZGVjcnlwdEFhY1NhbXBsZXM9ZnVuY3Rpb24odCxlLHIpe2Zvcig7O2UrKyl7aWYoZT49dC5sZW5ndGgpcmV0dXJuIHZvaWQgcigpO2lmKCEodFtlXS51bml0Lmxlbmd0aDwzMikpe3ZhciBpPXRoaXMuZGVjcnlwdGVyLmlzU3luYygpO2lmKHRoaXMuZGVjcnlwdEFhY1NhbXBsZSh0LGUscixpKSwhaSlyZXR1cm59fX0sZS5nZXRBdmNFbmNyeXB0ZWREYXRhPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xNipNYXRoLmZsb29yKCh0Lmxlbmd0aC00OCkvMTYwKSsxNixyPW5ldyBJbnQ4QXJyYXkoZSksaT0wLGE9MzI7YTx0Lmxlbmd0aC0xNjthKz0xNjAsaSs9MTYpci5zZXQodC5zdWJhcnJheShhLGErMTYpLGkpO3JldHVybiByfSxlLmdldEF2Y0RlY3J5cHRlZFVuaXQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9bmV3IFVpbnQ4QXJyYXkoZSksaT0wLGE9MzI7YTx0Lmxlbmd0aC0xNjthKz0xNjAsaSs9MTYpdC5zZXQoci5zdWJhcnJheShpLGkrMTYpLGEpO3JldHVybiB0fSxlLmRlY3J5cHRBdmNTYW1wbGU9ZnVuY3Rpb24odCxlLHIsaSxhLG4pe3ZhciBzPVgoYS5kYXRhKSxvPXRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShzKSxsPXRoaXM7dGhpcy5kZWNyeXB0QnVmZmVyKG8uYnVmZmVyLChmdW5jdGlvbihvKXthLmRhdGE9bC5nZXRBdmNEZWNyeXB0ZWRVbml0KHMsbyksbnx8bC5kZWNyeXB0QXZjU2FtcGxlcyh0LGUscisxLGkpfSkpfSxlLmRlY3J5cHRBdmNTYW1wbGVzPWZ1bmN0aW9uKHQsZSxyLGkpe2lmKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZWNyeXB0IHNhbXBsZXMgb2YgdHlwZSBVaW50OEFycmF5XCIpO2Zvcig7O2UrKyxyPTApe2lmKGU+PXQubGVuZ3RoKXJldHVybiB2b2lkIGkoKTtmb3IodmFyIGE9dFtlXS51bml0czshKHI+PWEubGVuZ3RoKTtyKyspe3ZhciBuPWFbcl07aWYoIShuLmRhdGEubGVuZ3RoPD00OHx8MSE9PW4udHlwZSYmNSE9PW4udHlwZSkpe3ZhciBzPXRoaXMuZGVjcnlwdGVyLmlzU3luYygpO2lmKHRoaXMuZGVjcnlwdEF2Y1NhbXBsZSh0LGUscixpLG4scyksIXMpcmV0dXJufX19fSx0fSgpLFU9e3ZpZGVvOjEsYXVkaW86MixpZDM6Myx0ZXh0OjR9LEc9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyKXt0aGlzLm9ic2VydmVyPXZvaWQgMCx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy50eXBlU3VwcG9ydGVkPXZvaWQgMCx0aGlzLnNhbXBsZUFlcz1udWxsLHRoaXMucG10UGFyc2VkPSExLHRoaXMuYXVkaW9Db2RlYz12b2lkIDAsdGhpcy52aWRlb0NvZGVjPXZvaWQgMCx0aGlzLl9kdXJhdGlvbj0wLHRoaXMuYWFjTGFzdFBUUz1udWxsLHRoaXMuX2luaXRQVFM9bnVsbCx0aGlzLl9pbml0RFRTPW51bGwsdGhpcy5fcG10SWQ9LTEsdGhpcy5fYXZjVHJhY2s9dm9pZCAwLHRoaXMuX2F1ZGlvVHJhY2s9dm9pZCAwLHRoaXMuX2lkM1RyYWNrPXZvaWQgMCx0aGlzLl90eHRUcmFjaz12b2lkIDAsdGhpcy5hYWNPdmVyRmxvdz1udWxsLHRoaXMuYXZjU2FtcGxlPW51bGwsdGhpcy5yZW1haW5kZXJEYXRhPW51bGwsdGhpcy5vYnNlcnZlcj10LHRoaXMuY29uZmlnPWUsdGhpcy50eXBlU3VwcG9ydGVkPXJ9dC5wcm9iZT1mdW5jdGlvbihlKXt2YXIgcj10LnN5bmNPZmZzZXQoZSk7cmV0dXJuIShyPDB8fChyJiZjLmIud2FybihcIk1QRUcyLVRTIGRldGVjdGVkIGJ1dCBmaXJzdCBzeW5jIHdvcmQgZm91bmQgQCBvZmZzZXQgXCIrcitcIiwganVuayBhaGVhZCA/XCIpLDApKX0sdC5zeW5jT2Zmc2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1NYXRoLm1pbigxZTMsdC5sZW5ndGgtNTY0KSxyPTA7cjxlOyl7aWYoNzE9PT10W3JdJiY3MT09PXRbcisxODhdJiY3MT09PXRbciszNzZdKXJldHVybiByO3IrK31yZXR1cm4tMX0sdC5jcmVhdGVUcmFjaz1mdW5jdGlvbih0LGUpe3JldHVybntjb250YWluZXI6XCJ2aWRlb1wiPT09dHx8XCJhdWRpb1wiPT09dD9cInZpZGVvL21wMnRcIjp2b2lkIDAsdHlwZTp0LGlkOlVbdF0scGlkOi0xLGlucHV0VGltZVNjYWxlOjllNCxzZXF1ZW5jZU51bWJlcjowLHNhbXBsZXM6W10sZHJvcHBlZDowLGR1cmF0aW9uOlwiYXVkaW9cIj09PXQ/ZTp2b2lkIDB9fTt2YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5yZXNldEluaXRTZWdtZW50PWZ1bmN0aW9uKGUscixpKXt0aGlzLnBtdFBhcnNlZD0hMSx0aGlzLl9wbXRJZD0tMSx0aGlzLl9hdmNUcmFjaz10LmNyZWF0ZVRyYWNrKFwidmlkZW9cIixpKSx0aGlzLl9hdWRpb1RyYWNrPXQuY3JlYXRlVHJhY2soXCJhdWRpb1wiLGkpLHRoaXMuX2lkM1RyYWNrPXQuY3JlYXRlVHJhY2soXCJpZDNcIixpKSx0aGlzLl90eHRUcmFjaz10LmNyZWF0ZVRyYWNrKFwidGV4dFwiLGkpLHRoaXMuX2F1ZGlvVHJhY2suaXNBQUM9ITAsdGhpcy5hYWNPdmVyRmxvdz1udWxsLHRoaXMuYWFjTGFzdFBUUz1udWxsLHRoaXMuYXZjU2FtcGxlPW51bGwsdGhpcy5hdWRpb0NvZGVjPWUsdGhpcy52aWRlb0NvZGVjPXIsdGhpcy5fZHVyYXRpb249aX0sZS5yZXNldFRpbWVTdGFtcD1mdW5jdGlvbigpe30sZS5yZXNldENvbnRpZ3VpdHk9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9hdWRpb1RyYWNrLGU9dGhpcy5fYXZjVHJhY2sscj10aGlzLl9pZDNUcmFjazt0JiYodC5wZXNEYXRhPW51bGwpLGUmJihlLnBlc0RhdGE9bnVsbCksciYmKHIucGVzRGF0YT1udWxsKSx0aGlzLmFhY092ZXJGbG93PW51bGwsdGhpcy5hYWNMYXN0UFRTPW51bGx9LGUuZGVtdXg9ZnVuY3Rpb24oZSxyLG4scyl7dmFyIG87dm9pZCAwPT09biYmKG49ITEpLHZvaWQgMD09PXMmJihzPSExKSxufHwodGhpcy5zYW1wbGVBZXM9bnVsbCk7dmFyIHU9dGhpcy5fYXZjVHJhY2ssZD10aGlzLl9hdWRpb1RyYWNrLGg9dGhpcy5faWQzVHJhY2ssZj11LnBpZCx2PXUucGVzRGF0YSxnPWQucGlkLHA9aC5waWQsbT1kLnBlc0RhdGEseT1oLnBlc0RhdGEsYj0hMSxUPXRoaXMucG10UGFyc2VkLEU9dGhpcy5fcG10SWQsUz1lLmxlbmd0aDtpZih0aGlzLnJlbWFpbmRlckRhdGEmJihTPShlPU9iamVjdChsLmEpKHRoaXMucmVtYWluZGVyRGF0YSxlKSkubGVuZ3RoLHRoaXMucmVtYWluZGVyRGF0YT1udWxsKSxTPDE4OCYmIXMpcmV0dXJuIHRoaXMucmVtYWluZGVyRGF0YT1lLHthdWRpb1RyYWNrOmQsYXZjVHJhY2s6dSxpZDNUcmFjazpoLHRleHRUcmFjazp0aGlzLl90eHRUcmFja307dmFyIEw9TWF0aC5tYXgoMCx0LnN5bmNPZmZzZXQoZSkpOyhTLT0oUytMKSUxODgpPGUuYnl0ZUxlbmd0aCYmIXMmJih0aGlzLnJlbWFpbmRlckRhdGE9bmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsUyxlLmJ1ZmZlci5ieXRlTGVuZ3RoLVMpKTtmb3IodmFyIEE9MCxSPUw7UjxTO1IrPTE4OClpZig3MT09PWVbUl0pe3ZhciBEPSEhKDY0JmVbUisxXSksXz0oKDMxJmVbUisxXSk8PDgpK2VbUisyXSxrPXZvaWQgMDtpZigoNDgmZVtSKzNdKT4+ND4xKXtpZigoaz1SKzUrZVtSKzRdKT09PVIrMTg4KWNvbnRpbnVlfWVsc2Ugaz1SKzQ7c3dpdGNoKF8pe2Nhc2UgZjpEJiYodiYmKG89Vih2KSkmJnRoaXMucGFyc2VBVkNQRVMobywhMSksdj17ZGF0YTpbXSxzaXplOjB9KSx2JiYodi5kYXRhLnB1c2goZS5zdWJhcnJheShrLFIrMTg4KSksdi5zaXplKz1SKzE4OC1rKTticmVhaztjYXNlIGc6RCYmKG0mJihvPVYobSkpJiYoZC5pc0FBQz90aGlzLnBhcnNlQUFDUEVTKG8pOnRoaXMucGFyc2VNUEVHUEVTKG8pKSxtPXtkYXRhOltdLHNpemU6MH0pLG0mJihtLmRhdGEucHVzaChlLnN1YmFycmF5KGssUisxODgpKSxtLnNpemUrPVIrMTg4LWspO2JyZWFrO2Nhc2UgcDpEJiYoeSYmKG89Vih5KSkmJnRoaXMucGFyc2VJRDNQRVMobykseT17ZGF0YTpbXSxzaXplOjB9KSx5JiYoeS5kYXRhLnB1c2goZS5zdWJhcnJheShrLFIrMTg4KSkseS5zaXplKz1SKzE4OC1rKTticmVhaztjYXNlIDA6RCYmKGsrPWVba10rMSksRT10aGlzLl9wbXRJZD1IKGUsayk7YnJlYWs7Y2FzZSBFOkQmJihrKz1lW2tdKzEpO3ZhciB4PUsoZSxrLCEwPT09dGhpcy50eXBlU3VwcG9ydGVkLm1wZWd8fCEwPT09dGhpcy50eXBlU3VwcG9ydGVkLm1wMyxuKTsoZj14LmF2Yyk+MCYmKHUucGlkPWYpLChnPXguYXVkaW8pPjAmJihkLnBpZD1nLGQuaXNBQUM9eC5pc0FBQyksKHA9eC5pZDMpPjAmJihoLnBpZD1wKSxiJiYhVCYmKGMuYi5sb2coXCJyZXBhcnNlIGZyb20gYmVnaW5uaW5nXCIpLGI9ITEsUj1MLTE4OCksVD10aGlzLnBtdFBhcnNlZD0hMDticmVhaztjYXNlIDE3OmNhc2UgODE5MTpicmVhaztkZWZhdWx0OmI9ITB9fWVsc2UgQSsrO0E+MCYmdGhpcy5vYnNlcnZlci5lbWl0KGkuYS5FUlJPUixpLmEuRVJST1Ise3R5cGU6YS5iLk1FRElBX0VSUk9SLGRldGFpbHM6YS5hLkZSQUdfUEFSU0lOR19FUlJPUixmYXRhbDohMSxyZWFzb246XCJGb3VuZCBcIitBK1wiIFRTIHBhY2tldC9zIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGggMHg0N1wifSksdS5wZXNEYXRhPXYsZC5wZXNEYXRhPW0saC5wZXNEYXRhPXk7dmFyIHc9e2F1ZGlvVHJhY2s6ZCxhdmNUcmFjazp1LGlkM1RyYWNrOmgsdGV4dFRyYWNrOnRoaXMuX3R4dFRyYWNrfTtyZXR1cm4gcyYmdGhpcy5leHRyYWN0UmVtYWluaW5nU2FtcGxlcyh3KSx3fSxlLmZsdXNoPWZ1bmN0aW9uKCl7dmFyIHQsZT10aGlzLnJlbWFpbmRlckRhdGE7cmV0dXJuIHRoaXMucmVtYWluZGVyRGF0YT1udWxsLHQ9ZT90aGlzLmRlbXV4KGUsLTEsITEsITApOnthdWRpb1RyYWNrOnRoaXMuX2F1ZGlvVHJhY2ssYXZjVHJhY2s6dGhpcy5fYXZjVHJhY2ssdGV4dFRyYWNrOnRoaXMuX3R4dFRyYWNrLGlkM1RyYWNrOnRoaXMuX2lkM1RyYWNrfSx0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHQpLHRoaXMuc2FtcGxlQWVzP3RoaXMuZGVjcnlwdCh0LHRoaXMuc2FtcGxlQWVzKTp0fSxlLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzPWZ1bmN0aW9uKHQpe3ZhciBlLHI9dC5hdWRpb1RyYWNrLGk9dC5hdmNUcmFjayxhPXQuaWQzVHJhY2ssbj1pLnBlc0RhdGEscz1yLnBlc0RhdGEsbz1hLnBlc0RhdGE7biYmKGU9VihuKSk/KHRoaXMucGFyc2VBVkNQRVMoZSwhMCksaS5wZXNEYXRhPW51bGwpOmkucGVzRGF0YT1uLHMmJihlPVYocykpPyhyLmlzQUFDP3RoaXMucGFyc2VBQUNQRVMoZSk6dGhpcy5wYXJzZU1QRUdQRVMoZSksci5wZXNEYXRhPW51bGwpOihudWxsIT1zJiZzLnNpemUmJmMuYi5sb2coXCJsYXN0IEFBQyBQRVMgcGFja2V0IHRydW5jYXRlZCxtaWdodCBvdmVybGFwIGJldHdlZW4gZnJhZ21lbnRzXCIpLHIucGVzRGF0YT1zKSxvJiYoZT1WKG8pKT8odGhpcy5wYXJzZUlEM1BFUyhlKSxhLnBlc0RhdGE9bnVsbCk6YS5wZXNEYXRhPW99LGUuZGVtdXhTYW1wbGVBZXM9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXMuZGVtdXgodCxyLCEwLCF0aGlzLmNvbmZpZy5wcm9ncmVzc2l2ZSksYT10aGlzLnNhbXBsZUFlcz1uZXcgQih0aGlzLm9ic2VydmVyLHRoaXMuY29uZmlnLGUpO3JldHVybiB0aGlzLmRlY3J5cHQoaSxhKX0sZS5kZWNyeXB0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihyKXt2YXIgaT10LmF1ZGlvVHJhY2ssYT10LmF2Y1RyYWNrO2kuc2FtcGxlcyYmaS5pc0FBQz9lLmRlY3J5cHRBYWNTYW1wbGVzKGkuc2FtcGxlcywwLChmdW5jdGlvbigpe2Euc2FtcGxlcz9lLmRlY3J5cHRBdmNTYW1wbGVzKGEuc2FtcGxlcywwLDAsKGZ1bmN0aW9uKCl7cih0KX0pKTpyKHQpfSkpOmEuc2FtcGxlcyYmZS5kZWNyeXB0QXZjU2FtcGxlcyhhLnNhbXBsZXMsMCwwLChmdW5jdGlvbigpe3IodCl9KSl9KSl9LGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuX2luaXRQVFM9dGhpcy5faW5pdERUUz1udWxsLHRoaXMuX2R1cmF0aW9uPTB9LGUucGFyc2VBVkNQRVM9ZnVuY3Rpb24odCxlKXt2YXIgcixpPXRoaXMsYT10aGlzLl9hdmNUcmFjayxuPXRoaXMucGFyc2VBVkNOQUx1KHQuZGF0YSkscz10aGlzLmF2Y1NhbXBsZSxsPSExO3QuZGF0YT1udWxsLHMmJm4ubGVuZ3RoJiYhYS5hdWRGb3VuZCYmKFcocyxhKSxzPXRoaXMuYXZjU2FtcGxlPWooITEsdC5wdHMsdC5kdHMsXCJcIikpLG4uZm9yRWFjaCgoZnVuY3Rpb24oZSl7c3dpdGNoKGUudHlwZSl7Y2FzZSAxOnI9ITAsc3x8KHM9aS5hdmNTYW1wbGU9aighMCx0LnB0cyx0LmR0cyxcIlwiKSkscy5mcmFtZT0hMDt2YXIgbj1lLmRhdGE7aWYobCYmbi5sZW5ndGg+NCl7dmFyIHU9bmV3IE4obikucmVhZFNsaWNlVHlwZSgpOzIhPT11JiY0IT09dSYmNyE9PXUmJjkhPT11fHwocy5rZXk9ITApfWJyZWFrO2Nhc2UgNTpyPSEwLHN8fChzPWkuYXZjU2FtcGxlPWooITAsdC5wdHMsdC5kdHMsXCJcIikpLHMua2V5PSEwLHMuZnJhbWU9ITA7YnJlYWs7Y2FzZSA2OnI9ITA7dmFyIGQ9bmV3IE4oWChlLmRhdGEpKTtkLnJlYWRVQnl0ZSgpO2Zvcih2YXIgaD0wLGY9MCxjPSExLHY9MDshYyYmZC5ieXRlc0F2YWlsYWJsZT4xOyl7aD0wO2Rve2grPXY9ZC5yZWFkVUJ5dGUoKX13aGlsZSgyNTU9PT12KTtmPTA7ZG97Zis9dj1kLnJlYWRVQnl0ZSgpfXdoaWxlKDI1NT09PXYpO2lmKDQ9PT1oJiYwIT09ZC5ieXRlc0F2YWlsYWJsZSl7aWYoYz0hMCwxODE9PT1kLnJlYWRVQnl0ZSgpJiY0OT09PWQucmVhZFVTaG9ydCgpJiYxMTk1NDU2ODIwPT09ZC5yZWFkVUludCgpJiYzPT09ZC5yZWFkVUJ5dGUoKSl7Zm9yKHZhciBnPWQucmVhZFVCeXRlKCkscD0zMSZnLG09W2csZC5yZWFkVUJ5dGUoKV0seT0wO3k8cDt5KyspbS5wdXNoKGQucmVhZFVCeXRlKCkpLG0ucHVzaChkLnJlYWRVQnl0ZSgpKSxtLnB1c2goZC5yZWFkVUJ5dGUoKSk7WShpLl90eHRUcmFjay5zYW1wbGVzLHt0eXBlOjMscHRzOnQucHRzLGJ5dGVzOm19KX19ZWxzZSBpZig1PT09aCYmMCE9PWQuYnl0ZXNBdmFpbGFibGUpe2lmKGM9ITAsZj4xNil7Zm9yKHZhciBiPVtdLFQ9MDtUPDE2O1QrKyliLnB1c2goZC5yZWFkVUJ5dGUoKS50b1N0cmluZygxNikpLDMhPT1UJiY1IT09VCYmNyE9PVQmJjkhPT1UfHxiLnB1c2goXCItXCIpO2Zvcih2YXIgRT1mLTE2LFM9bmV3IFVpbnQ4QXJyYXkoRSksTD0wO0w8RTtMKyspU1tMXT1kLnJlYWRVQnl0ZSgpO1koaS5fdHh0VHJhY2suc2FtcGxlcyx7cHRzOnQucHRzLHBheWxvYWRUeXBlOmgsdXVpZDpiLmpvaW4oXCJcIiksdXNlckRhdGE6T2JqZWN0KG8uZikoUyksdXNlckRhdGFCeXRlczpTfSl9fWVsc2UgaWYoZjxkLmJ5dGVzQXZhaWxhYmxlKWZvcih2YXIgQT0wO0E8ZjtBKyspZC5yZWFkVUJ5dGUoKX1icmVhaztjYXNlIDc6aWYocj0hMCxsPSEwLCFhLnNwcyl7dmFyIFI9bmV3IE4oZS5kYXRhKS5yZWFkU1BTKCk7YS53aWR0aD1SLndpZHRoLGEuaGVpZ2h0PVIuaGVpZ2h0LGEucGl4ZWxSYXRpbz1SLnBpeGVsUmF0aW8sYS5zcHM9W2UuZGF0YV0sYS5kdXJhdGlvbj1pLl9kdXJhdGlvbjtmb3IodmFyIEQ9ZS5kYXRhLnN1YmFycmF5KDEsNCksXz1cImF2YzEuXCIsaz0wO2s8MztrKyspe3ZhciB4PURba10udG9TdHJpbmcoMTYpO3gubGVuZ3RoPDImJih4PVwiMFwiK3gpLF8rPXh9YS5jb2RlYz1ffWJyZWFrO2Nhc2UgODpyPSEwLGEucHBzfHwoYS5wcHM9W2UuZGF0YV0pO2JyZWFrO2Nhc2UgOTpyPSExLGEuYXVkRm91bmQ9ITAscyYmVyhzLGEpLHM9aS5hdmNTYW1wbGU9aighMSx0LnB0cyx0LmR0cyxcIlwiKTticmVhaztjYXNlIDEyOnI9ITE7YnJlYWs7ZGVmYXVsdDpyPSExLHMmJihzLmRlYnVnKz1cInVua25vd24gTkFMIFwiK2UudHlwZStcIiBcIil9cyYmciYmcy51bml0cy5wdXNoKGUpfSkpLGUmJnMmJihXKHMsYSksdGhpcy5hdmNTYW1wbGU9bnVsbCl9LGUuZ2V0TGFzdE5hbFVuaXQ9ZnVuY3Rpb24oKXt2YXIgdCxlLHI9dGhpcy5hdmNTYW1wbGU7aWYoIXJ8fDA9PT1yLnVuaXRzLmxlbmd0aCl7dmFyIGk9dGhpcy5fYXZjVHJhY2suc2FtcGxlcztyPWlbaS5sZW5ndGgtMV19aWYobnVsbCE9PSh0PXIpJiZ2b2lkIDAhPT10JiZ0LnVuaXRzKXt2YXIgYT1yLnVuaXRzO2U9YVthLmxlbmd0aC0xXX1yZXR1cm4gZX0sZS5wYXJzZUFWQ05BTHU9ZnVuY3Rpb24odCl7dmFyIGUscixpPXQuYnl0ZUxlbmd0aCxhPXRoaXMuX2F2Y1RyYWNrLG49YS5uYWx1U3RhdGV8fDAscz1uLG89W10sbD0wLHU9LTEsZD0wO2ZvcigtMT09PW4mJih1PTAsZD0zMSZ0WzBdLG49MCxsPTEpO2w8aTspaWYoZT10W2wrK10sbilpZigxIT09bilpZihlKWlmKDE9PT1lKXtpZih1Pj0wKXt2YXIgaD17ZGF0YTp0LnN1YmFycmF5KHUsbC1uLTEpLHR5cGU6ZH07by5wdXNoKGgpfWVsc2V7dmFyIGY9dGhpcy5nZXRMYXN0TmFsVW5pdCgpO2lmKGYmJihzJiZsPD00LXMmJmYuc3RhdGUmJihmLmRhdGE9Zi5kYXRhLnN1YmFycmF5KDAsZi5kYXRhLmJ5dGVMZW5ndGgtcykpLChyPWwtbi0xKT4wKSl7dmFyIGM9bmV3IFVpbnQ4QXJyYXkoZi5kYXRhLmJ5dGVMZW5ndGgrcik7Yy5zZXQoZi5kYXRhLDApLGMuc2V0KHQuc3ViYXJyYXkoMCxyKSxmLmRhdGEuYnl0ZUxlbmd0aCksZi5kYXRhPWMsZi5zdGF0ZT0wfX1sPGk/KHU9bCxkPTMxJnRbbF0sbj0wKTpuPS0xfWVsc2Ugbj0wO2Vsc2Ugbj0zO2Vsc2Ugbj1lPzA6MjtlbHNlIG49ZT8wOjE7aWYodT49MCYmbj49MCl7dmFyIHY9e2RhdGE6dC5zdWJhcnJheSh1LGkpLHR5cGU6ZCxzdGF0ZTpufTtvLnB1c2godil9aWYoMD09PW8ubGVuZ3RoKXt2YXIgZz10aGlzLmdldExhc3ROYWxVbml0KCk7aWYoZyl7dmFyIHA9bmV3IFVpbnQ4QXJyYXkoZy5kYXRhLmJ5dGVMZW5ndGgrdC5ieXRlTGVuZ3RoKTtwLnNldChnLmRhdGEsMCkscC5zZXQodCxnLmRhdGEuYnl0ZUxlbmd0aCksZy5kYXRhPXB9fXJldHVybiBhLm5hbHVTdGF0ZT1uLG99LGUucGFyc2VBQUNQRVM9ZnVuY3Rpb24odCl7dmFyIGUscixuLHMsbyxsPTAsdT10aGlzLl9hdWRpb1RyYWNrLGQ9dGhpcy5hYWNPdmVyRmxvdyxoPXQuZGF0YTtpZihkKXt0aGlzLmFhY092ZXJGbG93PW51bGw7dmFyIGY9ZC5zYW1wbGUudW5pdC5ieXRlTGVuZ3RoLHY9TWF0aC5taW4oZC5taXNzaW5nLGYpLGc9Zi12O2Quc2FtcGxlLnVuaXQuc2V0KGguc3ViYXJyYXkoMCx2KSxnKSx1LnNhbXBsZXMucHVzaChkLnNhbXBsZSksbD1kLm1pc3Npbmd9Zm9yKGU9bCxyPWgubGVuZ3RoO2U8ci0xJiYhbShoLGUpO2UrKyk7aWYoZT09PWx8fChlPHItMT8obj1cIkFBQyBQRVMgZGlkIG5vdCBzdGFydCB3aXRoIEFEVFMgaGVhZGVyLG9mZnNldDpcIitlLHM9ITEpOihuPVwibm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFU1wiLHM9ITApLGMuYi53YXJuKFwicGFyc2luZyBlcnJvcjpcIituKSx0aGlzLm9ic2VydmVyLmVtaXQoaS5hLkVSUk9SLGkuYS5FUlJPUix7dHlwZTphLmIuTUVESUFfRVJST1IsZGV0YWlsczphLmEuRlJBR19QQVJTSU5HX0VSUk9SLGZhdGFsOnMscmVhc29uOm59KSwhcykpe2lmKGIodSx0aGlzLm9ic2VydmVyLGgsZSx0aGlzLmF1ZGlvQ29kZWMpLHZvaWQgMCE9PXQucHRzKW89dC5wdHM7ZWxzZXtpZighZClyZXR1cm4gdm9pZCBjLmIud2FybihcIlt0c2RlbXV4ZXJdOiBBQUMgUEVTIHVua25vd24gUFRTXCIpO3ZhciBwPVQodS5zYW1wbGVyYXRlKTtvPWQuc2FtcGxlLnB0cytwfWZvcih2YXIgeT0wO2U8cjspe2lmKG0oaCxlKSl7aWYoZSs1PHIpe3ZhciBTPUUodSxoLGUsbyx5KTtpZihTKXtpZighUy5taXNzaW5nKXtlKz1TLmxlbmd0aCx5Kys7Y29udGludWV9dGhpcy5hYWNPdmVyRmxvdz1TfX1icmVha31lKyt9fX0sZS5wYXJzZU1QRUdQRVM9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhLHI9ZS5sZW5ndGgsaT0wLGE9MCxuPXQucHRzO2lmKHZvaWQgMCE9PW4pZm9yKDthPHI7KWlmKEYoZSxhKSl7dmFyIHM9Tyh0aGlzLl9hdWRpb1RyYWNrLGUsYSxuLGkpO2lmKCFzKWJyZWFrO2ErPXMubGVuZ3RoLGkrK31lbHNlIGErKztlbHNlIGMuYi53YXJuKFwiW3RzZGVtdXhlcl06IE1QRUcgUEVTIHVua25vd24gUFRTXCIpfSxlLnBhcnNlSUQzUEVTPWZ1bmN0aW9uKHQpe3ZvaWQgMCE9PXQucHRzP3RoaXMuX2lkM1RyYWNrLnNhbXBsZXMucHVzaCh0KTpjLmIud2FybihcIlt0c2RlbXV4ZXJdOiBJRDMgUEVTIHVua25vd24gUFRTXCIpfSx0fSgpO2Z1bmN0aW9uIGoodCxlLHIsaSl7cmV0dXJue2tleTp0LGZyYW1lOiExLHB0czplLGR0czpyLHVuaXRzOltdLGRlYnVnOmksbGVuZ3RoOjB9fWZ1bmN0aW9uIEgodCxlKXtyZXR1cm4oMzEmdFtlKzEwXSk8PDh8dFtlKzExXX1mdW5jdGlvbiBLKHQsZSxyLGkpe3ZhciBhPXthdWRpbzotMSxhdmM6LTEsaWQzOi0xLGlzQUFDOiEwfSxuPWUrMysoKDE1JnRbZSsxXSk8PDh8dFtlKzJdKS00O2ZvcihlKz0xMisoKDE1JnRbZSsxMF0pPDw4fHRbZSsxMV0pO2U8bjspe3ZhciBzPSgzMSZ0W2UrMV0pPDw4fHRbZSsyXTtzd2l0Y2godFtlXSl7Y2FzZSAyMDc6aWYoIWkpe2MuYi5sb2coXCJBRFRTIEFBQyB3aXRoIEFFUy0xMjgtQ0JDIGZyYW1lIGVuY3J5cHRpb24gZm91bmQgaW4gdW5lbmNyeXB0ZWQgc3RyZWFtXCIpO2JyZWFrfWNhc2UgMTU6LTE9PT1hLmF1ZGlvJiYoYS5hdWRpbz1zKTticmVhaztjYXNlIDIxOi0xPT09YS5pZDMmJihhLmlkMz1zKTticmVhaztjYXNlIDIxOTppZighaSl7Yy5iLmxvZyhcIkguMjY0IHdpdGggQUVTLTEyOC1DQkMgc2xpY2UgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW1cIik7YnJlYWt9Y2FzZSAyNzotMT09PWEuYXZjJiYoYS5hdmM9cyk7YnJlYWs7Y2FzZSAzOmNhc2UgNDpyPy0xPT09YS5hdWRpbyYmKGEuYXVkaW89cyxhLmlzQUFDPSExKTpjLmIubG9nKFwiTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7YnJlYWs7Y2FzZSAzNjpjLmIud2FybihcIlVuc3VwcG9ydGVkIEhFVkMgc3RyZWFtIHR5cGUgZm91bmRcIil9ZSs9NSsoKDE1JnRbZSszXSk8PDh8dFtlKzRdKX1yZXR1cm4gYX1mdW5jdGlvbiBWKHQpe3ZhciBlLHIsaSxhLG4scz0wLG89dC5kYXRhO2lmKCF0fHwwPT09dC5zaXplKXJldHVybiBudWxsO2Zvcig7b1swXS5sZW5ndGg8MTkmJm8ubGVuZ3RoPjE7KXt2YXIgbD1uZXcgVWludDhBcnJheShvWzBdLmxlbmd0aCtvWzFdLmxlbmd0aCk7bC5zZXQob1swXSksbC5zZXQob1sxXSxvWzBdLmxlbmd0aCksb1swXT1sLG8uc3BsaWNlKDEsMSl9aWYoMT09PSgoZT1vWzBdKVswXTw8MTYpKyhlWzFdPDw4KStlWzJdKXtpZigocj0oZVs0XTw8OCkrZVs1XSkmJnI+dC5zaXplLTYpcmV0dXJuIG51bGw7dmFyIHU9ZVs3XTsxOTImdSYmKGE9NTM2ODcwOTEyKigxNCZlWzldKSs0MTk0MzA0KigyNTUmZVsxMF0pKzE2Mzg0KigyNTQmZVsxMV0pKzEyOCooMjU1JmVbMTJdKSsoMjU0JmVbMTNdKS8yLDY0JnU/YS0obj01MzY4NzA5MTIqKDE0JmVbMTRdKSs0MTk0MzA0KigyNTUmZVsxNV0pKzE2Mzg0KigyNTQmZVsxNl0pKzEyOCooMjU1JmVbMTddKSsoMjU0JmVbMThdKS8yKT41NGU1JiYoYy5iLndhcm4oTWF0aC5yb3VuZCgoYS1uKS85ZTQpK1wicyBkZWx0YSBiZXR3ZWVuIFBUUyBhbmQgRFRTLCBhbGlnbiB0aGVtXCIpLGE9bik6bj1hKTt2YXIgZD0oaT1lWzhdKSs5O2lmKHQuc2l6ZTw9ZClyZXR1cm4gbnVsbDt0LnNpemUtPWQ7Zm9yKHZhciBoPW5ldyBVaW50OEFycmF5KHQuc2l6ZSksZj0wLHY9by5sZW5ndGg7Zjx2O2YrKyl7dmFyIGc9KGU9b1tmXSkuYnl0ZUxlbmd0aDtpZihkKXtpZihkPmcpe2QtPWc7Y29udGludWV9ZT1lLnN1YmFycmF5KGQpLGctPWQsZD0wfWguc2V0KGUscykscys9Z31yZXR1cm4gciYmKHItPWkrMykse2RhdGE6aCxwdHM6YSxkdHM6bixsZW46cn19cmV0dXJuIG51bGx9ZnVuY3Rpb24gVyh0LGUpe2lmKHQudW5pdHMubGVuZ3RoJiZ0LmZyYW1lKXtpZih2b2lkIDA9PT10LnB0cyl7dmFyIHI9ZS5zYW1wbGVzLGk9ci5sZW5ndGg7aWYoIWkpcmV0dXJuIHZvaWQgZS5kcm9wcGVkKys7dmFyIGE9cltpLTFdO3QucHRzPWEucHRzLHQuZHRzPWEuZHRzfWUuc2FtcGxlcy5wdXNoKHQpfXQuZGVidWcubGVuZ3RoJiZjLmIubG9nKHQucHRzK1wiL1wiK3QuZHRzK1wiOlwiK3QuZGVidWcpfWZ1bmN0aW9uIFkodCxlKXt2YXIgcj10Lmxlbmd0aDtpZihyPjApe2lmKGUucHRzPj10W3ItMV0ucHRzKXQucHVzaChlKTtlbHNlIGZvcih2YXIgaT1yLTE7aT49MDtpLS0paWYoZS5wdHM8dFtpXS5wdHMpe3Quc3BsaWNlKGksMCxlKTticmVha319ZWxzZSB0LnB1c2goZSl9ZnVuY3Rpb24gWCh0KXtmb3IodmFyIGU9dC5ieXRlTGVuZ3RoLHI9W10saT0xO2k8ZS0yOykwPT09dFtpXSYmMD09PXRbaSsxXSYmMz09PXRbaSsyXT8oci5wdXNoKGkrMiksaSs9Mik6aSsrO2lmKDA9PT1yLmxlbmd0aClyZXR1cm4gdDt2YXIgYT1lLXIubGVuZ3RoLG49bmV3IFVpbnQ4QXJyYXkoYSkscz0wO2ZvcihpPTA7aTxhO3MrKyxpKyspcz09PXJbMF0mJihzKyssci5zaGlmdCgpKSxuW2ldPXRbc107cmV0dXJuIG59Ry5taW5Qcm9iZUJ5dGVMZW5ndGg9MTg4O3ZhciBxPUc7ZnVuY3Rpb24geih0LGUpe3JldHVybih6PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX12YXIgUT1mdW5jdGlvbih0KXt2YXIgZSxyO2Z1bmN0aW9uIGkoKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cj10LChlPWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLHooZSxyKTt2YXIgYT1pLnByb3RvdHlwZTtyZXR1cm4gYS5yZXNldEluaXRTZWdtZW50PWZ1bmN0aW9uKGUscixpKXt0LnByb3RvdHlwZS5yZXNldEluaXRTZWdtZW50LmNhbGwodGhpcyxlLHIsaSksdGhpcy5fYXVkaW9UcmFjaz17Y29udGFpbmVyOlwiYXVkaW8vbXBlZ1wiLHR5cGU6XCJhdWRpb1wiLGlkOjIscGlkOi0xLHNlcXVlbmNlTnVtYmVyOjAsaXNBQUM6ITEsc2FtcGxlczpbXSxtYW5pZmVzdENvZGVjOmUsZHVyYXRpb246aSxpbnB1dFRpbWVTY2FsZTo5ZTQsZHJvcHBlZDowfX0saS5wcm9iZT1mdW5jdGlvbih0KXtpZighdClyZXR1cm4hMTtmb3IodmFyIGU9KG8uYih0LDApfHxbXSkubGVuZ3RoLHI9dC5sZW5ndGg7ZTxyO2UrKylpZihNKHQsZSkpcmV0dXJuIGMuYi5sb2coXCJNUEVHIEF1ZGlvIHN5bmMgd29yZCBmb3VuZCAhXCIpLCEwO3JldHVybiExfSxhLmNhblBhcnNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFAodCxlKSYmNDw9dC5sZW5ndGgtZX0odCxlKX0sYS5hcHBlbmRGcmFtZT1mdW5jdGlvbih0LGUscil7aWYobnVsbCE9PXRoaXMuaW5pdFBUUylyZXR1cm4gTyh0LGUscix0aGlzLmluaXRQVFMsdGhpcy5mcmFtZUluZGV4KX0saX0oZik7US5taW5Qcm9iZUJ5dGVMZW5ndGg9NDt2YXIgJD1RLFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LmdldFNpbGVudEZyYW1lPWZ1bmN0aW9uKHQsZSl7aWYoXCJtcDRhLjQwLjJcIj09PXQpe2lmKDE9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzUsMTI4XSk7aWYoMj09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KFszMywwLDczLDE0NCwyLDI1LDAsMzUsMTI4XSk7aWYoMz09PWUpcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDIwMCwwLDEyOCwzMiwxMzIsMSwzOCw2NCw4LDEwMCwwLDE0Ml0pO2lmKDQ9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMjgsNDQsMTI4LDgsMiw1Nl0pO2lmKDU9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMzAsNDgsNCwxNTMsMCwzMywxNDQsMiw1Nl0pO2lmKDY9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMCwyMDAsMCwxMjgsMzIsMTMyLDEsMzgsNjQsOCwxMDAsMCwxMzAsNDgsNCwxNTMsMCwzMywxNDQsMiwwLDE3OCwwLDMyLDgsMjI0XSl9ZWxzZXtpZigxPT09ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEsNjQsMzQsMTI4LDE2Myw3OCwyMzAsMTI4LDE4Niw4LDAsMCwwLDI4LDYsMjQxLDE5MywxMCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5MCw5NF0pO2lmKDI9PT1lKXJldHVybiBuZXcgVWludDhBcnJheShbMSw2NCwzNCwxMjgsMTYzLDk0LDIzMCwxMjgsMTg2LDgsMCwwLDAsMCwxNDksMCw2LDI0MSwxNjEsMTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTAsOTRdKTtpZigzPT09ZSlyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzEsNjQsMzQsMTI4LDE2Myw5NCwyMzAsMTI4LDE4Niw4LDAsMCwwLDAsMTQ5LDAsNiwyNDEsMTYxLDEwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDkwLDk0XSl9fSx0fSgpLEo9TWF0aC5wb3coMiwzMiktMSx0dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQuaW5pdD1mdW5jdGlvbigpe3ZhciBlO2ZvcihlIGluIHQudHlwZXM9e2F2YzE6W10sYXZjQzpbXSxidHJ0OltdLGRpbmY6W10sZHJlZjpbXSxlc2RzOltdLGZ0eXA6W10saGRscjpbXSxtZGF0OltdLG1kaGQ6W10sbWRpYTpbXSxtZmhkOltdLG1pbmY6W10sbW9vZjpbXSxtb292OltdLG1wNGE6W10sXCIubXAzXCI6W10sbXZleDpbXSxtdmhkOltdLHBhc3A6W10sc2R0cDpbXSxzdGJsOltdLHN0Y286W10sc3RzYzpbXSxzdHNkOltdLHN0c3o6W10sc3R0czpbXSx0ZmR0OltdLHRmaGQ6W10sdHJhZjpbXSx0cmFrOltdLHRydW46W10sdHJleDpbXSx0a2hkOltdLHZtaGQ6W10sc21oZDpbXX0sdC50eXBlcyl0LnR5cGVzLmhhc093blByb3BlcnR5KGUpJiYodC50eXBlc1tlXT1bZS5jaGFyQ29kZUF0KDApLGUuY2hhckNvZGVBdCgxKSxlLmNoYXJDb2RlQXQoMiksZS5jaGFyQ29kZUF0KDMpXSk7dmFyIHI9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxMTgsMTA1LDEwMCwxMDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsODYsMTA1LDEwMCwxMDEsMTExLDcyLDk3LDExMCwxMDAsMTA4LDEwMSwxMTQsMF0pLGk9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxMTUsMTExLDExNywxMTAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsODMsMTExLDExNywxMTAsMTAwLDcyLDk3LDExMCwxMDAsMTA4LDEwMSwxMTQsMF0pO3QuSERMUl9UWVBFUz17dmlkZW86cixhdWRpbzppfTt2YXIgYT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDEyLDExNywxMTQsMTA4LDMyLDAsMCwwLDFdKSxuPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDBdKTt0LlNUVFM9dC5TVFNDPXQuU1RDTz1uLHQuU1RTWj1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdKSx0LlZNSEQ9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwXSksdC5TTUhEPW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDBdKSx0LlNUU0Q9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMV0pO3ZhciBzPW5ldyBVaW50OEFycmF5KFsxMDUsMTE1LDExMSwxMDldKSxvPW5ldyBVaW50OEFycmF5KFs5NywxMTgsOTksNDldKSxsPW5ldyBVaW50OEFycmF5KFswLDAsMCwxXSk7dC5GVFlQPXQuYm94KHQudHlwZXMuZnR5cCxzLGwscyxvKSx0LkRJTkY9dC5ib3godC50eXBlcy5kaW5mLHQuYm94KHQudHlwZXMuZHJlZixhKSl9LHQuYm94PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT04LHI9YXJndW1lbnRzLmxlbmd0aCxpPW5ldyBBcnJheShyPjE/ci0xOjApLGE9MTthPHI7YSsrKWlbYS0xXT1hcmd1bWVudHNbYV07Zm9yKHZhciBuPWkubGVuZ3RoLHM9bjtuLS07KWUrPWlbbl0uYnl0ZUxlbmd0aDt2YXIgbz1uZXcgVWludDhBcnJheShlKTtmb3Iob1swXT1lPj4yNCYyNTUsb1sxXT1lPj4xNiYyNTUsb1syXT1lPj44JjI1NSxvWzNdPTI1NSZlLG8uc2V0KHQsNCksbj0wLGU9ODtuPHM7bisrKW8uc2V0KGlbbl0sZSksZSs9aVtuXS5ieXRlTGVuZ3RoO3JldHVybiBvfSx0LmhkbHI9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMuaGRscix0LkhETFJfVFlQRVNbZV0pfSx0Lm1kYXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMubWRhdCxlKX0sdC5tZGhkPWZ1bmN0aW9uKGUscil7cio9ZTt2YXIgaT1NYXRoLmZsb29yKHIvKEorMSkpLGE9TWF0aC5mbG9vcihyJShKKzEpKTtyZXR1cm4gdC5ib3godC50eXBlcy5tZGhkLG5ldyBVaW50OEFycmF5KFsxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwwLDAsMCwwLDAsMCwwLDMsZT4+MjQmMjU1LGU+PjE2JjI1NSxlPj44JjI1NSwyNTUmZSxpPj4yNCxpPj4xNiYyNTUsaT4+OCYyNTUsMjU1JmksYT4+MjQsYT4+MTYmMjU1LGE+PjgmMjU1LDI1NSZhLDg1LDE5NiwwLDBdKSl9LHQubWRpYT1mdW5jdGlvbihlKXtyZXR1cm4gdC5ib3godC50eXBlcy5tZGlhLHQubWRoZChlLnRpbWVzY2FsZSxlLmR1cmF0aW9uKSx0LmhkbHIoZS50eXBlKSx0Lm1pbmYoZSkpfSx0Lm1maGQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMubWZoZCxuZXcgVWludDhBcnJheShbMCwwLDAsMCxlPj4yNCxlPj4xNiYyNTUsZT4+OCYyNTUsMjU1JmVdKSl9LHQubWluZj1mdW5jdGlvbihlKXtyZXR1cm5cImF1ZGlvXCI9PT1lLnR5cGU/dC5ib3godC50eXBlcy5taW5mLHQuYm94KHQudHlwZXMuc21oZCx0LlNNSEQpLHQuRElORix0LnN0YmwoZSkpOnQuYm94KHQudHlwZXMubWluZix0LmJveCh0LnR5cGVzLnZtaGQsdC5WTUhEKSx0LkRJTkYsdC5zdGJsKGUpKX0sdC5tb29mPWZ1bmN0aW9uKGUscixpKXtyZXR1cm4gdC5ib3godC50eXBlcy5tb29mLHQubWZoZChlKSx0LnRyYWYoaSxyKSl9LHQubW9vdj1mdW5jdGlvbihlKXtmb3IodmFyIHI9ZS5sZW5ndGgsaT1bXTtyLS07KWlbcl09dC50cmFrKGVbcl0pO3JldHVybiB0LmJveC5hcHBseShudWxsLFt0LnR5cGVzLm1vb3YsdC5tdmhkKGVbMF0udGltZXNjYWxlLGVbMF0uZHVyYXRpb24pXS5jb25jYXQoaSkuY29uY2F0KHQubXZleChlKSkpfSx0Lm12ZXg9ZnVuY3Rpb24oZSl7Zm9yKHZhciByPWUubGVuZ3RoLGk9W107ci0tOylpW3JdPXQudHJleChlW3JdKTtyZXR1cm4gdC5ib3guYXBwbHkobnVsbCxbdC50eXBlcy5tdmV4XS5jb25jYXQoaSkpfSx0Lm12aGQ9ZnVuY3Rpb24oZSxyKXtyKj1lO3ZhciBpPU1hdGguZmxvb3Ioci8oSisxKSksYT1NYXRoLmZsb29yKHIlKEorMSkpLG49bmV3IFVpbnQ4QXJyYXkoWzEsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDAsMCwwLDAsMCwwLDAsMyxlPj4yNCYyNTUsZT4+MTYmMjU1LGU+PjgmMjU1LDI1NSZlLGk+PjI0LGk+PjE2JjI1NSxpPj44JjI1NSwyNTUmaSxhPj4yNCxhPj4xNiYyNTUsYT4+OCYyNTUsMjU1JmEsMCwxLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsNjQsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjU1LDI1NSwyNTUsMjU1XSk7cmV0dXJuIHQuYm94KHQudHlwZXMubXZoZCxuKX0sdC5zZHRwPWZ1bmN0aW9uKGUpe3ZhciByLGksYT1lLnNhbXBsZXN8fFtdLG49bmV3IFVpbnQ4QXJyYXkoNCthLmxlbmd0aCk7Zm9yKHI9MDtyPGEubGVuZ3RoO3IrKylpPWFbcl0uZmxhZ3MsbltyKzRdPWkuZGVwZW5kc09uPDw0fGkuaXNEZXBlbmRlZE9uPDwyfGkuaGFzUmVkdW5kYW5jeTtyZXR1cm4gdC5ib3godC50eXBlcy5zZHRwLG4pfSx0LnN0Ymw9ZnVuY3Rpb24oZSl7cmV0dXJuIHQuYm94KHQudHlwZXMuc3RibCx0LnN0c2QoZSksdC5ib3godC50eXBlcy5zdHRzLHQuU1RUUyksdC5ib3godC50eXBlcy5zdHNjLHQuU1RTQyksdC5ib3godC50eXBlcy5zdHN6LHQuU1RTWiksdC5ib3godC50eXBlcy5zdGNvLHQuU1RDTykpfSx0LmF2YzE9ZnVuY3Rpb24oZSl7dmFyIHIsaSxhLG49W10scz1bXTtmb3Iocj0wO3I8ZS5zcHMubGVuZ3RoO3IrKylhPShpPWUuc3BzW3JdKS5ieXRlTGVuZ3RoLG4ucHVzaChhPj4+OCYyNTUpLG4ucHVzaCgyNTUmYSksbj1uLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpKSk7Zm9yKHI9MDtyPGUucHBzLmxlbmd0aDtyKyspYT0oaT1lLnBwc1tyXSkuYnl0ZUxlbmd0aCxzLnB1c2goYT4+PjgmMjU1KSxzLnB1c2goMjU1JmEpLHM9cy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaSkpO3ZhciBvPXQuYm94KHQudHlwZXMuYXZjQyxuZXcgVWludDhBcnJheShbMSxuWzNdLG5bNF0sbls1XSwyNTUsMjI0fGUuc3BzLmxlbmd0aF0uY29uY2F0KG4pLmNvbmNhdChbZS5wcHMubGVuZ3RoXSkuY29uY2F0KHMpKSksbD1lLndpZHRoLHU9ZS5oZWlnaHQsZD1lLnBpeGVsUmF0aW9bMF0saD1lLnBpeGVsUmF0aW9bMV07cmV0dXJuIHQuYm94KHQudHlwZXMuYXZjMSxuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsbD4+OCYyNTUsMjU1JmwsdT4+OCYyNTUsMjU1JnUsMCw3MiwwLDAsMCw3MiwwLDAsMCwwLDAsMCwwLDEsMTgsMTAwLDk3LDEwNSwxMDgsMTIxLDEwOSwxMTEsMTE2LDEwNSwxMTEsMTEwLDQ3LDEwNCwxMDgsMTE1LDQ2LDEwNiwxMTUsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI0LDE3LDE3XSksbyx0LmJveCh0LnR5cGVzLmJ0cnQsbmV3IFVpbnQ4QXJyYXkoWzAsMjgsMTU2LDEyOCwwLDQ1LDE5OCwxOTIsMCw0NSwxOTgsMTkyXSkpLHQuYm94KHQudHlwZXMucGFzcCxuZXcgVWludDhBcnJheShbZD4+MjQsZD4+MTYmMjU1LGQ+PjgmMjU1LDI1NSZkLGg+PjI0LGg+PjE2JjI1NSxoPj44JjI1NSwyNTUmaF0pKSl9LHQuZXNkcz1mdW5jdGlvbih0KXt2YXIgZT10LmNvbmZpZy5sZW5ndGg7cmV0dXJuIG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDMsMjMrZSwwLDEsMCw0LDE1K2UsNjQsMjEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDVdLmNvbmNhdChbZV0pLmNvbmNhdCh0LmNvbmZpZykuY29uY2F0KFs2LDEsMl0pKX0sdC5tcDRhPWZ1bmN0aW9uKGUpe3ZhciByPWUuc2FtcGxlcmF0ZTtyZXR1cm4gdC5ib3godC50eXBlcy5tcDRhLG5ldyBVaW50OEFycmF5KFswLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsZS5jaGFubmVsQ291bnQsMCwxNiwwLDAsMCwwLHI+PjgmMjU1LDI1NSZyLDAsMF0pLHQuYm94KHQudHlwZXMuZXNkcyx0LmVzZHMoZSkpKX0sdC5tcDM9ZnVuY3Rpb24oZSl7dmFyIHI9ZS5zYW1wbGVyYXRlO3JldHVybiB0LmJveCh0LnR5cGVzW1wiLm1wM1wiXSxuZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLGUuY2hhbm5lbENvdW50LDAsMTYsMCwwLDAsMCxyPj44JjI1NSwyNTUmciwwLDBdKSl9LHQuc3RzZD1mdW5jdGlvbihlKXtyZXR1cm5cImF1ZGlvXCI9PT1lLnR5cGU/ZS5pc0FBQ3x8XCJtcDNcIiE9PWUuY29kZWM/dC5ib3godC50eXBlcy5zdHNkLHQuU1RTRCx0Lm1wNGEoZSkpOnQuYm94KHQudHlwZXMuc3RzZCx0LlNUU0QsdC5tcDMoZSkpOnQuYm94KHQudHlwZXMuc3RzZCx0LlNUU0QsdC5hdmMxKGUpKX0sdC50a2hkPWZ1bmN0aW9uKGUpe3ZhciByPWUuaWQsaT1lLmR1cmF0aW9uKmUudGltZXNjYWxlLGE9ZS53aWR0aCxuPWUuaGVpZ2h0LHM9TWF0aC5mbG9vcihpLyhKKzEpKSxvPU1hdGguZmxvb3IoaSUoSisxKSk7cmV0dXJuIHQuYm94KHQudHlwZXMudGtoZCxuZXcgVWludDhBcnJheShbMSwwLDAsNywwLDAsMCwwLDAsMCwwLDIsMCwwLDAsMCwwLDAsMCwzLHI+PjI0JjI1NSxyPj4xNiYyNTUscj4+OCYyNTUsMjU1JnIsMCwwLDAsMCxzPj4yNCxzPj4xNiYyNTUscz4+OCYyNTUsMjU1JnMsbz4+MjQsbz4+MTYmMjU1LG8+PjgmMjU1LDI1NSZvLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDY0LDAsMCwwLGE+PjgmMjU1LDI1NSZhLDAsMCxuPj44JjI1NSwyNTUmbiwwLDBdKSl9LHQudHJhZj1mdW5jdGlvbihlLHIpe3ZhciBpPXQuc2R0cChlKSxhPWUuaWQsbj1NYXRoLmZsb29yKHIvKEorMSkpLHM9TWF0aC5mbG9vcihyJShKKzEpKTtyZXR1cm4gdC5ib3godC50eXBlcy50cmFmLHQuYm94KHQudHlwZXMudGZoZCxuZXcgVWludDhBcnJheShbMCwwLDAsMCxhPj4yNCxhPj4xNiYyNTUsYT4+OCYyNTUsMjU1JmFdKSksdC5ib3godC50eXBlcy50ZmR0LG5ldyBVaW50OEFycmF5KFsxLDAsMCwwLG4+PjI0LG4+PjE2JjI1NSxuPj44JjI1NSwyNTUmbixzPj4yNCxzPj4xNiYyNTUscz4+OCYyNTUsMjU1JnNdKSksdC50cnVuKGUsaS5sZW5ndGgrMTYrMjArOCsxNis4KzgpLGkpfSx0LnRyYWs9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZHVyYXRpb249ZS5kdXJhdGlvbnx8NDI5NDk2NzI5NSx0LmJveCh0LnR5cGVzLnRyYWssdC50a2hkKGUpLHQubWRpYShlKSl9LHQudHJleD1mdW5jdGlvbihlKXt2YXIgcj1lLmlkO3JldHVybiB0LmJveCh0LnR5cGVzLnRyZXgsbmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAscj4+MjQscj4+MTYmMjU1LHI+PjgmMjU1LDI1NSZyLDAsMCwwLDEsMCwwLDAsMCwwLDAsMCwwLDAsMSwwLDFdKSl9LHQudHJ1bj1mdW5jdGlvbihlLHIpe3ZhciBpLGEsbixzLG8sbCx1PWUuc2FtcGxlc3x8W10sZD11Lmxlbmd0aCxoPTEyKzE2KmQsZj1uZXcgVWludDhBcnJheShoKTtmb3Iocis9OCtoLGYuc2V0KFswLDAsMTUsMSxkPj4+MjQmMjU1LGQ+Pj4xNiYyNTUsZD4+PjgmMjU1LDI1NSZkLHI+Pj4yNCYyNTUscj4+PjE2JjI1NSxyPj4+OCYyNTUsMjU1JnJdLDApLGk9MDtpPGQ7aSsrKW49KGE9dVtpXSkuZHVyYXRpb24scz1hLnNpemUsbz1hLmZsYWdzLGw9YS5jdHMsZi5zZXQoW24+Pj4yNCYyNTUsbj4+PjE2JjI1NSxuPj4+OCYyNTUsMjU1Jm4scz4+PjI0JjI1NSxzPj4+MTYmMjU1LHM+Pj44JjI1NSwyNTUmcyxvLmlzTGVhZGluZzw8MnxvLmRlcGVuZHNPbixvLmlzRGVwZW5kZWRPbjw8NnxvLmhhc1JlZHVuZGFuY3k8PDR8by5wYWRkaW5nVmFsdWU8PDF8by5pc05vblN5bmMsNjE0NDAmby5kZWdyYWRQcmlvLDE1Jm8uZGVncmFkUHJpbyxsPj4+MjQmMjU1LGw+Pj4xNiYyNTUsbD4+PjgmMjU1LDI1NSZsXSwxMisxNippKTtyZXR1cm4gdC5ib3godC50eXBlcy50cnVuLGYpfSx0LmluaXRTZWdtZW50PWZ1bmN0aW9uKGUpe3QudHlwZXN8fHQuaW5pdCgpO3ZhciByPXQubW9vdihlKSxpPW5ldyBVaW50OEFycmF5KHQuRlRZUC5ieXRlTGVuZ3RoK3IuYnl0ZUxlbmd0aCk7cmV0dXJuIGkuc2V0KHQuRlRZUCksaS5zZXQocix0LkZUWVAuYnl0ZUxlbmd0aCksaX0sdH0oKTt0dC50eXBlcz12b2lkIDAsdHQuSERMUl9UWVBFUz12b2lkIDAsdHQuU1RUUz12b2lkIDAsdHQuU1RTQz12b2lkIDAsdHQuU1RDTz12b2lkIDAsdHQuU1RTWj12b2lkIDAsdHQuVk1IRD12b2lkIDAsdHQuU01IRD12b2lkIDAsdHQuU1RTRD12b2lkIDAsdHQuRlRZUD12b2lkIDAsdHQuRElORj12b2lkIDA7dmFyIGV0PXR0LHJ0PXIoNCk7ZnVuY3Rpb24gaXQodCxlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLGZ1bmN0aW9uKHQsZSxyLGkpe3ZvaWQgMD09PXImJihyPTEpLHZvaWQgMD09PWkmJihpPSExKTt2YXIgYT10KmUqcjtyZXR1cm4gaT9NYXRoLnJvdW5kKGEpOmF9KHQsMWUzLDEvOWU0LGUpfWZ1bmN0aW9uIGF0KCl7cmV0dXJuKGF0PU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciByPWFyZ3VtZW50c1tlXTtmb3IodmFyIGkgaW4gcilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixpKSYmKHRbaV09cltpXSl9cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9dmFyIG50PW51bGwsc3Q9bnVsbCxvdD0hMSxsdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIsaSl7aWYodm9pZCAwPT09aSYmKGk9XCJcIiksdGhpcy5vYnNlcnZlcj12b2lkIDAsdGhpcy5jb25maWc9dm9pZCAwLHRoaXMudHlwZVN1cHBvcnRlZD12b2lkIDAsdGhpcy5JU0dlbmVyYXRlZD0hMSx0aGlzLl9pbml0UFRTPXZvaWQgMCx0aGlzLl9pbml0RFRTPXZvaWQgMCx0aGlzLm5leHRBdmNEdHM9bnVsbCx0aGlzLm5leHRBdWRpb1B0cz1udWxsLHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXM9ITEsdGhpcy5pc1ZpZGVvQ29udGlndW91cz0hMSx0aGlzLm9ic2VydmVyPXQsdGhpcy5jb25maWc9ZSx0aGlzLnR5cGVTdXBwb3J0ZWQ9cix0aGlzLklTR2VuZXJhdGVkPSExLG51bGw9PT1udCl7dmFyIGE9KG5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCIpLm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvaSk7bnQ9YT9wYXJzZUludChhWzFdKTowfWlmKG51bGw9PT1zdCl7dmFyIG49bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvU2FmYXJpXFwvKFxcZCspL2kpO3N0PW4/cGFyc2VJbnQoblsxXSk6MH1vdD0hIW50JiZudDw3NXx8ISFzdCYmc3Q8NjAwfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt9LGUucmVzZXRUaW1lU3RhbXA9ZnVuY3Rpb24odCl7Yy5iLmxvZyhcIlttcDQtcmVtdXhlcl06IGluaXRQVFMgJiBpbml0RFRTIHJlc2V0XCIpLHRoaXMuX2luaXRQVFM9dGhpcy5faW5pdERUUz10fSxlLnJlc2V0TmV4dFRpbWVzdGFtcD1mdW5jdGlvbigpe2MuYi5sb2coXCJbbXA0LXJlbXV4ZXJdOiByZXNldCBuZXh0IHRpbWVzdGFtcFwiKSx0aGlzLmlzVmlkZW9Db250aWd1b3VzPSExLHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXM9ITF9LGUucmVzZXRJbml0U2VnbWVudD1mdW5jdGlvbigpe2MuYi5sb2coXCJbbXA0LXJlbXV4ZXJdOiBJU0dlbmVyYXRlZCBmbGFnIHJlc2V0XCIpLHRoaXMuSVNHZW5lcmF0ZWQ9ITF9LGUuZ2V0VmlkZW9TdGFydFB0cz1mdW5jdGlvbih0KXt2YXIgZT0hMSxyPXQucmVkdWNlKChmdW5jdGlvbih0LHIpe3ZhciBpPXIucHRzLXQ7cmV0dXJuIGk8LTQyOTQ5NjcyOTY/KGU9ITAsdXQodCxyLnB0cykpOmk+MD90OnIucHRzfSksdFswXS5wdHMpO3JldHVybiBlJiZjLmIuZGVidWcoXCJQVFMgcm9sbG92ZXIgZGV0ZWN0ZWRcIikscn0sZS5yZW11eD1mdW5jdGlvbih0LGUscixpLGEsbixzLG8pe3ZhciBsLHUsZCxoLGYsdixnPWEscD1hLG09dC5waWQ+LTEseT1lLnBpZD4tMSxiPWUuc2FtcGxlcy5sZW5ndGgsVD10LnNhbXBsZXMubGVuZ3RoPjAsRT1iPjE7aWYoKCFtfHxUKSYmKCF5fHxFKXx8dGhpcy5JU0dlbmVyYXRlZHx8cyl7dGhpcy5JU0dlbmVyYXRlZHx8KGQ9dGhpcy5nZW5lcmF0ZUlTKHQsZSxhKSk7dmFyIFM9dGhpcy5pc1ZpZGVvQ29udGlndW91cyxMPS0xO2lmKEUmJihMPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZV0ua2V5KXJldHVybiBlO3JldHVybi0xfShlLnNhbXBsZXMpLCFTJiZ0aGlzLmNvbmZpZy5mb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5KSlpZih2PSEwLEw+MCl7Yy5iLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiBEcm9wcGVkIFwiK0wrXCIgb3V0IG9mIFwiK2IrXCIgdmlkZW8gc2FtcGxlcyBkdWUgdG8gYSBtaXNzaW5nIGtleWZyYW1lXCIpO3ZhciBBPXRoaXMuZ2V0VmlkZW9TdGFydFB0cyhlLnNhbXBsZXMpO2Uuc2FtcGxlcz1lLnNhbXBsZXMuc2xpY2UoTCksZS5kcm9wcGVkKz1MLHArPShlLnNhbXBsZXNbMF0ucHRzLUEpLyhlLnRpbWVzY2FsZXx8OWU0KX1lbHNlLTE9PT1MJiYoYy5iLndhcm4oXCJbbXA0LXJlbXV4ZXJdOiBObyBrZXlmcmFtZSBmb3VuZCBvdXQgb2YgXCIrYitcIiB2aWRlbyBzYW1wbGVzXCIpLHY9ITEpO2lmKHRoaXMuSVNHZW5lcmF0ZWQpe2lmKFQmJkUpe3ZhciBSPXRoaXMuZ2V0VmlkZW9TdGFydFB0cyhlLnNhbXBsZXMpLEQ9KHV0KHQuc2FtcGxlc1swXS5wdHMsUiktUikvZS5pbnB1dFRpbWVTY2FsZTtnKz1NYXRoLm1heCgwLEQpLHArPU1hdGgubWF4KDAsLUQpfWlmKFQpe2lmKHQuc2FtcGxlcmF0ZXx8KGMuYi53YXJuKFwiW21wNC1yZW11eGVyXTogcmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyBhdWRpbyBkZXRlY3RlZFwiKSxkPXRoaXMuZ2VuZXJhdGVJUyh0LGUsYSkpLHU9dGhpcy5yZW11eEF1ZGlvKHQsZyx0aGlzLmlzQXVkaW9Db250aWd1b3VzLG4seXx8RXx8bz09PXJ0LmIuQVVESU8/cDp2b2lkIDApLEUpe3ZhciBfPXU/dS5lbmRQVFMtdS5zdGFydFBUUzowO2UuaW5wdXRUaW1lU2NhbGV8fChjLmIud2FybihcIlttcDQtcmVtdXhlcl06IHJlZ2VuZXJhdGUgSW5pdFNlZ21lbnQgYXMgdmlkZW8gZGV0ZWN0ZWRcIiksZD10aGlzLmdlbmVyYXRlSVModCxlLGEpKSxsPXRoaXMucmVtdXhWaWRlbyhlLHAsUyxfKX19ZWxzZSBFJiYobD10aGlzLnJlbXV4VmlkZW8oZSxwLFMsMCkpO2wmJihsLmZpcnN0S2V5RnJhbWU9TCxsLmluZGVwZW5kZW50PS0xIT09TCl9fXJldHVybiB0aGlzLklTR2VuZXJhdGVkJiYoci5zYW1wbGVzLmxlbmd0aCYmKGY9dGhpcy5yZW11eElEMyhyLGEpKSxpLnNhbXBsZXMubGVuZ3RoJiYoaD10aGlzLnJlbXV4VGV4dChpLGEpKSkse2F1ZGlvOnUsdmlkZW86bCxpbml0U2VnbWVudDpkLGluZGVwZW5kZW50OnYsdGV4dDpoLGlkMzpmfX0sZS5nZW5lcmF0ZUlTPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaSxhLG4sbz10LnNhbXBsZXMsbD1lLnNhbXBsZXMsdT10aGlzLnR5cGVTdXBwb3J0ZWQsZD17fSxoPSFPYmplY3Qocy5hKSh0aGlzLl9pbml0UFRTKSxmPVwiYXVkaW8vbXA0XCI7aWYoaCYmKGk9YT0xLzApLHQuY29uZmlnJiZvLmxlbmd0aCYmKHQudGltZXNjYWxlPXQuc2FtcGxlcmF0ZSx0LmlzQUFDfHwodS5tcGVnPyhmPVwiYXVkaW8vbXBlZ1wiLHQuY29kZWM9XCJcIik6dS5tcDMmJih0LmNvZGVjPVwibXAzXCIpKSxkLmF1ZGlvPXtpZDpcImF1ZGlvXCIsY29udGFpbmVyOmYsY29kZWM6dC5jb2RlYyxpbml0U2VnbWVudDohdC5pc0FBQyYmdS5tcGVnP25ldyBVaW50OEFycmF5KDApOmV0LmluaXRTZWdtZW50KFt0XSksbWV0YWRhdGE6e2NoYW5uZWxDb3VudDp0LmNoYW5uZWxDb3VudH19LGgmJihuPXQuaW5wdXRUaW1lU2NhbGUsaT1hPW9bMF0ucHRzLU1hdGgucm91bmQobipyKSkpLGUuc3BzJiZlLnBwcyYmbC5sZW5ndGgmJihlLnRpbWVzY2FsZT1lLmlucHV0VGltZVNjYWxlLGQudmlkZW89e2lkOlwibWFpblwiLGNvbnRhaW5lcjpcInZpZGVvL21wNFwiLGNvZGVjOmUuY29kZWMsaW5pdFNlZ21lbnQ6ZXQuaW5pdFNlZ21lbnQoW2VdKSxtZXRhZGF0YTp7d2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHR9fSxoKSl7bj1lLmlucHV0VGltZVNjYWxlO3ZhciBjPXRoaXMuZ2V0VmlkZW9TdGFydFB0cyhsKSx2PU1hdGgucm91bmQobipyKTthPU1hdGgubWluKGEsdXQobFswXS5kdHMsYyktdiksaT1NYXRoLm1pbihpLGMtdil9aWYoT2JqZWN0LmtleXMoZCkubGVuZ3RoKXJldHVybiB0aGlzLklTR2VuZXJhdGVkPSEwLGgmJih0aGlzLl9pbml0UFRTPWksdGhpcy5faW5pdERUUz1hKSx7dHJhY2tzOmQsaW5pdFBUUzppLHRpbWVzY2FsZTpufX0sZS5yZW11eFZpZGVvPWZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBzLG8sbCx1PXQuaW5wdXRUaW1lU2NhbGUsZD10LnNhbXBsZXMsaD1bXSxmPWQubGVuZ3RoLHY9dGhpcy5faW5pdFBUUyxnPXRoaXMubmV4dEF2Y0R0cyxwPTgsbT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkseT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksYj0wLFQ9ITE7ciYmbnVsbCE9PWd8fChnPWUqdS0oZFswXS5wdHMtdXQoZFswXS5kdHMsZFswXS5wdHMpKSk7Zm9yKHZhciBFPTA7RTxmO0UrKyl7dmFyIFM9ZFtFXTtTLnB0cz11dChTLnB0cy12LGcpLFMuZHRzPXV0KFMuZHRzLXYsZyksUy5kdHM+Uy5wdHMmJihiPU1hdGgubWF4KE1hdGgubWluKGIsUy5wdHMtUy5kdHMpLC0xOGUzKSksUy5kdHM8ZFtFPjA/RS0xOkVdLmR0cyYmKFQ9ITApfVQmJmQuc29ydCgoZnVuY3Rpb24odCxlKXt2YXIgcj10LmR0cy1lLmR0cyxpPXQucHRzLWUucHRzO3JldHVybiByfHxpfSkpLG89ZFswXS5kdHMsbD1kW2QubGVuZ3RoLTFdLmR0czt2YXIgTD1NYXRoLnJvdW5kKChsLW8pLyhmLTEpKTtpZihiPDApe2lmKGI8LTIqTCl7Yy5iLndhcm4oXCJQVFMgPCBEVFMgZGV0ZWN0ZWQgaW4gdmlkZW8gc2FtcGxlcywgb2Zmc2V0dGluZyBEVFMgZnJvbSBQVFMgYnkgXCIraXQoLUwsITApK1wiIG1zXCIpO2Zvcih2YXIgQT1iLFI9MDtSPGY7UisrKWRbUl0uZHRzPUE9TWF0aC5tYXgoQSxkW1JdLnB0cy1MKSxkW1JdLnB0cz1NYXRoLm1heChBLGRbUl0ucHRzKX1lbHNle2MuYi53YXJuKFwiUFRTIDwgRFRTIGRldGVjdGVkIGluIHZpZGVvIHNhbXBsZXMsIHNoaWZ0aW5nIERUUyBieSBcIitpdChiLCEwKStcIiBtcyB0byBvdmVyY29tZSB0aGlzIGlzc3VlXCIpO2Zvcih2YXIgRD0wO0Q8ZjtEKyspZFtEXS5kdHM9ZFtEXS5kdHMrYn1vPWRbMF0uZHRzfWlmKHIpe3ZhciBfPW8tZyxrPV8+TDtpZihrfHxfPC0xKXtrP2MuYi53YXJuKFwiQVZDOiBcIitpdChfLCEwKStcIiBtcyAoXCIrXytcImR0cykgaG9sZSBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZCwgZmlsbGluZyBpdFwiKTpjLmIud2FybihcIkFWQzogXCIraXQoLV8sITApK1wiIG1zIChcIitfK1wiZHRzKSBvdmVybGFwcGluZyBiZXR3ZWVuIGZyYWdtZW50cyBkZXRlY3RlZFwiKSxvPWc7dmFyIHg9ZFswXS5wdHMtXztkWzBdLmR0cz1vLGRbMF0ucHRzPXgsYy5iLmxvZyhcIlZpZGVvOiBGaXJzdCBQVFMvRFRTIGFkanVzdGVkOiBcIitpdCh4LCEwKStcIi9cIitpdChvLCEwKStcIiwgZGVsdGE6IFwiK2l0KF8sITApK1wiIG1zXCIpfX1vdCYmKG89TWF0aC5tYXgoMCxvKSk7Zm9yKHZhciB3PTAsQz0wLE89MDtPPGY7TysrKXtmb3IodmFyIEk9ZFtPXSxQPUkudW5pdHMsRj1QLmxlbmd0aCxNPTAsTj0wO048RjtOKyspTSs9UFtOXS5kYXRhLmxlbmd0aDtDKz1NLHcrPUYsSS5sZW5ndGg9TSxJLmR0cz1NYXRoLm1heChJLmR0cyxvKSxJLnB0cz1NYXRoLm1heChJLnB0cyxJLmR0cywwKSxtPU1hdGgubWluKEkucHRzLG0pLHk9TWF0aC5tYXgoSS5wdHMseSl9bD1kW2YtMV0uZHRzO3ZhciBCLFU9Qys0KncrODt0cnl7Qj1uZXcgVWludDhBcnJheShVKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCB0aGlzLm9ic2VydmVyLmVtaXQoaS5hLkVSUk9SLGkuYS5FUlJPUix7dHlwZTphLmIuTVVYX0VSUk9SLGRldGFpbHM6YS5hLlJFTVVYX0FMTE9DX0VSUk9SLGZhdGFsOiExLGJ5dGVzOlUscmVhc29uOlwiZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgXCIrVX0pfXZhciBHPW5ldyBEYXRhVmlldyhCLmJ1ZmZlcik7Ry5zZXRVaW50MzIoMCxVKSxCLnNldChldC50eXBlcy5tZGF0LDQpO2Zvcih2YXIgaj0wO2o8ZjtqKyspe2Zvcih2YXIgSD1kW2pdLEs9SC51bml0cyxWPTAsVz0wLFk9Sy5sZW5ndGg7VzxZO1crKyl7dmFyIFg9S1tXXSxxPVguZGF0YSx6PVguZGF0YS5ieXRlTGVuZ3RoO0cuc2V0VWludDMyKHAseikscCs9NCxCLnNldChxLHApLHArPXosVis9NCt6fWlmKGo8Zi0xKXM9ZFtqKzFdLmR0cy1ILmR0cztlbHNle3ZhciBRPXRoaXMuY29uZmlnLCQ9SC5kdHMtZFtqPjA/ai0xOmpdLmR0cztpZihRLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2smJm51bGwhPT10aGlzLm5leHRBdWRpb1B0cyl7dmFyIFo9TWF0aC5mbG9vcihRLm1heEJ1ZmZlckhvbGUqdSksSj0obj9tK24qdTp0aGlzLm5leHRBdWRpb1B0cyktSC5wdHM7Sj5aPygocz1KLSQpPDAmJihzPSQpLGMuYi5sb2coXCJbbXA0LXJlbXV4ZXJdOiBJdCBpcyBhcHByb3hpbWF0ZWx5IFwiK0ovOTArXCIgbXMgdG8gdGhlIG5leHQgc2VnbWVudDsgdXNpbmcgZHVyYXRpb24gXCIrcy85MCtcIiBtcyBmb3IgdGhlIGxhc3QgdmlkZW8gZnJhbWUuXCIpKTpzPSR9ZWxzZSBzPSR9dmFyIHR0PU1hdGgucm91bmQoSC5wdHMtSC5kdHMpO2gucHVzaChuZXcgZHQoSC5rZXkscyxWLHR0KSl9aWYoaC5sZW5ndGgmJm50JiZudDw3MCl7dmFyIHJ0PWhbMF0uZmxhZ3M7cnQuZGVwZW5kc09uPTIscnQuaXNOb25TeW5jPTB9dGhpcy5uZXh0QXZjRHRzPWc9bCtzLHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXM9ITA7dmFyIHN0PXtkYXRhMTpldC5tb29mKHQuc2VxdWVuY2VOdW1iZXIrKyxvLGF0KHt9LHQse3NhbXBsZXM6aH0pKSxkYXRhMjpCLHN0YXJ0UFRTOm0vdSxlbmRQVFM6KHkrcykvdSxzdGFydERUUzpvL3UsZW5kRFRTOmcvdSx0eXBlOlwidmlkZW9cIixoYXNBdWRpbzohMSxoYXNWaWRlbzohMCxuYjpoLmxlbmd0aCxkcm9wcGVkOnQuZHJvcHBlZH07cmV0dXJuIHQuc2FtcGxlcz1bXSx0LmRyb3BwZWQ9MCxzdH0sZS5yZW11eEF1ZGlvPWZ1bmN0aW9uKHQsZSxyLG4scyl7dmFyIG89dC5pbnB1dFRpbWVTY2FsZSxsPW8vKHQuc2FtcGxlcmF0ZT90LnNhbXBsZXJhdGU6byksdT10LmlzQUFDPzEwMjQ6MTE1MixkPXUqbCxoPXRoaXMuX2luaXRQVFMsZj0hdC5pc0FBQyYmdGhpcy50eXBlU3VwcG9ydGVkLm1wZWcsdj1bXSxnPXQuc2FtcGxlcyxwPWY/MDo4LG09dGhpcy5uZXh0QXVkaW9QdHN8fC0xLHk9ZSpvO2lmKHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXM9cj1yfHxnLmxlbmd0aCYmbT4wJiYobiYmTWF0aC5hYnMoeS1tKTw5ZTN8fE1hdGguYWJzKHV0KGdbMF0ucHRzLWgseSktbSk8MjAqZCksZy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnB0cz11dCh0LnB0cy1oLHkpfSkpLCFyfHxtPDApe2lmKCEoZz1nLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQucHRzPj0wfSkpKS5sZW5ndGgpcmV0dXJuO209MD09PXM/MDpuP01hdGgubWF4KDAseSk6Z1swXS5wdHN9aWYodC5pc0FBQylmb3IodmFyIGI9dm9pZCAwIT09cyxUPXRoaXMuY29uZmlnLm1heEF1ZGlvRnJhbWVzRHJpZnQsRT0wLFM9bTtFPGcubGVuZ3RoO0UrKyl7dmFyIEw9Z1tFXSxBPUwucHRzLFI9QS1TLEQ9TWF0aC5hYnMoMWUzKlIvbyk7aWYoUjw9LVQqZCYmYikwPT09RSYmKGMuYi53YXJuKFwiQXVkaW8gZnJhbWUgQCBcIisoQS9vKS50b0ZpeGVkKDMpK1wicyBvdmVybGFwcyBuZXh0QXVkaW9QdHMgYnkgXCIrTWF0aC5yb3VuZCgxZTMqUi9vKStcIiBtcy5cIiksdGhpcy5uZXh0QXVkaW9QdHM9bT1TPUEpO2Vsc2UgaWYoUj49VCpkJiZEPDFlNCYmYil7dmFyIF89TWF0aC5yb3VuZChSL2QpOyhTPUEtXypkKTwwJiYoXy0tLFMrPWQpLDA9PT1FJiYodGhpcy5uZXh0QXVkaW9QdHM9bT1TKSxjLmIud2FybihcIlttcDQtcmVtdXhlcl06IEluamVjdGluZyBcIitfK1wiIGF1ZGlvIGZyYW1lIEAgXCIrKFMvbykudG9GaXhlZCgzKStcInMgZHVlIHRvIFwiK01hdGgucm91bmQoMWUzKlIvbykrXCIgbXMgZ2FwLlwiKTtmb3IodmFyIGs9MDtrPF87aysrKXt2YXIgeD1NYXRoLm1heChTLDApLHc9Wi5nZXRTaWxlbnRGcmFtZSh0Lm1hbmlmZXN0Q29kZWN8fHQuY29kZWMsdC5jaGFubmVsQ291bnQpO3d8fChjLmIubG9nKFwiW21wNC1yZW11eGVyXTogVW5hYmxlIHRvIGdldCBzaWxlbnQgZnJhbWUgZm9yIGdpdmVuIGF1ZGlvIGNvZGVjOyBkdXBsaWNhdGluZyBsYXN0IGZyYW1lIGluc3RlYWQuXCIpLHc9TC51bml0LnN1YmFycmF5KCkpLGcuc3BsaWNlKEUsMCx7dW5pdDp3LHB0czp4fSksUys9ZCxFKyt9fUwucHRzPVMsUys9ZH1mb3IodmFyIEMsTz1udWxsLEk9bnVsbCxQPTAsRj1nLmxlbmd0aDtGLS07KVArPWdbRl0udW5pdC5ieXRlTGVuZ3RoO2Zvcih2YXIgTT0wLE49Zy5sZW5ndGg7TTxOO00rKyl7dmFyIEI9Z1tNXSxVPUIudW5pdCxHPUIucHRzO2lmKG51bGwhPT1JKXZbTS0xXS5kdXJhdGlvbj1NYXRoLnJvdW5kKChHLUkpL2wpO2Vsc2V7aWYociYmdC5pc0FBQyYmKEc9bSksTz1HLCEoUD4wKSlyZXR1cm47UCs9cDt0cnl7Qz1uZXcgVWludDhBcnJheShQKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCB0aGlzLm9ic2VydmVyLmVtaXQoaS5hLkVSUk9SLGkuYS5FUlJPUix7dHlwZTphLmIuTVVYX0VSUk9SLGRldGFpbHM6YS5hLlJFTVVYX0FMTE9DX0VSUk9SLGZhdGFsOiExLGJ5dGVzOlAscmVhc29uOlwiZmFpbCBhbGxvY2F0aW5nIGF1ZGlvIG1kYXQgXCIrUH0pfWZ8fChuZXcgRGF0YVZpZXcoQy5idWZmZXIpLnNldFVpbnQzMigwLFApLEMuc2V0KGV0LnR5cGVzLm1kYXQsNCkpfUMuc2V0KFUscCk7dmFyIGo9VS5ieXRlTGVuZ3RoO3ArPWosdi5wdXNoKG5ldyBkdCghMCx1LGosMCkpLEk9R312YXIgSD12Lmxlbmd0aDtpZihIKXt2YXIgSz12W3YubGVuZ3RoLTFdO3RoaXMubmV4dEF1ZGlvUHRzPW09SStsKksuZHVyYXRpb247dmFyIFY9Zj9uZXcgVWludDhBcnJheSgwKTpldC5tb29mKHQuc2VxdWVuY2VOdW1iZXIrKyxPL2wsYXQoe30sdCx7c2FtcGxlczp2fSkpO3Quc2FtcGxlcz1bXTt2YXIgVz1PL28sWT1tL28sWD17ZGF0YTE6VixkYXRhMjpDLHN0YXJ0UFRTOlcsZW5kUFRTOlksc3RhcnREVFM6VyxlbmREVFM6WSx0eXBlOlwiYXVkaW9cIixoYXNBdWRpbzohMCxoYXNWaWRlbzohMSxuYjpIfTtyZXR1cm4gdGhpcy5pc0F1ZGlvQ29udGlndW91cz0hMCxYfX0sZS5yZW11eEVtcHR5QXVkaW89ZnVuY3Rpb24odCxlLHIsaSl7dmFyIGE9dC5pbnB1dFRpbWVTY2FsZSxuPWEvKHQuc2FtcGxlcmF0ZT90LnNhbXBsZXJhdGU6YSkscz10aGlzLm5leHRBdWRpb1B0cyxvPShudWxsIT09cz9zOmkuc3RhcnREVFMqYSkrdGhpcy5faW5pdERUUyxsPWkuZW5kRFRTKmErdGhpcy5faW5pdERUUyx1PTEwMjQqbixkPU1hdGguY2VpbCgobC1vKS91KSxoPVouZ2V0U2lsZW50RnJhbWUodC5tYW5pZmVzdENvZGVjfHx0LmNvZGVjLHQuY2hhbm5lbENvdW50KTtpZihjLmIud2FybihcIlttcDQtcmVtdXhlcl06IHJlbXV4IGVtcHR5IEF1ZGlvXCIpLGgpe2Zvcih2YXIgZj1bXSx2PTA7djxkO3YrKyl7dmFyIGc9byt2KnU7Zi5wdXNoKHt1bml0OmgscHRzOmcsZHRzOmd9KX1yZXR1cm4gdC5zYW1wbGVzPWYsdGhpcy5yZW11eEF1ZGlvKHQsZSxyLCExKX1jLmIudHJhY2UoXCJbbXA0LXJlbXV4ZXJdOiBVbmFibGUgdG8gcmVtdXhFbXB0eUF1ZGlvIHNpbmNlIHdlIHdlcmUgdW5hYmxlIHRvIGdldCBhIHNpbGVudCBmcmFtZSBmb3IgZ2l2ZW4gYXVkaW8gY29kZWNcIil9LGUucmVtdXhJRDM9ZnVuY3Rpb24odCxlKXt2YXIgcj10LnNhbXBsZXMubGVuZ3RoO2lmKHIpe2Zvcih2YXIgaT10LmlucHV0VGltZVNjYWxlLGE9dGhpcy5faW5pdFBUUyxuPXRoaXMuX2luaXREVFMscz0wO3M8cjtzKyspe3ZhciBvPXQuc2FtcGxlc1tzXTtvLnB0cz11dChvLnB0cy1hLGUqaSkvaSxvLmR0cz11dChvLmR0cy1uLGUqaSkvaX12YXIgbD10LnNhbXBsZXM7cmV0dXJuIHQuc2FtcGxlcz1bXSx7c2FtcGxlczpsfX19LGUucmVtdXhUZXh0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5zYW1wbGVzLmxlbmd0aDtpZihyKXtmb3IodmFyIGk9dC5pbnB1dFRpbWVTY2FsZSxhPXRoaXMuX2luaXRQVFMsbj0wO248cjtuKyspe3ZhciBzPXQuc2FtcGxlc1tuXTtzLnB0cz11dChzLnB0cy1hLGUqaSkvaX10LnNhbXBsZXMuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5wdHMtZS5wdHN9KSk7dmFyIG89dC5zYW1wbGVzO3JldHVybiB0LnNhbXBsZXM9W10se3NhbXBsZXM6b319fSx0fSgpO2Z1bmN0aW9uIHV0KHQsZSl7dmFyIHI7aWYobnVsbD09PWUpcmV0dXJuIHQ7Zm9yKHI9ZTx0Py04NTg5OTM0NTkyOjg1ODk5MzQ1OTI7TWF0aC5hYnModC1lKT40Mjk0OTY3Mjk2Oyl0Kz1yO3JldHVybiB0fXZhciBkdD1mdW5jdGlvbih0LGUscixpKXt0aGlzLnNpemU9dm9pZCAwLHRoaXMuZHVyYXRpb249dm9pZCAwLHRoaXMuY3RzPXZvaWQgMCx0aGlzLmZsYWdzPXZvaWQgMCx0aGlzLmR1cmF0aW9uPWUsdGhpcy5zaXplPXIsdGhpcy5jdHM9aSx0aGlzLmZsYWdzPW5ldyBodCh0KX0saHQ9ZnVuY3Rpb24odCl7dGhpcy5pc0xlYWRpbmc9MCx0aGlzLmlzRGVwZW5kZWRPbj0wLHRoaXMuaGFzUmVkdW5kYW5jeT0wLHRoaXMuZGVncmFkUHJpbz0wLHRoaXMuZGVwZW5kc09uPTEsdGhpcy5pc05vblN5bmM9MSx0aGlzLmRlcGVuZHNPbj10PzI6MSx0aGlzLmlzTm9uU3luYz10PzA6MX0sZnQ9cig1KSxjdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLmVtaXRJbml0U2VnbWVudD0hMSx0aGlzLmF1ZGlvQ29kZWM9dm9pZCAwLHRoaXMudmlkZW9Db2RlYz12b2lkIDAsdGhpcy5pbml0RGF0YT12b2lkIDAsdGhpcy5pbml0UFRTPXZvaWQgMCx0aGlzLmluaXRUcmFja3M9dm9pZCAwLHRoaXMubGFzdEVuZERUUz1udWxsfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt9LGUucmVzZXRUaW1lU3RhbXA9ZnVuY3Rpb24odCl7dGhpcy5pbml0UFRTPXQsdGhpcy5sYXN0RW5kRFRTPW51bGx9LGUucmVzZXROZXh0VGltZXN0YW1wPWZ1bmN0aW9uKCl7dGhpcy5sYXN0RW5kRFRTPW51bGx9LGUucmVzZXRJbml0U2VnbWVudD1mdW5jdGlvbih0LGUscil7dGhpcy5hdWRpb0NvZGVjPWUsdGhpcy52aWRlb0NvZGVjPXIsdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KHQpLHRoaXMuZW1pdEluaXRTZWdtZW50PSEwfSxlLmdlbmVyYXRlSW5pdFNlZ21lbnQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5hdWRpb0NvZGVjLHI9dGhpcy52aWRlb0NvZGVjO2lmKCF0fHwhdC5ieXRlTGVuZ3RoKXJldHVybiB0aGlzLmluaXRUcmFja3M9dm9pZCAwLHZvaWQodGhpcy5pbml0RGF0YT12b2lkIDApO3ZhciBpPXRoaXMuaW5pdERhdGE9T2JqZWN0KGwuZikodCk7ZXx8KGU9Z3QoaS5hdWRpbyxmdC5hLkFVRElPKSkscnx8KHI9Z3QoaS52aWRlbyxmdC5hLlZJREVPKSk7dmFyIGE9e307aS5hdWRpbyYmaS52aWRlbz9hLmF1ZGlvdmlkZW89e2NvbnRhaW5lcjpcInZpZGVvL21wNFwiLGNvZGVjOmUrXCIsXCIrcixpbml0U2VnbWVudDp0LGlkOlwibWFpblwifTppLmF1ZGlvP2EuYXVkaW89e2NvbnRhaW5lcjpcImF1ZGlvL21wNFwiLGNvZGVjOmUsaW5pdFNlZ21lbnQ6dCxpZDpcImF1ZGlvXCJ9OmkudmlkZW8/YS52aWRlbz17Y29udGFpbmVyOlwidmlkZW8vbXA0XCIsY29kZWM6cixpbml0U2VnbWVudDp0LGlkOlwibWFpblwifTpjLmIud2FybihcIltwYXNzdGhyb3VnaC1yZW11eGVyLnRzXTogaW5pdFNlZ21lbnQgZG9lcyBub3QgY29udGFpbiBtb292IG9yIHRyYWsgYm94ZXMuXCIpLHRoaXMuaW5pdFRyYWNrcz1hfSxlLnJlbXV4PWZ1bmN0aW9uKHQsZSxyLGksYSl7dmFyIG49dGhpcy5pbml0UFRTLG89dGhpcy5sYXN0RW5kRFRTLHU9e2F1ZGlvOnZvaWQgMCx2aWRlbzp2b2lkIDAsdGV4dDppLGlkMzpyLGluaXRTZWdtZW50OnZvaWQgMH07T2JqZWN0KHMuYSkobyl8fChvPXRoaXMubGFzdEVuZERUUz1hfHwwKTt2YXIgZD1lLnNhbXBsZXM7aWYoIWR8fCFkLmxlbmd0aClyZXR1cm4gdTt2YXIgaD17aW5pdFBUUzp2b2lkIDAsdGltZXNjYWxlOjF9LGY9dGhpcy5pbml0RGF0YTtpZihmJiZmLmxlbmd0aHx8KHRoaXMuZ2VuZXJhdGVJbml0U2VnbWVudChkKSxmPXRoaXMuaW5pdERhdGEpLCFmfHwhZi5sZW5ndGgpcmV0dXJuIGMuYi53YXJuKFwiW3Bhc3N0aHJvdWdoLXJlbXV4ZXIudHNdOiBGYWlsZWQgdG8gZ2VuZXJhdGUgaW5pdFNlZ21lbnQuXCIpLHU7dGhpcy5lbWl0SW5pdFNlZ21lbnQmJihoLnRyYWNrcz10aGlzLmluaXRUcmFja3MsdGhpcy5lbWl0SW5pdFNlZ21lbnQ9ITEpLE9iamVjdChzLmEpKG4pfHwodGhpcy5pbml0UFRTPWguaW5pdFBUUz1uPXZ0KGYsZCxvKSk7dmFyIHY9T2JqZWN0KGwuYykoZCxmKSxnPW8scD12K2c7T2JqZWN0KGwuZSkoZixkLG4pLHY+MD90aGlzLmxhc3RFbmREVFM9cDooYy5iLndhcm4oXCJEdXJhdGlvbiBwYXJzZWQgZnJvbSBtcDQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvXCIpLHRoaXMucmVzZXROZXh0VGltZXN0YW1wKCkpO3ZhciBtPSEhZi5hdWRpbyx5PSEhZi52aWRlbyxiPVwiXCI7bSYmKGIrPVwiYXVkaW9cIikseSYmKGIrPVwidmlkZW9cIik7dmFyIFQ9e2RhdGExOmQsc3RhcnRQVFM6ZyxzdGFydERUUzpnLGVuZFBUUzpwLGVuZERUUzpwLHR5cGU6YixoYXNBdWRpbzptLGhhc1ZpZGVvOnksbmI6MSxkcm9wcGVkOjB9O3JldHVybiB1LmF1ZGlvPVwiYXVkaW9cIj09PVQudHlwZT9UOnZvaWQgMCx1LnZpZGVvPVwiYXVkaW9cIiE9PVQudHlwZT9UOnZvaWQgMCx1LnRleHQ9aSx1LmlkMz1yLHUuaW5pdFNlZ21lbnQ9aCx1fSx0fSgpLHZ0PWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gT2JqZWN0KGwuZCkodCxlKS1yfTtmdW5jdGlvbiBndCh0LGUpe3ZhciByPW51bGw9PXQ/dm9pZCAwOnQuY29kZWM7cmV0dXJuIHImJnIubGVuZ3RoPjQ/cjpcImh2YzFcIj09PXI/XCJodmMxLjEuYy5MMTIwLjkwXCI6XCJhdjAxXCI9PT1yP1wiYXYwMS4wLjA0TS4wOFwiOlwiYXZjMVwiPT09cnx8ZT09PWZ0LmEuVklERU8/XCJhdmMxLjQyZTAxZVwiOlwibXA0YS40MC41XCJ9dmFyIHB0LG10PWN0LHl0PXIoMTYpO3RyeXtwdD1zZWxmLnBlcmZvcm1hbmNlLm5vdy5iaW5kKHNlbGYucGVyZm9ybWFuY2UpfWNhdGNoKHQpe2MuYi5kZWJ1ZyhcIlVuYWJsZSB0byB1c2UgUGVyZm9ybWFuY2UgQVBJIG9uIHRoaXMgZW52aXJvbm1lbnRcIikscHQ9c2VsZi5EYXRlLm5vd312YXIgYnQ9W3tkZW11eDpxLHJlbXV4Omx0fSx7ZGVtdXg6RCxyZW11eDptdH0se2RlbXV4OkEscmVtdXg6bHR9LHtkZW11eDokLHJlbXV4Omx0fV0sVHQ9MTAyNDtidC5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LmRlbXV4O1R0PU1hdGgubWF4KFR0LGUubWluUHJvYmVCeXRlTGVuZ3RoKX0pKTt2YXIgRXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyLGksYSl7dGhpcy5vYnNlcnZlcj12b2lkIDAsdGhpcy50eXBlU3VwcG9ydGVkPXZvaWQgMCx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy52ZW5kb3I9dm9pZCAwLHRoaXMuaWQ9dm9pZCAwLHRoaXMuZGVtdXhlcj12b2lkIDAsdGhpcy5yZW11eGVyPXZvaWQgMCx0aGlzLmRlY3J5cHRlcj12b2lkIDAsdGhpcy5wcm9iZT12b2lkIDAsdGhpcy5kZWNyeXB0aW9uUHJvbWlzZT1udWxsLHRoaXMudHJhbnNtdXhDb25maWc9dm9pZCAwLHRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU9dm9pZCAwLHRoaXMuY2FjaGU9bmV3IHl0LmEsdGhpcy5vYnNlcnZlcj10LHRoaXMudHlwZVN1cHBvcnRlZD1lLHRoaXMuY29uZmlnPXIsdGhpcy52ZW5kb3I9aSx0aGlzLmlkPWF9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuY29uZmlndXJlPWZ1bmN0aW9uKHQpe3RoaXMudHJhbnNtdXhDb25maWc9dCx0aGlzLmRlY3J5cHRlciYmdGhpcy5kZWNyeXB0ZXIucmVzZXQoKX0sZS5wdXNoPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXRoaXMsbj1yLnRyYW5zbXV4aW5nO24uZXhlY3V0ZVN0YXJ0PXB0KCk7dmFyIHM9bmV3IFVpbnQ4QXJyYXkodCksbz10aGlzLmNhY2hlLHU9dGhpcy5jb25maWcsZD10aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlLGg9dGhpcy50cmFuc211eENvbmZpZztpJiYodGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZT1pKTt2YXIgZj1mdW5jdGlvbih0LGUpe3ZhciByPW51bGw7cmV0dXJuIHQuYnl0ZUxlbmd0aD4wJiZudWxsIT1lJiZudWxsIT1lLmtleSYmbnVsbCE9PWUuaXYmJm51bGwhPWUubWV0aG9kJiYocj1lKSxyfShzLGUpO2lmKGYmJlwiQUVTLTEyOFwiPT09Zi5tZXRob2Qpe3ZhciBjPXRoaXMuZ2V0RGVjcnlwdGVyKCk7aWYoIXUuZW5hYmxlU29mdHdhcmVBRVMpcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2U9Yy53ZWJDcnlwdG9EZWNyeXB0KHMsZi5rZXkuYnVmZmVyLGYuaXYuYnVmZmVyKS50aGVuKChmdW5jdGlvbih0KXt2YXIgZT1hLnB1c2godCxudWxsLHIpO3JldHVybiBhLmRlY3J5cHRpb25Qcm9taXNlPW51bGwsZX0pKSx0aGlzLmRlY3J5cHRpb25Qcm9taXNlO3ZhciB2PWMuc29mdHdhcmVEZWNyeXB0KHMsZi5rZXkuYnVmZmVyLGYuaXYuYnVmZmVyKTtpZighdilyZXR1cm4gbi5leGVjdXRlRW5kPXB0KCksU3Qocik7cz1uZXcgVWludDhBcnJheSh2KX12YXIgZz1pfHxkLHA9Zy5jb250aWd1b3VzLG09Zy5kaXNjb250aW51aXR5LHk9Zy50cmFja1N3aXRjaCxiPWcuYWNjdXJhdGVUaW1lT2Zmc2V0LFQ9Zy50aW1lT2Zmc2V0LEU9Zy5pbml0U2VnbWVudENoYW5nZSxTPWguYXVkaW9Db2RlYyxMPWgudmlkZW9Db2RlYyxBPWguZGVmYXVsdEluaXRQdHMsUj1oLmR1cmF0aW9uLEQ9aC5pbml0U2VnbWVudERhdGE7aWYoKG18fHl8fEUpJiZ0aGlzLnJlc2V0SW5pdFNlZ21lbnQoRCxTLEwsUiksKG18fEUpJiZ0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChBKSxwfHx0aGlzLnJlc2V0Q29udGlndWl0eSgpLHRoaXMubmVlZHNQcm9iaW5nKHMsbSx5KSl7aWYoby5kYXRhTGVuZ3RoKXt2YXIgXz1vLmZsdXNoKCk7cz1PYmplY3QobC5hKShfLHMpfXRoaXMuY29uZmlndXJlVHJhbnNtdXhlcihzLGgpfXZhciBrPXRoaXMudHJhbnNtdXgocyxmLFQsYixyKSx4PXRoaXMuY3VycmVudFRyYW5zbXV4U3RhdGU7cmV0dXJuIHguY29udGlndW91cz0hMCx4LmRpc2NvbnRpbnVpdHk9ITEseC50cmFja1N3aXRjaD0hMSxuLmV4ZWN1dGVFbmQ9cHQoKSxrfSxlLmZsdXNoPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10LnRyYW5zbXV4aW5nO3IuZXhlY3V0ZVN0YXJ0PXB0KCk7dmFyIG49dGhpcy5kZWNyeXB0ZXIscz10aGlzLmNhY2hlLG89dGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSxsPXRoaXMuZGVjcnlwdGlvblByb21pc2U7aWYobClyZXR1cm4gbC50aGVuKChmdW5jdGlvbigpe3JldHVybiBlLmZsdXNoKHQpfSkpO3ZhciB1PVtdLGQ9by50aW1lT2Zmc2V0O2lmKG4pe3ZhciBoPW4uZmx1c2goKTtoJiZ1LnB1c2godGhpcy5wdXNoKGgsbnVsbCx0KSl9dmFyIGY9cy5kYXRhTGVuZ3RoO3MucmVzZXQoKTt2YXIgYz10aGlzLmRlbXV4ZXIsdj10aGlzLnJlbXV4ZXI7aWYoIWN8fCF2KXJldHVybiBmPj1UdCYmdGhpcy5vYnNlcnZlci5lbWl0KGkuYS5FUlJPUixpLmEuRVJST1Ise3R5cGU6YS5iLk1FRElBX0VSUk9SLGRldGFpbHM6YS5hLkZSQUdfUEFSU0lOR19FUlJPUixmYXRhbDohMCxyZWFzb246XCJubyBkZW11eCBtYXRjaGluZyB3aXRoIGNvbnRlbnQgZm91bmRcIn0pLHIuZXhlY3V0ZUVuZD1wdCgpLFtTdCh0KV07dmFyIGc9Yy5mbHVzaChkKTtyZXR1cm4gTHQoZyk/Zy50aGVuKChmdW5jdGlvbihyKXtyZXR1cm4gZS5mbHVzaFJlbXV4KHUscix0KSx1fSkpOih0aGlzLmZsdXNoUmVtdXgodSxnLHQpLHUpfSxlLmZsdXNoUmVtdXg9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPWUuYXVkaW9UcmFjayxhPWUuYXZjVHJhY2ssbj1lLmlkM1RyYWNrLHM9ZS50ZXh0VHJhY2ssbz10aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlLGw9by5hY2N1cmF0ZVRpbWVPZmZzZXQsdT1vLnRpbWVPZmZzZXQ7Yy5iLmxvZyhcIlt0cmFuc211eGVyLnRzXTogRmx1c2hlZCBmcmFnbWVudCBcIityLnNuKyhyLnBhcnQ+LTE/XCIgcDogXCIrci5wYXJ0OlwiXCIpK1wiIG9mIGxldmVsIFwiK3IubGV2ZWwpO3ZhciBkPXRoaXMucmVtdXhlci5yZW11eChpLGEsbixzLHUsbCwhMCx0aGlzLmlkKTt0LnB1c2goe3JlbXV4UmVzdWx0OmQsY2h1bmtNZXRhOnJ9KSxyLnRyYW5zbXV4aW5nLmV4ZWN1dGVFbmQ9cHQoKX0sZS5yZXNldEluaXRpYWxUaW1lc3RhbXA9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5kZW11eGVyLHI9dGhpcy5yZW11eGVyO2UmJnImJihlLnJlc2V0VGltZVN0YW1wKHQpLHIucmVzZXRUaW1lU3RhbXAodCkpfSxlLnJlc2V0Q29udGlndWl0eT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZGVtdXhlcixlPXRoaXMucmVtdXhlcjt0JiZlJiYodC5yZXNldENvbnRpZ3VpdHkoKSxlLnJlc2V0TmV4dFRpbWVzdGFtcCgpKX0sZS5yZXNldEluaXRTZWdtZW50PWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXRoaXMuZGVtdXhlcixuPXRoaXMucmVtdXhlcjthJiZuJiYoYS5yZXNldEluaXRTZWdtZW50KGUscixpKSxuLnJlc2V0SW5pdFNlZ21lbnQodCxlLHIpKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5kZW11eGVyJiYodGhpcy5kZW11eGVyLmRlc3Ryb3koKSx0aGlzLmRlbXV4ZXI9dm9pZCAwKSx0aGlzLnJlbXV4ZXImJih0aGlzLnJlbXV4ZXIuZGVzdHJveSgpLHRoaXMucmVtdXhlcj12b2lkIDApfSxlLnRyYW5zbXV4PWZ1bmN0aW9uKHQsZSxyLGksYSl7cmV0dXJuIGUmJlwiU0FNUExFLUFFU1wiPT09ZS5tZXRob2Q/dGhpcy50cmFuc211eFNhbXBsZUFlcyh0LGUscixpLGEpOnRoaXMudHJhbnNtdXhVbmVuY3J5cHRlZCh0LHIsaSxhKX0sZS50cmFuc211eFVuZW5jcnlwdGVkPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXRoaXMuZGVtdXhlci5kZW11eCh0LGUsITEsIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSxuPWEuYXVkaW9UcmFjayxzPWEuYXZjVHJhY2ssbz1hLmlkM1RyYWNrLGw9YS50ZXh0VHJhY2s7cmV0dXJue3JlbXV4UmVzdWx0OnRoaXMucmVtdXhlci5yZW11eChuLHMsbyxsLGUsciwhMSx0aGlzLmlkKSxjaHVua01ldGE6aX19LGUudHJhbnNtdXhTYW1wbGVBZXM9ZnVuY3Rpb24odCxlLHIsaSxhKXt2YXIgbj10aGlzO3JldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXModCxlLHIpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybntyZW11eFJlc3VsdDpuLnJlbXV4ZXIucmVtdXgodC5hdWRpb1RyYWNrLHQuYXZjVHJhY2ssdC5pZDNUcmFjayx0LnRleHRUcmFjayxyLGksITEsbi5pZCksY2h1bmtNZXRhOmF9fSkpfSxlLmNvbmZpZ3VyZVRyYW5zbXV4ZXI9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIsaT10aGlzLmNvbmZpZyxhPXRoaXMub2JzZXJ2ZXIsbj10aGlzLnR5cGVTdXBwb3J0ZWQscz10aGlzLnZlbmRvcixvPWUuYXVkaW9Db2RlYyxsPWUuZGVmYXVsdEluaXRQdHMsdT1lLmR1cmF0aW9uLGQ9ZS5pbml0U2VnbWVudERhdGEsaD1lLnZpZGVvQ29kZWMsZj0wLHY9YnQubGVuZ3RoO2Y8djtmKyspaWYoYnRbZl0uZGVtdXgucHJvYmUodCkpe3I9YnRbZl07YnJlYWt9cnx8KGMuYi53YXJuKFwiRmFpbGVkIHRvIGZpbmQgZGVtdXhlciBieSBwcm9iaW5nIGZyYWcsIHRyZWF0aW5nIGFzIG1wNCBwYXNzdGhyb3VnaFwiKSxyPXtkZW11eDpELHJlbXV4Om10fSk7dmFyIGc9dGhpcy5kZW11eGVyLHA9dGhpcy5yZW11eGVyLG09ci5yZW11eCx5PXIuZGVtdXg7cCYmcCBpbnN0YW5jZW9mIG18fCh0aGlzLnJlbXV4ZXI9bmV3IG0oYSxpLG4scykpLGcmJmcgaW5zdGFuY2VvZiB5fHwodGhpcy5kZW11eGVyPW5ldyB5KGEsaSxuKSx0aGlzLnByb2JlPXkucHJvYmUpLHRoaXMucmVzZXRJbml0U2VnbWVudChkLG8saCx1KSx0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChsKX0sZS5uZWVkc1Byb2Jpbmc9ZnVuY3Rpb24odCxlLHIpe3JldHVybiF0aGlzLmRlbXV4ZXJ8fCF0aGlzLnJlbXV4ZXJ8fGV8fHJ9LGUuZ2V0RGVjcnlwdGVyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5kZWNyeXB0ZXI7cmV0dXJuIHR8fCh0PXRoaXMuZGVjcnlwdGVyPW5ldyBuLmEodGhpcy5vYnNlcnZlcix0aGlzLmNvbmZpZykpLHR9LHR9KCksU3Q9ZnVuY3Rpb24odCl7cmV0dXJue3JlbXV4UmVzdWx0Ont9LGNodW5rTWV0YTp0fX07ZnVuY3Rpb24gTHQodCl7cmV0dXJuXCJ0aGVuXCJpbiB0JiZ0LnRoZW4gaW5zdGFuY2VvZiBGdW5jdGlvbn12YXIgQXQ9ZnVuY3Rpb24odCxlLHIsaSxhKXt0aGlzLmF1ZGlvQ29kZWM9dm9pZCAwLHRoaXMudmlkZW9Db2RlYz12b2lkIDAsdGhpcy5pbml0U2VnbWVudERhdGE9dm9pZCAwLHRoaXMuZHVyYXRpb249dm9pZCAwLHRoaXMuZGVmYXVsdEluaXRQdHM9dm9pZCAwLHRoaXMuYXVkaW9Db2RlYz10LHRoaXMudmlkZW9Db2RlYz1lLHRoaXMuaW5pdFNlZ21lbnREYXRhPXIsdGhpcy5kdXJhdGlvbj1pLHRoaXMuZGVmYXVsdEluaXRQdHM9YX0sUnQ9ZnVuY3Rpb24odCxlLHIsaSxhLG4pe3RoaXMuZGlzY29udGludWl0eT12b2lkIDAsdGhpcy5jb250aWd1b3VzPXZvaWQgMCx0aGlzLmFjY3VyYXRlVGltZU9mZnNldD12b2lkIDAsdGhpcy50cmFja1N3aXRjaD12b2lkIDAsdGhpcy50aW1lT2Zmc2V0PXZvaWQgMCx0aGlzLmluaXRTZWdtZW50Q2hhbmdlPXZvaWQgMCx0aGlzLmRpc2NvbnRpbnVpdHk9dCx0aGlzLmNvbnRpZ3VvdXM9ZSx0aGlzLmFjY3VyYXRlVGltZU9mZnNldD1yLHRoaXMudHJhY2tTd2l0Y2g9aSx0aGlzLnRpbWVPZmZzZXQ9YSx0aGlzLmluaXRTZWdtZW50Q2hhbmdlPW59fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz12b2lkIDB9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgaSxhLG4scyxvO2k9L14oKD86W2EtekEtWjAtOStcXC0uXSs6KT8pKFxcL1xcL1teXFwvPyNdKik/KCg/OlteXFwvPyNdKlxcLykqW147PyNdKik/KDtbXj8jXSopPyhcXD9bXiNdKik/KCNbXl0qKT8kLyxhPS9eKFteXFwvPyNdKikoW15dKikkLyxuPS8oPzpcXC98XilcXC4oPz1cXC8pL2cscz0vKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKVteXFwvXSooPz1cXC8pL2csbz17YnVpbGRBYnNvbHV0ZVVSTDpmdW5jdGlvbih0LGUscil7aWYocj1yfHx7fSx0PXQudHJpbSgpLCEoZT1lLnRyaW0oKSkpe2lmKCFyLmFsd2F5c05vcm1hbGl6ZSlyZXR1cm4gdDt2YXIgaT1vLnBhcnNlVVJMKHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC5cIik7cmV0dXJuIGkucGF0aD1vLm5vcm1hbGl6ZVBhdGgoaS5wYXRoKSxvLmJ1aWxkVVJMRnJvbVBhcnRzKGkpfXZhciBuPW8ucGFyc2VVUkwoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC5cIik7aWYobi5zY2hlbWUpcmV0dXJuIHIuYWx3YXlzTm9ybWFsaXplPyhuLnBhdGg9by5ub3JtYWxpemVQYXRoKG4ucGF0aCksby5idWlsZFVSTEZyb21QYXJ0cyhuKSk6ZTt2YXIgcz1vLnBhcnNlVVJMKHQpO2lmKCFzKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC5cIik7aWYoIXMubmV0TG9jJiZzLnBhdGgmJlwiL1wiIT09cy5wYXRoWzBdKXt2YXIgbD1hLmV4ZWMocy5wYXRoKTtzLm5ldExvYz1sWzFdLHMucGF0aD1sWzJdfXMubmV0TG9jJiYhcy5wYXRoJiYocy5wYXRoPVwiL1wiKTt2YXIgdT17c2NoZW1lOnMuc2NoZW1lLG5ldExvYzpuLm5ldExvYyxwYXRoOm51bGwscGFyYW1zOm4ucGFyYW1zLHF1ZXJ5Om4ucXVlcnksZnJhZ21lbnQ6bi5mcmFnbWVudH07aWYoIW4ubmV0TG9jJiYodS5uZXRMb2M9cy5uZXRMb2MsXCIvXCIhPT1uLnBhdGhbMF0pKWlmKG4ucGF0aCl7dmFyIGQ9cy5wYXRoLGg9ZC5zdWJzdHJpbmcoMCxkLmxhc3RJbmRleE9mKFwiL1wiKSsxKStuLnBhdGg7dS5wYXRoPW8ubm9ybWFsaXplUGF0aChoKX1lbHNlIHUucGF0aD1zLnBhdGgsbi5wYXJhbXN8fCh1LnBhcmFtcz1zLnBhcmFtcyxuLnF1ZXJ5fHwodS5xdWVyeT1zLnF1ZXJ5KSk7cmV0dXJuIG51bGw9PT11LnBhdGgmJih1LnBhdGg9ci5hbHdheXNOb3JtYWxpemU/by5ub3JtYWxpemVQYXRoKG4ucGF0aCk6bi5wYXRoKSxvLmJ1aWxkVVJMRnJvbVBhcnRzKHUpfSxwYXJzZVVSTDpmdW5jdGlvbih0KXt2YXIgZT1pLmV4ZWModCk7cmV0dXJuIGU/e3NjaGVtZTplWzFdfHxcIlwiLG5ldExvYzplWzJdfHxcIlwiLHBhdGg6ZVszXXx8XCJcIixwYXJhbXM6ZVs0XXx8XCJcIixxdWVyeTplWzVdfHxcIlwiLGZyYWdtZW50OmVbNl18fFwiXCJ9Om51bGx9LG5vcm1hbGl6ZVBhdGg6ZnVuY3Rpb24odCl7Zm9yKHQ9dC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKS5yZXBsYWNlKG4sXCJcIik7dC5sZW5ndGghPT0odD10LnJlcGxhY2UocyxcIlwiKSkubGVuZ3RoOyk7cmV0dXJuIHQuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIil9LGJ1aWxkVVJMRnJvbVBhcnRzOmZ1bmN0aW9uKHQpe3JldHVybiB0LnNjaGVtZSt0Lm5ldExvYyt0LnBhdGgrdC5wYXJhbXMrdC5xdWVyeSt0LmZyYWdtZW50fX0sdC5leHBvcnRzPW99LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKTt2YXIgaT1mdW5jdGlvbigpe3RoaXMuYWJvcnRlZD0hMSx0aGlzLmxvYWRlZD0wLHRoaXMucmV0cnk9MCx0aGlzLnRvdGFsPTAsdGhpcy5jaHVua0NvdW50PTAsdGhpcy5id0VzdGltYXRlPTAsdGhpcy5sb2FkaW5nPXtzdGFydDowLGZpcnN0OjAsZW5kOjB9LHRoaXMucGFyc2luZz17c3RhcnQ6MCxlbmQ6MH0sdGhpcy5idWZmZXJpbmc9e3N0YXJ0OjAsZmlyc3Q6MCxlbmQ6MH19fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxhPVwiflwiO2Z1bmN0aW9uIG4oKXt9ZnVuY3Rpb24gcyh0LGUscil7dGhpcy5mbj10LHRoaXMuY29udGV4dD1lLHRoaXMub25jZT1yfHwhMX1mdW5jdGlvbiBvKHQsZSxyLGksbil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTt2YXIgbz1uZXcgcyhyLGl8fHQsbiksbD1hP2ErZTplO3JldHVybiB0Ll9ldmVudHNbbF0/dC5fZXZlbnRzW2xdLmZuP3QuX2V2ZW50c1tsXT1bdC5fZXZlbnRzW2xdLG9dOnQuX2V2ZW50c1tsXS5wdXNoKG8pOih0Ll9ldmVudHNbbF09byx0Ll9ldmVudHNDb3VudCsrKSx0fWZ1bmN0aW9uIGwodCxlKXswPT0tLXQuX2V2ZW50c0NvdW50P3QuX2V2ZW50cz1uZXcgbjpkZWxldGUgdC5fZXZlbnRzW2VdfWZ1bmN0aW9uIHUoKXt0aGlzLl9ldmVudHM9bmV3IG4sdGhpcy5fZXZlbnRzQ291bnQ9MH1PYmplY3QuY3JlYXRlJiYobi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShudWxsKSwobmV3IG4pLl9fcHJvdG9fX3x8KGE9ITEpKSx1LnByb3RvdHlwZS5ldmVudE5hbWVzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyPVtdO2lmKDA9PT10aGlzLl9ldmVudHNDb3VudClyZXR1cm4gcjtmb3IoZSBpbiB0PXRoaXMuX2V2ZW50cylpLmNhbGwodCxlKSYmci5wdXNoKGE/ZS5zbGljZSgxKTplKTtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scz9yLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpKTpyfSx1LnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24odCl7dmFyIGU9YT9hK3Q6dCxyPXRoaXMuX2V2ZW50c1tlXTtpZighcilyZXR1cm5bXTtpZihyLmZuKXJldHVybltyLmZuXTtmb3IodmFyIGk9MCxuPXIubGVuZ3RoLHM9bmV3IEFycmF5KG4pO2k8bjtpKyspc1tpXT1yW2ldLmZuO3JldHVybiBzfSx1LnByb3RvdHlwZS5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKHQpe3ZhciBlPWE/YSt0OnQscj10aGlzLl9ldmVudHNbZV07cmV0dXJuIHI/ci5mbj8xOnIubGVuZ3RoOjB9LHUucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCxlLHIsaSxuLHMpe3ZhciBvPWE/YSt0OnQ7aWYoIXRoaXMuX2V2ZW50c1tvXSlyZXR1cm4hMTt2YXIgbCx1LGQ9dGhpcy5fZXZlbnRzW29dLGg9YXJndW1lbnRzLmxlbmd0aDtpZihkLmZuKXtzd2l0Y2goZC5vbmNlJiZ0aGlzLnJlbW92ZUxpc3RlbmVyKHQsZC5mbix2b2lkIDAsITApLGgpe2Nhc2UgMTpyZXR1cm4gZC5mbi5jYWxsKGQuY29udGV4dCksITA7Y2FzZSAyOnJldHVybiBkLmZuLmNhbGwoZC5jb250ZXh0LGUpLCEwO2Nhc2UgMzpyZXR1cm4gZC5mbi5jYWxsKGQuY29udGV4dCxlLHIpLCEwO2Nhc2UgNDpyZXR1cm4gZC5mbi5jYWxsKGQuY29udGV4dCxlLHIsaSksITA7Y2FzZSA1OnJldHVybiBkLmZuLmNhbGwoZC5jb250ZXh0LGUscixpLG4pLCEwO2Nhc2UgNjpyZXR1cm4gZC5mbi5jYWxsKGQuY29udGV4dCxlLHIsaSxuLHMpLCEwfWZvcih1PTEsbD1uZXcgQXJyYXkoaC0xKTt1PGg7dSsrKWxbdS0xXT1hcmd1bWVudHNbdV07ZC5mbi5hcHBseShkLmNvbnRleHQsbCl9ZWxzZXt2YXIgZixjPWQubGVuZ3RoO2Zvcih1PTA7dTxjO3UrKylzd2l0Y2goZFt1XS5vbmNlJiZ0aGlzLnJlbW92ZUxpc3RlbmVyKHQsZFt1XS5mbix2b2lkIDAsITApLGgpe2Nhc2UgMTpkW3VdLmZuLmNhbGwoZFt1XS5jb250ZXh0KTticmVhaztjYXNlIDI6ZFt1XS5mbi5jYWxsKGRbdV0uY29udGV4dCxlKTticmVhaztjYXNlIDM6ZFt1XS5mbi5jYWxsKGRbdV0uY29udGV4dCxlLHIpO2JyZWFrO2Nhc2UgNDpkW3VdLmZuLmNhbGwoZFt1XS5jb250ZXh0LGUscixpKTticmVhaztkZWZhdWx0OmlmKCFsKWZvcihmPTEsbD1uZXcgQXJyYXkoaC0xKTtmPGg7ZisrKWxbZi0xXT1hcmd1bWVudHNbZl07ZFt1XS5mbi5hcHBseShkW3VdLmNvbnRleHQsbCl9fXJldHVybiEwfSx1LnByb3RvdHlwZS5vbj1mdW5jdGlvbih0LGUscil7cmV0dXJuIG8odGhpcyx0LGUsciwhMSl9LHUucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBvKHRoaXMsdCxlLHIsITApfSx1LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbih0LGUscixpKXt2YXIgbj1hP2ErdDp0O2lmKCF0aGlzLl9ldmVudHNbbl0pcmV0dXJuIHRoaXM7aWYoIWUpcmV0dXJuIGwodGhpcyxuKSx0aGlzO3ZhciBzPXRoaXMuX2V2ZW50c1tuXTtpZihzLmZuKXMuZm4hPT1lfHxpJiYhcy5vbmNlfHxyJiZzLmNvbnRleHQhPT1yfHxsKHRoaXMsbik7ZWxzZXtmb3IodmFyIG89MCx1PVtdLGQ9cy5sZW5ndGg7bzxkO28rKykoc1tvXS5mbiE9PWV8fGkmJiFzW29dLm9uY2V8fHImJnNbb10uY29udGV4dCE9PXIpJiZ1LnB1c2goc1tvXSk7dS5sZW5ndGg/dGhpcy5fZXZlbnRzW25dPTE9PT11Lmxlbmd0aD91WzBdOnU6bCh0aGlzLG4pfXJldHVybiB0aGlzfSx1LnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIHQ/KGU9YT9hK3Q6dCx0aGlzLl9ldmVudHNbZV0mJmwodGhpcyxlKSk6KHRoaXMuX2V2ZW50cz1uZXcgbix0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzfSx1LnByb3RvdHlwZS5vZmY9dS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsdS5wcm90b3R5cGUuYWRkTGlzdGVuZXI9dS5wcm90b3R5cGUub24sdS5wcmVmaXhlZD1hLHUuRXZlbnRFbWl0dGVyPXUsdC5leHBvcnRzPXV9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gdX0pKTt2YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLnN1YnRsZT12b2lkIDAsdGhpcy5hZXNJVj12b2lkIDAsdGhpcy5zdWJ0bGU9dCx0aGlzLmFlc0lWPWV9cmV0dXJuIHQucHJvdG90eXBlLmRlY3J5cHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdWJ0bGUuZGVjcnlwdCh7bmFtZTpcIkFFUy1DQkNcIixpdjp0aGlzLmFlc0lWfSxlLHQpfSx0fSgpLGE9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5zdWJ0bGU9dm9pZCAwLHRoaXMua2V5PXZvaWQgMCx0aGlzLnN1YnRsZT10LHRoaXMua2V5PWV9cmV0dXJuIHQucHJvdG90eXBlLmV4cGFuZEtleT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIix0aGlzLmtleSx7bmFtZTpcIkFFUy1DQkNcIn0sITEsW1wiZW5jcnlwdFwiLFwiZGVjcnlwdFwiXSl9LHR9KCksbj1yKDgpLHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7dGhpcy5yY29uPVswLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0XSx0aGlzLnN1Yk1peD1bbmV3IFVpbnQzMkFycmF5KDI1NiksbmV3IFVpbnQzMkFycmF5KDI1NiksbmV3IFVpbnQzMkFycmF5KDI1NiksbmV3IFVpbnQzMkFycmF5KDI1NildLHRoaXMuaW52U3ViTWl4PVtuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KSxuZXcgVWludDMyQXJyYXkoMjU2KV0sdGhpcy5zQm94PW5ldyBVaW50MzJBcnJheSgyNTYpLHRoaXMuaW52U0JveD1uZXcgVWludDMyQXJyYXkoMjU2KSx0aGlzLmtleT1uZXcgVWludDMyQXJyYXkoMCksdGhpcy5rc1Jvd3M9MCx0aGlzLmtleVNpemU9MCx0aGlzLmtleVNjaGVkdWxlPXZvaWQgMCx0aGlzLmludktleVNjaGVkdWxlPXZvaWQgMCx0aGlzLmluaXRUYWJsZSgpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5Xz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IERhdGFWaWV3KHQpLHI9bmV3IFVpbnQzMkFycmF5KDQpLGk9MDtpPDQ7aSsrKXJbaV09ZS5nZXRVaW50MzIoNCppKTtyZXR1cm4gcn0sZS5pbml0VGFibGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnNCb3gsZT10aGlzLmludlNCb3gscj10aGlzLnN1Yk1peCxpPXJbMF0sYT1yWzFdLG49clsyXSxzPXJbM10sbz10aGlzLmludlN1Yk1peCxsPW9bMF0sdT1vWzFdLGQ9b1syXSxoPW9bM10sZj1uZXcgVWludDMyQXJyYXkoMjU2KSxjPTAsdj0wLGc9MDtmb3IoZz0wO2c8MjU2O2crKylmW2ddPWc8MTI4P2c8PDE6Zzw8MV4yODM7Zm9yKGc9MDtnPDI1NjtnKyspe3ZhciBwPXZedjw8MV52PDwyXnY8PDNedjw8NDtwPXA+Pj44XjI1NSZwXjk5LHRbY109cCxlW3BdPWM7dmFyIG09ZltjXSx5PWZbbV0sYj1mW3ldLFQ9MjU3KmZbcF1eMTY4NDMwMDgqcDtpW2NdPVQ8PDI0fFQ+Pj44LGFbY109VDw8MTZ8VD4+PjE2LG5bY109VDw8OHxUPj4+MjQsc1tjXT1ULFQ9MTY4NDMwMDkqYl42NTUzNyp5XjI1NyptXjE2ODQzMDA4KmMsbFtwXT1UPDwyNHxUPj4+OCx1W3BdPVQ8PDE2fFQ+Pj4xNixkW3BdPVQ8PDh8VD4+PjI0LGhbcF09VCxjPyhjPW1eZltmW2ZbYl5tXV1dLHZePWZbZlt2XV0pOmM9dj0xfX0sZS5leHBhbmRLZXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKHQpLHI9ITAsaT0wO2k8ZS5sZW5ndGgmJnI7KXI9ZVtpXT09PXRoaXMua2V5W2ldLGkrKztpZighcil7dGhpcy5rZXk9ZTt2YXIgYT10aGlzLmtleVNpemU9ZS5sZW5ndGg7aWYoNCE9PWEmJjYhPT1hJiY4IT09YSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFlcyBrZXkgc2l6ZT1cIithKTt2YXIgbixzLG8sbCx1PXRoaXMua3NSb3dzPTQqKGErNisxKSxkPXRoaXMua2V5U2NoZWR1bGU9bmV3IFVpbnQzMkFycmF5KHUpLGg9dGhpcy5pbnZLZXlTY2hlZHVsZT1uZXcgVWludDMyQXJyYXkodSksZj10aGlzLnNCb3gsYz10aGlzLnJjb24sdj10aGlzLmludlN1Yk1peCxnPXZbMF0scD12WzFdLG09dlsyXSx5PXZbM107Zm9yKG49MDtuPHU7bisrKW48YT9vPWRbbl09ZVtuXToobD1vLG4lYT09MD8obD1mWyhsPWw8PDh8bD4+PjI0KT4+PjI0XTw8MjR8ZltsPj4+MTYmMjU1XTw8MTZ8ZltsPj4+OCYyNTVdPDw4fGZbMjU1JmxdLGxePWNbbi9hfDBdPDwyNCk6YT42JiZuJWE9PTQmJihsPWZbbD4+PjI0XTw8MjR8ZltsPj4+MTYmMjU1XTw8MTZ8ZltsPj4+OCYyNTVdPDw4fGZbMjU1JmxdKSxkW25dPW89KGRbbi1hXV5sKT4+PjApO2ZvcihzPTA7czx1O3MrKyluPXUtcyxsPTMmcz9kW25dOmRbbi00XSxoW3NdPXM8NHx8bjw9ND9sOmdbZltsPj4+MjRdXV5wW2ZbbD4+PjE2JjI1NV1dXm1bZltsPj4+OCYyNTVdXV55W2ZbMjU1JmxdXSxoW3NdPWhbc10+Pj4wfX0sZS5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwPWZ1bmN0aW9uKHQpe3JldHVybiB0PDwyNHwoNjUyODAmdCk8PDh8KDE2NzExNjgwJnQpPj44fHQ+Pj4yNH0sZS5kZWNyeXB0PWZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIGksYSxuLHMsbyxsLHUsZCxoLGYsYyx2LGcscCxtPXRoaXMua2V5U2l6ZSs2LHk9dGhpcy5pbnZLZXlTY2hlZHVsZSxiPXRoaXMuaW52U0JveCxUPXRoaXMuaW52U3ViTWl4LEU9VFswXSxTPVRbMV0sTD1UWzJdLEE9VFszXSxSPXRoaXMudWludDhBcnJheVRvVWludDMyQXJyYXlfKHIpLEQ9UlswXSxfPVJbMV0saz1SWzJdLHg9UlszXSx3PW5ldyBJbnQzMkFycmF5KHQpLEM9bmV3IEludDMyQXJyYXkody5sZW5ndGgpLE89dGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO2U8dy5sZW5ndGg7KXtmb3IoaD1PKHdbZV0pLGY9Tyh3W2UrMV0pLGM9Tyh3W2UrMl0pLHY9Tyh3W2UrM10pLG89aF55WzBdLGw9dl55WzFdLHU9Y155WzJdLGQ9Zl55WzNdLGc9NCxwPTE7cDxtO3ArKylpPUVbbz4+PjI0XV5TW2w+PjE2JjI1NV1eTFt1Pj44JjI1NV1eQVsyNTUmZF1eeVtnXSxhPUVbbD4+PjI0XV5TW3U+PjE2JjI1NV1eTFtkPj44JjI1NV1eQVsyNTUmb11eeVtnKzFdLG49RVt1Pj4+MjRdXlNbZD4+MTYmMjU1XV5MW28+PjgmMjU1XV5BWzI1NSZsXV55W2crMl0scz1FW2Q+Pj4yNF1eU1tvPj4xNiYyNTVdXkxbbD4+OCYyNTVdXkFbMjU1JnVdXnlbZyszXSxvPWksbD1hLHU9bixkPXMsZys9NDtpPWJbbz4+PjI0XTw8MjReYltsPj4xNiYyNTVdPDwxNl5iW3U+PjgmMjU1XTw8OF5iWzI1NSZkXV55W2ddLGE9YltsPj4+MjRdPDwyNF5iW3U+PjE2JjI1NV08PDE2XmJbZD4+OCYyNTVdPDw4XmJbMjU1Jm9dXnlbZysxXSxuPWJbdT4+PjI0XTw8MjReYltkPj4xNiYyNTVdPDwxNl5iW28+PjgmMjU1XTw8OF5iWzI1NSZsXV55W2crMl0scz1iW2Q+Pj4yNF08PDI0XmJbbz4+MTYmMjU1XTw8MTZeYltsPj44JjI1NV08PDheYlsyNTUmdV1eeVtnKzNdLENbZV09TyhpXkQpLENbZSsxXT1PKHNeXyksQ1tlKzJdPU8obl5rKSxDW2UrM109TyhhXngpLEQ9aCxfPWYsaz1jLHg9dixlKz00fXJldHVybiBDLmJ1ZmZlcn0sdH0oKSxvPXIoMSksbD1yKDYpLHU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyKXt2YXIgaT0odm9pZCAwPT09cj97fTpyKS5yZW1vdmVQS0NTN1BhZGRpbmcsYT12b2lkIDA9PT1pfHxpO2lmKHRoaXMubG9nRW5hYmxlZD0hMCx0aGlzLm9ic2VydmVyPXZvaWQgMCx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy5yZW1vdmVQS0NTN1BhZGRpbmc9dm9pZCAwLHRoaXMuc3VidGxlPW51bGwsdGhpcy5zb2Z0d2FyZURlY3J5cHRlcj1udWxsLHRoaXMua2V5PW51bGwsdGhpcy5mYXN0QWVzS2V5PW51bGwsdGhpcy5yZW1haW5kZXJEYXRhPW51bGwsdGhpcy5jdXJyZW50SVY9bnVsbCx0aGlzLmN1cnJlbnRSZXN1bHQ9bnVsbCx0aGlzLm9ic2VydmVyPXQsdGhpcy5jb25maWc9ZSx0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZz1hLGEpdHJ5e3ZhciBuPXNlbGYuY3J5cHRvO24mJih0aGlzLnN1YnRsZT1uLnN1YnRsZXx8bi53ZWJraXRTdWJ0bGUpfWNhdGNoKHQpe31udWxsPT09dGhpcy5zdWJ0bGUmJih0aGlzLmNvbmZpZy5lbmFibGVTb2Z0d2FyZUFFUz0hMCl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMub2JzZXJ2ZXI9bnVsbH0sZS5pc1N5bmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVN9LGUuZmx1c2g9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmN1cnJlbnRSZXN1bHQ7aWYodCl7dmFyIGUscixpLGE9bmV3IFVpbnQ4QXJyYXkodCk7cmV0dXJuIHRoaXMucmVzZXQoKSx0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZz8oaT0ocj0oZT1hKS5ieXRlTGVuZ3RoKSYmbmV3IERhdGFWaWV3KGUuYnVmZmVyKS5nZXRVaW50OChyLTEpKT9PYmplY3Qobi5hKShlLDAsci1pKTplOmF9dGhpcy5yZXNldCgpfSxlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5jdXJyZW50UmVzdWx0PW51bGwsdGhpcy5jdXJyZW50SVY9bnVsbCx0aGlzLnJlbWFpbmRlckRhdGE9bnVsbCx0aGlzLnNvZnR3YXJlRGVjcnlwdGVyJiYodGhpcy5zb2Z0d2FyZURlY3J5cHRlcj1udWxsKX0sZS5kZWNyeXB0PWZ1bmN0aW9uKHQsZSxyLGkpe2lmKHRoaXMuY29uZmlnLmVuYWJsZVNvZnR3YXJlQUVTKXt0aGlzLnNvZnR3YXJlRGVjcnlwdChuZXcgVWludDhBcnJheSh0KSxlLHIpO3ZhciBhPXRoaXMuZmx1c2goKTthJiZpKGEuYnVmZmVyKX1lbHNlIHRoaXMud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheSh0KSxlLHIpLnRoZW4oaSl9LGUuc29mdHdhcmVEZWNyeXB0PWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT10aGlzLmN1cnJlbnRJVixhPXRoaXMuY3VycmVudFJlc3VsdCxvPXRoaXMucmVtYWluZGVyRGF0YTt0aGlzLmxvZ09uY2UoXCJKUyBBRVMgZGVjcnlwdFwiKSxvJiYodD1PYmplY3QobC5hKShvLHQpLHRoaXMucmVtYWluZGVyRGF0YT1udWxsKTt2YXIgdT10aGlzLmdldFZhbGlkQ2h1bmsodCk7aWYoIXUubGVuZ3RoKXJldHVybiBudWxsO2kmJihyPWkpO3ZhciBkPXRoaXMuc29mdHdhcmVEZWNyeXB0ZXI7ZHx8KGQ9dGhpcy5zb2Z0d2FyZURlY3J5cHRlcj1uZXcgcyksZC5leHBhbmRLZXkoZSk7dmFyIGg9YTtyZXR1cm4gdGhpcy5jdXJyZW50UmVzdWx0PWQuZGVjcnlwdCh1LmJ1ZmZlciwwLHIpLHRoaXMuY3VycmVudElWPU9iamVjdChuLmEpKHUsLTE2KS5idWZmZXIsaHx8bnVsbH0sZS53ZWJDcnlwdG9EZWNyeXB0PWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj10aGlzLHM9dGhpcy5zdWJ0bGU7cmV0dXJuIHRoaXMua2V5PT09ZSYmdGhpcy5mYXN0QWVzS2V5fHwodGhpcy5rZXk9ZSx0aGlzLmZhc3RBZXNLZXk9bmV3IGEocyxlKSksdGhpcy5mYXN0QWVzS2V5LmV4cGFuZEtleSgpLnRoZW4oKGZ1bmN0aW9uKGUpe3JldHVybiBzP25ldyBpKHMscikuZGVjcnlwdCh0LmJ1ZmZlcixlKTpQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZFwiKSl9KSkuY2F0Y2goKGZ1bmN0aW9uKGkpe3JldHVybiBuLm9uV2ViQ3J5cHRvRXJyb3IoaSx0LGUscil9KSl9LGUub25XZWJDcnlwdG9FcnJvcj1mdW5jdGlvbih0LGUscixpKXtyZXR1cm4gby5iLndhcm4oXCJbZGVjcnlwdGVyLnRzXTogV2ViQ3J5cHRvIEVycm9yLCBkaXNhYmxlIFdlYkNyeXB0byBBUEk6XCIsdCksdGhpcy5jb25maWcuZW5hYmxlU29mdHdhcmVBRVM9ITAsdGhpcy5sb2dFbmFibGVkPSEwLHRoaXMuc29mdHdhcmVEZWNyeXB0KGUscixpKX0sZS5nZXRWYWxpZENodW5rPWZ1bmN0aW9uKHQpe3ZhciBlPXQscj10Lmxlbmd0aC10Lmxlbmd0aCUxNjtyZXR1cm4gciE9PXQubGVuZ3RoJiYoZT1PYmplY3Qobi5hKSh0LDAsciksdGhpcy5yZW1haW5kZXJEYXRhPU9iamVjdChuLmEpKHQscikpLGV9LGUubG9nT25jZT1mdW5jdGlvbih0KXt0aGlzLmxvZ0VuYWJsZWQmJihvLmIubG9nKFwiW2RlY3J5cHRlci50c106IFwiK3QpLHRoaXMubG9nRW5hYmxlZD0hMSl9LHR9KCl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gbn0pKTt2YXIgaT1yKDExKTtmdW5jdGlvbiBhKHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBpPWVbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX12YXIgbj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt0aGlzLl91cmk9bnVsbCx0aGlzLm1ldGhvZD1udWxsLHRoaXMua2V5Rm9ybWF0PW51bGwsdGhpcy5rZXlGb3JtYXRWZXJzaW9ucz1udWxsLHRoaXMua2V5SUQ9bnVsbCx0aGlzLmtleT1udWxsLHRoaXMuaXY9bnVsbCx0aGlzLl91cmk9ZT9PYmplY3QoaS5idWlsZEFic29sdXRlVVJMKSh0LGUse2Fsd2F5c05vcm1hbGl6ZTohMH0pOnR9dmFyIGUscjtyZXR1cm4gdC5mcm9tVVJMPWZ1bmN0aW9uKGUscil7cmV0dXJuIG5ldyB0KGUscil9LHQuZnJvbVVSST1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQoZSl9LGU9dCwocj1be2tleTpcInVyaVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91cml9fV0pJiZhKGUucHJvdG90eXBlLHIpLHR9KCl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmQoZSxcImFcIiwoZnVuY3Rpb24oKXtyZXR1cm4gaX0pKTt2YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt0aGlzLmNodW5rcz1bXSx0aGlzLmRhdGFMZW5ndGg9MH12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5wdXNoPWZ1bmN0aW9uKHQpe3RoaXMuY2h1bmtzLnB1c2godCksdGhpcy5kYXRhTGVuZ3RoKz10Lmxlbmd0aH0sZS5mbHVzaD1mdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5jaHVua3Mscj10aGlzLmRhdGFMZW5ndGg7cmV0dXJuIGUubGVuZ3RoPyh0PTE9PT1lLmxlbmd0aD9lWzBdOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPW5ldyBVaW50OEFycmF5KGUpLGk9MCxhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBuPXRbYV07ci5zZXQobixpKSxpKz1uLmxlbmd0aH1yZXR1cm4gcn0oZSxyKSx0aGlzLnJlc2V0KCksdCk6bmV3IFVpbnQ4QXJyYXkoMCl9LGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmNodW5rcy5sZW5ndGg9MCx0aGlzLmRhdGFMZW5ndGg9MH0sdH0oKX0sZnVuY3Rpb24odCxlLHIpe2Z1bmN0aW9uIGkodCl7dmFyIGU9e307ZnVuY3Rpb24gcihpKXtpZihlW2ldKXJldHVybiBlW2ldLmV4cG9ydHM7dmFyIGE9ZVtpXT17aSxsOiExLGV4cG9ydHM6e319O3JldHVybiB0W2ldLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLHIpLGEubD0hMCxhLmV4cG9ydHN9ci5tPXQsci5jPWUsci5pPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxyLmQ9ZnVuY3Rpb24odCxlLGkpe3Iubyh0LGUpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6aX0pfSxyLnI9ZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIubj1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gci5kKGUsXCJhXCIsZSksZX0sci5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxyLnA9XCIvXCIsci5vZT1mdW5jdGlvbih0KXt0aHJvdyBjb25zb2xlLmVycm9yKHQpLHR9O3ZhciBpPXIoci5zPUVOVFJZX01PRFVMRSk7cmV0dXJuIGkuZGVmYXVsdHx8aX1mdW5jdGlvbiBhKHQpe3JldHVybih0K1wiXCIpLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZyxcIlxcXFwkJlwiKX1mdW5jdGlvbiBuKHQsZSxpKXt2YXIgbj17fTtuW2ldPVtdO3ZhciBzPWUudG9TdHJpbmcoKSxvPXMubWF0Y2goL15mdW5jdGlvblxccz9cXHcqXFwoXFx3KyxcXHMqXFx3KyxcXHMqKFxcdyspXFwpLyk7aWYoIW8pcmV0dXJuIG47Zm9yKHZhciBsLHU9b1sxXSxkPW5ldyBSZWdFeHAoXCIoXFxcXFxcXFxufFxcXFxXKVwiK2EodSkrXCJcXFxcKFxcXFxzKigvXFxcXCouKj9cXFxcKi8pP1xcXFxzKi4qPyhbXFxcXC58XFxcXC18XFxcXCt8XFxcXHd8L3xAXSspLio/XFxcXClcIixcImdcIik7bD1kLmV4ZWMocyk7KVwiZGxsLXJlZmVyZW5jZVwiIT09bFszXSYmbltpXS5wdXNoKGxbM10pO2ZvcihkPW5ldyBSZWdFeHAoXCJcXFxcKFwiK2EodSkrJ1xcXFwoXCIoZGxsLXJlZmVyZW5jZVxcXFxzKFtcXFxcLnxcXFxcLXxcXFxcK3xcXFxcd3wvfEBdKykpXCJcXFxcKVxcXFwpXFxcXChcXFxccyooL1xcXFwqLio/XFxcXCovKT9cXFxccyouKj8oW1xcXFwufFxcXFwtfFxcXFwrfFxcXFx3fC98QF0rKS4qP1xcXFwpJyxcImdcIik7bD1kLmV4ZWMocyk7KXRbbFsyXV18fChuW2ldLnB1c2gobFsxXSksdFtsWzJdXT1yKGxbMV0pLm0pLG5bbFsyXV09bltsWzJdXXx8W10sbltsWzJdXS5wdXNoKGxbNF0pO2Zvcih2YXIgaCxmPU9iamVjdC5rZXlzKG4pLGM9MDtjPGYubGVuZ3RoO2MrKylmb3IodmFyIHY9MDt2PG5bZltjXV0ubGVuZ3RoO3YrKyloPW5bZltjXV1bdl0saXNOYU4oMSpoKXx8KG5bZltjXV1bdl09MSpuW2ZbY11dW3ZdKTtyZXR1cm4gbn1mdW5jdGlvbiBzKHQpe3JldHVybiBPYmplY3Qua2V5cyh0KS5yZWR1Y2UoKGZ1bmN0aW9uKGUscil7cmV0dXJuIGV8fHRbcl0ubGVuZ3RoPjB9KSwhMSl9dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7ZT1lfHx7fTt2YXIgYT17bWFpbjpyLm19LG89ZS5hbGw/e21haW46T2JqZWN0LmtleXMoYS5tYWluKX06ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9e21haW46W2VdfSxpPXttYWluOltdfSxhPXttYWluOnt9fTtzKHIpOylmb3IodmFyIG89T2JqZWN0LmtleXMociksbD0wO2w8by5sZW5ndGg7bCsrKXt2YXIgdT1vW2xdLGQ9clt1XS5wb3AoKTtpZihhW3VdPWFbdV18fHt9LCFhW3VdW2RdJiZ0W3VdW2RdKXthW3VdW2RdPSEwLGlbdV09aVt1XXx8W10saVt1XS5wdXNoKGQpO2Zvcih2YXIgaD1uKHQsdFt1XVtkXSx1KSxmPU9iamVjdC5rZXlzKGgpLGM9MDtjPGYubGVuZ3RoO2MrKylyW2ZbY11dPXJbZltjXV18fFtdLHJbZltjXV09cltmW2NdXS5jb25jYXQoaFtmW2NdXSl9fXJldHVybiBpfShhLHQpLGw9XCJcIjtPYmplY3Qua2V5cyhvKS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVyblwibWFpblwiIT09dH0pKS5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtvW3RdW2VdOyllKys7b1t0XS5wdXNoKGUpLGFbdF1bZV09XCIoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7IG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXzsgfSlcIixsPWwrXCJ2YXIgXCIrdCtcIiA9IChcIitpLnRvU3RyaW5nKCkucmVwbGFjZShcIkVOVFJZX01PRFVMRVwiLEpTT04uc3RyaW5naWZ5KGUpKStcIikoe1wiK29bdF0ubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSkrXCI6IFwiK2FbdF1bZV0udG9TdHJpbmcoKX0pKS5qb2luKFwiLFwiKStcIn0pO1xcblwifSkpLGw9bCtcIm5ldyAoKFwiK2kudG9TdHJpbmcoKS5yZXBsYWNlKFwiRU5UUllfTU9EVUxFXCIsSlNPTi5zdHJpbmdpZnkodCkpK1wiKSh7XCIrby5tYWluLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHQpK1wiOiBcIithLm1haW5bdF0udG9TdHJpbmcoKX0pKS5qb2luKFwiLFwiKStcIn0pKShzZWxmKTtcIjt2YXIgdT1uZXcgd2luZG93LkJsb2IoW2xdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KTtpZihlLmJhcmUpcmV0dXJuIHU7dmFyIGQ9KHdpbmRvdy5VUkx8fHdpbmRvdy53ZWJraXRVUkx8fHdpbmRvdy5tb3pVUkx8fHdpbmRvdy5tc1VSTCkuY3JlYXRlT2JqZWN0VVJMKHUpLGg9bmV3IHdpbmRvdy5Xb3JrZXIoZCk7cmV0dXJuIGgub2JqZWN0VVJMPWQsaH19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLnIoZSksci5kKGUsXCJkZWZhdWx0XCIsKGZ1bmN0aW9uKCl7cmV0dXJuIG99KSk7dmFyIGk9cig5KSxhPXIoMCksbj1yKDEpLHM9cigxMyk7ZnVuY3Rpb24gbyh0KXt2YXIgZT1uZXcgcy5FdmVudEVtaXR0ZXIscj1mdW5jdGlvbihlLHIpe3QucG9zdE1lc3NhZ2Uoe2V2ZW50OmUsZGF0YTpyfSl9O2Uub24oYS5hLkZSQUdfREVDUllQVEVELHIpLGUub24oYS5hLkVSUk9SLHIpLHQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24oYSl7dmFyIHM9YS5kYXRhO3N3aXRjaChzLmNtZCl7Y2FzZVwiaW5pdFwiOnZhciBvPUpTT04ucGFyc2Uocy5jb25maWcpO3QudHJhbnNtdXhlcj1uZXcgaS5jKGUscy50eXBlU3VwcG9ydGVkLG8scy52ZW5kb3Iscy5pZCksT2JqZWN0KG4uYSkoby5kZWJ1ZykscihcImluaXRcIixudWxsKTticmVhaztjYXNlXCJjb25maWd1cmVcIjp0LnRyYW5zbXV4ZXIuY29uZmlndXJlKHMuY29uZmlnKTticmVhaztjYXNlXCJkZW11eFwiOnZhciB1PXQudHJhbnNtdXhlci5wdXNoKHMuZGF0YSxzLmRlY3J5cHRkYXRhLHMuY2h1bmtNZXRhLHMuc3RhdGUpO09iamVjdChpLmQpKHUpP3UudGhlbigoZnVuY3Rpb24oZSl7bCh0LGUpfSkpOmwodCx1KTticmVhaztjYXNlXCJmbHVzaFwiOnZhciBoPXMuY2h1bmtNZXRhLGY9dC50cmFuc211eGVyLmZsdXNoKGgpO09iamVjdChpLmQpKGYpP2YudGhlbigoZnVuY3Rpb24oZSl7ZCh0LGUsaCl9KSk6ZCh0LGYsaCl9fSkpfWZ1bmN0aW9uIGwodCxlKXtpZigocj1lLnJlbXV4UmVzdWx0KS5hdWRpb3x8ci52aWRlb3x8ci50ZXh0fHxyLmlkM3x8ci5pbml0U2VnbWVudCl7dmFyIHIsaT1bXSxhPWUucmVtdXhSZXN1bHQsbj1hLmF1ZGlvLHM9YS52aWRlbztuJiZ1KGksbikscyYmdShpLHMpLHQucG9zdE1lc3NhZ2Uoe2V2ZW50OlwidHJhbnNtdXhDb21wbGV0ZVwiLGRhdGE6ZX0saSl9fWZ1bmN0aW9uIHUodCxlKXtlLmRhdGExJiZ0LnB1c2goZS5kYXRhMS5idWZmZXIpLGUuZGF0YTImJnQucHVzaChlLmRhdGEyLmJ1ZmZlcil9ZnVuY3Rpb24gZCh0LGUscil7ZS5mb3JFYWNoKChmdW5jdGlvbihlKXtsKHQsZSl9KSksdC5wb3N0TWVzc2FnZSh7ZXZlbnQ6XCJmbHVzaFwiLGRhdGE6cn0pfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IucihlKSxyLmQoZSxcImRlZmF1bHRcIiwoZnVuY3Rpb24oKXtyZXR1cm4geGV9KSk7dmFyIGk9cigxMSksYT1yKDMpLG49cigwKSxzPXIoMiksbz1yKDEpLGw9cig2KSx1PXIoNSk7ZnVuY3Rpb24gZCh0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgaT1lW3JdO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19dmFyIGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuUFRTS25vd249ITEsdGhpcy5hbGlnbmVkU2xpZGluZz0hMSx0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbj12b2lkIDAsdGhpcy5lbmRDQz0wLHRoaXMuZW5kU049MCx0aGlzLmZyYWdtZW50cz12b2lkIDAsdGhpcy5mcmFnbWVudEhpbnQ9dm9pZCAwLHRoaXMucGFydExpc3Q9bnVsbCx0aGlzLmxpdmU9ITAsdGhpcy5hZ2VIZWFkZXI9MCx0aGlzLmFkdmFuY2VkRGF0ZVRpbWU9dm9pZCAwLHRoaXMudXBkYXRlZD0hMCx0aGlzLmFkdmFuY2VkPSEwLHRoaXMuYXZhaWxhYmlsaXR5RGVsYXk9dm9pZCAwLHRoaXMubWlzc2VzPTAsdGhpcy5uZWVkU2lkeFJhbmdlcz0hMSx0aGlzLnN0YXJ0Q0M9MCx0aGlzLnN0YXJ0U049MCx0aGlzLnN0YXJ0VGltZU9mZnNldD1udWxsLHRoaXMudGFyZ2V0ZHVyYXRpb249MCx0aGlzLnRvdGFsZHVyYXRpb249MCx0aGlzLnR5cGU9bnVsbCx0aGlzLnVybD12b2lkIDAsdGhpcy5tM3U4PVwiXCIsdGhpcy52ZXJzaW9uPW51bGwsdGhpcy5jYW5CbG9ja1JlbG9hZD0hMSx0aGlzLmNhblNraXBVbnRpbD0wLHRoaXMuY2FuU2tpcERhdGVSYW5nZXM9ITEsdGhpcy5za2lwcGVkU2VnbWVudHM9MCx0aGlzLnJlY2VudGx5UmVtb3ZlZERhdGVyYW5nZXM9dm9pZCAwLHRoaXMucGFydEhvbGRCYWNrPTAsdGhpcy5ob2xkQmFjaz0wLHRoaXMucGFydFRhcmdldD0wLHRoaXMucHJlbG9hZEhpbnQ9dm9pZCAwLHRoaXMucmVuZGl0aW9uUmVwb3J0cz12b2lkIDAsdGhpcy50dW5lSW5Hb2FsPTAsdGhpcy5kZWx0YVVwZGF0ZUZhaWxlZD12b2lkIDAsdGhpcy5kcmlmdFN0YXJ0VGltZT0wLHRoaXMuZHJpZnRFbmRUaW1lPTAsdGhpcy5kcmlmdFN0YXJ0PTAsdGhpcy5kcmlmdEVuZD0wLHRoaXMuZnJhZ21lbnRzPVtdLHRoaXMudXJsPXR9dmFyIGUscjtyZXR1cm4gdC5wcm90b3R5cGUucmVsb2FkZWQ9ZnVuY3Rpb24odCl7aWYoIXQpcmV0dXJuIHRoaXMuYWR2YW5jZWQ9ITAsdm9pZCh0aGlzLnVwZGF0ZWQ9ITApO3ZhciBlPXRoaXMubGFzdFBhcnRTbi10Lmxhc3RQYXJ0U24scj10aGlzLmxhc3RQYXJ0SW5kZXgtdC5sYXN0UGFydEluZGV4O3RoaXMudXBkYXRlZD10aGlzLmVuZFNOIT09dC5lbmRTTnx8ISFyfHwhIWUsdGhpcy5hZHZhbmNlZD10aGlzLmVuZFNOPnQuZW5kU058fGU+MHx8MD09PWUmJnI+MCx0aGlzLnVwZGF0ZWR8fHRoaXMuYWR2YW5jZWQ/dGhpcy5taXNzZXM9TWF0aC5mbG9vciguNip0Lm1pc3Nlcyk6dGhpcy5taXNzZXM9dC5taXNzZXMrMSx0aGlzLmF2YWlsYWJpbGl0eURlbGF5PXQuYXZhaWxhYmlsaXR5RGVsYXl9LGU9dCwocj1be2tleTpcImhhc1Byb2dyYW1EYXRlVGltZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiEhdGhpcy5mcmFnbWVudHMubGVuZ3RoJiZPYmplY3QoYS5hKSh0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGgtMV0ucHJvZ3JhbURhdGVUaW1lKX19LHtrZXk6XCJsZXZlbFRhcmdldER1cmF0aW9uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXZlcmFnZXRhcmdldGR1cmF0aW9ufHx0aGlzLnRhcmdldGR1cmF0aW9ufHwxMH19LHtrZXk6XCJkcmlmdFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZHJpZnRFbmRUaW1lLXRoaXMuZHJpZnRTdGFydFRpbWU7cmV0dXJuIHQ+MD8xZTMqKHRoaXMuZHJpZnRFbmQtdGhpcy5kcmlmdFN0YXJ0KS90OjF9fSx7a2V5OlwiZWRnZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnRFbmR8fHRoaXMuZnJhZ21lbnRFbmR9fSx7a2V5OlwicGFydEVuZFwiLGdldDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsIT09KHQ9dGhpcy5wYXJ0TGlzdCkmJnZvaWQgMCE9PXQmJnQubGVuZ3RoP3RoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGgtMV0uZW5kOnRoaXMuZnJhZ21lbnRFbmR9fSx7a2V5OlwiZnJhZ21lbnRFbmRcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gbnVsbCE9PSh0PXRoaXMuZnJhZ21lbnRzKSYmdm9pZCAwIT09dCYmdC5sZW5ndGg/dGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoLTFdLmVuZDowfX0se2tleTpcImFnZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFkdmFuY2VkRGF0ZVRpbWU/TWF0aC5tYXgoRGF0ZS5ub3coKS10aGlzLmFkdmFuY2VkRGF0ZVRpbWUsMCkvMWUzOjB9fSx7a2V5OlwibGFzdFBhcnRJbmRleFwiLGdldDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsIT09KHQ9dGhpcy5wYXJ0TGlzdCkmJnZvaWQgMCE9PXQmJnQubGVuZ3RoP3RoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGgtMV0uaW5kZXg6LTF9fSx7a2V5OlwibGFzdFBhcnRTblwiLGdldDpmdW5jdGlvbigpe3ZhciB0O3JldHVybiBudWxsIT09KHQ9dGhpcy5wYXJ0TGlzdCkmJnZvaWQgMCE9PXQmJnQubGVuZ3RoP3RoaXMucGFydExpc3RbdGhpcy5wYXJ0TGlzdC5sZW5ndGgtMV0uZnJhZ21lbnQuc246dGhpcy5lbmRTTn19XSkmJmQoZS5wcm90b3R5cGUsciksdH0oKSxmPXIoMTUpLGM9L14oXFxkKyl4KFxcZCspJC8sdj0vXFxzKiguKz8pXFxzKj0oKD86XFxcIi4qP1xcXCIpfC4qPykoPzosfCQpL2csZz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSl7Zm9yKHZhciByIGluXCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPXQucGFyc2VBdHRyTGlzdChlKSksZSllLmhhc093blByb3BlcnR5KHIpJiYodGhpc1tyXT1lW3JdKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5kZWNpbWFsSW50ZWdlcj1mdW5jdGlvbih0KXt2YXIgZT1wYXJzZUludCh0aGlzW3RdLDEwKTtyZXR1cm4gZT5OdW1iZXIuTUFYX1NBRkVfSU5URUdFUj8xLzA6ZX0sZS5oZXhhZGVjaW1hbEludGVnZXI9ZnVuY3Rpb24odCl7aWYodGhpc1t0XSl7dmFyIGU9KHRoaXNbdF18fFwiMHhcIikuc2xpY2UoMik7ZT0oMSZlLmxlbmd0aD9cIjBcIjpcIlwiKStlO2Zvcih2YXIgcj1uZXcgVWludDhBcnJheShlLmxlbmd0aC8yKSxpPTA7aTxlLmxlbmd0aC8yO2krKylyW2ldPXBhcnNlSW50KGUuc2xpY2UoMippLDIqaSsyKSwxNik7cmV0dXJuIHJ9cmV0dXJuIG51bGx9LGUuaGV4YWRlY2ltYWxJbnRlZ2VyQXNOdW1iZXI9ZnVuY3Rpb24odCl7dmFyIGU9cGFyc2VJbnQodGhpc1t0XSwxNik7cmV0dXJuIGU+TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI/MS8wOmV9LGUuZGVjaW1hbEZsb2F0aW5nUG9pbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHBhcnNlRmxvYXQodGhpc1t0XSl9LGUub3B0aW9uYWxGbG9hdD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXNbdF07cmV0dXJuIHI/cGFyc2VGbG9hdChyKTplfSxlLmVudW1lcmF0ZWRTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXNbdF19LGUuYm9vbD1mdW5jdGlvbih0KXtyZXR1cm5cIllFU1wiPT09dGhpc1t0XX0sZS5kZWNpbWFsUmVzb2x1dGlvbj1mdW5jdGlvbih0KXt2YXIgZT1jLmV4ZWModGhpc1t0XSk7aWYobnVsbCE9PWUpcmV0dXJue3dpZHRoOnBhcnNlSW50KGVbMV0sMTApLGhlaWdodDpwYXJzZUludChlWzJdLDEwKX19LHQucGFyc2VBdHRyTGlzdD1mdW5jdGlvbih0KXt2YXIgZSxyPXt9O2Zvcih2Lmxhc3RJbmRleD0wO251bGwhPT0oZT12LmV4ZWModCkpOyl7dmFyIGk9ZVsyXTswPT09aS5pbmRleE9mKCdcIicpJiZpLmxhc3RJbmRleE9mKCdcIicpPT09aS5sZW5ndGgtMSYmKGk9aS5zbGljZSgxLC0xKSkscltlWzFdXT1pfXJldHVybiByfSx0fSgpLHA9e2F1ZGlvOnthM2RzOiEwLFwiYWMtM1wiOiEwLFwiYWMtNFwiOiEwLGFsYWM6ITAsYWxhdzohMCxkcmExOiEwLFwiZHRzK1wiOiEwLFwiZHRzLVwiOiEwLGR0c2M6ITAsZHRzZTohMCxkdHNoOiEwLFwiZWMtM1wiOiEwLGVuY2E6ITAsZzcxOTohMCxnNzI2OiEwLG00YWU6ITAsbWhhMTohMCxtaGEyOiEwLG1obTE6ITAsbWhtMjohMCxtbHBhOiEwLG1wNGE6ITAsXCJyYXcgXCI6ITAsT3B1czohMCxzYW1yOiEwLHNhd2I6ITAsc2F3cDohMCxzZXZjOiEwLHNxY3A6ITAsc3NtdjohMCx0d29zOiEwLHVsYXc6ITB9LHZpZGVvOnthdmMxOiEwLGF2YzI6ITAsYXZjMzohMCxhdmM0OiEwLGF2Y3A6ITAsYXYwMTohMCxkcmFjOiEwLGR2YXY6ITAsZHZoZTohMCxlbmN2OiEwLGhldjE6ITAsaHZjMTohMCxtanAyOiEwLG1wNHY6ITAsbXZjMTohMCxtdmMyOiEwLG12YzM6ITAsbXZjNDohMCxyZXN2OiEwLHJ2NjA6ITAsczI2MzohMCxzdmMxOiEwLHN2YzI6ITAsXCJ2Yy0xXCI6ITAsdnAwODohMCx2cDA5OiEwfSx0ZXh0OntzdHBwOiEwLHd2dHQ6ITB9fTtmdW5jdGlvbiBtKHQsZSl7cmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZCgoZXx8XCJ2aWRlb1wiKSsnL21wNDtjb2RlY3M9XCInK3QrJ1wiJyl9dmFyIHk9LyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcclxcbl0qKSg/OltcXHJcXG5dKD86I1teXFxyXFxuXSopPykqKFteXFxyXFxuXSspfCNFWFQtWC1TRVNTSU9OLURBVEE6KFteXFxyXFxuXSopW1xcclxcbl0rL2csYj0vI0VYVC1YLU1FRElBOiguKikvZyxUPW5ldyBSZWdFeHAoWy8jRVhUSU5GOlxccyooXFxkKig/OlxcLlxcZCspPykoPzosKC4qKVxccyspPy8uc291cmNlLC8oPyEjKSAqKFxcU1tcXFMgXSopLy5zb3VyY2UsLyNFWFQtWC1CWVRFUkFOR0U6KiguKykvLnNvdXJjZSwvI0VYVC1YLVBST0dSQU0tREFURS1USU1FOiguKykvLnNvdXJjZSwvIy4qLy5zb3VyY2VdLmpvaW4oXCJ8XCIpLFwiZ1wiKSxFPW5ldyBSZWdFeHAoWy8jKEVYVE0zVSkvLnNvdXJjZSwvI0VYVC1YLShQTEFZTElTVC1UWVBFKTooLispLy5zb3VyY2UsLyNFWFQtWC0oTUVESUEtU0VRVUVOQ0UpOiAqKFxcZCspLy5zb3VyY2UsLyNFWFQtWC0oU0tJUCk6KC4rKS8uc291cmNlLC8jRVhULVgtKFRBUkdFVERVUkFUSU9OKTogKihcXGQrKS8uc291cmNlLC8jRVhULVgtKEtFWSk6KC4rKS8uc291cmNlLC8jRVhULVgtKFNUQVJUKTooLispLy5zb3VyY2UsLyNFWFQtWC0oRU5ETElTVCkvLnNvdXJjZSwvI0VYVC1YLShESVNDT05USU5VSVRZLVNFUSlVRU5DRTogKihcXGQrKS8uc291cmNlLC8jRVhULVgtKERJUylDT05USU5VSVRZLy5zb3VyY2UsLyNFWFQtWC0oVkVSU0lPTik6KFxcZCspLy5zb3VyY2UsLyNFWFQtWC0oTUFQKTooLispLy5zb3VyY2UsLyNFWFQtWC0oU0VSVkVSLUNPTlRST0wpOiguKykvLnNvdXJjZSwvI0VYVC1YLShQQVJULUlORik6KC4rKS8uc291cmNlLC8jRVhULVgtKEdBUCkvLnNvdXJjZSwvI0VYVC1YLShCSVRSQVRFKTpcXHMqKFxcZCspLy5zb3VyY2UsLyNFWFQtWC0oUEFSVCk6KC4rKS8uc291cmNlLC8jRVhULVgtKFBSRUxPQUQtSElOVCk6KC4rKS8uc291cmNlLC8jRVhULVgtKFJFTkRJVElPTi1SRVBPUlQpOiguKykvLnNvdXJjZSwvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsLygjKSguKikoPzouKilcXHI/XFxuPy8uc291cmNlXS5qb2luKFwifFwiKSksUz0vXFwuKG1wNHxtNHN8bTR2fG00YSkkL2ksTD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIHQuZmluZEdyb3VwPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBpPXRbcl07aWYoaS5pZD09PWUpcmV0dXJuIGl9fSx0LmNvbnZlcnRBVkMxVG9BVkNPVEk9ZnVuY3Rpb24odCl7dmFyIGU9dC5zcGxpdChcIi5cIik7aWYoZS5sZW5ndGg+Mil7dmFyIHI9ZS5zaGlmdCgpK1wiLlwiO3JldHVybihyKz1wYXJzZUludChlLnNoaWZ0KCkpLnRvU3RyaW5nKDE2KSkrKFwiMDAwXCIrcGFyc2VJbnQoZS5zaGlmdCgpKS50b1N0cmluZygxNikpLnN1YnN0cigtNCl9cmV0dXJuIHR9LHQucmVzb2x2ZT1mdW5jdGlvbih0LGUpe3JldHVybiBpLmJ1aWxkQWJzb2x1dGVVUkwoZSx0LHthbHdheXNOb3JtYWxpemU6ITB9KX0sdC5wYXJzZU1hc3RlclBsYXlsaXN0PWZ1bmN0aW9uKGUscil7dmFyIGksYT1bXSxuPXt9LHM9ITE7Zm9yKHkubGFzdEluZGV4PTA7bnVsbCE9KGk9eS5leGVjKGUpKTspaWYoaVsxXSl7dmFyIG89bmV3IGcoaVsxXSksbD17YXR0cnM6byxiaXRyYXRlOm8uZGVjaW1hbEludGVnZXIoXCJBVkVSQUdFLUJBTkRXSURUSFwiKXx8by5kZWNpbWFsSW50ZWdlcihcIkJBTkRXSURUSFwiKSxuYW1lOm8uTkFNRSx1cmw6dC5yZXNvbHZlKGlbMl0scil9LHU9by5kZWNpbWFsUmVzb2x1dGlvbihcIlJFU09MVVRJT05cIik7dSYmKGwud2lkdGg9dS53aWR0aCxsLmhlaWdodD11LmhlaWdodCksQSgoby5DT0RFQ1N8fFwiXCIpLnNwbGl0KC9bICxdKy8pLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSksbCksbC52aWRlb0NvZGVjJiYtMSE9PWwudmlkZW9Db2RlYy5pbmRleE9mKFwiYXZjMVwiKSYmKGwudmlkZW9Db2RlYz10LmNvbnZlcnRBVkMxVG9BVkNPVEkobC52aWRlb0NvZGVjKSksYS5wdXNoKGwpfWVsc2UgaWYoaVszXSl7dmFyIGQ9bmV3IGcoaVszXSk7ZFtcIkRBVEEtSURcIl0mJihzPSEwLG5bZFtcIkRBVEEtSURcIl1dPWQpfXJldHVybntsZXZlbHM6YSxzZXNzaW9uRGF0YTpzP246bnVsbH19LHQucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhPWZ1bmN0aW9uKGUscixpLGEpe3ZhciBuO3ZvaWQgMD09PWEmJihhPVtdKTt2YXIgcz1bXSxvPTA7Zm9yKGIubGFzdEluZGV4PTA7bnVsbCE9PShuPWIuZXhlYyhlKSk7KXt2YXIgbD1uZXcgZyhuWzFdKTtpZihsLlRZUEU9PT1pKXt2YXIgdT17YXR0cnM6bCxiaXRyYXRlOjAsaWQ6bysrLGdyb3VwSWQ6bFtcIkdST1VQLUlEXCJdLGluc3RyZWFtSWQ6bFtcIklOU1RSRUFNLUlEXCJdLG5hbWU6bC5OQU1FfHxsLkxBTkdVQUdFfHxcIlwiLHR5cGU6aSxkZWZhdWx0OmwuYm9vbChcIkRFRkFVTFRcIiksYXV0b3NlbGVjdDpsLmJvb2woXCJBVVRPU0VMRUNUXCIpLGZvcmNlZDpsLmJvb2woXCJGT1JDRURcIiksbGFuZzpsLkxBTkdVQUdFLHVybDpsLlVSST90LnJlc29sdmUobC5VUkkscik6XCJcIn07aWYoYS5sZW5ndGgpe3ZhciBkPXQuZmluZEdyb3VwKGEsdS5ncm91cElkKXx8YVswXTtSKHUsZCxcImF1ZGlvQ29kZWNcIiksUih1LGQsXCJ0ZXh0Q29kZWNcIil9cy5wdXNoKHUpfX1yZXR1cm4gc30sdC5wYXJzZUxldmVsUGxheWxpc3Q9ZnVuY3Rpb24odCxlLHIsbixzKXt2YXIgbCxkLGMsdj1uZXcgaChlKSxwPXYuZnJhZ21lbnRzLG09bnVsbCx5PTAsYj0wLEw9MCxBPTAsUj1udWxsLF89bmV3IHUuYihuLGUpLGs9LTEseD0hMTtmb3IoVC5sYXN0SW5kZXg9MCx2Lm0zdTg9dDtudWxsIT09KGw9VC5leGVjKHQpKTspe3gmJih4PSExLChfPW5ldyB1LmIobixlKSkuc3RhcnQ9TCxfLnNuPXksXy5jYz1BLF8ubGV2ZWw9cixtJiYoXy5pbml0U2VnbWVudD1tLF8ucmF3UHJvZ3JhbURhdGVUaW1lPW0ucmF3UHJvZ3JhbURhdGVUaW1lKSk7dmFyIHc9bFsxXTtpZih3KXtfLmR1cmF0aW9uPXBhcnNlRmxvYXQodyk7dmFyIEM9KFwiIFwiK2xbMl0pLnNsaWNlKDEpO18udGl0bGU9Q3x8bnVsbCxfLnRhZ0xpc3QucHVzaChDP1tcIklORlwiLHcsQ106W1wiSU5GXCIsd10pfWVsc2UgaWYobFszXSlPYmplY3QoYS5hKShfLmR1cmF0aW9uKSYmKF8uc3RhcnQ9TCxjJiYoXy5sZXZlbGtleT1jKSxfLnNuPXksXy5sZXZlbD1yLF8uY2M9QSxfLnVybElkPXMscC5wdXNoKF8pLF8ucmVsdXJsPShcIiBcIitsWzNdKS5zbGljZSgxKSxEKF8sUiksUj1fLEwrPV8uZHVyYXRpb24seSsrLGI9MCx4PSEwKTtlbHNlIGlmKGxbNF0pe3ZhciBPPShcIiBcIitsWzRdKS5zbGljZSgxKTtSP18uc2V0Qnl0ZVJhbmdlKE8sUik6Xy5zZXRCeXRlUmFuZ2UoTyl9ZWxzZSBpZihsWzVdKV8ucmF3UHJvZ3JhbURhdGVUaW1lPShcIiBcIitsWzVdKS5zbGljZSgxKSxfLnRhZ0xpc3QucHVzaChbXCJQUk9HUkFNLURBVEUtVElNRVwiLF8ucmF3UHJvZ3JhbURhdGVUaW1lXSksLTE9PT1rJiYoaz1wLmxlbmd0aCk7ZWxzZXtpZighKGw9bFswXS5tYXRjaChFKSkpe28uYi53YXJuKFwiTm8gbWF0Y2hlcyBvbiBzbG93IHJlZ2V4IG1hdGNoIGZvciBsZXZlbCBwbGF5bGlzdCFcIik7Y29udGludWV9Zm9yKGQ9MTtkPGwubGVuZ3RoJiZ2b2lkIDA9PT1sW2RdO2QrKyk7dmFyIEk9KFwiIFwiK2xbZF0pLnNsaWNlKDEpLFA9KFwiIFwiK2xbZCsxXSkuc2xpY2UoMSksRj1sW2QrMl0/KFwiIFwiK2xbZCsyXSkuc2xpY2UoMSk6XCJcIjtzd2l0Y2goSSl7Y2FzZVwiUExBWUxJU1QtVFlQRVwiOnYudHlwZT1QLnRvVXBwZXJDYXNlKCk7YnJlYWs7Y2FzZVwiTUVESUEtU0VRVUVOQ0VcIjp5PXYuc3RhcnRTTj1wYXJzZUludChQKTticmVhaztjYXNlXCJTS0lQXCI6dmFyIE09bmV3IGcoUCksTj1NLmRlY2ltYWxJbnRlZ2VyKFwiU0tJUFBFRC1TRUdNRU5UU1wiKTtpZihPYmplY3QoYS5hKShOKSl7di5za2lwcGVkU2VnbWVudHM9Tjtmb3IodmFyIEI9TjtCLS07KXAudW5zaGlmdChudWxsKTt5Kz1OfXZhciBVPU0uZW51bWVyYXRlZFN0cmluZyhcIlJFQ0VOVExZLVJFTU9WRUQtREFURVJBTkdFU1wiKTtVJiYodi5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzPVUuc3BsaXQoXCJcXHRcIikpO2JyZWFrO2Nhc2VcIlRBUkdFVERVUkFUSU9OXCI6di50YXJnZXRkdXJhdGlvbj1wYXJzZUZsb2F0KFApO2JyZWFrO2Nhc2VcIlZFUlNJT05cIjp2LnZlcnNpb249cGFyc2VJbnQoUCk7YnJlYWs7Y2FzZVwiRVhUTTNVXCI6YnJlYWs7Y2FzZVwiRU5ETElTVFwiOnYubGl2ZT0hMTticmVhaztjYXNlXCIjXCI6KFB8fEYpJiZfLnRhZ0xpc3QucHVzaChGP1tQLEZdOltQXSk7YnJlYWs7Y2FzZVwiRElTXCI6QSsrO2Nhc2VcIkdBUFwiOl8udGFnTGlzdC5wdXNoKFtJXSk7YnJlYWs7Y2FzZVwiQklUUkFURVwiOl8udGFnTGlzdC5wdXNoKFtJLFBdKTticmVhaztjYXNlXCJESVNDT05USU5VSVRZLVNFUVwiOkE9cGFyc2VJbnQoUCk7YnJlYWs7Y2FzZVwiS0VZXCI6dmFyIEcsaj1uZXcgZyhQKSxIPWouZW51bWVyYXRlZFN0cmluZyhcIk1FVEhPRFwiKSxLPWouVVJJLFY9ai5oZXhhZGVjaW1hbEludGVnZXIoXCJJVlwiKSxXPWouZW51bWVyYXRlZFN0cmluZyhcIktFWUZPUk1BVFZFUlNJT05TXCIpLFk9ai5lbnVtZXJhdGVkU3RyaW5nKFwiS0VZSURcIiksWD1udWxsIT0oRz1qLmVudW1lcmF0ZWRTdHJpbmcoXCJLRVlGT1JNQVRcIikpP0c6XCJpZGVudGl0eVwiO2lmKFtcImNvbS5hcHBsZS5zdHJlYW1pbmdrZXlkZWxpdmVyeVwiLFwiY29tLm1pY3Jvc29mdC5wbGF5cmVhZHlcIixcInVybjp1dWlkOmVkZWY4YmE5LTc5ZDYtNGFjZS1hM2M4LTI3ZGNkNTFkMjFlZFwiLFwiY29tLndpZGV2aW5lXCJdLmluZGV4T2YoWCk+LTEpe28uYi53YXJuKFwiS2V5Zm9ybWF0IFwiK1grXCIgaXMgbm90IHN1cHBvcnRlZCBmcm9tIHRoZSBtYW5pZmVzdFwiKTtjb250aW51ZX1pZihcImlkZW50aXR5XCIhPT1YKWNvbnRpbnVlO0gmJihjPWYuYS5mcm9tVVJMKGUsSyksSyYmW1wiQUVTLTEyOFwiLFwiU0FNUExFLUFFU1wiLFwiU0FNUExFLUFFUy1DRU5DXCJdLmluZGV4T2YoSCk+PTAmJihjLm1ldGhvZD1ILGMua2V5Rm9ybWF0PVgsWSYmKGMua2V5SUQ9WSksVyYmKGMua2V5Rm9ybWF0VmVyc2lvbnM9VyksYy5pdj1WKSk7YnJlYWs7Y2FzZVwiU1RBUlRcIjp2YXIgcT1uZXcgZyhQKS5kZWNpbWFsRmxvYXRpbmdQb2ludChcIlRJTUUtT0ZGU0VUXCIpO09iamVjdChhLmEpKHEpJiYodi5zdGFydFRpbWVPZmZzZXQ9cSk7YnJlYWs7Y2FzZVwiTUFQXCI6dmFyIHo9bmV3IGcoUCk7Xy5yZWx1cmw9ei5VUkksei5CWVRFUkFOR0UmJl8uc2V0Qnl0ZVJhbmdlKHouQllURVJBTkdFKSxfLmxldmVsPXIsXy5zbj1cImluaXRTZWdtZW50XCIsYyYmKF8ubGV2ZWxrZXk9YyksXy5pbml0U2VnbWVudD1udWxsLG09Xyx4PSEwO2JyZWFrO2Nhc2VcIlNFUlZFUi1DT05UUk9MXCI6dmFyIFE9bmV3IGcoUCk7di5jYW5CbG9ja1JlbG9hZD1RLmJvb2woXCJDQU4tQkxPQ0stUkVMT0FEXCIpLHYuY2FuU2tpcFVudGlsPVEub3B0aW9uYWxGbG9hdChcIkNBTi1TS0lQLVVOVElMXCIsMCksdi5jYW5Ta2lwRGF0ZVJhbmdlcz12LmNhblNraXBVbnRpbD4wJiZRLmJvb2woXCJDQU4tU0tJUC1EQVRFUkFOR0VTXCIpLHYucGFydEhvbGRCYWNrPVEub3B0aW9uYWxGbG9hdChcIlBBUlQtSE9MRC1CQUNLXCIsMCksdi5ob2xkQmFjaz1RLm9wdGlvbmFsRmxvYXQoXCJIT0xELUJBQ0tcIiwwKTticmVhaztjYXNlXCJQQVJULUlORlwiOnZhciAkPW5ldyBnKFApO3YucGFydFRhcmdldD0kLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiUEFSVC1UQVJHRVRcIik7YnJlYWs7Y2FzZVwiUEFSVFwiOnZhciBaPXYucGFydExpc3Q7Wnx8KFo9di5wYXJ0TGlzdD1bXSk7dmFyIEo9Yj4wP1pbWi5sZW5ndGgtMV06dm9pZCAwLHR0PWIrKyxldD1uZXcgdS5jKG5ldyBnKFApLF8sZSx0dCxKKTtaLnB1c2goZXQpLF8uZHVyYXRpb24rPWV0LmR1cmF0aW9uO2JyZWFrO2Nhc2VcIlBSRUxPQUQtSElOVFwiOnZhciBydD1uZXcgZyhQKTt2LnByZWxvYWRIaW50PXJ0O2JyZWFrO2Nhc2VcIlJFTkRJVElPTi1SRVBPUlRcIjp2YXIgaXQ9bmV3IGcoUCk7di5yZW5kaXRpb25SZXBvcnRzPXYucmVuZGl0aW9uUmVwb3J0c3x8W10sdi5yZW5kaXRpb25SZXBvcnRzLnB1c2goaXQpO2JyZWFrO2RlZmF1bHQ6by5iLndhcm4oXCJsaW5lIHBhcnNlZCBidXQgbm90IGhhbmRsZWQ6IFwiK2wpfX19UiYmIVIucmVsdXJsPyhwLnBvcCgpLEwtPVIuZHVyYXRpb24sdi5wYXJ0TGlzdCYmKHYuZnJhZ21lbnRIaW50PVIpKTp2LnBhcnRMaXN0JiYoRChfLFIpLF8uY2M9QSx2LmZyYWdtZW50SGludD1fKTt2YXIgYXQ9cC5sZW5ndGgsbnQ9cFswXSxzdD1wW2F0LTFdO2lmKChMKz12LnNraXBwZWRTZWdtZW50cyp2LnRhcmdldGR1cmF0aW9uKT4wJiZhdCYmc3Qpe3YuYXZlcmFnZXRhcmdldGR1cmF0aW9uPUwvYXQ7dmFyIG90PXN0LnNuO3YuZW5kU049XCJpbml0U2VnbWVudFwiIT09b3Q/b3Q6MCxudCYmKHYuc3RhcnRDQz1udC5jYyxudC5pbml0U2VnbWVudHx8di5mcmFnbWVudHMuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlbHVybCYmKGU9dC5yZWx1cmwsUy50ZXN0KG51bGwhPShyPW51bGw9PT0oYT1pLnBhcnNlVVJMKGUpKXx8dm9pZCAwPT09YT92b2lkIDA6YS5wYXRoKT9yOlwiXCIpKTt2YXIgZSxyLGF9KSkmJihvLmIud2FybihcIk1QNCBmcmFnbWVudHMgZm91bmQgYnV0IG5vIGluaXQgc2VnbWVudCAocHJvYmFibHkgbm8gTUFQLCBpbmNvbXBsZXRlIE0zVTgpLCB0cnlpbmcgdG8gZmV0Y2ggU0lEWFwiKSwoXz1uZXcgdS5iKG4sZSkpLnJlbHVybD1zdC5yZWx1cmwsXy5sZXZlbD1yLF8uc249XCJpbml0U2VnbWVudFwiLG50LmluaXRTZWdtZW50PV8sdi5uZWVkU2lkeFJhbmdlcz0hMCkpfWVsc2Ugdi5lbmRTTj0wLHYuc3RhcnRDQz0wO3JldHVybiB2LmZyYWdtZW50SGludCYmKEwrPXYuZnJhZ21lbnRIaW50LmR1cmF0aW9uKSx2LnRvdGFsZHVyYXRpb249TCx2LmVuZENDPUEsaz4wJiZmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj10W2VdLGk9ZTtpLS07KXt2YXIgYT10W2ldO2lmKCFhKXJldHVybjthLnByb2dyYW1EYXRlVGltZT1yLnByb2dyYW1EYXRlVGltZS0xZTMqYS5kdXJhdGlvbixyPWF9fShwLGspLHZ9LHR9KCk7ZnVuY3Rpb24gQSh0LGUpe1tcInZpZGVvXCIsXCJhdWRpb1wiLFwidGV4dFwiXS5mb3JFYWNoKChmdW5jdGlvbihyKXt2YXIgaT10LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIHI9cFtlXTtyZXR1cm4hIXImJiEwPT09clt0LnNsaWNlKDAsNCldfSh0LHIpfSkpO2lmKGkubGVuZ3RoKXt2YXIgYT1pLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIDA9PT10Lmxhc3RJbmRleE9mKFwiYXZjMVwiLDApfHwwPT09dC5sYXN0SW5kZXhPZihcIm1wNGFcIiwwKX0pKTtlW3IrXCJDb2RlY1wiXT1hLmxlbmd0aD4wP2FbMF06aVswXSx0PXQuZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm4tMT09PWkuaW5kZXhPZih0KX0pKX19KSksZS51bmtub3duQ29kZWNzPXR9ZnVuY3Rpb24gUih0LGUscil7dmFyIGk9ZVtyXTtpJiYodFtyXT1pKX1mdW5jdGlvbiBEKHQsZSl7dC5yYXdQcm9ncmFtRGF0ZVRpbWU/dC5wcm9ncmFtRGF0ZVRpbWU9RGF0ZS5wYXJzZSh0LnJhd1Byb2dyYW1EYXRlVGltZSk6bnVsbCE9ZSYmZS5wcm9ncmFtRGF0ZVRpbWUmJih0LnByb2dyYW1EYXRlVGltZT1lLmVuZFByb2dyYW1EYXRlVGltZSksT2JqZWN0KGEuYSkodC5wcm9ncmFtRGF0ZVRpbWUpfHwodC5wcm9ncmFtRGF0ZVRpbWU9bnVsbCx0LnJhd1Byb2dyYW1EYXRlVGltZT1udWxsKX12YXIgXz1yKDQpO2Z1bmN0aW9uIGsodCxlKXt2YXIgcj10LnVybDtyZXR1cm4gdm9pZCAwIT09ciYmMCE9PXIuaW5kZXhPZihcImRhdGE6XCIpfHwocj1lLnVybCkscn12YXIgeD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5obHM9dm9pZCAwLHRoaXMubG9hZGVycz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuaGxzPXQsdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vbihuLmEuTUFOSUZFU1RfTE9BRElORyx0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLHRoaXMpLHQub24obi5hLkxFVkVMX0xPQURJTkcsdGhpcy5vbkxldmVsTG9hZGluZyx0aGlzKSx0Lm9uKG4uYS5BVURJT19UUkFDS19MT0FESU5HLHRoaXMub25BdWRpb1RyYWNrTG9hZGluZyx0aGlzKSx0Lm9uKG4uYS5TVUJUSVRMRV9UUkFDS19MT0FESU5HLHRoaXMub25TdWJ0aXRsZVRyYWNrTG9hZGluZyx0aGlzKX0sZS51bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLk1BTklGRVNUX0xPQURJTkcsdGhpcy5vbk1hbmlmZXN0TG9hZGluZyx0aGlzKSx0Lm9mZihuLmEuTEVWRUxfTE9BRElORyx0aGlzLm9uTGV2ZWxMb2FkaW5nLHRoaXMpLHQub2ZmKG4uYS5BVURJT19UUkFDS19MT0FESU5HLHRoaXMub25BdWRpb1RyYWNrTG9hZGluZyx0aGlzKSx0Lm9mZihuLmEuU1VCVElUTEVfVFJBQ0tfTE9BRElORyx0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsdGhpcyl9LGUuY3JlYXRlSW50ZXJuYWxMb2FkZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5obHMuY29uZmlnLHI9ZS5wTG9hZGVyLGk9ZS5sb2FkZXIsYT1uZXcocnx8aSkoZSk7cmV0dXJuIHQubG9hZGVyPWEsdGhpcy5sb2FkZXJzW3QudHlwZV09YSxhfSxlLmdldEludGVybmFsTG9hZGVyPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxvYWRlcnNbdC50eXBlXX0sZS5yZXNldEludGVybmFsTG9hZGVyPWZ1bmN0aW9uKHQpe3RoaXMubG9hZGVyc1t0XSYmZGVsZXRlIHRoaXMubG9hZGVyc1t0XX0sZS5kZXN0cm95SW50ZXJuYWxMb2FkZXJzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMubG9hZGVycyl7dmFyIGU9dGhpcy5sb2FkZXJzW3RdO2UmJmUuZGVzdHJveSgpLHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcih0KX19LGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLHRoaXMuZGVzdHJveUludGVybmFsTG9hZGVycygpfSxlLm9uTWFuaWZlc3RMb2FkaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS51cmw7dGhpcy5sb2FkKHtpZDpudWxsLGdyb3VwSWQ6bnVsbCxsZXZlbDowLHJlc3BvbnNlVHlwZTpcInRleHRcIix0eXBlOl8uYS5NQU5JRkVTVCx1cmw6cixkZWxpdmVyeURpcmVjdGl2ZXM6bnVsbH0pfSxlLm9uTGV2ZWxMb2FkaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5pZCxpPWUubGV2ZWwsYT1lLnVybCxuPWUuZGVsaXZlcnlEaXJlY3RpdmVzO3RoaXMubG9hZCh7aWQ6cixncm91cElkOm51bGwsbGV2ZWw6aSxyZXNwb25zZVR5cGU6XCJ0ZXh0XCIsdHlwZTpfLmEuTEVWRUwsdXJsOmEsZGVsaXZlcnlEaXJlY3RpdmVzOm59KX0sZS5vbkF1ZGlvVHJhY2tMb2FkaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5pZCxpPWUuZ3JvdXBJZCxhPWUudXJsLG49ZS5kZWxpdmVyeURpcmVjdGl2ZXM7dGhpcy5sb2FkKHtpZDpyLGdyb3VwSWQ6aSxsZXZlbDpudWxsLHJlc3BvbnNlVHlwZTpcInRleHRcIix0eXBlOl8uYS5BVURJT19UUkFDSyx1cmw6YSxkZWxpdmVyeURpcmVjdGl2ZXM6bn0pfSxlLm9uU3VidGl0bGVUcmFja0xvYWRpbmc9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmlkLGk9ZS5ncm91cElkLGE9ZS51cmwsbj1lLmRlbGl2ZXJ5RGlyZWN0aXZlczt0aGlzLmxvYWQoe2lkOnIsZ3JvdXBJZDppLGxldmVsOm51bGwscmVzcG9uc2VUeXBlOlwidGV4dFwiLHR5cGU6Xy5hLlNVQlRJVExFX1RSQUNLLHVybDphLGRlbGl2ZXJ5RGlyZWN0aXZlczpufSl9LGUubG9hZD1mdW5jdGlvbih0KXt2YXIgZSxyLGksYSxuLHMsbD10aGlzLmhscy5jb25maWcsdT10aGlzLmdldEludGVybmFsTG9hZGVyKHQpO2lmKHUpe3ZhciBkPXUuY29udGV4dDtpZihkJiZkLnVybD09PXQudXJsKXJldHVybiB2b2lkIG8uYi50cmFjZShcIltwbGF5bGlzdC1sb2FkZXJdOiBwbGF5bGlzdCByZXF1ZXN0IG9uZ29pbmdcIik7by5iLmxvZyhcIltwbGF5bGlzdC1sb2FkZXJdOiBhYm9ydGluZyBwcmV2aW91cyBsb2FkZXIgZm9yIHR5cGU6IFwiK3QudHlwZSksdS5hYm9ydCgpfXN3aXRjaCh0LnR5cGUpe2Nhc2UgXy5hLk1BTklGRVNUOnI9bC5tYW5pZmVzdExvYWRpbmdNYXhSZXRyeSxpPWwubWFuaWZlc3RMb2FkaW5nVGltZU91dCxhPWwubWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheSxuPWwubWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0O2JyZWFrO2Nhc2UgXy5hLkxFVkVMOmNhc2UgXy5hLkFVRElPX1RSQUNLOmNhc2UgXy5hLlNVQlRJVExFX1RSQUNLOnI9MCxpPWwubGV2ZWxMb2FkaW5nVGltZU91dDticmVhaztkZWZhdWx0OnI9bC5sZXZlbExvYWRpbmdNYXhSZXRyeSxpPWwubGV2ZWxMb2FkaW5nVGltZU91dCxhPWwubGV2ZWxMb2FkaW5nUmV0cnlEZWxheSxuPWwubGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0fWlmKHU9dGhpcy5jcmVhdGVJbnRlcm5hbExvYWRlcih0KSxudWxsIT09KGU9dC5kZWxpdmVyeURpcmVjdGl2ZXMpJiZ2b2lkIDAhPT1lJiZlLnBhcnQmJih0LnR5cGU9PT1fLmEuTEVWRUwmJm51bGwhPT10LmxldmVsP3M9dGhpcy5obHMubGV2ZWxzW3QubGV2ZWxdLmRldGFpbHM6dC50eXBlPT09Xy5hLkFVRElPX1RSQUNLJiZudWxsIT09dC5pZD9zPXRoaXMuaGxzLmF1ZGlvVHJhY2tzW3QuaWRdLmRldGFpbHM6dC50eXBlPT09Xy5hLlNVQlRJVExFX1RSQUNLJiZudWxsIT09dC5pZCYmKHM9dGhpcy5obHMuc3VidGl0bGVUcmFja3NbdC5pZF0uZGV0YWlscykscykpe3ZhciBoPXMucGFydFRhcmdldCxmPXMudGFyZ2V0ZHVyYXRpb247aCYmZiYmKGk9TWF0aC5taW4oMWUzKk1hdGgubWF4KDMqaCwuOCpmKSxpKSl9dmFyIGM9e3RpbWVvdXQ6aSxtYXhSZXRyeTpyLHJldHJ5RGVsYXk6YSxtYXhSZXRyeURlbGF5Om4saGlnaFdhdGVyTWFyazowfSx2PXtvblN1Y2Nlc3M6dGhpcy5sb2Fkc3VjY2Vzcy5iaW5kKHRoaXMpLG9uRXJyb3I6dGhpcy5sb2FkZXJyb3IuYmluZCh0aGlzKSxvblRpbWVvdXQ6dGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpfTt1LmxvYWQodCxjLHYpfSxlLmxvYWRzdWNjZXNzPWZ1bmN0aW9uKHQsZSxyLGkpe2lmKHZvaWQgMD09PWkmJihpPW51bGwpLHIuaXNTaWR4UmVxdWVzdClyZXR1cm4gdGhpcy5oYW5kbGVTaWR4UmVxdWVzdCh0LHIpLHZvaWQgdGhpcy5oYW5kbGVQbGF5bGlzdExvYWRlZCh0LGUscixpKTt0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIoci50eXBlKTt2YXIgYT10LmRhdGE7MD09PWEuaW5kZXhPZihcIiNFWFRNM1VcIik/KGUucGFyc2luZy5zdGFydD1wZXJmb3JtYW5jZS5ub3coKSxhLmluZGV4T2YoXCIjRVhUSU5GOlwiKT4wfHxhLmluZGV4T2YoXCIjRVhULVgtVEFSR0VURFVSQVRJT046XCIpPjA/dGhpcy5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdCh0LGUscixpKTp0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KHQsZSxyLGkpKTp0aGlzLmhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKHQscixcIm5vIEVYVE0zVSBkZWxpbWl0ZXJcIixpKX0sZS5sb2FkZXJyb3I9ZnVuY3Rpb24odCxlLHIpe3ZvaWQgMD09PXImJihyPW51bGwpLHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKGUsciwhMSx0KX0sZS5sb2FkdGltZW91dD1mdW5jdGlvbih0LGUscil7dm9pZCAwPT09ciYmKHI9bnVsbCksdGhpcy5oYW5kbGVOZXR3b3JrRXJyb3IoZSxyLCEwKX0sZS5oYW5kbGVNYXN0ZXJQbGF5bGlzdD1mdW5jdGlvbih0LGUscixpKXt2YXIgYT10aGlzLmhscyxzPXQuZGF0YSxsPWsodCxyKSx1PUwucGFyc2VNYXN0ZXJQbGF5bGlzdChzLGwpLGQ9dS5sZXZlbHMsaD11LnNlc3Npb25EYXRhO2lmKGQubGVuZ3RoKXt2YXIgZj1kLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue2lkOnQuYXR0cnMuQVVESU8sYXVkaW9Db2RlYzp0LmF1ZGlvQ29kZWN9fSkpLGM9ZC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybntpZDp0LmF0dHJzLlNVQlRJVExFUyx0ZXh0Q29kZWM6dC50ZXh0Q29kZWN9fSkpLHY9TC5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEocyxsLFwiQVVESU9cIixmKSxwPUwucGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKHMsbCxcIlNVQlRJVExFU1wiLGMpLG09TC5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEocyxsLFwiQ0xPU0VELUNBUFRJT05TXCIpO3YubGVuZ3RoJiYodi5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4hdC51cmx9KSl8fCFkWzBdLmF1ZGlvQ29kZWN8fGRbMF0uYXR0cnMuQVVESU98fChvLmIubG9nKFwiW3BsYXlsaXN0LWxvYWRlcl06IGF1ZGlvIGNvZGVjIHNpZ25hbGVkIGluIHF1YWxpdHkgbGV2ZWwsIGJ1dCBubyBlbWJlZGRlZCBhdWRpbyB0cmFjayBzaWduYWxlZCwgY3JlYXRlIG9uZVwiKSx2LnVuc2hpZnQoe3R5cGU6XCJtYWluXCIsbmFtZTpcIm1haW5cIixkZWZhdWx0OiExLGF1dG9zZWxlY3Q6ITEsZm9yY2VkOiExLGlkOi0xLGF0dHJzOm5ldyBnKHt9KSxiaXRyYXRlOjAsdXJsOlwiXCJ9KSkpLGEudHJpZ2dlcihuLmEuTUFOSUZFU1RfTE9BREVELHtsZXZlbHM6ZCxhdWRpb1RyYWNrczp2LHN1YnRpdGxlczpwLGNhcHRpb25zOm0sdXJsOmwsc3RhdHM6ZSxuZXR3b3JrRGV0YWlsczppLHNlc3Npb25EYXRhOmh9KX1lbHNlIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IodCxyLFwibm8gbGV2ZWwgZm91bmQgaW4gbWFuaWZlc3RcIixpKX0sZS5oYW5kbGVUcmFja09yTGV2ZWxQbGF5bGlzdD1mdW5jdGlvbih0LGUscixpKXt2YXIgbz10aGlzLmhscyxsPXIuaWQsdT1yLmxldmVsLGQ9ci50eXBlLGg9ayh0LHIpLGY9T2JqZWN0KGEuYSkobCk/bDowLGM9T2JqZWN0KGEuYSkodSk/dTpmLHY9ZnVuY3Rpb24odCl7c3dpdGNoKHQudHlwZSl7Y2FzZSBfLmEuQVVESU9fVFJBQ0s6cmV0dXJuIF8uYi5BVURJTztjYXNlIF8uYS5TVUJUSVRMRV9UUkFDSzpyZXR1cm4gXy5iLlNVQlRJVExFO2RlZmF1bHQ6cmV0dXJuIF8uYi5NQUlOfX0ocikscD1MLnBhcnNlTGV2ZWxQbGF5bGlzdCh0LmRhdGEsaCxjLHYsZik7aWYocC5mcmFnbWVudHMubGVuZ3RoKXtpZihkPT09Xy5hLk1BTklGRVNUKXt2YXIgbT17YXR0cnM6bmV3IGcoe30pLGJpdHJhdGU6MCxkZXRhaWxzOnAsbmFtZTpcIlwiLHVybDpofTtvLnRyaWdnZXIobi5hLk1BTklGRVNUX0xPQURFRCx7bGV2ZWxzOlttXSxhdWRpb1RyYWNrczpbXSx1cmw6aCxzdGF0czplLG5ldHdvcmtEZXRhaWxzOmksc2Vzc2lvbkRhdGE6bnVsbH0pfWlmKGUucGFyc2luZy5lbmQ9cGVyZm9ybWFuY2Uubm93KCkscC5uZWVkU2lkeFJhbmdlcyl7dmFyIHksYj1udWxsPT09KHk9cC5mcmFnbWVudHNbMF0uaW5pdFNlZ21lbnQpfHx2b2lkIDA9PT15P3ZvaWQgMDp5LnVybDt0aGlzLmxvYWQoe3VybDpiLGlzU2lkeFJlcXVlc3Q6ITAsdHlwZTpkLGxldmVsOnUsbGV2ZWxEZXRhaWxzOnAsaWQ6bCxncm91cElkOm51bGwscmFuZ2VTdGFydDowLHJhbmdlRW5kOjIwNDgscmVzcG9uc2VUeXBlOlwiYXJyYXlidWZmZXJcIixkZWxpdmVyeURpcmVjdGl2ZXM6bnVsbH0pfWVsc2Ugci5sZXZlbERldGFpbHM9cCx0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKHQsZSxyLGkpfWVsc2Ugby50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5MRVZFTF9FTVBUWV9FUlJPUixmYXRhbDohMSx1cmw6aCxyZWFzb246XCJubyBmcmFnbWVudHMgZm91bmQgaW4gbGV2ZWxcIixsZXZlbDpcIm51bWJlclwiPT10eXBlb2Ygci5sZXZlbD9yLmxldmVsOnZvaWQgMH0pfSxlLmhhbmRsZVNpZHhSZXF1ZXN0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9T2JqZWN0KGwuZykobmV3IFVpbnQ4QXJyYXkodC5kYXRhKSk7aWYocil7dmFyIGk9ci5yZWZlcmVuY2VzLGE9ZS5sZXZlbERldGFpbHM7aS5mb3JFYWNoKChmdW5jdGlvbih0LGUpe3ZhciBpPXQuaW5mbyxuPWEuZnJhZ21lbnRzW2VdOzA9PT1uLmJ5dGVSYW5nZS5sZW5ndGgmJm4uc2V0Qnl0ZVJhbmdlKFN0cmluZygxK2kuZW5kLWkuc3RhcnQpK1wiQFwiK1N0cmluZyhpLnN0YXJ0KSksbi5pbml0U2VnbWVudCYmbi5pbml0U2VnbWVudC5zZXRCeXRlUmFuZ2UoU3RyaW5nKHIubW9vdkVuZE9mZnNldCkrXCJAMFwiKX0pKX19LGUuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3I9ZnVuY3Rpb24odCxlLHIsaSl7dGhpcy5obHMudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuTUFOSUZFU1RfUEFSU0lOR19FUlJPUixmYXRhbDplLnR5cGU9PT1fLmEuTUFOSUZFU1QsdXJsOnQudXJsLHJlYXNvbjpyLHJlc3BvbnNlOnQsY29udGV4dDplLG5ldHdvcmtEZXRhaWxzOml9KX0sZS5oYW5kbGVOZXR3b3JrRXJyb3I9ZnVuY3Rpb24odCxlLHIsaSl7dm9pZCAwPT09ciYmKHI9ITEpLG8uYi53YXJuKFwiW3BsYXlsaXN0LWxvYWRlcl06IEEgbmV0d29yayBcIisocj9cInRpbWVvdXRcIjpcImVycm9yXCIpK1wiIG9jY3VycmVkIHdoaWxlIGxvYWRpbmcgXCIrdC50eXBlK1wiIGxldmVsOiBcIit0LmxldmVsK1wiIGlkOiBcIit0LmlkKycgZ3JvdXAtaWQ6IFwiJyt0Lmdyb3VwSWQrJ1wiJyk7dmFyIGE9cy5hLlVOS05PV04sbD0hMSx1PXRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIodCk7c3dpdGNoKHQudHlwZSl7Y2FzZSBfLmEuTUFOSUZFU1Q6YT1yP3MuYS5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ6cy5hLk1BTklGRVNUX0xPQURfRVJST1IsbD0hMDticmVhaztjYXNlIF8uYS5MRVZFTDphPXI/cy5hLkxFVkVMX0xPQURfVElNRU9VVDpzLmEuTEVWRUxfTE9BRF9FUlJPUixsPSExO2JyZWFrO2Nhc2UgXy5hLkFVRElPX1RSQUNLOmE9cj9zLmEuQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOnMuYS5BVURJT19UUkFDS19MT0FEX0VSUk9SLGw9ITE7YnJlYWs7Y2FzZSBfLmEuU1VCVElUTEVfVFJBQ0s6YT1yP3MuYS5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ6cy5hLlNVQlRJVExFX0xPQURfRVJST1IsbD0hMX11JiZ0aGlzLnJlc2V0SW50ZXJuYWxMb2FkZXIodC50eXBlKTt2YXIgZD17dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOmEsZmF0YWw6bCx1cmw6dC51cmwsbG9hZGVyOnUsY29udGV4dDp0LG5ldHdvcmtEZXRhaWxzOmV9O2kmJihkLnJlc3BvbnNlPWkpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkVSUk9SLGQpfSxlLmhhbmRsZVBsYXlsaXN0TG9hZGVkPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXIudHlwZSxzPXIubGV2ZWwsbz1yLmlkLGw9ci5ncm91cElkLHU9ci5sb2FkZXIsZD1yLmxldmVsRGV0YWlscyxoPXIuZGVsaXZlcnlEaXJlY3RpdmVzO2lmKG51bGwhPWQmJmQudGFyZ2V0ZHVyYXRpb24pe2lmKHUpc3dpdGNoKGQubGl2ZSYmKHUuZ2V0Q2FjaGVBZ2UmJihkLmFnZUhlYWRlcj11LmdldENhY2hlQWdlKCl8fDApLHUuZ2V0Q2FjaGVBZ2UmJiFpc05hTihkLmFnZUhlYWRlcil8fChkLmFnZUhlYWRlcj0wKSksYSl7Y2FzZSBfLmEuTUFOSUZFU1Q6Y2FzZSBfLmEuTEVWRUw6dGhpcy5obHMudHJpZ2dlcihuLmEuTEVWRUxfTE9BREVELHtkZXRhaWxzOmQsbGV2ZWw6c3x8MCxpZDpvfHwwLHN0YXRzOmUsbmV0d29ya0RldGFpbHM6aSxkZWxpdmVyeURpcmVjdGl2ZXM6aH0pO2JyZWFrO2Nhc2UgXy5hLkFVRElPX1RSQUNLOnRoaXMuaGxzLnRyaWdnZXIobi5hLkFVRElPX1RSQUNLX0xPQURFRCx7ZGV0YWlsczpkLGlkOm98fDAsZ3JvdXBJZDpsfHxcIlwiLHN0YXRzOmUsbmV0d29ya0RldGFpbHM6aSxkZWxpdmVyeURpcmVjdGl2ZXM6aH0pO2JyZWFrO2Nhc2UgXy5hLlNVQlRJVExFX1RSQUNLOnRoaXMuaGxzLnRyaWdnZXIobi5hLlNVQlRJVExFX1RSQUNLX0xPQURFRCx7ZGV0YWlsczpkLGlkOm98fDAsZ3JvdXBJZDpsfHxcIlwiLHN0YXRzOmUsbmV0d29ya0RldGFpbHM6aSxkZWxpdmVyeURpcmVjdGl2ZXM6aH0pfX1lbHNlIHRoaXMuaGFuZGxlTWFuaWZlc3RQYXJzaW5nRXJyb3IodCxyLFwiaW52YWxpZCB0YXJnZXQgZHVyYXRpb25cIixpKX0sdH0oKSx3PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmhscz12b2lkIDAsdGhpcy5sb2FkZXJzPXt9LHRoaXMuZGVjcnlwdGtleT1udWxsLHRoaXMuZGVjcnlwdHVybD1udWxsLHRoaXMuaGxzPXQsdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5fcmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vbihuLmEuS0VZX0xPQURJTkcsdGhpcy5vbktleUxvYWRpbmcsdGhpcyl9LGUuX3VucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vZmYobi5hLktFWV9MT0FESU5HLHRoaXMub25LZXlMb2FkaW5nKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSx0aGlzLmxvYWRlcnMpe3ZhciBlPXRoaXMubG9hZGVyc1t0XTtlJiZlLmRlc3Ryb3koKX10aGlzLmxvYWRlcnM9e319LGUub25LZXlMb2FkaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ci50eXBlLGE9dGhpcy5sb2FkZXJzW2ldO2lmKHIuZGVjcnlwdGRhdGEpe3ZhciBzPXIuZGVjcnlwdGRhdGEudXJpO2lmKHMhPT10aGlzLmRlY3J5cHR1cmx8fG51bGw9PT10aGlzLmRlY3J5cHRrZXkpe3ZhciBsPXRoaXMuaGxzLmNvbmZpZztpZihhJiYoby5iLndhcm4oXCJhYm9ydCBwcmV2aW91cyBrZXkgbG9hZGVyIGZvciB0eXBlOlwiK2kpLGEuYWJvcnQoKSksIXMpcmV0dXJuIHZvaWQgby5iLndhcm4oXCJrZXkgdXJpIGlzIGZhbHN5XCIpO3ZhciB1PWwubG9hZGVyLGQ9ci5sb2FkZXI9dGhpcy5sb2FkZXJzW2ldPW5ldyB1KGwpO3RoaXMuZGVjcnlwdHVybD1zLHRoaXMuZGVjcnlwdGtleT1udWxsO3ZhciBoPXt1cmw6cyxmcmFnOnIscmVzcG9uc2VUeXBlOlwiYXJyYXlidWZmZXJcIn0sZj17dGltZW91dDpsLmZyYWdMb2FkaW5nVGltZU91dCxtYXhSZXRyeTowLHJldHJ5RGVsYXk6bC5mcmFnTG9hZGluZ1JldHJ5RGVsYXksbWF4UmV0cnlEZWxheTpsLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LGhpZ2hXYXRlck1hcms6MH0sYz17b25TdWNjZXNzOnRoaXMubG9hZHN1Y2Nlc3MuYmluZCh0aGlzKSxvbkVycm9yOnRoaXMubG9hZGVycm9yLmJpbmQodGhpcyksb25UaW1lb3V0OnRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKX07ZC5sb2FkKGgsZixjKX1lbHNlIHRoaXMuZGVjcnlwdGtleSYmKHIuZGVjcnlwdGRhdGEua2V5PXRoaXMuZGVjcnlwdGtleSx0aGlzLmhscy50cmlnZ2VyKG4uYS5LRVlfTE9BREVELHtmcmFnOnJ9KSl9ZWxzZSBvLmIud2FybihcIk1pc3NpbmcgZGVjcnlwdGlvbiBkYXRhIG9uIGZyYWdtZW50IGluIG9uS2V5TG9hZGluZ1wiKX0sZS5sb2Fkc3VjY2Vzcz1mdW5jdGlvbih0LGUscil7dmFyIGk9ci5mcmFnO2kuZGVjcnlwdGRhdGE/KHRoaXMuZGVjcnlwdGtleT1pLmRlY3J5cHRkYXRhLmtleT1uZXcgVWludDhBcnJheSh0LmRhdGEpLGkubG9hZGVyPW51bGwsZGVsZXRlIHRoaXMubG9hZGVyc1tpLnR5cGVdLHRoaXMuaGxzLnRyaWdnZXIobi5hLktFWV9MT0FERUQse2ZyYWc6aX0pKTpvLmIuZXJyb3IoXCJhZnRlciBrZXkgbG9hZCwgZGVjcnlwdGRhdGEgdW5zZXRcIil9LGUubG9hZGVycm9yPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ci5sb2FkZXI7aSYmaS5hYm9ydCgpLGRlbGV0ZSB0aGlzLmxvYWRlcnNbci50eXBlXSx0aGlzLmhscy50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5LRVlfTE9BRF9FUlJPUixmYXRhbDohMSxmcmFnOnIscmVzcG9uc2U6dH0pfSxlLmxvYWR0aW1lb3V0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ci5sb2FkZXI7aSYmaS5hYm9ydCgpLGRlbGV0ZSB0aGlzLmxvYWRlcnNbci50eXBlXSx0aGlzLmhscy50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5LRVlfTE9BRF9USU1FT1VULGZhdGFsOiExLGZyYWc6cn0pfSx0fSgpO2Z1bmN0aW9uIEModCxlKXt2YXIgcjt0cnl7cj1uZXcgRXZlbnQoXCJhZGR0cmFja1wiKX1jYXRjaCh0KXsocj1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKS5pbml0RXZlbnQoXCJhZGR0cmFja1wiLCExLCExKX1yLnRyYWNrPXQsZS5kaXNwYXRjaEV2ZW50KHIpfXZhciBPPXIoNyksST1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5obHM9dm9pZCAwLHRoaXMuaWQzVHJhY2s9bnVsbCx0aGlzLm1lZGlhPW51bGwsdGhpcy5obHM9dCx0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCl9LGUuX3JlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vbihuLmEuTUVESUFfQVRUQUNIRUQsdGhpcy5vbk1lZGlhQXR0YWNoZWQsdGhpcyksdC5vbihuLmEuTUVESUFfREVUQUNISU5HLHRoaXMub25NZWRpYURldGFjaGluZyx0aGlzKSx0Lm9uKG4uYS5GUkFHX1BBUlNJTkdfTUVUQURBVEEsdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsdGhpcyksdC5vbihuLmEuQlVGRkVSX0ZMVVNISU5HLHRoaXMub25CdWZmZXJGbHVzaGluZyx0aGlzKX0sZS5fdW5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub2ZmKG4uYS5NRURJQV9BVFRBQ0hFRCx0aGlzLm9uTWVkaWFBdHRhY2hlZCx0aGlzKSx0Lm9mZihuLmEuTUVESUFfREVUQUNISU5HLHRoaXMub25NZWRpYURldGFjaGluZyx0aGlzKSx0Lm9mZihuLmEuRlJBR19QQVJTSU5HX01FVEFEQVRBLHRoaXMub25GcmFnUGFyc2luZ01ldGFkYXRhLHRoaXMpLHQub2ZmKG4uYS5CVUZGRVJfRkxVU0hJTkcsdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLHRoaXMpfSxlLm9uTWVkaWFBdHRhY2hlZD1mdW5jdGlvbih0LGUpe3RoaXMubWVkaWE9ZS5tZWRpYX0sZS5vbk1lZGlhRGV0YWNoaW5nPWZ1bmN0aW9uKCl7dGhpcy5pZDNUcmFjayYmKGZ1bmN0aW9uKHQpe3ZhciBlPXQubW9kZTtpZihcImRpc2FibGVkXCI9PT1lJiYodC5tb2RlPVwiaGlkZGVuXCIpLHQuY3Vlcylmb3IodmFyIHI9dC5jdWVzLmxlbmd0aDtyLS07KXQucmVtb3ZlQ3VlKHQuY3Vlc1tyXSk7XCJkaXNhYmxlZFwiPT09ZSYmKHQubW9kZT1lKX0odGhpcy5pZDNUcmFjayksdGhpcy5pZDNUcmFjaz1udWxsLHRoaXMubWVkaWE9bnVsbCl9LGUuZ2V0SUQzVHJhY2s9ZnVuY3Rpb24odCl7aWYodGhpcy5tZWRpYSl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciByPXRbZV07aWYoXCJtZXRhZGF0YVwiPT09ci5raW5kJiZcImlkM1wiPT09ci5sYWJlbClyZXR1cm4gQyhyLHRoaXMubWVkaWEpLHJ9cmV0dXJuIHRoaXMubWVkaWEuYWRkVGV4dFRyYWNrKFwibWV0YWRhdGFcIixcImlkM1wiKX19LGUub25GcmFnUGFyc2luZ01ldGFkYXRhPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5tZWRpYSl7dmFyIHI9ZS5mcmFnLGk9ZS5zYW1wbGVzO3RoaXMuaWQzVHJhY2t8fCh0aGlzLmlkM1RyYWNrPXRoaXMuZ2V0SUQzVHJhY2sodGhpcy5tZWRpYS50ZXh0VHJhY2tzKSx0aGlzLmlkM1RyYWNrLm1vZGU9XCJoaWRkZW5cIik7Zm9yKHZhciBhPXNlbGYuV2ViS2l0RGF0YUN1ZXx8c2VsZi5WVFRDdWV8fHNlbGYuVGV4dFRyYWNrQ3VlLG49MDtuPGkubGVuZ3RoO24rKyl7dmFyIHM9Ty5jKGlbbl0uZGF0YSk7aWYocyl7dmFyIG89aVtuXS5wdHMsbD1uPGkubGVuZ3RoLTE/aVtuKzFdLnB0czpyLmVuZDtsLW88PTAmJihsPW8rLjI1KTtmb3IodmFyIHU9MDt1PHMubGVuZ3RoO3UrKyl7dmFyIGQ9c1t1XTtpZighTy5lKGQpKXt2YXIgaD1uZXcgYShvLGwsXCJcIik7aC52YWx1ZT1kLHRoaXMuaWQzVHJhY2suYWRkQ3VlKGgpfX19fX19LGUub25CdWZmZXJGbHVzaGluZz1mdW5jdGlvbih0LGUpe3ZhciByPWUuc3RhcnRPZmZzZXQsaT1lLmVuZE9mZnNldCxhPWUudHlwZTtpZighYXx8XCJhdWRpb1wiPT09YSl7dmFyIG49dGhpcy5pZDNUcmFjaztuJiZmdW5jdGlvbih0LGUscil7dmFyIGk9dC5tb2RlO2lmKFwiZGlzYWJsZWRcIj09PWkmJih0Lm1vZGU9XCJoaWRkZW5cIiksdC5jdWVzJiZ0LmN1ZXMubGVuZ3RoPjApZm9yKHZhciBhPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT1bXSxhPWZ1bmN0aW9uKHQsZSl7aWYoZTx0WzBdLnN0YXJ0VGltZSlyZXR1cm4gMDt2YXIgcj10Lmxlbmd0aC0xO2lmKGU+dFtyXS5lbmRUaW1lKXJldHVybi0xO2Zvcih2YXIgaT0wLGE9cjtpPD1hOyl7dmFyIG49TWF0aC5mbG9vcigoYStpKS8yKTtpZihlPHRbbl0uc3RhcnRUaW1lKWE9bi0xO2Vsc2V7aWYoIShlPnRbbl0uc3RhcnRUaW1lJiZpPHIpKXJldHVybiBuO2k9bisxfX1yZXR1cm4gdFtpXS5zdGFydFRpbWUtZTxlLXRbYV0uc3RhcnRUaW1lP2k6YX0odCxlKTtpZihhPi0xKWZvcih2YXIgbj1hLHM9dC5sZW5ndGg7bjxzO24rKyl7dmFyIG89dFtuXTtpZihvLnN0YXJ0VGltZT49ZSYmby5lbmRUaW1lPD1yKWkucHVzaChvKTtlbHNlIGlmKG8uc3RhcnRUaW1lPnIpcmV0dXJuIGl9cmV0dXJuIGl9KHQuY3VlcyxlLHIpLG49MDtuPGEubGVuZ3RoO24rKyl0LnJlbW92ZUN1ZShhW25dKTtcImRpc2FibGVkXCI9PT1pJiYodC5tb2RlPWkpfShuLHIsaSl9fSx0fSgpO2Z1bmN0aW9uIFAodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fXZhciBGLE09ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3ZhciBlPXRoaXM7dGhpcy5obHM9dm9pZCAwLHRoaXMuY29uZmlnPXZvaWQgMCx0aGlzLm1lZGlhPW51bGwsdGhpcy5sZXZlbERldGFpbHM9bnVsbCx0aGlzLmN1cnJlbnRUaW1lPTAsdGhpcy5zdGFsbENvdW50PTAsdGhpcy5fbGF0ZW5jeT1udWxsLHRoaXMudGltZXVwZGF0ZUhhbmRsZXI9ZnVuY3Rpb24oKXtyZXR1cm4gZS50aW1ldXBkYXRlKCl9LHRoaXMuaGxzPXQsdGhpcy5jb25maWc9dC5jb25maWcsdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpfXZhciBlLHIsaT10LnByb3RvdHlwZTtyZXR1cm4gaS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCksdGhpcy5sZXZlbERldGFpbHM9bnVsbCx0aGlzLmhscz10aGlzLnRpbWV1cGRhdGVIYW5kbGVyPW51bGx9LGkucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vbihuLmEuTUVESUFfQVRUQUNIRUQsdGhpcy5vbk1lZGlhQXR0YWNoZWQsdGhpcyksdGhpcy5obHMub24obi5hLk1FRElBX0RFVEFDSElORyx0aGlzLm9uTWVkaWFEZXRhY2hpbmcsdGhpcyksdGhpcy5obHMub24obi5hLk1BTklGRVNUX0xPQURJTkcsdGhpcy5vbk1hbmlmZXN0TG9hZGluZyx0aGlzKSx0aGlzLmhscy5vbihuLmEuTEVWRUxfVVBEQVRFRCx0aGlzLm9uTGV2ZWxVcGRhdGVkLHRoaXMpLHRoaXMuaGxzLm9uKG4uYS5FUlJPUix0aGlzLm9uRXJyb3IsdGhpcyl9LGkudW5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3RoaXMuaGxzLm9mZihuLmEuTUVESUFfQVRUQUNIRUQsdGhpcy5vbk1lZGlhQXR0YWNoZWQpLHRoaXMuaGxzLm9mZihuLmEuTUVESUFfREVUQUNISU5HLHRoaXMub25NZWRpYURldGFjaGluZyksdGhpcy5obHMub2ZmKG4uYS5NQU5JRkVTVF9MT0FESU5HLHRoaXMub25NYW5pZmVzdExvYWRpbmcpLHRoaXMuaGxzLm9mZihuLmEuTEVWRUxfVVBEQVRFRCx0aGlzLm9uTGV2ZWxVcGRhdGVkKSx0aGlzLmhscy5vZmYobi5hLkVSUk9SLHRoaXMub25FcnJvcil9LGkub25NZWRpYUF0dGFjaGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy5tZWRpYT1lLm1lZGlhLHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIix0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKX0saS5vbk1lZGlhRGV0YWNoaW5nPWZ1bmN0aW9uKCl7dGhpcy5tZWRpYSYmKHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIix0aGlzLnRpbWV1cGRhdGVIYW5kbGVyKSx0aGlzLm1lZGlhPW51bGwpfSxpLm9uTWFuaWZlc3RMb2FkaW5nPWZ1bmN0aW9uKCl7dGhpcy5sZXZlbERldGFpbHM9bnVsbCx0aGlzLl9sYXRlbmN5PW51bGwsdGhpcy5zdGFsbENvdW50PTB9LGkub25MZXZlbFVwZGF0ZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmRldGFpbHM7dGhpcy5sZXZlbERldGFpbHM9cixyLmFkdmFuY2VkJiZ0aGlzLnRpbWV1cGRhdGUoKSwhci5saXZlJiZ0aGlzLm1lZGlhJiZ0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsdGhpcy50aW1ldXBkYXRlSGFuZGxlcil9LGkub25FcnJvcj1mdW5jdGlvbih0LGUpe2UuZGV0YWlscz09PXMuYS5CVUZGRVJfU1RBTExFRF9FUlJPUiYmKHRoaXMuc3RhbGxDb3VudCsrLG8uYi53YXJuKFwiW3BsYXliYWNrLXJhdGUtY29udHJvbGxlcl06IFN0YWxsIGRldGVjdGVkLCBhZGp1c3RpbmcgdGFyZ2V0IGxhdGVuY3lcIikpfSxpLnRpbWV1cGRhdGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhLGU9dGhpcy5sZXZlbERldGFpbHM7aWYodCYmZSl7dGhpcy5jdXJyZW50VGltZT10LmN1cnJlbnRUaW1lO3ZhciByPXRoaXMuY29tcHV0ZUxhdGVuY3koKTtpZihudWxsIT09cil7dGhpcy5fbGF0ZW5jeT1yO3ZhciBpPXRoaXMuY29uZmlnLGE9aS5sb3dMYXRlbmN5TW9kZSxuPWkubWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU7aWYoYSYmMSE9PW4pe3ZhciBzPXRoaXMudGFyZ2V0TGF0ZW5jeTtpZihudWxsIT09cyl7dmFyIG89ci1zLGw9bzxNYXRoLm1pbih0aGlzLm1heExhdGVuY3kscytlLnRhcmdldGR1cmF0aW9uKTtpZihlLmxpdmUmJmwmJm8+LjA1JiZ0aGlzLmZvcndhcmRCdWZmZXJMZW5ndGg+MSl7dmFyIHU9TWF0aC5taW4oMixNYXRoLm1heCgxLG4pKSxkPU1hdGgucm91bmQoMi8oMStNYXRoLmV4cCgtLjc1Km8tdGhpcy5lZGdlU3RhbGxlZCkpKjIwKS8yMDt0LnBsYXliYWNrUmF0ZT1NYXRoLm1pbih1LE1hdGgubWF4KDEsZCkpfWVsc2UgMSE9PXQucGxheWJhY2tSYXRlJiYwIT09dC5wbGF5YmFja1JhdGUmJih0LnBsYXliYWNrUmF0ZT0xKX19fX19LGkuZXN0aW1hdGVMaXZlRWRnZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGV2ZWxEZXRhaWxzO3JldHVybiBudWxsPT09dD9udWxsOnQuZWRnZSt0LmFnZX0saS5jb21wdXRlTGF0ZW5jeT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZXN0aW1hdGVMaXZlRWRnZSgpO3JldHVybiBudWxsPT09dD9udWxsOnQtdGhpcy5jdXJyZW50VGltZX0sZT10LChyPVt7a2V5OlwibGF0ZW5jeVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9sYXRlbmN5fHwwfX0se2tleTpcIm1heExhdGVuY3lcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbmZpZyxlPXRoaXMubGV2ZWxEZXRhaWxzO3JldHVybiB2b2lkIDAhPT10LmxpdmVNYXhMYXRlbmN5RHVyYXRpb24/dC5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uOmU/dC5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQqZS50YXJnZXRkdXJhdGlvbjowfX0se2tleTpcInRhcmdldExhdGVuY3lcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxldmVsRGV0YWlscztpZihudWxsPT09dClyZXR1cm4gbnVsbDt2YXIgZT10LmhvbGRCYWNrLHI9dC5wYXJ0SG9sZEJhY2ssaT10LnRhcmdldGR1cmF0aW9uLGE9dGhpcy5jb25maWcsbj1hLmxpdmVTeW5jRHVyYXRpb24scz1hLmxpdmVTeW5jRHVyYXRpb25Db3VudCxvPWEubG93TGF0ZW5jeU1vZGUsbD10aGlzLmhscy51c2VyQ29uZmlnLHU9byYmcnx8ZTsobC5saXZlU3luY0R1cmF0aW9ufHxsLmxpdmVTeW5jRHVyYXRpb25Db3VudHx8MD09PXUpJiYodT12b2lkIDAhPT1uP246cyppKTt2YXIgZD1pO3JldHVybiB1K01hdGgubWluKDEqdGhpcy5zdGFsbENvdW50LGQpfX0se2tleTpcImxpdmVTeW5jUG9zaXRpb25cIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVzdGltYXRlTGl2ZUVkZ2UoKSxlPXRoaXMudGFyZ2V0TGF0ZW5jeSxyPXRoaXMubGV2ZWxEZXRhaWxzO2lmKG51bGw9PT10fHxudWxsPT09ZXx8bnVsbD09PXIpcmV0dXJuIG51bGw7dmFyIGk9ci5lZGdlLGE9dC1lLXRoaXMuZWRnZVN0YWxsZWQsbj1pLXIudG90YWxkdXJhdGlvbixzPWktKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlJiZyLnBhcnRUYXJnZXR8fHIudGFyZ2V0ZHVyYXRpb24pO3JldHVybiBNYXRoLm1pbihNYXRoLm1heChuLGEpLHMpfX0se2tleTpcImRyaWZ0XCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZXZlbERldGFpbHM7cmV0dXJuIG51bGw9PT10PzE6dC5kcmlmdH19LHtrZXk6XCJlZGdlU3RhbGxlZFwiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubGV2ZWxEZXRhaWxzO2lmKG51bGw9PT10KXJldHVybiAwO3ZhciBlPTMqKHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlJiZ0LnBhcnRUYXJnZXR8fHQudGFyZ2V0ZHVyYXRpb24pO3JldHVybiBNYXRoLm1heCh0LmFnZS1lLDApfX0se2tleTpcImZvcndhcmRCdWZmZXJMZW5ndGhcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhLGU9dGhpcy5sZXZlbERldGFpbHM7aWYoIXR8fCFlKXJldHVybiAwO3ZhciByPXQuYnVmZmVyZWQubGVuZ3RoO3JldHVybiByP3QuYnVmZmVyZWQuZW5kKHItMSk6ZS5lZGdlLXRoaXMuY3VycmVudFRpbWV9fV0pJiZQKGUucHJvdG90eXBlLHIpLHR9KCk7ZnVuY3Rpb24gTih0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgaT1lW3JdO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19IWZ1bmN0aW9uKHQpe3QuTm89XCJcIix0Llllcz1cIllFU1wiLHQudjI9XCJ2MlwifShGfHwoRj17fSkpO3ZhciBCPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscil7dGhpcy5tc249dm9pZCAwLHRoaXMucGFydD12b2lkIDAsdGhpcy5za2lwPXZvaWQgMCx0aGlzLm1zbj10LHRoaXMucGFydD1lLHRoaXMuc2tpcD1yfXJldHVybiB0LnByb3RvdHlwZS5hZGREaXJlY3RpdmVzPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBzZWxmLlVSTCh0KTtyZXR1cm4gdm9pZCAwIT09dGhpcy5tc24mJmUuc2VhcmNoUGFyYW1zLnNldChcIl9ITFNfbXNuXCIsdGhpcy5tc24udG9TdHJpbmcoKSksdm9pZCAwIT09dGhpcy5wYXJ0JiZlLnNlYXJjaFBhcmFtcy5zZXQoXCJfSExTX3BhcnRcIix0aGlzLnBhcnQudG9TdHJpbmcoKSksdGhpcy5za2lwJiZlLnNlYXJjaFBhcmFtcy5zZXQoXCJfSExTX3NraXBcIix0aGlzLnNraXApLGUudG9TdHJpbmcoKX0sdH0oKSxVPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmF0dHJzPXZvaWQgMCx0aGlzLmF1ZGlvQ29kZWM9dm9pZCAwLHRoaXMuYml0cmF0ZT12b2lkIDAsdGhpcy5jb2RlY1NldD12b2lkIDAsdGhpcy5oZWlnaHQ9dm9pZCAwLHRoaXMuaWQ9dm9pZCAwLHRoaXMubmFtZT12b2lkIDAsdGhpcy52aWRlb0NvZGVjPXZvaWQgMCx0aGlzLndpZHRoPXZvaWQgMCx0aGlzLnVua25vd25Db2RlY3M9dm9pZCAwLHRoaXMuYXVkaW9Hcm91cElkcz12b2lkIDAsdGhpcy5kZXRhaWxzPXZvaWQgMCx0aGlzLmZyYWdtZW50RXJyb3I9MCx0aGlzLmxvYWRFcnJvcj0wLHRoaXMubG9hZGVkPXZvaWQgMCx0aGlzLnJlYWxCaXRyYXRlPTAsdGhpcy50ZXh0R3JvdXBJZHM9dm9pZCAwLHRoaXMudXJsPXZvaWQgMCx0aGlzLl91cmxJZD0wLHRoaXMudXJsPVt0LnVybF0sdGhpcy5hdHRycz10LmF0dHJzLHRoaXMuYml0cmF0ZT10LmJpdHJhdGUsdC5kZXRhaWxzJiYodGhpcy5kZXRhaWxzPXQuZGV0YWlscyksdGhpcy5pZD10LmlkfHwwLHRoaXMubmFtZT10Lm5hbWUsdGhpcy53aWR0aD10LndpZHRofHwwLHRoaXMuaGVpZ2h0PXQuaGVpZ2h0fHwwLHRoaXMuYXVkaW9Db2RlYz10LmF1ZGlvQ29kZWMsdGhpcy52aWRlb0NvZGVjPXQudmlkZW9Db2RlYyx0aGlzLnVua25vd25Db2RlY3M9dC51bmtub3duQ29kZWNzLHRoaXMuY29kZWNTZXQ9W3QudmlkZW9Db2RlYyx0LmF1ZGlvQ29kZWNdLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSkuam9pbihcIixcIikucmVwbGFjZSgvXFwuW14uLF0rL2csXCJcIil9dmFyIGUscjtyZXR1cm4gZT10LChyPVt7a2V5OlwibWF4Qml0cmF0ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1heCh0aGlzLnJlYWxCaXRyYXRlLHRoaXMuYml0cmF0ZSl9fSx7a2V5OlwidXJpXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXJsW3RoaXMuX3VybElkXXx8XCJcIn19LHtrZXk6XCJ1cmxJZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91cmxJZH0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXQldGhpcy51cmwubGVuZ3RoO3RoaXMuX3VybElkIT09ZSYmKHRoaXMuZGV0YWlscz12b2lkIDAsdGhpcy5fdXJsSWQ9ZSl9fV0pJiZOKGUucHJvdG90eXBlLHIpLHR9KCk7ZnVuY3Rpb24gRyh0LGUscil7c3dpdGNoKGUpe2Nhc2VcImF1ZGlvXCI6dC5hdWRpb0dyb3VwSWRzfHwodC5hdWRpb0dyb3VwSWRzPVtdKSx0LmF1ZGlvR3JvdXBJZHMucHVzaChyKTticmVhaztjYXNlXCJ0ZXh0XCI6dC50ZXh0R3JvdXBJZHN8fCh0LnRleHRHcm91cElkcz1bXSksdC50ZXh0R3JvdXBJZHMucHVzaChyKX19ZnVuY3Rpb24gaih0KXt2YXIgZT17fTt0LmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciByPXQuZ3JvdXBJZHx8XCJcIjt0LmlkPWVbcl09ZVtyXXx8MCxlW3JdKyt9KSl9ZnVuY3Rpb24gSCh0LGUpe3ZhciByPWUuc3RhcnRQVFM7aWYoT2JqZWN0KGEuYSkocikpe3ZhciBpLG49MDtlLnNuPnQuc24/KG49ci10LnN0YXJ0LGk9dCk6KG49dC5zdGFydC1yLGk9ZSksaS5kdXJhdGlvbiE9PW4mJihpLmR1cmF0aW9uPW4pfWVsc2UgZS5zbj50LnNuP3QuY2M9PT1lLmNjJiZ0Lm1pbkVuZFBUUz9lLnN0YXJ0PXQuc3RhcnQrKHQubWluRW5kUFRTLXQuc3RhcnQpOmUuc3RhcnQ9dC5zdGFydCt0LmR1cmF0aW9uOmUuc3RhcnQ9TWF0aC5tYXgodC5zdGFydC1lLmR1cmF0aW9uLDApfWZ1bmN0aW9uIEsodCxlLHIsaSxuLHMpe2ktcjw9MCYmKG8uYi53YXJuKFwiRnJhZ21lbnQgc2hvdWxkIGhhdmUgYSBwb3NpdGl2ZSBkdXJhdGlvblwiLGUpLGk9citlLmR1cmF0aW9uLHM9bitlLmR1cmF0aW9uKTt2YXIgbD1yLHU9aSxkPWUuc3RhcnRQVFMsaD1lLmVuZFBUUztpZihPYmplY3QoYS5hKShkKSl7dmFyIGY9TWF0aC5hYnMoZC1yKTtPYmplY3QoYS5hKShlLmRlbHRhUFRTKT9lLmRlbHRhUFRTPU1hdGgubWF4KGYsZS5kZWx0YVBUUyk6ZS5kZWx0YVBUUz1mLGw9TWF0aC5tYXgocixkKSxyPU1hdGgubWluKHIsZCksbj1NYXRoLm1pbihuLGUuc3RhcnREVFMpLHU9TWF0aC5taW4oaSxoKSxpPU1hdGgubWF4KGksaCkscz1NYXRoLm1heChzLGUuZW5kRFRTKX1lLmR1cmF0aW9uPWktcjt2YXIgYz1yLWUuc3RhcnQ7ZS5hcHBlbmRlZFBUUz1pLGUuc3RhcnQ9ZS5zdGFydFBUUz1yLGUubWF4U3RhcnRQVFM9bCxlLnN0YXJ0RFRTPW4sZS5lbmRQVFM9aSxlLm1pbkVuZFBUUz11LGUuZW5kRFRTPXM7dmFyIHYsZz1lLnNuO2lmKCF0fHxnPHQuc3RhcnRTTnx8Zz50LmVuZFNOKXJldHVybiAwO3ZhciBwPWctdC5zdGFydFNOLG09dC5mcmFnbWVudHM7Zm9yKG1bcF09ZSx2PXA7dj4wO3YtLSlIKG1bdl0sbVt2LTFdKTtmb3Iodj1wO3Y8bS5sZW5ndGgtMTt2KyspSChtW3ZdLG1bdisxXSk7cmV0dXJuIHQuZnJhZ21lbnRIaW50JiZIKG1bbS5sZW5ndGgtMV0sdC5mcmFnbWVudEhpbnQpLHQuUFRTS25vd249dC5hbGlnbmVkU2xpZGluZz0hMCxjfWZ1bmN0aW9uIFYodCxlKXtmb3IodmFyIHI9bnVsbCxpPXQuZnJhZ21lbnRzLG49aS5sZW5ndGgtMTtuPj0wO24tLSl7dmFyIHM9aVtuXS5pbml0U2VnbWVudDtpZihzKXtyPXM7YnJlYWt9fXQuZnJhZ21lbnRIaW50JiZkZWxldGUgdC5mcmFnbWVudEhpbnQuZW5kUFRTO3ZhciBsLHU9MDtpZihmdW5jdGlvbih0LGUscil7Zm9yKHZhciBpPWUuc2tpcHBlZFNlZ21lbnRzLGE9TWF0aC5tYXgodC5zdGFydFNOLGUuc3RhcnRTTiktZS5zdGFydFNOLG49KHQuZnJhZ21lbnRIaW50PzE6MCkrKGk/ZS5lbmRTTjpNYXRoLm1pbih0LmVuZFNOLGUuZW5kU04pKS1lLnN0YXJ0U04scz1lLnN0YXJ0U04tdC5zdGFydFNOLG89ZS5mcmFnbWVudEhpbnQ/ZS5mcmFnbWVudHMuY29uY2F0KGUuZnJhZ21lbnRIaW50KTplLmZyYWdtZW50cyxsPXQuZnJhZ21lbnRIaW50P3QuZnJhZ21lbnRzLmNvbmNhdCh0LmZyYWdtZW50SGludCk6dC5mcmFnbWVudHMsdT1hO3U8PW47dSsrKXt2YXIgZD1sW3MrdV0saD1vW3VdO2kmJiFoJiZ1PGkmJihoPWUuZnJhZ21lbnRzW3VdPWQpLGQmJmgmJnIoZCxoKX19KHQsZSwoZnVuY3Rpb24odCxpKXt0LnJlbHVybCYmKHU9dC5jYy1pLmNjKSxPYmplY3QoYS5hKSh0LnN0YXJ0UFRTKSYmT2JqZWN0KGEuYSkodC5lbmRQVFMpJiYoaS5zdGFydD1pLnN0YXJ0UFRTPXQuc3RhcnRQVFMsaS5zdGFydERUUz10LnN0YXJ0RFRTLGkuYXBwZW5kZWRQVFM9dC5hcHBlbmRlZFBUUyxpLm1heFN0YXJ0UFRTPXQubWF4U3RhcnRQVFMsaS5lbmRQVFM9dC5lbmRQVFMsaS5lbmREVFM9dC5lbmREVFMsaS5taW5FbmRQVFM9dC5taW5FbmRQVFMsaS5kdXJhdGlvbj10LmVuZFBUUy10LnN0YXJ0UFRTLGkuZHVyYXRpb24mJihsPWkpLGUuUFRTS25vd249ZS5hbGlnbmVkU2xpZGluZz0hMCksaS5lbGVtZW50YXJ5U3RyZWFtcz10LmVsZW1lbnRhcnlTdHJlYW1zLGkubG9hZGVyPXQubG9hZGVyLGkuc3RhdHM9dC5zdGF0cyxpLnVybElkPXQudXJsSWQsdC5pbml0U2VnbWVudCYmKGkuaW5pdFNlZ21lbnQ9dC5pbml0U2VnbWVudCxyPXQuaW5pdFNlZ21lbnQpfSkpLHImJihlLmZyYWdtZW50SGludD9lLmZyYWdtZW50cy5jb25jYXQoZS5mcmFnbWVudEhpbnQpOmUuZnJhZ21lbnRzKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZTt0LmluaXRTZWdtZW50JiZ0LmluaXRTZWdtZW50LnJlbHVybCE9PShudWxsPT09KGU9cil8fHZvaWQgMD09PWU/dm9pZCAwOmUucmVsdXJsKXx8KHQuaW5pdFNlZ21lbnQ9cil9KSksZS5za2lwcGVkU2VnbWVudHMmJihlLmRlbHRhVXBkYXRlRmFpbGVkPWUuZnJhZ21lbnRzLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiF0fSkpLGUuZGVsdGFVcGRhdGVGYWlsZWQpKXtvLmIud2FybihcIltsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdFwiKTtmb3IodmFyIGQ9ZS5za2lwcGVkU2VnbWVudHM7ZC0tOyllLmZyYWdtZW50cy5zaGlmdCgpO2Uuc3RhcnRTTj1lLmZyYWdtZW50c1swXS5zbixlLnN0YXJ0Q0M9ZS5mcmFnbWVudHNbMF0uY2N9dmFyIGg9ZS5mcmFnbWVudHM7aWYodSl7by5iLndhcm4oXCJkaXNjb250aW51aXR5IHNsaWRpbmcgZnJvbSBwbGF5bGlzdCwgdGFrZSBkcmlmdCBpbnRvIGFjY291bnRcIik7Zm9yKHZhciBmPTA7ZjxoLmxlbmd0aDtmKyspaFtmXS5jYys9dX1lLnNraXBwZWRTZWdtZW50cyYmKGUuc3RhcnRDQz1lLmZyYWdtZW50c1swXS5jYyksZnVuY3Rpb24odCxlLHIpe2lmKHQmJmUpZm9yKHZhciBpPTAsYT0wLG49dC5sZW5ndGg7YTw9bjthKyspe3ZhciBzPXRbYV0sbz1lW2EraV07cyYmbyYmcy5pbmRleD09PW8uaW5kZXgmJnMuZnJhZ21lbnQuc249PT1vLmZyYWdtZW50LnNuP3IocyxvKTppLS19fSh0LnBhcnRMaXN0LGUucGFydExpc3QsKGZ1bmN0aW9uKHQsZSl7ZS5lbGVtZW50YXJ5U3RyZWFtcz10LmVsZW1lbnRhcnlTdHJlYW1zLGUuc3RhdHM9dC5zdGF0c30pKSxsP0soZSxsLGwuc3RhcnRQVFMsbC5lbmRQVFMsbC5zdGFydERUUyxsLmVuZERUUyk6Vyh0LGUpLGgubGVuZ3RoJiYoZS50b3RhbGR1cmF0aW9uPWUuZWRnZS1oWzBdLnN0YXJ0KSxlLmRyaWZ0U3RhcnRUaW1lPXQuZHJpZnRTdGFydFRpbWUsZS5kcmlmdFN0YXJ0PXQuZHJpZnRTdGFydDt2YXIgYz1lLmFkdmFuY2VkRGF0ZVRpbWU7aWYoZS5hZHZhbmNlZCYmYyl7dmFyIHY9ZS5lZGdlO2UuZHJpZnRTdGFydHx8KGUuZHJpZnRTdGFydFRpbWU9YyxlLmRyaWZ0U3RhcnQ9diksZS5kcmlmdEVuZFRpbWU9YyxlLmRyaWZ0RW5kPXZ9ZWxzZSBlLmRyaWZ0RW5kVGltZT10LmRyaWZ0RW5kVGltZSxlLmRyaWZ0RW5kPXQuZHJpZnRFbmQsZS5hZHZhbmNlZERhdGVUaW1lPXQuYWR2YW5jZWREYXRlVGltZX1mdW5jdGlvbiBXKHQsZSl7dmFyIHI9ZS5zdGFydFNOK2Uuc2tpcHBlZFNlZ21lbnRzLXQuc3RhcnRTTixpPXQuZnJhZ21lbnRzO3I8MHx8cj49aS5sZW5ndGh8fGZ1bmN0aW9uKHQsZSl7aWYoZSl7Zm9yKHZhciByPXQuZnJhZ21lbnRzLGk9dC5za2lwcGVkU2VnbWVudHM7aTxyLmxlbmd0aDtpKyspcltpXS5zdGFydCs9ZTt0LmZyYWdtZW50SGludCYmKHQuZnJhZ21lbnRIaW50LnN0YXJ0Kz1lKX19KGUsaVtyXS5zdGFydCl9dmFyIFk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5obHM9dm9pZCAwLHRoaXMudGltZXI9LTEsdGhpcy5jYW5Mb2FkPSExLHRoaXMucmV0cnlDb3VudD0wLHRoaXMubG9nPXZvaWQgMCx0aGlzLndhcm49dm9pZCAwLHRoaXMubG9nPW8uYi5sb2cuYmluZChvLmIsZStcIjpcIiksdGhpcy53YXJuPW8uYi53YXJuLmJpbmQoby5iLGUrXCI6XCIpLHRoaXMuaGxzPXR9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuY2xlYXJUaW1lcigpLHRoaXMuaGxzPXRoaXMubG9nPXRoaXMud2Fybj1udWxsfSxlLm9uRXJyb3I9ZnVuY3Rpb24odCxlKXtlLmZhdGFsJiZlLnR5cGU9PT1zLmIuTkVUV09SS19FUlJPUiYmdGhpcy5jbGVhclRpbWVyKCl9LGUuY2xlYXJUaW1lcj1mdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aGlzLnRpbWVyKSx0aGlzLnRpbWVyPS0xfSxlLnN0YXJ0TG9hZD1mdW5jdGlvbigpe3RoaXMuY2FuTG9hZD0hMCx0aGlzLnJldHJ5Q291bnQ9MCx0aGlzLmxvYWRQbGF5bGlzdCgpfSxlLnN0b3BMb2FkPWZ1bmN0aW9uKCl7dGhpcy5jYW5Mb2FkPSExLHRoaXMuY2xlYXJUaW1lcigpfSxlLnN3aXRjaFBhcmFtcz1mdW5jdGlvbih0LGUpe3ZhciByPW51bGw9PWU/dm9pZCAwOmUucmVuZGl0aW9uUmVwb3J0cztpZihyKWZvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbj1yW2ldLHM9XCJcIituLlVSSTtpZihzPT09dC5zdWJzdHIoLXMubGVuZ3RoKSl7dmFyIG89cGFyc2VJbnQobltcIkxBU1QtTVNOXCJdKSxsPXBhcnNlSW50KG5bXCJMQVNULVBBUlRcIl0pO2lmKGUmJnRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSl7dmFyIHU9TWF0aC5taW4oZS5hZ2UtZS5wYXJ0VGFyZ2V0LGUudGFyZ2V0ZHVyYXRpb24pO3ZvaWQgMCE9PWwmJnU+ZS5wYXJ0VGFyZ2V0JiYobCs9MSl9aWYoT2JqZWN0KGEuYSkobykpcmV0dXJuIG5ldyBCKG8sT2JqZWN0KGEuYSkobCk/bDp2b2lkIDAsRi5Obyl9fX0sZS5sb2FkUGxheWxpc3Q9ZnVuY3Rpb24odCl7fSxlLnNob3VsZExvYWRUcmFjaz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYW5Mb2FkJiZ0JiYhIXQudXJsJiYoIXQuZGV0YWlsc3x8dC5kZXRhaWxzLmxpdmUpfSxlLnBsYXlsaXN0TG9hZGVkPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT10aGlzLGE9ZS5kZXRhaWxzLG49ZS5zdGF0cyxzPW4ubG9hZGluZy5lbmQ/TWF0aC5tYXgoMCxzZWxmLnBlcmZvcm1hbmNlLm5vdygpLW4ubG9hZGluZy5lbmQpOjA7aWYoYS5hZHZhbmNlZERhdGVUaW1lPURhdGUubm93KCktcyxhLmxpdmV8fG51bGwhPXImJnIubGl2ZSl7aWYoYS5yZWxvYWRlZChyKSxyJiZ0aGlzLmxvZyhcImxpdmUgcGxheWxpc3QgXCIrdCtcIiBcIisoYS5hZHZhbmNlZD9cIlJFRlJFU0hFRCBcIithLmxhc3RQYXJ0U24rXCItXCIrYS5sYXN0UGFydEluZGV4OlwiTUlTU0VEXCIpKSxyJiZhLmZyYWdtZW50cy5sZW5ndGg+MCYmVihyLGEpLCF0aGlzLmNhbkxvYWR8fCFhLmxpdmUpcmV0dXJuO3ZhciBvLGw9dm9pZCAwLHU9dm9pZCAwO2lmKGEuY2FuQmxvY2tSZWxvYWQmJmEuZW5kU04mJmEuYWR2YW5jZWQpe3ZhciBkPXRoaXMuaGxzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSxoPWEubGFzdFBhcnRTbixmPWEuZW5kU04sYz1hLmxhc3RQYXJ0SW5kZXgsdj1oPT09ZjstMSE9PWM/KGw9dj9mKzE6aCx1PXY/ZD8wOmM6YysxKTpsPWYrMTt2YXIgZz1hLmFnZSxwPWcrYS5hZ2VIZWFkZXIsbT1NYXRoLm1pbihwLWEucGFydFRhcmdldCwxLjUqYS50YXJnZXRkdXJhdGlvbik7aWYobT4wKXtpZihyJiZtPnIudHVuZUluR29hbCl0aGlzLndhcm4oXCJDRE4gVHVuZS1pbiBnb2FsIGluY3JlYXNlZCBmcm9tOiBcIityLnR1bmVJbkdvYWwrXCIgdG86IFwiK20rXCIgd2l0aCBwbGF5bGlzdCBhZ2U6IFwiK2EuYWdlKSxtPTA7ZWxzZXt2YXIgeT1NYXRoLmZsb29yKG0vYS50YXJnZXRkdXJhdGlvbik7bCs9eSx2b2lkIDAhPT11JiYodSs9TWF0aC5yb3VuZChtJWEudGFyZ2V0ZHVyYXRpb24vYS5wYXJ0VGFyZ2V0KSksdGhpcy5sb2coXCJDRE4gVHVuZS1pbiBhZ2U6IFwiK2EuYWdlSGVhZGVyK1wicyBsYXN0IGFkdmFuY2VkIFwiK2cudG9GaXhlZCgyKStcInMgZ29hbDogXCIrbStcIiBza2lwIHNuIFwiK3krXCIgdG8gcGFydCBcIit1KX1hLnR1bmVJbkdvYWw9bX1pZihvPXRoaXMuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzKGEsZS5kZWxpdmVyeURpcmVjdGl2ZXMsbCx1KSxkfHwhdilyZXR1cm4gdm9pZCB0aGlzLmxvYWRQbGF5bGlzdChvKX1lbHNlIG89dGhpcy5nZXREZWxpdmVyeURpcmVjdGl2ZXMoYSxlLmRlbGl2ZXJ5RGlyZWN0aXZlcyxsLHUpO3ZhciBiPWZ1bmN0aW9uKHQsZSl7dmFyIHIsaT0xZTMqdC5sZXZlbFRhcmdldER1cmF0aW9uLGE9aS8yLG49dC5hZ2Uscz1uPjAmJm48MyppLG89ZS5sb2FkaW5nLmVuZC1lLmxvYWRpbmcuc3RhcnQsbD10LmF2YWlsYWJpbGl0eURlbGF5O2lmKCExPT09dC51cGRhdGVkKWlmKHMpe3ZhciB1PTMzMyp0Lm1pc3NlcztyPU1hdGgubWF4KE1hdGgubWluKGEsMipvKSx1KSx0LmF2YWlsYWJpbGl0eURlbGF5PSh0LmF2YWlsYWJpbGl0eURlbGF5fHwwKStyfWVsc2Ugcj1hO2Vsc2Ugcz8obD1NYXRoLm1pbihsfHxpLzIsbiksdC5hdmFpbGFiaWxpdHlEZWxheT1sLHI9bCtpLW4pOnI9aS1vO3JldHVybiBNYXRoLnJvdW5kKHIpfShhLG4pO3ZvaWQgMCE9PWwmJmEuY2FuQmxvY2tSZWxvYWQmJihiLT1hLnBhcnRUYXJnZXR8fDEpLHRoaXMubG9nKFwicmVsb2FkIGxpdmUgcGxheWxpc3QgXCIrdCtcIiBpbiBcIitNYXRoLnJvdW5kKGIpK1wiIG1zXCIpLHRoaXMudGltZXI9c2VsZi5zZXRUaW1lb3V0KChmdW5jdGlvbigpe3JldHVybiBpLmxvYWRQbGF5bGlzdChvKX0pLGIpfWVsc2UgdGhpcy5jbGVhclRpbWVyKCl9LGUuZ2V0RGVsaXZlcnlEaXJlY3RpdmVzPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5jYW5Ta2lwVW50aWwsaT10LmNhblNraXBEYXRlUmFuZ2VzLGE9dC5lbmRTTjtyZXR1cm4gciYmKHZvaWQgMCE9PWU/ZS1hOjApPHI/aT9GLnYyOkYuWWVzOkYuTm99KHQscik7cmV0dXJuIG51bGwhPWUmJmUuc2tpcCYmdC5kZWx0YVVwZGF0ZUZhaWxlZCYmKHI9ZS5tc24saT1lLnBhcnQsYT1GLk5vKSxuZXcgQihyLGksYSl9LGUucmV0cnlMb2FkaW5nT3JGYWlsPWZ1bmN0aW9uKHQpe3ZhciBlLHI9dGhpcyxpPXRoaXMuaGxzLmNvbmZpZyxhPXRoaXMucmV0cnlDb3VudDxpLmxldmVsTG9hZGluZ01heFJldHJ5O2lmKGEpaWYodGhpcy5yZXRyeUNvdW50KyssdC5kZXRhaWxzLmluZGV4T2YoXCJMb2FkVGltZU91dFwiKT4tMSYmbnVsbCE9PShlPXQuY29udGV4dCkmJnZvaWQgMCE9PWUmJmUuZGVsaXZlcnlEaXJlY3RpdmVzKXRoaXMud2FybihcInJldHJ5IHBsYXlsaXN0IGxvYWRpbmcgI1wiK3RoaXMucmV0cnlDb3VudCsnIGFmdGVyIFwiJyt0LmRldGFpbHMrJ1wiJyksdGhpcy5sb2FkUGxheWxpc3QoKTtlbHNle3ZhciBuPU1hdGgubWluKE1hdGgucG93KDIsdGhpcy5yZXRyeUNvdW50KSppLmxldmVsTG9hZGluZ1JldHJ5RGVsYXksaS5sZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQpO3RoaXMudGltZXI9c2VsZi5zZXRUaW1lb3V0KChmdW5jdGlvbigpe3JldHVybiByLmxvYWRQbGF5bGlzdCgpfSksbiksdGhpcy53YXJuKFwicmV0cnkgcGxheWxpc3QgbG9hZGluZyAjXCIrdGhpcy5yZXRyeUNvdW50K1wiIGluIFwiK24rJyBtcyBhZnRlciBcIicrdC5kZXRhaWxzKydcIicpfWVsc2UgdGhpcy53YXJuKCdjYW5ub3QgcmVjb3ZlciBmcm9tIGVycm9yIFwiJyt0LmRldGFpbHMrJ1wiJyksdGhpcy5jbGVhclRpbWVyKCksdC5mYXRhbD0hMDtyZXR1cm4gYX0sdH0oKTtmdW5jdGlvbiBYKCl7cmV0dXJuKFg9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHI9YXJndW1lbnRzW2VdO2Zvcih2YXIgaSBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGkpJiYodFtpXT1yW2ldKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBxKHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBpPWVbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX1mdW5jdGlvbiB6KHQsZSl7cmV0dXJuKHo9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfXZhciBRLCQ9L2Nocm9tZXxmaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSksWj1mdW5jdGlvbih0KXt2YXIgZSxyO2Z1bmN0aW9uIGkoZSl7dmFyIHI7cmV0dXJuKHI9dC5jYWxsKHRoaXMsZSxcIltsZXZlbC1jb250cm9sbGVyXVwiKXx8dGhpcykuX2xldmVscz1bXSxyLl9maXJzdExldmVsPS0xLHIuX3N0YXJ0TGV2ZWw9dm9pZCAwLHIuY3VycmVudExldmVsSW5kZXg9LTEsci5tYW51YWxMZXZlbEluZGV4PS0xLHIub25QYXJzZWRDb21wbGV0ZT12b2lkIDAsci5fcmVnaXN0ZXJMaXN0ZW5lcnMoKSxyfXI9dCwoZT1pKS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSx6KGUscik7dmFyIGEsbyxsPWkucHJvdG90eXBlO3JldHVybiBsLl9yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub24obi5hLk1BTklGRVNUX0xPQURFRCx0aGlzLm9uTWFuaWZlc3RMb2FkZWQsdGhpcyksdC5vbihuLmEuTEVWRUxfTE9BREVELHRoaXMub25MZXZlbExvYWRlZCx0aGlzKSx0Lm9uKG4uYS5BVURJT19UUkFDS19TV0lUQ0hFRCx0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLHRoaXMpLHQub24obi5hLkZSQUdfTE9BREVELHRoaXMub25GcmFnTG9hZGVkLHRoaXMpLHQub24obi5hLkVSUk9SLHRoaXMub25FcnJvcix0aGlzKX0sbC5fdW5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub2ZmKG4uYS5NQU5JRkVTVF9MT0FERUQsdGhpcy5vbk1hbmlmZXN0TG9hZGVkLHRoaXMpLHQub2ZmKG4uYS5MRVZFTF9MT0FERUQsdGhpcy5vbkxldmVsTG9hZGVkLHRoaXMpLHQub2ZmKG4uYS5BVURJT19UUkFDS19TV0lUQ0hFRCx0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLHRoaXMpLHQub2ZmKG4uYS5GUkFHX0xPQURFRCx0aGlzLm9uRnJhZ0xvYWRlZCx0aGlzKSx0Lm9mZihuLmEuRVJST1IsdGhpcy5vbkVycm9yLHRoaXMpfSxsLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5tYW51YWxMZXZlbEluZGV4PS0xLHRoaXMuX2xldmVscy5sZW5ndGg9MCx0LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyl9LGwuc3RhcnRMb2FkPWZ1bmN0aW9uKCl7dGhpcy5fbGV2ZWxzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QubG9hZEVycm9yPTB9KSksdC5wcm90b3R5cGUuc3RhcnRMb2FkLmNhbGwodGhpcyl9LGwub25NYW5pZmVzdExvYWRlZD1mdW5jdGlvbih0LGUpe3ZhciByLGksYT1bXSxvPVtdLGw9W10sdT17fSxkPSExLGg9ITEsZj0hMTtpZihlLmxldmVscy5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LmF0dHJzO2Q9ZHx8ISghdC53aWR0aHx8IXQuaGVpZ2h0KSxoPWh8fCEhdC52aWRlb0NvZGVjLGY9Znx8ISF0LmF1ZGlvQ29kZWMsJCYmdC5hdWRpb0NvZGVjJiYtMSE9PXQuYXVkaW9Db2RlYy5pbmRleE9mKFwibXA0YS40MC4zNFwiKSYmKHQuYXVkaW9Db2RlYz12b2lkIDApO3ZhciByPXQuYml0cmF0ZStcIi1cIit0LmF0dHJzLlJFU09MVVRJT04rXCItXCIrdC5hdHRycy5DT0RFQ1M7KGk9dVtyXSk/aS51cmwucHVzaCh0LnVybCk6KGk9bmV3IFUodCksdVtyXT1pLGEucHVzaChpKSksZSYmKGUuQVVESU8mJkcoaSxcImF1ZGlvXCIsZS5BVURJTyksZS5TVUJUSVRMRVMmJkcoaSxcInRleHRcIixlLlNVQlRJVExFUykpfSkpLChkfHxoKSYmZiYmKGE9YS5maWx0ZXIoKGZ1bmN0aW9uKHQpe3ZhciBlPXQudmlkZW9Db2RlYyxyPXQud2lkdGgsaT10LmhlaWdodDtyZXR1cm4hIWV8fCEoIXJ8fCFpKX0pKSksYT1hLmZpbHRlcigoZnVuY3Rpb24odCl7dmFyIGU9dC5hdWRpb0NvZGVjLHI9dC52aWRlb0NvZGVjO3JldHVybighZXx8bShlLFwiYXVkaW9cIikpJiYoIXJ8fG0ocixcInZpZGVvXCIpKX0pKSxlLmF1ZGlvVHJhY2tzJiZqKG89ZS5hdWRpb1RyYWNrcy5maWx0ZXIoKGZ1bmN0aW9uKHQpe3JldHVybiF0LmF1ZGlvQ29kZWN8fG0odC5hdWRpb0NvZGVjLFwiYXVkaW9cIil9KSkpLGUuc3VidGl0bGVzJiZqKGw9ZS5zdWJ0aXRsZXMpLGEubGVuZ3RoPjApe3I9YVswXS5iaXRyYXRlLGEuc29ydCgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5iaXRyYXRlLWUuYml0cmF0ZX0pKSx0aGlzLl9sZXZlbHM9YTtmb3IodmFyIGM9MDtjPGEubGVuZ3RoO2MrKylpZihhW2NdLmJpdHJhdGU9PT1yKXt0aGlzLl9maXJzdExldmVsPWMsdGhpcy5sb2coXCJtYW5pZmVzdCBsb2FkZWQsIFwiK2EubGVuZ3RoK1wiIGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiBcIityKTticmVha312YXIgdj1mJiYhaCxnPXtsZXZlbHM6YSxhdWRpb1RyYWNrczpvLHN1YnRpdGxlVHJhY2tzOmwsZmlyc3RMZXZlbDp0aGlzLl9maXJzdExldmVsLHN0YXRzOmUuc3RhdHMsYXVkaW86Zix2aWRlbzpoLGFsdEF1ZGlvOiF2JiZvLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiEhdC51cmx9KSl9O3RoaXMuaGxzLnRyaWdnZXIobi5hLk1BTklGRVNUX1BBUlNFRCxnKSwodGhpcy5obHMuY29uZmlnLmF1dG9TdGFydExvYWR8fHRoaXMuaGxzLmZvcmNlU3RhcnRMb2FkKSYmdGhpcy5obHMuc3RhcnRMb2FkKHRoaXMuaGxzLmNvbmZpZy5zdGFydFBvc2l0aW9uKX1lbHNlIHRoaXMuaGxzLnRyaWdnZXIobi5hLkVSUk9SLHt0eXBlOnMuYi5NRURJQV9FUlJPUixkZXRhaWxzOnMuYS5NQU5JRkVTVF9JTkNPTVBBVElCTEVfQ09ERUNTX0VSUk9SLGZhdGFsOiEwLHVybDplLnVybCxyZWFzb246XCJubyBsZXZlbCB3aXRoIGNvbXBhdGlibGUgY29kZWNzIGZvdW5kIGluIG1hbmlmZXN0XCJ9KX0sbC5vbkVycm9yPWZ1bmN0aW9uKGUscil7aWYodC5wcm90b3R5cGUub25FcnJvci5jYWxsKHRoaXMsZSxyKSwhci5mYXRhbCl7dmFyIGk9ci5jb250ZXh0LGE9dGhpcy5fbGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO2lmKGkmJihpLnR5cGU9PT1fLmEuQVVESU9fVFJBQ0smJmEuYXVkaW9Hcm91cElkcyYmaS5ncm91cElkPT09YS5hdWRpb0dyb3VwSWRzW2EudXJsSWRdfHxpLnR5cGU9PT1fLmEuU1VCVElUTEVfVFJBQ0smJmEudGV4dEdyb3VwSWRzJiZpLmdyb3VwSWQ9PT1hLnRleHRHcm91cElkc1thLnVybElkXSkpdGhpcy5yZWR1bmRhbnRGYWlsb3Zlcih0aGlzLmN1cnJlbnRMZXZlbEluZGV4KTtlbHNle3ZhciBuLG89ITEsbD0hMDtzd2l0Y2goci5kZXRhaWxzKXtjYXNlIHMuYS5GUkFHX0xPQURfRVJST1I6Y2FzZSBzLmEuRlJBR19MT0FEX1RJTUVPVVQ6Y2FzZSBzLmEuS0VZX0xPQURfRVJST1I6Y2FzZSBzLmEuS0VZX0xPQURfVElNRU9VVDppZihyLmZyYWcpe3ZhciB1PXRoaXMuX2xldmVsc1tyLmZyYWcubGV2ZWxdO3U/KHUuZnJhZ21lbnRFcnJvcisrLHUuZnJhZ21lbnRFcnJvcj50aGlzLmhscy5jb25maWcuZnJhZ0xvYWRpbmdNYXhSZXRyeSYmKG49ci5mcmFnLmxldmVsKSk6bj1yLmZyYWcubGV2ZWx9YnJlYWs7Y2FzZSBzLmEuTEVWRUxfTE9BRF9FUlJPUjpjYXNlIHMuYS5MRVZFTF9MT0FEX1RJTUVPVVQ6aSYmKGkuZGVsaXZlcnlEaXJlY3RpdmVzJiYobD0hMSksbj1pLmxldmVsKSxvPSEwO2JyZWFrO2Nhc2Ugcy5hLlJFTVVYX0FMTE9DX0VSUk9SOm49ci5sZXZlbCxvPSEwfXZvaWQgMCE9PW4mJnRoaXMucmVjb3ZlckxldmVsKHIsbixvLGwpfX19LGwucmVjb3ZlckxldmVsPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXQuZGV0YWlscyxuPXRoaXMuX2xldmVsc1tlXTtpZihuLmxvYWRFcnJvcisrLHIpe2lmKCF0aGlzLnJldHJ5TG9hZGluZ09yRmFpbCh0KSlyZXR1cm4gdm9pZCh0aGlzLmN1cnJlbnRMZXZlbEluZGV4PS0xKTt0LmxldmVsUmV0cnk9ITB9aWYoaSl7dmFyIHM9bi51cmwubGVuZ3RoO2lmKHM+MSYmbi5sb2FkRXJyb3I8cyl0LmxldmVsUmV0cnk9ITAsdGhpcy5yZWR1bmRhbnRGYWlsb3ZlcihlKTtlbHNlIGlmKC0xPT09dGhpcy5tYW51YWxMZXZlbEluZGV4KXt2YXIgbz0wPT09ZT90aGlzLl9sZXZlbHMubGVuZ3RoLTE6ZS0xO3RoaXMuY3VycmVudExldmVsSW5kZXghPT1vJiYwPT09dGhpcy5fbGV2ZWxzW29dLmxvYWRFcnJvciYmKHRoaXMud2FybihhK1wiOiBzd2l0Y2ggdG8gXCIrbyksdC5sZXZlbFJldHJ5PSEwLHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw9byl9fX0sbC5yZWR1bmRhbnRGYWlsb3Zlcj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9sZXZlbHNbdF0scj1lLnVybC5sZW5ndGg7aWYocj4xKXt2YXIgaT0oZS51cmxJZCsxKSVyO3RoaXMud2FybihcIlN3aXRjaGluZyB0byByZWR1bmRhbnQgVVJMLWlkIFwiK2kpLHRoaXMuX2xldmVscy5mb3JFYWNoKChmdW5jdGlvbih0KXt0LnVybElkPWl9KSksdGhpcy5sZXZlbD10fX0sbC5vbkZyYWdMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmZyYWc7aWYodm9pZCAwIT09ciYmci50eXBlPT09Xy5iLk1BSU4pe3ZhciBpPXRoaXMuX2xldmVsc1tyLmxldmVsXTt2b2lkIDAhPT1pJiYoaS5mcmFnbWVudEVycm9yPTAsaS5sb2FkRXJyb3I9MCl9fSxsLm9uTGV2ZWxMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcixpLGE9ZS5sZXZlbCxuPWUuZGV0YWlscyxzPXRoaXMuX2xldmVsc1thXTtpZighcylyZXR1cm4gdGhpcy53YXJuKFwiSW52YWxpZCBsZXZlbCBpbmRleCBcIithKSx2b2lkKG51bGwhPT0oaT1lLmRlbGl2ZXJ5RGlyZWN0aXZlcykmJnZvaWQgMCE9PWkmJmkuc2tpcCYmKG4uZGVsdGFVcGRhdGVGYWlsZWQ9ITApKTthPT09dGhpcy5jdXJyZW50TGV2ZWxJbmRleD8oMD09PXMuZnJhZ21lbnRFcnJvciYmKHMubG9hZEVycm9yPTAsdGhpcy5yZXRyeUNvdW50PTApLHRoaXMucGxheWxpc3RMb2FkZWQoYSxlLHMuZGV0YWlscykpOm51bGwhPT0ocj1lLmRlbGl2ZXJ5RGlyZWN0aXZlcykmJnZvaWQgMCE9PXImJnIuc2tpcCYmKG4uZGVsdGFVcGRhdGVGYWlsZWQ9ITApfSxsLm9uQXVkaW9UcmFja1N3aXRjaGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5obHMubGV2ZWxzW3RoaXMuY3VycmVudExldmVsSW5kZXhdO2lmKHImJnIuYXVkaW9Hcm91cElkcyl7Zm9yKHZhciBpPS0xLGE9dGhpcy5obHMuYXVkaW9UcmFja3NbZS5pZF0uZ3JvdXBJZCxuPTA7bjxyLmF1ZGlvR3JvdXBJZHMubGVuZ3RoO24rKylpZihyLmF1ZGlvR3JvdXBJZHNbbl09PT1hKXtpPW47YnJlYWt9aSE9PXIudXJsSWQmJihyLnVybElkPWksdGhpcy5zdGFydExvYWQoKSl9fSxsLmxvYWRQbGF5bGlzdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmN1cnJlbnRMZXZlbEluZGV4LHI9dGhpcy5fbGV2ZWxzW2VdO2lmKHRoaXMuY2FuTG9hZCYmciYmci51cmwubGVuZ3RoPjApe3ZhciBpPXIudXJsSWQsYT1yLnVybFtpXTtpZih0KXRyeXthPXQuYWRkRGlyZWN0aXZlcyhhKX1jYXRjaCh0KXt0aGlzLndhcm4oXCJDb3VsZCBub3QgY29uc3RydWN0IG5ldyBVUkwgd2l0aCBITFMgRGVsaXZlcnkgRGlyZWN0aXZlczogXCIrdCl9dGhpcy5sb2coXCJBdHRlbXB0IGxvYWRpbmcgbGV2ZWwgaW5kZXggXCIrZSsodD9cIiBhdCBzbiBcIit0Lm1zbitcIiBwYXJ0IFwiK3QucGFydDpcIlwiKStcIiB3aXRoIFVSTC1pZCBcIitpK1wiIFwiK2EpLHRoaXMuY2xlYXJUaW1lcigpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkxFVkVMX0xPQURJTkcse3VybDphLGxldmVsOmUsaWQ6aSxkZWxpdmVyeURpcmVjdGl2ZXM6dHx8bnVsbH0pfX0sbC5yZW1vdmVMZXZlbD1mdW5jdGlvbih0LGUpe3ZhciByPWZ1bmN0aW9uKHQscil7cmV0dXJuIHIhPT1lfSxpPXRoaXMuX2xldmVscy5maWx0ZXIoKGZ1bmN0aW9uKGksYSl7cmV0dXJuIGEhPT10fHxpLnVybC5sZW5ndGg+MSYmdm9pZCAwIT09ZSYmKGkudXJsPWkudXJsLmZpbHRlcihyKSxpLmF1ZGlvR3JvdXBJZHMmJihpLmF1ZGlvR3JvdXBJZHM9aS5hdWRpb0dyb3VwSWRzLmZpbHRlcihyKSksaS50ZXh0R3JvdXBJZHMmJihpLnRleHRHcm91cElkcz1pLnRleHRHcm91cElkcy5maWx0ZXIocikpLGkudXJsSWQ9MCwhMCl9KSkubWFwKChmdW5jdGlvbih0LGUpe3ZhciByPXQuZGV0YWlscztyZXR1cm4gbnVsbCE9ciYmci5mcmFnbWVudHMmJnIuZnJhZ21lbnRzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3QubGV2ZWw9ZX0pKSx0fSkpO3RoaXMuX2xldmVscz1pLHRoaXMuaGxzLnRyaWdnZXIobi5hLkxFVkVMU19VUERBVEVELHtsZXZlbHM6aX0pfSxhPWksKG89W3trZXk6XCJsZXZlbHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuX2xldmVscy5sZW5ndGg/bnVsbDp0aGlzLl9sZXZlbHN9fSx7a2V5OlwibGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWxJbmRleH0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlLHI9dGhpcy5fbGV2ZWxzO2lmKDAhPT1yLmxlbmd0aCYmKHRoaXMuY3VycmVudExldmVsSW5kZXghPT10fHxudWxsPT09KGU9clt0XSl8fHZvaWQgMD09PWV8fCFlLmRldGFpbHMpKXtpZih0PDB8fHQ+PXIubGVuZ3RoKXt2YXIgaT10PDA7aWYodGhpcy5obHMudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk9USEVSX0VSUk9SLGRldGFpbHM6cy5hLkxFVkVMX1NXSVRDSF9FUlJPUixsZXZlbDp0LGZhdGFsOmkscmVhc29uOlwiaW52YWxpZCBsZXZlbCBpZHhcIn0pLGkpcmV0dXJuO3Q9TWF0aC5taW4odCxyLmxlbmd0aC0xKX10aGlzLmNsZWFyVGltZXIoKTt2YXIgYT10aGlzLmN1cnJlbnRMZXZlbEluZGV4LG89clthXSxsPXJbdF07dGhpcy5sb2coXCJzd2l0Y2hpbmcgdG8gbGV2ZWwgXCIrdCtcIiBmcm9tIFwiK2EpLHRoaXMuY3VycmVudExldmVsSW5kZXg9dDt2YXIgdT1YKHt9LGwse2xldmVsOnQsbWF4Qml0cmF0ZTpsLm1heEJpdHJhdGUsdXJpOmwudXJpLHVybElkOmwudXJsSWR9KTtkZWxldGUgdS5fdXJsSWQsdGhpcy5obHMudHJpZ2dlcihuLmEuTEVWRUxfU1dJVENISU5HLHUpO3ZhciBkPWwuZGV0YWlscztpZighZHx8ZC5saXZlKXt2YXIgaD10aGlzLnN3aXRjaFBhcmFtcyhsLnVyaSxudWxsPT1vP3ZvaWQgMDpvLmRldGFpbHMpO3RoaXMubG9hZFBsYXlsaXN0KGgpfX19fSx7a2V5OlwibWFudWFsTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5tYW51YWxMZXZlbEluZGV4PXQsdm9pZCAwPT09dGhpcy5fc3RhcnRMZXZlbCYmKHRoaXMuX3N0YXJ0TGV2ZWw9dCksLTEhPT10JiYodGhpcy5sZXZlbD10KX19LHtrZXk6XCJmaXJzdExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWx9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9maXJzdExldmVsPXR9fSx7a2V5Olwic3RhcnRMZXZlbFwiLGdldDpmdW5jdGlvbigpe2lmKHZvaWQgMD09PXRoaXMuX3N0YXJ0TGV2ZWwpe3ZhciB0PXRoaXMuaGxzLmNvbmZpZy5zdGFydExldmVsO3JldHVybiB2b2lkIDAhPT10P3Q6dGhpcy5fZmlyc3RMZXZlbH1yZXR1cm4gdGhpcy5fc3RhcnRMZXZlbH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX3N0YXJ0TGV2ZWw9dH19LHtrZXk6XCJuZXh0TG9hZExldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuLTEhPT10aGlzLm1hbnVhbExldmVsSW5kZXg/dGhpcy5tYW51YWxMZXZlbEluZGV4OnRoaXMuaGxzLm5leHRBdXRvTGV2ZWx9LHNldDpmdW5jdGlvbih0KXt0aGlzLmxldmVsPXQsLTE9PT10aGlzLm1hbnVhbExldmVsSW5kZXgmJih0aGlzLmhscy5uZXh0QXV0b0xldmVsPXQpfX1dKSYmcShhLnByb3RvdHlwZSxvKSxpfShZKTshZnVuY3Rpb24odCl7dC5OT1RfTE9BREVEPVwiTk9UX0xPQURFRFwiLHQuQkFDS1RSQUNLRUQ9XCJCQUNLVFJBQ0tFRFwiLHQuQVBQRU5ESU5HPVwiQVBQRU5ESU5HXCIsdC5QQVJUSUFMPVwiUEFSVElBTFwiLHQuT0s9XCJPS1wifShRfHwoUT17fSkpO3ZhciBKPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmFjdGl2ZUZyYWdtZW50PW51bGwsdGhpcy5hY3RpdmVQYXJ0cz1udWxsLHRoaXMuZnJhZ21lbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy50aW1lUmFuZ2VzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5idWZmZXJQYWRkaW5nPS4yLHRoaXMuaGxzPXZvaWQgMCx0aGlzLmhscz10LHRoaXMuX3JlZ2lzdGVyTGlzdGVuZXJzKCl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuX3JlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vbihuLmEuQlVGRkVSX0FQUEVOREVELHRoaXMub25CdWZmZXJBcHBlbmRlZCx0aGlzKSx0Lm9uKG4uYS5GUkFHX0JVRkZFUkVELHRoaXMub25GcmFnQnVmZmVyZWQsdGhpcyksdC5vbihuLmEuRlJBR19MT0FERUQsdGhpcy5vbkZyYWdMb2FkZWQsdGhpcyl9LGUuX3VucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhsczt0Lm9mZihuLmEuQlVGRkVSX0FQUEVOREVELHRoaXMub25CdWZmZXJBcHBlbmRlZCx0aGlzKSx0Lm9mZihuLmEuRlJBR19CVUZGRVJFRCx0aGlzLm9uRnJhZ0J1ZmZlcmVkLHRoaXMpLHQub2ZmKG4uYS5GUkFHX0xPQURFRCx0aGlzLm9uRnJhZ0xvYWRlZCx0aGlzKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5fdW5yZWdpc3Rlckxpc3RlbmVycygpLHRoaXMuZnJhZ21lbnRzPXRoaXMudGltZVJhbmdlcz1udWxsfSxlLmdldEFwcGVuZGVkRnJhZz1mdW5jdGlvbih0LGUpe2lmKGU9PT1fLmIuTUFJTil7dmFyIHI9dGhpcy5hY3RpdmVGcmFnbWVudCxpPXRoaXMuYWN0aXZlUGFydHM7aWYoIXIpcmV0dXJuIG51bGw7aWYoaSlmb3IodmFyIGE9aS5sZW5ndGg7YS0tOyl7dmFyIG49aVthXSxzPW4/bi5lbmQ6ci5hcHBlbmRlZFBUUztpZihuLnN0YXJ0PD10JiZ2b2lkIDAhPT1zJiZ0PD1zKXJldHVybiBhPjkmJih0aGlzLmFjdGl2ZVBhcnRzPWkuc2xpY2UoYS05KSksbn1lbHNlIGlmKHIuc3RhcnQ8PXQmJnZvaWQgMCE9PXIuYXBwZW5kZWRQVFMmJnQ8PXIuYXBwZW5kZWRQVFMpcmV0dXJuIHJ9cmV0dXJuIHRoaXMuZ2V0QnVmZmVyZWRGcmFnKHQsZSl9LGUuZ2V0QnVmZmVyZWRGcmFnPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPXRoaXMuZnJhZ21lbnRzLGk9T2JqZWN0LmtleXMociksYT1pLmxlbmd0aDthLS07KXt2YXIgbj1yW2lbYV1dO2lmKChudWxsPT1uP3ZvaWQgMDpuLmJvZHkudHlwZSk9PT1lJiZuLmJ1ZmZlcmVkKXt2YXIgcz1uLmJvZHk7aWYocy5zdGFydDw9dCYmdDw9cy5lbmQpcmV0dXJuIHN9fXJldHVybiBudWxsfSxlLmRldGVjdEV2aWN0ZWRGcmFnbWVudHM9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXM7T2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goKGZ1bmN0aW9uKGEpe3ZhciBuPWkuZnJhZ21lbnRzW2FdO2lmKG4paWYobi5idWZmZXJlZCl7dmFyIHM9bi5yYW5nZVt0XTtzJiZzLnRpbWUuc29tZSgoZnVuY3Rpb24odCl7dmFyIHI9IWkuaXNUaW1lQnVmZmVyZWQodC5zdGFydFBUUyx0LmVuZFBUUyxlKTtyZXR1cm4gciYmaS5yZW1vdmVGcmFnbWVudChuLmJvZHkpLHJ9KSl9ZWxzZSBuLmJvZHkudHlwZT09PXImJmkucmVtb3ZlRnJhZ21lbnQobi5ib2R5KX0pKX0sZS5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj10aGlzLnRpbWVSYW5nZXMsaT10LmZyYWcsYT10LnBhcnQ7aWYociYmXCJpbml0U2VnbWVudFwiIT09aS5zbil7dmFyIG49ZXQoaSkscz10aGlzLmZyYWdtZW50c1tuXTtzJiYoT2JqZWN0LmtleXMocikuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49aS5lbGVtZW50YXJ5U3RyZWFtc1t0XTtpZihuKXt2YXIgbz1yW3RdLGw9bnVsbCE9PWF8fCEwPT09bi5wYXJ0aWFsO3MucmFuZ2VbdF09ZS5nZXRCdWZmZXJlZFRpbWVzKGksYSxsLG8pfX0pKSxzLmJhY2t0cmFjaz1zLmxvYWRlZD1udWxsLE9iamVjdC5rZXlzKHMucmFuZ2UpLmxlbmd0aD9zLmJ1ZmZlcmVkPSEwOnRoaXMucmVtb3ZlRnJhZ21lbnQocy5ib2R5KSl9fSxlLmZyYWdCdWZmZXJlZD1mdW5jdGlvbih0KXt2YXIgZT1ldCh0KSxyPXRoaXMuZnJhZ21lbnRzW2VdO3ImJihyLmJhY2t0cmFjaz1yLmxvYWRlZD1udWxsLHIuYnVmZmVyZWQ9ITApfSxlLmdldEJ1ZmZlcmVkVGltZXM9ZnVuY3Rpb24odCxlLHIsaSl7Zm9yKHZhciBhPXt0aW1lOltdLHBhcnRpYWw6cn0sbj1lP2Uuc3RhcnQ6dC5zdGFydCxzPWU/ZS5lbmQ6dC5lbmQsbz10Lm1pbkVuZFBUU3x8cyxsPXQubWF4U3RhcnRQVFN8fG4sdT0wO3U8aS5sZW5ndGg7dSsrKXt2YXIgZD1pLnN0YXJ0KHUpLXRoaXMuYnVmZmVyUGFkZGluZyxoPWkuZW5kKHUpK3RoaXMuYnVmZmVyUGFkZGluZztpZihsPj1kJiZvPD1oKXthLnRpbWUucHVzaCh7c3RhcnRQVFM6TWF0aC5tYXgobixpLnN0YXJ0KHUpKSxlbmRQVFM6TWF0aC5taW4ocyxpLmVuZCh1KSl9KTticmVha31pZihuPGgmJnM+ZClhLnBhcnRpYWw9ITAsYS50aW1lLnB1c2goe3N0YXJ0UFRTOk1hdGgubWF4KG4saS5zdGFydCh1KSksZW5kUFRTOk1hdGgubWluKHMsaS5lbmQodSkpfSk7ZWxzZSBpZihzPD1kKWJyZWFrfXJldHVybiBhfSxlLmdldFBhcnRpYWxGcmFnbWVudD1mdW5jdGlvbih0KXt2YXIgZSxyLGksYT1udWxsLG49MCxzPXRoaXMuYnVmZmVyUGFkZGluZyxvPXRoaXMuZnJhZ21lbnRzO3JldHVybiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChmdW5jdGlvbihsKXt2YXIgdT1vW2xdO3UmJnR0KHUpJiYocj11LmJvZHkuc3RhcnQtcyxpPXUuYm9keS5lbmQrcyx0Pj1yJiZ0PD1pJiYoZT1NYXRoLm1pbih0LXIsaS10KSxuPD1lJiYoYT11LmJvZHksbj1lKSkpfSkpLGF9LGUuZ2V0U3RhdGU9ZnVuY3Rpb24odCl7dmFyIGU9ZXQodCkscj10aGlzLmZyYWdtZW50c1tlXTtyZXR1cm4gcj9yLmJ1ZmZlcmVkP3R0KHIpP1EuUEFSVElBTDpRLk9LOnIuYmFja3RyYWNrP1EuQkFDS1RSQUNLRUQ6US5BUFBFTkRJTkc6US5OT1RfTE9BREVEfSxlLmJhY2t0cmFjaz1mdW5jdGlvbih0LGUpe3ZhciByPWV0KHQpLGk9dGhpcy5mcmFnbWVudHNbcl07aWYoIWl8fGkuYmFja3RyYWNrKXJldHVybiBudWxsO3ZhciBhPWkuYmFja3RyYWNrPWV8fGkubG9hZGVkO3JldHVybiBpLmxvYWRlZD1udWxsLGF9LGUuZ2V0QmFja3RyYWNrRGF0YT1mdW5jdGlvbih0KXt2YXIgZT1ldCh0KSxyPXRoaXMuZnJhZ21lbnRzW2VdO2lmKHIpe3ZhciBpLGE9ci5iYWNrdHJhY2s7aWYobnVsbCE9YSYmbnVsbCE9PShpPWEucGF5bG9hZCkmJnZvaWQgMCE9PWkmJmkuYnl0ZUxlbmd0aClyZXR1cm4gYTt0aGlzLnJlbW92ZUZyYWdtZW50KHQpfXJldHVybiBudWxsfSxlLmlzVGltZUJ1ZmZlcmVkPWZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIGksYSxuPTA7bjxyLmxlbmd0aDtuKyspe2lmKGk9ci5zdGFydChuKS10aGlzLmJ1ZmZlclBhZGRpbmcsYT1yLmVuZChuKSt0aGlzLmJ1ZmZlclBhZGRpbmcsdD49aSYmZTw9YSlyZXR1cm4hMDtpZihlPD1pKXJldHVybiExfXJldHVybiExfSxlLm9uRnJhZ0xvYWRlZD1mdW5jdGlvbih0LGUpe3ZhciByPWUuZnJhZyxpPWUucGFydDtpZihcImluaXRTZWdtZW50XCIhPT1yLnNuJiYhci5iaXRyYXRlVGVzdCYmIWkpe3ZhciBhPWV0KHIpO3RoaXMuZnJhZ21lbnRzW2FdPXtib2R5OnIsbG9hZGVkOmUsYmFja3RyYWNrOm51bGwsYnVmZmVyZWQ6ITEscmFuZ2U6T2JqZWN0LmNyZWF0ZShudWxsKX19fSxlLm9uQnVmZmVyQXBwZW5kZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLGk9ZS5mcmFnLGE9ZS5wYXJ0LG49ZS50aW1lUmFuZ2VzO2lmKGkudHlwZT09PV8uYi5NQUlOKWlmKHRoaXMuYWN0aXZlRnJhZ21lbnQ9aSxhKXt2YXIgcz10aGlzLmFjdGl2ZVBhcnRzO3N8fCh0aGlzLmFjdGl2ZVBhcnRzPXM9W10pLHMucHVzaChhKX1lbHNlIHRoaXMuYWN0aXZlUGFydHM9bnVsbDt0aGlzLnRpbWVSYW5nZXM9bixPYmplY3Qua2V5cyhuKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1uW3RdO2lmKHIuZGV0ZWN0RXZpY3RlZEZyYWdtZW50cyh0LGUpLCFhKWZvcih2YXIgcz0wO3M8ZS5sZW5ndGg7cysrKWkuYXBwZW5kZWRQVFM9TWF0aC5tYXgoZS5lbmQocyksaS5hcHBlbmRlZFBUU3x8MCl9KSl9LGUub25GcmFnQnVmZmVyZWQ9ZnVuY3Rpb24odCxlKXt0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHMoZSl9LGUuaGFzRnJhZ21lbnQ9ZnVuY3Rpb24odCl7dmFyIGU9ZXQodCk7cmV0dXJuISF0aGlzLmZyYWdtZW50c1tlXX0sZS5yZW1vdmVGcmFnbWVudHNJblJhbmdlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT10aGlzO09iamVjdC5rZXlzKHRoaXMuZnJhZ21lbnRzKS5mb3JFYWNoKChmdW5jdGlvbihhKXt2YXIgbj1pLmZyYWdtZW50c1thXTtpZihuJiZuLmJ1ZmZlcmVkKXt2YXIgcz1uLmJvZHk7cy50eXBlPT09ciYmcy5zdGFydDxlJiZzLmVuZD50JiZpLnJlbW92ZUZyYWdtZW50KHMpfX0pKX0sZS5yZW1vdmVGcmFnbWVudD1mdW5jdGlvbih0KXt2YXIgZT1ldCh0KTt0LnN0YXRzLmxvYWRlZD0wLHQuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpLGRlbGV0ZSB0aGlzLmZyYWdtZW50c1tlXX0sZS5yZW1vdmVBbGxGcmFnbWVudHM9ZnVuY3Rpb24oKXt0aGlzLmZyYWdtZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuYWN0aXZlRnJhZ21lbnQ9bnVsbCx0aGlzLmFjdGl2ZVBhcnRzPW51bGx9LHR9KCk7ZnVuY3Rpb24gdHQodCl7dmFyIGUscjtyZXR1cm4gdC5idWZmZXJlZCYmKChudWxsPT09KGU9dC5yYW5nZS52aWRlbyl8fHZvaWQgMD09PWU/dm9pZCAwOmUucGFydGlhbCl8fChudWxsPT09KHI9dC5yYW5nZS5hdWRpbyl8fHZvaWQgMD09PXI/dm9pZCAwOnIucGFydGlhbCkpfWZ1bmN0aW9uIGV0KHQpe3JldHVybiB0LnR5cGUrXCJfXCIrdC5sZXZlbCtcIl9cIit0LnVybElkK1wiX1wiK3Quc259dmFyIHJ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe3RoaXMuX2JvdW5kVGljaz12b2lkIDAsdGhpcy5fdGlja1RpbWVyPW51bGwsdGhpcy5fdGlja0ludGVydmFsPW51bGwsdGhpcy5fdGlja0NhbGxDb3VudD0wLHRoaXMuX2JvdW5kVGljaz10aGlzLnRpY2suYmluZCh0aGlzKX12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCksdGhpcy5vbkhhbmRsZXJEZXN0cm95ZWQoKX0sZS5vbkhhbmRsZXJEZXN0cm95aW5nPWZ1bmN0aW9uKCl7dGhpcy5jbGVhck5leHRUaWNrKCksdGhpcy5jbGVhckludGVydmFsKCl9LGUub25IYW5kbGVyRGVzdHJveWVkPWZ1bmN0aW9uKCl7fSxlLmhhc0ludGVydmFsPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLl90aWNrSW50ZXJ2YWx9LGUuaGFzTmV4dFRpY2s9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuX3RpY2tUaW1lcn0sZS5zZXRJbnRlcnZhbD1mdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5fdGlja0ludGVydmFsJiYodGhpcy5fdGlja0ludGVydmFsPXNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYm91bmRUaWNrLHQpLCEwKX0sZS5jbGVhckludGVydmFsPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLl90aWNrSW50ZXJ2YWwmJihzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5fdGlja0ludGVydmFsKSx0aGlzLl90aWNrSW50ZXJ2YWw9bnVsbCwhMCl9LGUuY2xlYXJOZXh0VGljaz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5fdGlja1RpbWVyJiYoc2VsZi5jbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKSx0aGlzLl90aWNrVGltZXI9bnVsbCwhMCl9LGUudGljaz1mdW5jdGlvbigpe3RoaXMuX3RpY2tDYWxsQ291bnQrKywxPT09dGhpcy5fdGlja0NhbGxDb3VudCYmKHRoaXMuZG9UaWNrKCksdGhpcy5fdGlja0NhbGxDb3VudD4xJiZ0aGlzLnRpY2tJbW1lZGlhdGUoKSx0aGlzLl90aWNrQ2FsbENvdW50PTApfSxlLnRpY2tJbW1lZGlhdGU9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyTmV4dFRpY2soKSx0aGlzLl90aWNrVGltZXI9c2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywwKX0sZS5kb1RpY2s9ZnVuY3Rpb24oKXt9LHR9KCksaXQ9e2xlbmd0aDowLHN0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGVuZDpmdW5jdGlvbigpe3JldHVybiAwfX0sYXQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LmlzQnVmZmVyZWQ9ZnVuY3Rpb24oZSxyKXt0cnl7aWYoZSlmb3IodmFyIGk9dC5nZXRCdWZmZXJlZChlKSxhPTA7YTxpLmxlbmd0aDthKyspaWYocj49aS5zdGFydChhKSYmcjw9aS5lbmQoYSkpcmV0dXJuITB9Y2F0Y2godCl7fXJldHVybiExfSx0LmJ1ZmZlckluZm89ZnVuY3Rpb24oZSxyLGkpe3RyeXtpZihlKXt2YXIgYSxuPXQuZ2V0QnVmZmVyZWQoZSkscz1bXTtmb3IoYT0wO2E8bi5sZW5ndGg7YSsrKXMucHVzaCh7c3RhcnQ6bi5zdGFydChhKSxlbmQ6bi5lbmQoYSl9KTtyZXR1cm4gdGhpcy5idWZmZXJlZEluZm8ocyxyLGkpfX1jYXRjaCh0KXt9cmV0dXJue2xlbjowLHN0YXJ0OnIsZW5kOnIsbmV4dFN0YXJ0OnZvaWQgMH19LHQuYnVmZmVyZWRJbmZvPWZ1bmN0aW9uKHQsZSxyKXtlPU1hdGgubWF4KDAsZSksdC5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0LnN0YXJ0LWUuc3RhcnR8fGUuZW5kLXQuZW5kfSkpO3ZhciBpPVtdO2lmKHIpZm9yKHZhciBhPTA7YTx0Lmxlbmd0aDthKyspe3ZhciBuPWkubGVuZ3RoO2lmKG4pe3ZhciBzPWlbbi0xXS5lbmQ7dFthXS5zdGFydC1zPHI/dFthXS5lbmQ+cyYmKGlbbi0xXS5lbmQ9dFthXS5lbmQpOmkucHVzaCh0W2FdKX1lbHNlIGkucHVzaCh0W2FdKX1lbHNlIGk9dDtmb3IodmFyIG8sbD0wLHU9ZSxkPWUsaD0wO2g8aS5sZW5ndGg7aCsrKXt2YXIgZj1pW2hdLnN0YXJ0LGM9aVtoXS5lbmQ7aWYoZStyPj1mJiZlPGMpdT1mLGw9KGQ9YyktZTtlbHNlIGlmKGUrcjxmKXtvPWY7YnJlYWt9fXJldHVybntsZW46bCxzdGFydDp1fHwwLGVuZDpkfHwwLG5leHRTdGFydDpvfX0sdC5nZXRCdWZmZXJlZD1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIHQuYnVmZmVyZWR9Y2F0Y2godCl7cmV0dXJuIG8uYi5sb2coXCJmYWlsZWQgdG8gZ2V0IG1lZGlhLmJ1ZmZlcmVkXCIsdCksaXR9fSx0fSgpLG50PWZ1bmN0aW9uKHQsZSxyLGksYSxuKXt2b2lkIDA9PT1pJiYoaT0wKSx2b2lkIDA9PT1hJiYoYT0tMSksdm9pZCAwPT09biYmKG49ITEpLHRoaXMubGV2ZWw9dm9pZCAwLHRoaXMuc249dm9pZCAwLHRoaXMucGFydD12b2lkIDAsdGhpcy5pZD12b2lkIDAsdGhpcy5zaXplPXZvaWQgMCx0aGlzLnBhcnRpYWw9dm9pZCAwLHRoaXMudHJhbnNtdXhpbmc9e3N0YXJ0OjAsZXhlY3V0ZVN0YXJ0OjAsZXhlY3V0ZUVuZDowLGVuZDowfSx0aGlzLmJ1ZmZlcmluZz17YXVkaW86e3N0YXJ0OjAsZXhlY3V0ZVN0YXJ0OjAsZXhlY3V0ZUVuZDowLGVuZDowfSx2aWRlbzp7c3RhcnQ6MCxleGVjdXRlU3RhcnQ6MCxleGVjdXRlRW5kOjAsZW5kOjB9LGF1ZGlvdmlkZW86e3N0YXJ0OjAsZXhlY3V0ZVN0YXJ0OjAsZXhlY3V0ZUVuZDowLGVuZDowfX0sdGhpcy5sZXZlbD10LHRoaXMuc249ZSx0aGlzLmlkPXIsdGhpcy5zaXplPWksdGhpcy5wYXJ0PWEsdGhpcy5wYXJ0aWFsPW59O2Z1bmN0aW9uIHN0KHQsZSl7aWYodCl7dmFyIHI9dC5zdGFydCtlO3Quc3RhcnQ9dC5zdGFydFBUUz1yLHQuZW5kUFRTPXIrdC5kdXJhdGlvbn19ZnVuY3Rpb24gb3QodCxlKXtmb3IodmFyIHI9ZS5mcmFnbWVudHMsaT0wLGE9ci5sZW5ndGg7aTxhO2krKylzdChyW2ldLHQpO2UuZnJhZ21lbnRIaW50JiZzdChlLmZyYWdtZW50SGludCx0KSxlLmFsaWduZWRTbGlkaW5nPSEwfWZ1bmN0aW9uIGx0KHQsZSxyKXtlJiYoZnVuY3Rpb24odCxlLHIpe2lmKGZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4hKCFlLmRldGFpbHN8fCEoci5lbmRDQz5yLnN0YXJ0Q0N8fHQmJnQuY2M8ci5zdGFydENDKSl9KHQscixlKSl7dmFyIGk9ZnVuY3Rpb24odCxlKXt2YXIgcj10LmZyYWdtZW50cyxpPWUuZnJhZ21lbnRzO2lmKGkubGVuZ3RoJiZyLmxlbmd0aCl7dmFyIGE9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9bnVsbCxpPTAsYT10Lmxlbmd0aDtpPGE7aSsrKXt2YXIgbj10W2ldO2lmKG4mJm4uY2M9PT1lKXtyPW47YnJlYWt9fXJldHVybiByfShyLGlbMF0uY2MpO2lmKGEmJighYXx8YS5zdGFydFBUUykpcmV0dXJuIGE7by5iLmxvZyhcIk5vIGZyYWcgaW4gcHJldmlvdXMgbGV2ZWwgdG8gYWxpZ24gb25cIil9ZWxzZSBvLmIubG9nKFwiTm8gZnJhZ21lbnRzIHRvIGFsaWduXCIpfShyLmRldGFpbHMsZSk7aSYmT2JqZWN0KGEuYSkoaS5zdGFydCkmJihvLmIubG9nKFwiQWRqdXN0aW5nIFBUUyB1c2luZyBsYXN0IGxldmVsIGR1ZSB0byBDQyBpbmNyZWFzZSB3aXRoaW4gY3VycmVudCBsZXZlbCBcIitlLnVybCksb3QoaS5zdGFydCxlKSl9fSh0LHIsZSksIXIuYWxpZ25lZFNsaWRpbmcmJmUuZGV0YWlscyYmZnVuY3Rpb24odCxlKXtpZihlLmZyYWdtZW50cy5sZW5ndGgmJnQuaGFzUHJvZ3JhbURhdGVUaW1lJiZlLmhhc1Byb2dyYW1EYXRlVGltZSl7dmFyIHI9ZS5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lLGk9dC5mcmFnbWVudHNbMF0ucHJvZ3JhbURhdGVUaW1lLG49KGktcikvMWUzK2UuZnJhZ21lbnRzWzBdLnN0YXJ0O24mJk9iamVjdChhLmEpKG4pJiYoby5iLmxvZyhcIkFkanVzdGluZyBQVFMgdXNpbmcgcHJvZ3JhbURhdGVUaW1lIGRlbHRhIFwiKyhpLXIpK1wibXMsIHNsaWRpbmc6XCIrbi50b0ZpeGVkKDMpK1wiIFwiK3QudXJsK1wiIFwiKSxvdChuLHQpKX19KHIsZS5kZXRhaWxzKSxyLmFsaWduZWRTbGlkaW5nfHwhZS5kZXRhaWxzfHxyLnNraXBwZWRTZWdtZW50c3x8VyhlLmRldGFpbHMscikpfXZhciB1dD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj0wLGk9dC5sZW5ndGgtMSxhPW51bGwsbj1udWxsO3I8PWk7KXt2YXIgcz1lKG49dFthPShyK2kpLzJ8MF0pO2lmKHM+MClyPWErMTtlbHNle2lmKCEoczwwKSlyZXR1cm4gbjtpPWEtMX19cmV0dXJuIG51bGx9O2Z1bmN0aW9uIGR0KHQsZSxyKXt2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1lJiYoZT0wKTt2YXIgaT1NYXRoLm1pbihlLHIuZHVyYXRpb24rKHIuZGVsdGFQVFM/ci5kZWx0YVBUUzowKSk7cmV0dXJuIHIuc3RhcnQrci5kdXJhdGlvbi1pPD10PzE6ci5zdGFydC1pPnQmJnIuc3RhcnQ/LTE6MH1mdW5jdGlvbiBodCh0LGUscil7dmFyIGk9MWUzKk1hdGgubWluKGUsci5kdXJhdGlvbisoci5kZWx0YVBUUz9yLmRlbHRhUFRTOjApKTtyZXR1cm4oci5lbmRQcm9ncmFtRGF0ZVRpbWV8fDApLWk+dH1mdW5jdGlvbiBmdCh0KXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuKGZ0PWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10fHwocj10LC0xPT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbChyKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSkpcmV0dXJuIHQ7dmFyIHI7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7aWYodm9pZCAwIT09ZSl7aWYoZS5oYXModCkpcmV0dXJuIGUuZ2V0KHQpO2Uuc2V0KHQsaSl9ZnVuY3Rpb24gaSgpe3JldHVybiBjdCh0LGFyZ3VtZW50cyxwdCh0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTppLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGd0KGksdCl9KSh0KX1mdW5jdGlvbiBjdCh0LGUscil7cmV0dXJuKGN0PXZ0KCk/UmVmbGVjdC5jb25zdHJ1Y3Q6ZnVuY3Rpb24odCxlLHIpe3ZhciBpPVtudWxsXTtpLnB1c2guYXBwbHkoaSxlKTt2YXIgYT1uZXcoRnVuY3Rpb24uYmluZC5hcHBseSh0LGkpKTtyZXR1cm4gciYmZ3QoYSxyLnByb3RvdHlwZSksYX0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiB2dCgpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBSZWZsZWN0fHwhUmVmbGVjdC5jb25zdHJ1Y3QpcmV0dXJuITE7aWYoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm94eSlyZXR1cm4hMDt0cnl7cmV0dXJuIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIGd0KHQsZSl7cmV0dXJuKGd0PU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fX3Byb3RvX189ZSx0fSkodCxlKX1mdW5jdGlvbiBwdCh0KXtyZXR1cm4ocHQ9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZih0KX0pKHQpfXZhciBtdD1NYXRoLnBvdygyLDE3KSx5dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5jb25maWc9dm9pZCAwLHRoaXMubG9hZGVyPW51bGwsdGhpcy5wYXJ0TG9hZFRpbWVvdXQ9LTEsdGhpcy5jb25maWc9dH12YXIgZT10LnByb3RvdHlwZTtyZXR1cm4gZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5sb2FkZXImJih0aGlzLmxvYWRlci5kZXN0cm95KCksdGhpcy5sb2FkZXI9bnVsbCl9LGUuYWJvcnQ9ZnVuY3Rpb24oKXt0aGlzLmxvYWRlciYmdGhpcy5sb2FkZXIuYWJvcnQoKX0sZS5sb2FkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxpPXQudXJsO2lmKCFpKXJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHQoe3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuRlJBR19MT0FEX0VSUk9SLGZhdGFsOiExLGZyYWc6dCxuZXR3b3JrRGV0YWlsczpudWxsfSxcIkZyYWdtZW50IGRvZXMgbm90IGhhdmUgYSBcIisoaT9cInBhcnQgbGlzdFwiOlwidXJsXCIpKSk7dGhpcy5hYm9ydCgpO3ZhciBhPXRoaXMuY29uZmlnLG49YS5mTG9hZGVyLG89YS5sb2FkZXI7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihpLGwpe3IubG9hZGVyJiZyLmxvYWRlci5kZXN0cm95KCk7dmFyIHU9ci5sb2FkZXI9dC5sb2FkZXI9bj9uZXcgbihhKTpuZXcgbyhhKSxkPWJ0KHQpLGg9e3RpbWVvdXQ6YS5mcmFnTG9hZGluZ1RpbWVPdXQsbWF4UmV0cnk6MCxyZXRyeURlbGF5OjAsbWF4UmV0cnlEZWxheTphLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0LGhpZ2hXYXRlck1hcms6bXR9O3Quc3RhdHM9dS5zdGF0cyx1LmxvYWQoZCxoLHtvblN1Y2Nlc3M6ZnVuY3Rpb24oZSxhLG4scyl7ci5yZXNldExvYWRlcih0LHUpLGkoe2ZyYWc6dCxwYXJ0Om51bGwscGF5bG9hZDplLmRhdGEsbmV0d29ya0RldGFpbHM6c30pfSxvbkVycm9yOmZ1bmN0aW9uKGUsaSxhKXtyLnJlc2V0TG9hZGVyKHQsdSksbChuZXcgVHQoe3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuRlJBR19MT0FEX0VSUk9SLGZhdGFsOiExLGZyYWc6dCxyZXNwb25zZTplLG5ldHdvcmtEZXRhaWxzOmF9KSl9LG9uQWJvcnQ6ZnVuY3Rpb24oZSxpLGEpe3IucmVzZXRMb2FkZXIodCx1KSxsKG5ldyBUdCh7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5JTlRFUk5BTF9BQk9SVEVELGZhdGFsOiExLGZyYWc6dCxuZXR3b3JrRGV0YWlsczphfSkpfSxvblRpbWVvdXQ6ZnVuY3Rpb24oZSxpLGEpe3IucmVzZXRMb2FkZXIodCx1KSxsKG5ldyBUdCh7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5GUkFHX0xPQURfVElNRU9VVCxmYXRhbDohMSxmcmFnOnQsbmV0d29ya0RldGFpbHM6YX0pKX0sb25Qcm9ncmVzczpmdW5jdGlvbihyLGksYSxuKXtlJiZlKHtmcmFnOnQscGFydDpudWxsLHBheWxvYWQ6YSxuZXR3b3JrRGV0YWlsczpufSl9fSl9KSl9LGUubG9hZFBhcnQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXM7dGhpcy5hYm9ydCgpO3ZhciBhPXRoaXMuY29uZmlnLG49YS5mTG9hZGVyLG89YS5sb2FkZXI7cmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihsLHUpe2kubG9hZGVyJiZpLmxvYWRlci5kZXN0cm95KCk7dmFyIGQ9aS5sb2FkZXI9dC5sb2FkZXI9bj9uZXcgbihhKTpuZXcgbyhhKSxoPWJ0KHQsZSksZj17dGltZW91dDphLmZyYWdMb2FkaW5nVGltZU91dCxtYXhSZXRyeTowLHJldHJ5RGVsYXk6MCxtYXhSZXRyeURlbGF5OmEuZnJhZ0xvYWRpbmdNYXhSZXRyeVRpbWVvdXQsaGlnaFdhdGVyTWFyazptdH07ZS5zdGF0cz1kLnN0YXRzLGQubG9hZChoLGYse29uU3VjY2VzczpmdW5jdGlvbihhLG4scyxvKXtpLnJlc2V0TG9hZGVyKHQsZCksaS51cGRhdGVTdGF0c0Zyb21QYXJ0KHQsZSk7dmFyIHU9e2ZyYWc6dCxwYXJ0OmUscGF5bG9hZDphLmRhdGEsbmV0d29ya0RldGFpbHM6b307cih1KSxsKHUpfSxvbkVycm9yOmZ1bmN0aW9uKHIsYSxuKXtpLnJlc2V0TG9hZGVyKHQsZCksdShuZXcgVHQoe3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuRlJBR19MT0FEX0VSUk9SLGZhdGFsOiExLGZyYWc6dCxwYXJ0OmUscmVzcG9uc2U6cixuZXR3b3JrRGV0YWlsczpufSkpfSxvbkFib3J0OmZ1bmN0aW9uKHIsYSxuKXt0LnN0YXRzLmFib3J0ZWQ9ZS5zdGF0cy5hYm9ydGVkLGkucmVzZXRMb2FkZXIodCxkKSx1KG5ldyBUdCh7dHlwZTpzLmIuTkVUV09SS19FUlJPUixkZXRhaWxzOnMuYS5JTlRFUk5BTF9BQk9SVEVELGZhdGFsOiExLGZyYWc6dCxwYXJ0OmUsbmV0d29ya0RldGFpbHM6bn0pKX0sb25UaW1lb3V0OmZ1bmN0aW9uKHIsYSxuKXtpLnJlc2V0TG9hZGVyKHQsZCksdShuZXcgVHQoe3R5cGU6cy5iLk5FVFdPUktfRVJST1IsZGV0YWlsczpzLmEuRlJBR19MT0FEX1RJTUVPVVQsZmF0YWw6ITEsZnJhZzp0LHBhcnQ6ZSxuZXR3b3JrRGV0YWlsczpufSkpfX0pfSkpfSxlLnVwZGF0ZVN0YXRzRnJvbVBhcnQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10LnN0YXRzLGk9ZS5zdGF0cyxhPWkudG90YWw7aWYoci5sb2FkZWQrPWkubG9hZGVkLGEpe3ZhciBuPU1hdGgucm91bmQodC5kdXJhdGlvbi9lLmR1cmF0aW9uKSxzPU1hdGgubWluKE1hdGgucm91bmQoci5sb2FkZWQvYSksbiksbz0obi1zKSpNYXRoLnJvdW5kKHIubG9hZGVkL3MpO3IudG90YWw9ci5sb2FkZWQrb31lbHNlIHIudG90YWw9TWF0aC5tYXgoci5sb2FkZWQsci50b3RhbCk7dmFyIGw9ci5sb2FkaW5nLHU9aS5sb2FkaW5nO2wuc3RhcnQ/bC5maXJzdCs9dS5maXJzdC11LnN0YXJ0OihsLnN0YXJ0PXUuc3RhcnQsbC5maXJzdD11LmZpcnN0KSxsLmVuZD11LmVuZH0sZS5yZXNldExvYWRlcj1mdW5jdGlvbih0LGUpe3QubG9hZGVyPW51bGwsdGhpcy5sb2FkZXI9PT1lJiYoc2VsZi5jbGVhclRpbWVvdXQodGhpcy5wYXJ0TG9hZFRpbWVvdXQpLHRoaXMubG9hZGVyPW51bGwpLGUuZGVzdHJveSgpfSx0fSgpO2Z1bmN0aW9uIGJ0KHQsZSl7dm9pZCAwPT09ZSYmKGU9bnVsbCk7dmFyIHI9ZXx8dCxpPXtmcmFnOnQscGFydDplLHJlc3BvbnNlVHlwZTpcImFycmF5YnVmZmVyXCIsdXJsOnIudXJsLGhlYWRlcnM6e30scmFuZ2VTdGFydDowLHJhbmdlRW5kOjB9LG49ci5ieXRlUmFuZ2VTdGFydE9mZnNldCxzPXIuYnl0ZVJhbmdlRW5kT2Zmc2V0O3JldHVybiBPYmplY3QoYS5hKShuKSYmT2JqZWN0KGEuYSkocykmJihpLnJhbmdlU3RhcnQ9bixpLnJhbmdlRW5kPXMpLGl9dmFyIFR0PWZ1bmN0aW9uKHQpe3ZhciBlLHI7ZnVuY3Rpb24gaShlKXtmb3IodmFyIHIsaT1hcmd1bWVudHMubGVuZ3RoLGE9bmV3IEFycmF5KGk+MT9pLTE6MCksbj0xO248aTtuKyspYVtuLTFdPWFyZ3VtZW50c1tuXTtyZXR1cm4ocj10LmNhbGwuYXBwbHkodCxbdGhpc10uY29uY2F0KGEpKXx8dGhpcykuZGF0YT12b2lkIDAsci5kYXRhPWUscn1yZXR1cm4gcj10LChlPWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLGd0KGUsciksaX0oZnQoRXJyb3IpKSxFdD1yKDE0KSxTdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9XCJcIixyPXQubGVuZ3RoLGk9MDtpPHI7aSsrKWUrPVwiW1wiK3Quc3RhcnQoaSkudG9GaXhlZCgzKStcIixcIit0LmVuZChpKS50b0ZpeGVkKDMpK1wiXVwiO3JldHVybiBlfTtmdW5jdGlvbiBMdCh0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgaT1lW3JdO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19ZnVuY3Rpb24gQXQodCxlKXtyZXR1cm4oQXQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfXZhciBSdD1cIlNUT1BQRURcIixEdD1cIklETEVcIixfdD1cIktFWV9MT0FESU5HXCIsa3Q9XCJGUkFHX0xPQURJTkdcIix4dD1cIkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZXCIsd3Q9XCJQQVJTSU5HXCIsQ3Q9XCJQQVJTRURcIixPdD1cIkJBQ0tUUkFDS0lOR1wiLEl0PVwiRU5ERURcIixQdD1cIkVSUk9SXCIsRnQ9XCJXQUlUSU5HX0xFVkVMXCIsTXQ9ZnVuY3Rpb24odCl7dmFyIGUscjtmdW5jdGlvbiBpKGUscixpKXt2YXIgYTtyZXR1cm4oYT10LmNhbGwodGhpcyl8fHRoaXMpLmhscz12b2lkIDAsYS5mcmFnUHJldmlvdXM9bnVsbCxhLmZyYWdDdXJyZW50PW51bGwsYS5mcmFnbWVudFRyYWNrZXI9dm9pZCAwLGEudHJhbnNtdXhlcj1udWxsLGEuX3N0YXRlPVJ0LGEubWVkaWE9dm9pZCAwLGEubWVkaWFCdWZmZXI9dm9pZCAwLGEuY29uZmlnPXZvaWQgMCxhLmJpdHJhdGVUZXN0PSExLGEubGFzdEN1cnJlbnRUaW1lPTAsYS5uZXh0TG9hZFBvc2l0aW9uPTAsYS5zdGFydFBvc2l0aW9uPTAsYS5sb2FkZWRtZXRhZGF0YT0hMSxhLmZyYWdMb2FkRXJyb3I9MCxhLnJldHJ5RGF0ZT0wLGEubGV2ZWxzPW51bGwsYS5mcmFnbWVudExvYWRlcj12b2lkIDAsYS5sZXZlbExhc3RMb2FkZWQ9bnVsbCxhLnN0YXJ0RnJhZ1JlcXVlc3RlZD0hMSxhLmRlY3J5cHRlcj12b2lkIDAsYS5pbml0UFRTPVtdLGEub252c2Vla2luZz1udWxsLGEub252ZW5kZWQ9bnVsbCxhLmxvZ1ByZWZpeD1cIlwiLGEubG9nPXZvaWQgMCxhLndhcm49dm9pZCAwLGEubG9nUHJlZml4PWksYS5sb2c9by5iLmxvZy5iaW5kKG8uYixpK1wiOlwiKSxhLndhcm49by5iLndhcm4uYmluZChvLmIsaStcIjpcIiksYS5obHM9ZSxhLmZyYWdtZW50TG9hZGVyPW5ldyB5dChlLmNvbmZpZyksYS5mcmFnbWVudFRyYWNrZXI9cixhLmNvbmZpZz1lLmNvbmZpZyxhLmRlY3J5cHRlcj1uZXcgRXQuYShlLGUuY29uZmlnKSxlLm9uKG4uYS5LRVlfTE9BREVELGEub25LZXlMb2FkZWQsZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9KGEpKSxhfXI9dCwoZT1pKS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZSxBdChlLHIpO3ZhciB1LGQsaD1pLnByb3RvdHlwZTtyZXR1cm4gaC5kb1RpY2s9ZnVuY3Rpb24oKXt0aGlzLm9uVGlja0VuZCgpfSxoLm9uVGlja0VuZD1mdW5jdGlvbigpe30saC5zdGFydExvYWQ9ZnVuY3Rpb24odCl7fSxoLnN0b3BMb2FkPWZ1bmN0aW9uKCl7dGhpcy5mcmFnbWVudExvYWRlci5hYm9ydCgpO3ZhciB0PXRoaXMuZnJhZ0N1cnJlbnQ7dCYmdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQodCksdGhpcy5yZXNldFRyYW5zbXV4ZXIoKSx0aGlzLmZyYWdDdXJyZW50PW51bGwsdGhpcy5mcmFnUHJldmlvdXM9bnVsbCx0aGlzLmNsZWFySW50ZXJ2YWwoKSx0aGlzLmNsZWFyTmV4dFRpY2soKSx0aGlzLnN0YXRlPVJ0fSxoLl9zdHJlYW1FbmRlZD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuZnJhZ0N1cnJlbnQsaT10aGlzLmZyYWdtZW50VHJhY2tlcjtpZighZS5saXZlJiZyJiZyLnNuPj1lLmVuZFNOJiYhdC5uZXh0U3RhcnQpe3ZhciBhPWUucGFydExpc3Q7aWYobnVsbCE9YSYmYS5sZW5ndGgpe3ZhciBuPWFbYS5sZW5ndGgtMV07cmV0dXJuIGF0LmlzQnVmZmVyZWQodGhpcy5tZWRpYSxuLnN0YXJ0K24uZHVyYXRpb24vMil9dmFyIHM9aS5nZXRTdGF0ZShyKTtyZXR1cm4gcz09PVEuUEFSVElBTHx8cz09PVEuT0t9cmV0dXJuITF9LGgub25NZWRpYUF0dGFjaGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5tZWRpYT10aGlzLm1lZGlhQnVmZmVyPWUubWVkaWE7dGhpcy5vbnZzZWVraW5nPXRoaXMub25NZWRpYVNlZWtpbmcuYmluZCh0aGlzKSx0aGlzLm9udmVuZGVkPXRoaXMub25NZWRpYUVuZGVkLmJpbmQodGhpcyksci5hZGRFdmVudExpc3RlbmVyKFwic2Vla2luZ1wiLHRoaXMub252c2Vla2luZyksci5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIix0aGlzLm9udmVuZGVkKTt2YXIgaT10aGlzLmNvbmZpZzt0aGlzLmxldmVscyYmaS5hdXRvU3RhcnRMb2FkJiZ0aGlzLnN0YXRlPT09UnQmJnRoaXMuc3RhcnRMb2FkKGkuc3RhcnRQb3NpdGlvbil9LGgub25NZWRpYURldGFjaGluZz1mdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWE7bnVsbCE9dCYmdC5lbmRlZCYmKHRoaXMubG9nKFwiTVNFIGRldGFjaGluZyBhbmQgdmlkZW8gZW5kZWQsIHJlc2V0IHN0YXJ0UG9zaXRpb25cIiksdGhpcy5zdGFydFBvc2l0aW9uPXRoaXMubGFzdEN1cnJlbnRUaW1lPTApLHQmJih0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVraW5nXCIsdGhpcy5vbnZzZWVraW5nKSx0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLHRoaXMub252ZW5kZWQpLHRoaXMub252c2Vla2luZz10aGlzLm9udmVuZGVkPW51bGwpLHRoaXMubWVkaWE9dGhpcy5tZWRpYUJ1ZmZlcj1udWxsLHRoaXMubG9hZGVkbWV0YWRhdGE9ITEsdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlQWxsRnJhZ21lbnRzKCksdGhpcy5zdG9wTG9hZCgpfSxoLm9uTWVkaWFTZWVraW5nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb25maWcsZT10aGlzLmZyYWdDdXJyZW50LHI9dGhpcy5tZWRpYSxpPXRoaXMubWVkaWFCdWZmZXIsbj10aGlzLnN0YXRlLHM9cj9yLmN1cnJlbnRUaW1lOjAsbz1hdC5idWZmZXJJbmZvKGl8fHIscyx0Lm1heEJ1ZmZlckhvbGUpO2lmKHRoaXMubG9nKFwibWVkaWEgc2Vla2luZyB0byBcIisoT2JqZWN0KGEuYSkocyk/cy50b0ZpeGVkKDMpOnMpK1wiLCBzdGF0ZTogXCIrbiksbj09PUl0KXRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtlbHNlIGlmKGUmJiFvLmxlbil7dmFyIGw9dC5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLHU9ZS5zdGFydC1sLGQ9cz5lLnN0YXJ0K2UuZHVyYXRpb24rbDsoczx1fHxkKSYmKGQmJmUubG9hZGVyJiYodGhpcy5sb2coXCJzZWVraW5nIG91dHNpZGUgb2YgYnVmZmVyIHdoaWxlIGZyYWdtZW50IGxvYWQgaW4gcHJvZ3Jlc3MsIGNhbmNlbCBmcmFnbWVudCBsb2FkXCIpLGUubG9hZGVyLmFib3J0KCkpLHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKSl9ciYmKHRoaXMubGFzdEN1cnJlbnRUaW1lPXMpLHRoaXMubG9hZGVkbWV0YWRhdGF8fG8ubGVufHwodGhpcy5uZXh0TG9hZFBvc2l0aW9uPXRoaXMuc3RhcnRQb3NpdGlvbj1zKSx0aGlzLnRpY2tJbW1lZGlhdGUoKX0saC5vbk1lZGlhRW5kZWQ9ZnVuY3Rpb24oKXt0aGlzLnN0YXJ0UG9zaXRpb249dGhpcy5sYXN0Q3VycmVudFRpbWU9MH0saC5vbktleUxvYWRlZD1mdW5jdGlvbih0LGUpe2lmKHRoaXMuc3RhdGU9PT1fdCYmZS5mcmFnPT09dGhpcy5mcmFnQ3VycmVudCYmdGhpcy5sZXZlbHMpe3RoaXMuc3RhdGU9RHQ7dmFyIHI9dGhpcy5sZXZlbHNbZS5mcmFnLmxldmVsXS5kZXRhaWxzO3ImJnRoaXMubG9hZEZyYWdtZW50KGUuZnJhZyxyLGUuZnJhZy5zdGFydCl9fSxoLm9uSGFuZGxlckRlc3Ryb3lpbmc9ZnVuY3Rpb24oKXt0aGlzLnN0b3BMb2FkKCksdC5wcm90b3R5cGUub25IYW5kbGVyRGVzdHJveWluZy5jYWxsKHRoaXMpfSxoLm9uSGFuZGxlckRlc3Ryb3llZD1mdW5jdGlvbigpe3RoaXMuc3RhdGU9UnQsdGhpcy5obHMub2ZmKG4uYS5LRVlfTE9BREVELHRoaXMub25LZXlMb2FkZWQsdGhpcyksdGhpcy5mcmFnbWVudExvYWRlciYmdGhpcy5mcmFnbWVudExvYWRlci5kZXN0cm95KCksdGhpcy5kZWNyeXB0ZXImJnRoaXMuZGVjcnlwdGVyLmRlc3Ryb3koKSx0aGlzLmhscz10aGlzLmxvZz10aGlzLndhcm49dGhpcy5kZWNyeXB0ZXI9dGhpcy5mcmFnbWVudExvYWRlcj10aGlzLmZyYWdtZW50VHJhY2tlcj1udWxsLHQucHJvdG90eXBlLm9uSGFuZGxlckRlc3Ryb3llZC5jYWxsKHRoaXMpfSxoLmxvYWRLZXk9ZnVuY3Rpb24odCxlKXt0aGlzLmxvZyhcIkxvYWRpbmcga2V5IGZvciBcIit0LnNuK1wiIG9mIFtcIitlLnN0YXJ0U04rXCItXCIrZS5lbmRTTitcIl0sIFwiKyhcIltzdHJlYW0tY29udHJvbGxlcl1cIj09PXRoaXMubG9nUHJlZml4P1wibGV2ZWxcIjpcInRyYWNrXCIpK1wiIFwiK3QubGV2ZWwpLHRoaXMuc3RhdGU9X3QsdGhpcy5mcmFnQ3VycmVudD10LHRoaXMuaGxzLnRyaWdnZXIobi5hLktFWV9MT0FESU5HLHtmcmFnOnR9KX0saC5sb2FkRnJhZ21lbnQ9ZnVuY3Rpb24odCxlLHIpe3RoaXMuX2xvYWRGcmFnRm9yUGxheWJhY2sodCxlLHIpfSxoLl9sb2FkRnJhZ0ZvclBsYXliYWNrPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT10aGlzO3RoaXMuX2RvRnJhZ0xvYWQodCxlLHIsKGZ1bmN0aW9uKGUpe2lmKGkuZnJhZ0NvbnRleHRDaGFuZ2VkKHQpKXJldHVybiBpLndhcm4oXCJGcmFnbWVudCBcIit0LnNuKyhlLnBhcnQ/XCIgcDogXCIrZS5wYXJ0LmluZGV4OlwiXCIpK1wiIG9mIGxldmVsIFwiK3QubGV2ZWwrXCIgd2FzIGRyb3BwZWQgZHVyaW5nIGRvd25sb2FkLlwiKSx2b2lkIGkuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHQpO3Quc3RhdHMuY2h1bmtDb3VudCsrLGkuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGUpfSkpLnRoZW4oKGZ1bmN0aW9uKGUpe2lmKGUpe2kuZnJhZ0xvYWRFcnJvcj0wO3ZhciByPWkuc3RhdGU7aWYoIWkuZnJhZ0NvbnRleHRDaGFuZ2VkKHQpKXJldHVyblwicGF5bG9hZFwiaW4gZSYmKGkubG9nKFwiTG9hZGVkIGZyYWdtZW50IFwiK3Quc24rXCIgb2YgbGV2ZWwgXCIrdC5sZXZlbCksaS5obHMudHJpZ2dlcihuLmEuRlJBR19MT0FERUQsZSksaS5zdGF0ZT09PU90KT8oaS5mcmFnbWVudFRyYWNrZXIuYmFja3RyYWNrKHQsZSksdm9pZCBpLnJlc2V0RnJhZ21lbnRMb2FkaW5nKHQpKTp2b2lkIGkuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGUpOyhyPT09a3R8fHI9PT1PdHx8IWkuZnJhZ0N1cnJlbnQmJnI9PT13dCkmJihpLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh0KSxpLnN0YXRlPUR0KX19KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2kud2FybihlKSxpLnJlc2V0RnJhZ21lbnRMb2FkaW5nKHQpfSkpfSxoLmZsdXNoTWFpbkJ1ZmZlcj1mdW5jdGlvbih0LGUscil7aWYodm9pZCAwPT09ciYmKHI9bnVsbCksdC1lKXt2YXIgaT17c3RhcnRPZmZzZXQ6dCxlbmRPZmZzZXQ6ZSx0eXBlOnJ9O3RoaXMuZnJhZ0xvYWRFcnJvcj0wLHRoaXMuaGxzLnRyaWdnZXIobi5hLkJVRkZFUl9GTFVTSElORyxpKX19LGguX2xvYWRJbml0U2VnbWVudD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMuX2RvRnJhZ0xvYWQodCkudGhlbigoZnVuY3Rpb24ocil7aWYoIXJ8fGUuZnJhZ0NvbnRleHRDaGFuZ2VkKHQpfHwhZS5sZXZlbHMpdGhyb3cgbmV3IEVycm9yKFwiaW5pdCBsb2FkIGFib3J0ZWRcIik7cmV0dXJuIHJ9KSkudGhlbigoZnVuY3Rpb24ocil7dmFyIGk9ZS5obHMsYT1yLnBheWxvYWQscz10LmRlY3J5cHRkYXRhO2lmKGEmJmEuYnl0ZUxlbmd0aD4wJiZzJiZzLmtleSYmcy5pdiYmXCJBRVMtMTI4XCI9PT1zLm1ldGhvZCl7dmFyIG89c2VsZi5wZXJmb3JtYW5jZS5ub3coKTtyZXR1cm4gZS5kZWNyeXB0ZXIud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShhKSxzLmtleS5idWZmZXIscy5pdi5idWZmZXIpLnRoZW4oKGZ1bmN0aW9uKGUpe3ZhciBhPXNlbGYucGVyZm9ybWFuY2Uubm93KCk7cmV0dXJuIGkudHJpZ2dlcihuLmEuRlJBR19ERUNSWVBURUQse2ZyYWc6dCxwYXlsb2FkOmUsc3RhdHM6e3RzdGFydDpvLHRkZWNyeXB0OmF9fSksci5wYXlsb2FkPWUscn0pKX1yZXR1cm4gcn0pKS50aGVuKChmdW5jdGlvbihyKXt2YXIgaT1lLmZyYWdDdXJyZW50LGE9ZS5obHMscz1lLmxldmVscztpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJpbml0IGxvYWQgYWJvcnRlZCwgbWlzc2luZyBsZXZlbHNcIik7c1t0LmxldmVsXS5kZXRhaWxzO3ZhciBvPXQuc3RhdHM7ZS5zdGF0ZT1EdCxlLmZyYWdMb2FkRXJyb3I9MCx0LmRhdGE9bmV3IFVpbnQ4QXJyYXkoci5wYXlsb2FkKSxvLnBhcnNpbmcuc3RhcnQ9by5idWZmZXJpbmcuc3RhcnQ9c2VsZi5wZXJmb3JtYW5jZS5ub3coKSxvLnBhcnNpbmcuZW5kPW8uYnVmZmVyaW5nLmVuZD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpLHIuZnJhZz09PWkmJmEudHJpZ2dlcihuLmEuRlJBR19CVUZGRVJFRCx7c3RhdHM6byxmcmFnOmkscGFydDpudWxsLGlkOnQudHlwZX0pLGUudGljaygpfSkpLmNhdGNoKChmdW5jdGlvbihyKXtlLndhcm4ociksZS5yZXNldEZyYWdtZW50TG9hZGluZyh0KX0pKX0saC5mcmFnQ29udGV4dENoYW5nZWQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5mcmFnQ3VycmVudDtyZXR1cm4hdHx8IWV8fHQubGV2ZWwhPT1lLmxldmVsfHx0LnNuIT09ZS5zbnx8dC51cmxJZCE9PWUudXJsSWR9LGguZnJhZ0J1ZmZlcmVkQ29tcGxldGU9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLm1lZGlhQnVmZmVyP3RoaXMubWVkaWFCdWZmZXI6dGhpcy5tZWRpYTt0aGlzLmxvZyhcIkJ1ZmZlcmVkIFwiK3QudHlwZStcIiBzbjogXCIrdC5zbisoZT9cIiBwYXJ0OiBcIitlLmluZGV4OlwiXCIpK1wiIG9mIFwiKyhcIltzdHJlYW0tY29udHJvbGxlcl1cIj09PXRoaXMubG9nUHJlZml4P1wibGV2ZWxcIjpcInRyYWNrXCIpK1wiIFwiK3QubGV2ZWwrXCIgXCIrU3QoYXQuZ2V0QnVmZmVyZWQocikpKSx0aGlzLnN0YXRlPUR0LHRoaXMudGljaygpfSxoLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnRyYW5zbXV4ZXI7aWYoZSl7dmFyIHI9dC5mcmFnLGk9dC5wYXJ0LGE9dC5wYXJ0c0xvYWRlZCxuPSFhfHwwPT09YS5sZW5ndGh8fGEuc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIXR9KSkscz1uZXcgbnQoci5sZXZlbCxyLnNuLHIuc3RhdHMuY2h1bmtDb3VudCsxLDAsaT9pLmluZGV4Oi0xLCFuKTtlLmZsdXNoKHMpfX0saC5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3M9ZnVuY3Rpb24odCl7fSxoLl9kb0ZyYWdMb2FkPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBzPXRoaXM7aWYodm9pZCAwPT09ciYmKHI9bnVsbCksIXRoaXMubGV2ZWxzKXRocm93IG5ldyBFcnJvcihcImZyYWcgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVsc1wiKTtpZihyPU1hdGgubWF4KHQuc3RhcnQscnx8MCksdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUmJmUpe3ZhciBvPWUucGFydExpc3Q7aWYobyYmaSl7cj50LmVuZCYmZS5mcmFnbWVudEhpbnQmJih0PWUuZnJhZ21lbnRIaW50KTt2YXIgbD10aGlzLmdldE5leHRQYXJ0KG8sdCxyKTtpZihsPi0xKXt2YXIgdT1vW2xdO3JldHVybiB0aGlzLmxvZyhcIkxvYWRpbmcgcGFydCBzbjogXCIrdC5zbitcIiBwOiBcIit1LmluZGV4K1wiIGNjOiBcIit0LmNjK1wiIG9mIHBsYXlsaXN0IFtcIitlLnN0YXJ0U04rXCItXCIrZS5lbmRTTitcIl0gcGFydHMgWzAtXCIrbCtcIi1cIisoby5sZW5ndGgtMSkrXCJdIFwiKyhcIltzdHJlYW0tY29udHJvbGxlcl1cIj09PXRoaXMubG9nUHJlZml4P1wibGV2ZWxcIjpcInRyYWNrXCIpK1wiOiBcIit0LmxldmVsK1wiLCB0YXJnZXQ6IFwiK3BhcnNlRmxvYXQoci50b0ZpeGVkKDMpKSksdGhpcy5uZXh0TG9hZFBvc2l0aW9uPXUuc3RhcnQrdS5kdXJhdGlvbix0aGlzLnN0YXRlPWt0LHRoaXMuaGxzLnRyaWdnZXIobi5hLkZSQUdfTE9BRElORyx7ZnJhZzp0LHBhcnQ6b1tsXSx0YXJnZXRCdWZmZXJUaW1lOnJ9KSx0aGlzLmRvRnJhZ1BhcnRzTG9hZCh0LG8sbCxpKS5jYXRjaCgoZnVuY3Rpb24odCl7cmV0dXJuIHMuaGFuZGxlRnJhZ0xvYWRFcnJvcih0KX0pKX1pZighdC51cmx8fHRoaXMubG9hZGVkRW5kT2ZQYXJ0cyhvLHIpKXJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCl9fXJldHVybiB0aGlzLmxvZyhcIkxvYWRpbmcgZnJhZ21lbnQgXCIrdC5zbitcIiBjYzogXCIrdC5jYytcIiBcIisoZT9cIm9mIFtcIitlLnN0YXJ0U04rXCItXCIrZS5lbmRTTitcIl0gXCI6XCJcIikrKFwiW3N0cmVhbS1jb250cm9sbGVyXVwiPT09dGhpcy5sb2dQcmVmaXg/XCJsZXZlbFwiOlwidHJhY2tcIikrXCI6IFwiK3QubGV2ZWwrXCIsIHRhcmdldDogXCIrcGFyc2VGbG9hdChyLnRvRml4ZWQoMykpKSxPYmplY3QoYS5hKSh0LnNuKSYmIXRoaXMuYml0cmF0ZVRlc3QmJih0aGlzLm5leHRMb2FkUG9zaXRpb249dC5zdGFydCt0LmR1cmF0aW9uKSx0aGlzLnN0YXRlPWt0LHRoaXMuaGxzLnRyaWdnZXIobi5hLkZSQUdfTE9BRElORyx7ZnJhZzp0LHRhcmdldEJ1ZmZlclRpbWU6cn0pLHRoaXMuZnJhZ21lbnRMb2FkZXIubG9hZCh0LGkpLmNhdGNoKChmdW5jdGlvbih0KXtyZXR1cm4gcy5oYW5kbGVGcmFnTG9hZEVycm9yKHQpfSkpfSxoLmRvRnJhZ1BhcnRzTG9hZD1mdW5jdGlvbih0LGUscixpKXt2YXIgYT10aGlzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24ocyxvKXt2YXIgbD1bXTshZnVuY3Rpb24gcih1KXt2YXIgZD1lW3VdO2EuZnJhZ21lbnRMb2FkZXIubG9hZFBhcnQodCxkLGkpLnRoZW4oKGZ1bmN0aW9uKGkpe2xbZC5pbmRleF09aTt2YXIgbz1pLnBhcnQ7YS5obHMudHJpZ2dlcihuLmEuRlJBR19MT0FERUQsaSk7dmFyIGg9ZVt1KzFdO2lmKCFofHxoLmZyYWdtZW50IT09dClyZXR1cm4gcyh7ZnJhZzp0LHBhcnQ6byxwYXJ0c0xvYWRlZDpsfSk7cih1KzEpfSkpLmNhdGNoKG8pfShyKX0pKX0saC5oYW5kbGVGcmFnTG9hZEVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0YTtyZXR1cm4gZSYmZS5kZXRhaWxzPT09cy5hLklOVEVSTkFMX0FCT1JURUQ/dGhpcy5oYW5kbGVGcmFnTG9hZEFib3J0ZWQoZS5mcmFnLGUucGFydCk6dGhpcy5obHMudHJpZ2dlcihuLmEuRVJST1IsZSksbnVsbH0saC5faGFuZGxlVHJhbnNtdXhlckZsdXNoPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Q3VycmVudENvbnRleHQodCk7aWYoZSYmdGhpcy5zdGF0ZT09PXd0KXt2YXIgcj1lLmZyYWcsaT1lLnBhcnQsYT1lLmxldmVsLG49c2VsZi5wZXJmb3JtYW5jZS5ub3coKTtyLnN0YXRzLnBhcnNpbmcuZW5kPW4saSYmKGkuc3RhdHMucGFyc2luZy5lbmQ9biksdGhpcy51cGRhdGVMZXZlbFRpbWluZyhyLGksYSx0LnBhcnRpYWwpfWVsc2UgdGhpcy5mcmFnQ3VycmVudHx8KHRoaXMuc3RhdGU9RHQpfSxoLmdldEN1cnJlbnRDb250ZXh0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubGV2ZWxzLHI9dC5sZXZlbCxpPXQuc24sYT10LnBhcnQ7aWYoIWV8fCFlW3JdKXJldHVybiB0aGlzLndhcm4oXCJMZXZlbHMgb2JqZWN0IHdhcyB1bnNldCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgXCIraStcIiBvZiBsZXZlbCBcIityK1wiLiBUaGUgY3VycmVudCBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5cIiksbnVsbDt2YXIgbj1lW3JdLHM9YT4tMT9mdW5jdGlvbih0LGUscil7aWYoIXR8fCF0LmRldGFpbHMpcmV0dXJuIG51bGw7dmFyIGk9dC5kZXRhaWxzLnBhcnRMaXN0O2lmKGkpZm9yKHZhciBhPWkubGVuZ3RoO2EtLTspe3ZhciBuPWlbYV07aWYobi5pbmRleD09PXImJm4uZnJhZ21lbnQuc249PT1lKXJldHVybiBufXJldHVybiBudWxsfShuLGksYSk6bnVsbCxvPXM/cy5mcmFnbWVudDpmdW5jdGlvbih0LGUscil7aWYoIXR8fCF0LmRldGFpbHMpcmV0dXJuIG51bGw7dmFyIGk9dC5kZXRhaWxzLGE9aS5mcmFnbWVudHNbZS1pLnN0YXJ0U05dO3JldHVybiBhfHwoKGE9aS5mcmFnbWVudEhpbnQpJiZhLnNuPT09ZT9hOmU8aS5zdGFydFNOJiZyJiZyLnNuPT09ZT9yOm51bGwpfShuLGksdGhpcy5mcmFnQ3VycmVudCk7cmV0dXJuIG8/e2ZyYWc6byxwYXJ0OnMsbGV2ZWw6bn06bnVsbH0saC5idWZmZXJGcmFnbWVudERhdGE9ZnVuY3Rpb24odCxlLHIsaSl7aWYodCYmdGhpcy5zdGF0ZT09PXd0KXt2YXIgYT10LmRhdGExLHM9dC5kYXRhMixvPWE7aWYoYSYmcyYmKG89T2JqZWN0KGwuYSkoYSxzKSksbyYmby5sZW5ndGgpe3ZhciB1PXt0eXBlOnQudHlwZSxmcmFnOmUscGFydDpyLGNodW5rTWV0YTppLHBhcmVudDplLnR5cGUsZGF0YTpvfTt0aGlzLmhscy50cmlnZ2VyKG4uYS5CVUZGRVJfQVBQRU5ESU5HLHUpLHQuZHJvcHBlZCYmdC5pbmRlcGVuZGVudCYmIXImJnRoaXMuZmx1c2hCdWZmZXJHYXAoZSl9fX0saC5mbHVzaEJ1ZmZlckdhcD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm1lZGlhO2lmKGUpaWYoYXQuaXNCdWZmZXJlZChlLGUuY3VycmVudFRpbWUpKXt2YXIgcj1lLmN1cnJlbnRUaW1lLGk9YXQuYnVmZmVySW5mbyhlLHIsMCksYT10LmR1cmF0aW9uLG49TWF0aC5taW4oMip0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLC4yNSphKSxzPU1hdGgubWF4KE1hdGgubWluKHQuc3RhcnQtbixpLmVuZC1uKSxyK24pO3Quc3RhcnQtcz5uJiZ0aGlzLmZsdXNoTWFpbkJ1ZmZlcihzLHQuc3RhcnQpfWVsc2UgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCx0LnN0YXJ0KX0saC5nZXRGd2RCdWZmZXJJbmZvPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5jb25maWcsaT10aGlzLmdldExvYWRQb3NpdGlvbigpO2lmKCFPYmplY3QoYS5hKShpKSlyZXR1cm4gbnVsbDt2YXIgbj1hdC5idWZmZXJJbmZvKHQsaSxyLm1heEJ1ZmZlckhvbGUpO2lmKDA9PT1uLmxlbiYmdm9pZCAwIT09bi5uZXh0U3RhcnQpe3ZhciBzPXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyhpLGUpO2lmKHMmJm4ubmV4dFN0YXJ0PHMuZW5kKXJldHVybiBhdC5idWZmZXJJbmZvKHQsaSxNYXRoLm1heChuLm5leHRTdGFydCxyLm1heEJ1ZmZlckhvbGUpKX1yZXR1cm4gbn0saC5nZXRNYXhCdWZmZXJMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIGUscj10aGlzLmNvbmZpZztyZXR1cm4gZT10P01hdGgubWF4KDgqci5tYXhCdWZmZXJTaXplL3Qsci5tYXhCdWZmZXJMZW5ndGgpOnIubWF4QnVmZmVyTGVuZ3RoLE1hdGgubWluKGUsci5tYXhNYXhCdWZmZXJMZW5ndGgpfSxoLnJlZHVjZU1heEJ1ZmZlckxlbmd0aD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbmZpZyxyPXR8fGUubWF4QnVmZmVyTGVuZ3RoO3JldHVybiBlLm1heE1heEJ1ZmZlckxlbmd0aD49ciYmKGUubWF4TWF4QnVmZmVyTGVuZ3RoLz0yLHRoaXMud2FybihcIlJlZHVjZSBtYXggYnVmZmVyIGxlbmd0aCB0byBcIitlLm1heE1heEJ1ZmZlckxlbmd0aCtcInNcIiksITApfSxoLmdldE5leHRGcmFnbWVudD1mdW5jdGlvbih0LGUpe3ZhciByLGksYT1lLmZyYWdtZW50cyxuPWEubGVuZ3RoO2lmKCFuKXJldHVybiBudWxsO3ZhciBzLG89dGhpcy5jb25maWcsbD1hWzBdLnN0YXJ0O2lmKGUubGl2ZSl7dmFyIHU9by5pbml0aWFsTGl2ZU1hbmlmZXN0U2l6ZTtpZihuPHUpcmV0dXJuIHRoaXMud2FybihcIk5vdCBlbm91Z2ggZnJhZ21lbnRzIHRvIHN0YXJ0IHBsYXliYWNrIChoYXZlOiBcIituK1wiLCBuZWVkOiBcIit1K1wiKVwiKSxudWxsO2UuUFRTS25vd258fHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkfHwtMSE9PXRoaXMuc3RhcnRQb3NpdGlvbnx8KHM9dGhpcy5nZXRJbml0aWFsTGl2ZUZyYWdtZW50KGUsYSksdGhpcy5zdGFydFBvc2l0aW9uPXM/dGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbnx8cy5zdGFydDp0KX1lbHNlIHQ8PWwmJihzPWFbMF0pO2lmKCFzKXt2YXIgZD1vLmxvd0xhdGVuY3lNb2RlP2UucGFydEVuZDplLmZyYWdtZW50RW5kO3M9dGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24odCxkLGUpfXJldHVybiBudWxsPT09KHI9cyl8fHZvaWQgMD09PXJ8fCFyLmluaXRTZWdtZW50fHxudWxsIT09KGk9cykmJnZvaWQgMCE9PWkmJmkuaW5pdFNlZ21lbnQuZGF0YXx8dGhpcy5iaXRyYXRlVGVzdHx8KHM9cy5pbml0U2VnbWVudCksc30saC5nZXROZXh0UGFydD1mdW5jdGlvbih0LGUscil7Zm9yKHZhciBpPS0xLGE9ITEsbj0hMCxzPTAsbz10Lmxlbmd0aDtzPG87cysrKXt2YXIgbD10W3NdO2lmKG49biYmIWwuaW5kZXBlbmRlbnQsaT4tMSYmcjxsLnN0YXJ0KWJyZWFrO3ZhciB1PWwubG9hZGVkOyF1JiYoYXx8bC5pbmRlcGVuZGVudHx8bikmJmwuZnJhZ21lbnQ9PT1lJiYoaT1zKSxhPXV9cmV0dXJuIGl9LGgubG9hZGVkRW5kT2ZQYXJ0cz1mdW5jdGlvbih0LGUpe3ZhciByPXRbdC5sZW5ndGgtMV07cmV0dXJuIHImJmU+ci5zdGFydCYmci5sb2FkZWR9LGguZ2V0SW5pdGlhbExpdmVGcmFnbWVudD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuZnJhZ1ByZXZpb3VzLGk9bnVsbDtpZihyKXtpZih0Lmhhc1Byb2dyYW1EYXRlVGltZSYmKHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogXCIrci5wcm9ncmFtRGF0ZVRpbWUpLGk9ZnVuY3Rpb24odCxlLHIpe2lmKG51bGw9PT1lfHwhQXJyYXkuaXNBcnJheSh0KXx8IXQubGVuZ3RofHwhT2JqZWN0KGEuYSkoZSkpcmV0dXJuIG51bGw7aWYoZTwodFswXS5wcm9ncmFtRGF0ZVRpbWV8fDApKXJldHVybiBudWxsO2lmKGU+PSh0W3QubGVuZ3RoLTFdLmVuZFByb2dyYW1EYXRlVGltZXx8MCkpcmV0dXJuIG51bGw7cj1yfHwwO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7KytpKXt2YXIgbj10W2ldO2lmKGh0KGUscixuKSlyZXR1cm4gbn1yZXR1cm4gbnVsbH0oZSxyLmVuZFByb2dyYW1EYXRlVGltZSx0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSksIWkpe3ZhciBuPXIuc24rMTtpZihuPj10LnN0YXJ0U04mJm48PXQuZW5kU04pe3ZhciBzPWVbbi10LnN0YXJ0U05dO3IuY2M9PT1zLmNjJiYoaT1zLHRoaXMubG9nKFwiTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiBcIitpLnNuKSl9aXx8KGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdXQodCwoZnVuY3Rpb24odCl7cmV0dXJuIHQuY2M8ZT8xOnQuY2M+ZT8tMTowfSkpfShlLHIuY2MpKSYmdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0LCBzd2l0Y2hpbmcgcGxheWxpc3QsIGxvYWQgZnJhZyB3aXRoIHNhbWUgQ0M6IFwiK2kuc24pfX1lbHNle3ZhciBvPXRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247bnVsbCE9PW8mJihpPXRoaXMuZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKG8sdGhpcy5iaXRyYXRlVGVzdD90LmZyYWdtZW50RW5kOnQuZWRnZSx0KSl9cmV0dXJuIGl9LGguZ2V0RnJhZ21lbnRBdFBvc2l0aW9uPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaSxhPXRoaXMuY29uZmlnLG49dGhpcy5mcmFnUHJldmlvdXMscz1yLmZyYWdtZW50cyxvPXIuZW5kU04sbD1yLmZyYWdtZW50SGludCx1PWEubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSxkPSEhKGEubG93TGF0ZW5jeU1vZGUmJnIucGFydExpc3QmJmwpO2lmKGQmJmwmJiF0aGlzLmJpdHJhdGVUZXN0JiYocz1zLmNvbmNhdChsKSxvPWwuc24pLGk9dDxlP2Z1bmN0aW9uKHQsZSxyLGkpe3ZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PWkmJihpPTApO3ZhciBhPW51bGw7cmV0dXJuIHQ/YT1lW3Quc24tZVswXS5zbisxXXx8bnVsbDowPT09ciYmMD09PWVbMF0uc3RhcnQmJihhPWVbMF0pLGEmJjA9PT1kdChyLGksYSk/YTp1dChlLGR0LmJpbmQobnVsbCxyLGkpKXx8YX0obixzLHQsdD5lLXU/MDp1KTpzW3MubGVuZ3RoLTFdLGkpe3ZhciBoPWkuc24tci5zdGFydFNOLGY9biYmaS5sZXZlbD09PW4ubGV2ZWwsYz1zW2grMV07aWYodGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoaSk9PT1RLkJBQ0tUUkFDS0VEKXtpPW51bGw7Zm9yKHZhciB2PWg7c1t2XSYmdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoc1t2XSk9PT1RLkJBQ0tUUkFDS0VEOylpPW4/c1t2LS1dOnNbLS12XTtpfHwoaT1jKX1lbHNlIG4mJmkuc249PT1uLnNuJiYhZCYmZiYmKGkuc248byYmdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoYykhPT1RLk9LPyh0aGlzLmxvZyhcIlNOIFwiK2kuc24rXCIganVzdCBsb2FkZWQsIGxvYWQgbmV4dCBvbmU6IFwiK2Muc24pLGk9Yyk6aT1udWxsKX1yZXR1cm4gaX0saC5zeW5jaHJvbml6ZVRvTGl2ZUVkZ2U9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb25maWcscj10aGlzLm1lZGlhO2lmKHIpe3ZhciBpPXRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24sYT1yLmN1cnJlbnRUaW1lLG49dC5mcmFnbWVudHNbMF0uc3RhcnQscz10LmVkZ2Usbz1hPj1uLWUubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSYmYTw9cztpZihudWxsIT09aSYmci5kdXJhdGlvbj5pJiYoYTxpfHwhbykpe3ZhciBsPXZvaWQgMCE9PWUubGl2ZU1heExhdGVuY3lEdXJhdGlvbj9lLmxpdmVNYXhMYXRlbmN5RHVyYXRpb246ZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQqdC50YXJnZXRkdXJhdGlvbjsoIW8mJnIucmVhZHlTdGF0ZTw0fHxhPHMtbCkmJih0aGlzLmxvYWRlZG1ldGFkYXRhfHwodGhpcy5uZXh0TG9hZFBvc2l0aW9uPWkpLHIucmVhZHlTdGF0ZSYmKHRoaXMud2FybihcIlBsYXliYWNrOiBcIithLnRvRml4ZWQoMykrXCIgaXMgbG9jYXRlZCB0b28gZmFyIGZyb20gdGhlIGVuZCBvZiBsaXZlIHNsaWRpbmcgcGxheWxpc3Q6IFwiK3MrXCIsIHJlc2V0IGN1cnJlbnRUaW1lIHRvIDogXCIraS50b0ZpeGVkKDMpKSxyLmN1cnJlbnRUaW1lPWkpKX19fSxoLmFsaWduUGxheWxpc3RzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5sZXZlbHMsaT10aGlzLmxldmVsTGFzdExvYWRlZCxuPXRoaXMuZnJhZ1ByZXZpb3VzLHM9bnVsbCE9PWk/cltpXTpudWxsLG89dC5mcmFnbWVudHMubGVuZ3RoO2lmKCFvKXJldHVybiB0aGlzLndhcm4oXCJObyBmcmFnbWVudHMgaW4gbGl2ZSBwbGF5bGlzdFwiKSwwO3ZhciBsPXQuZnJhZ21lbnRzWzBdLnN0YXJ0LHU9IWUsZD10LmFsaWduZWRTbGlkaW5nJiZPYmplY3QoYS5hKShsKTtpZih1fHwhZCYmIWwpe2x0KG4scyx0KTt2YXIgaD10LmZyYWdtZW50c1swXS5zdGFydDtyZXR1cm4gdGhpcy5sb2coXCJMaXZlIHBsYXlsaXN0IHNsaWRpbmc6IFwiK2gudG9GaXhlZCgyKStcIiBzdGFydC1zbjogXCIrKGU/ZS5zdGFydFNOOlwibmFcIikrXCItPlwiK3Quc3RhcnRTTitcIiBwcmV2LXNuOiBcIisobj9uLnNuOlwibmFcIikrXCIgZnJhZ21lbnRzOiBcIitvKSxofXJldHVybiBsfSxoLndhaXRGb3JDZG5UdW5lSW49ZnVuY3Rpb24odCl7cmV0dXJuIHQubGl2ZSYmdC5jYW5CbG9ja1JlbG9hZCYmdC50dW5lSW5Hb2FsPk1hdGgubWF4KHQucGFydEhvbGRCYWNrLDMqdC5wYXJ0VGFyZ2V0KX0saC5zZXRTdGFydFBvc2l0aW9uPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5zdGFydFBvc2l0aW9uO2lmKHI8ZSYmKHI9LTEpLC0xPT09cnx8LTE9PT10aGlzLmxhc3RDdXJyZW50VGltZSl7dmFyIGk9dC5zdGFydFRpbWVPZmZzZXQ7T2JqZWN0KGEuYSkoaSk/KHI9ZStpLGk8MCYmKHIrPXQudG90YWxkdXJhdGlvbikscj1NYXRoLm1pbihNYXRoLm1heChlLHIpLGUrdC50b3RhbGR1cmF0aW9uKSx0aGlzLmxvZyhcIlN0YXJ0IHRpbWUgb2Zmc2V0IFwiK2krXCIgZm91bmQgaW4gcGxheWxpc3QsIGFkanVzdCBzdGFydFBvc2l0aW9uIHRvIFwiK3IpLHRoaXMuc3RhcnRQb3NpdGlvbj1yKTp0LmxpdmU/cj10aGlzLmhscy5saXZlU3luY1Bvc2l0aW9ufHxlOnRoaXMuc3RhcnRQb3NpdGlvbj1yPTAsdGhpcy5sYXN0Q3VycmVudFRpbWU9cn10aGlzLm5leHRMb2FkUG9zaXRpb249cn0saC5nZXRMb2FkUG9zaXRpb249ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhLGU9MDtyZXR1cm4gdGhpcy5sb2FkZWRtZXRhZGF0YSYmdD9lPXQuY3VycmVudFRpbWU6dGhpcy5uZXh0TG9hZFBvc2l0aW9uJiYoZT10aGlzLm5leHRMb2FkUG9zaXRpb24pLGV9LGguaGFuZGxlRnJhZ0xvYWRBYm9ydGVkPWZ1bmN0aW9uKHQsZSl7dGhpcy50cmFuc211eGVyJiZcImluaXRTZWdtZW50XCIhPT10LnNuJiZ0LnN0YXRzLmFib3J0ZWQmJih0aGlzLndhcm4oXCJGcmFnbWVudCBcIit0LnNuKyhlP1wiIHBhcnRcIitlLmluZGV4OlwiXCIpK1wiIG9mIGxldmVsIFwiK3QubGV2ZWwrXCIgd2FzIGFib3J0ZWRcIiksdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyh0KSl9LGgucmVzZXRGcmFnbWVudExvYWRpbmc9ZnVuY3Rpb24odCl7dGhpcy5mcmFnQ3VycmVudCYmdGhpcy5mcmFnQ29udGV4dENoYW5nZWQodCl8fCh0aGlzLnN0YXRlPUR0KX0saC5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3I9ZnVuY3Rpb24odCxlKXtpZighZS5mYXRhbCl7dmFyIHI9ZS5mcmFnO2lmKHImJnIudHlwZT09PXQpe3RoaXMuZnJhZ0N1cnJlbnQ7dmFyIGk9dGhpcy5jb25maWc7aWYodGhpcy5mcmFnTG9hZEVycm9yKzE8PWkuZnJhZ0xvYWRpbmdNYXhSZXRyeSl7aWYodGhpcy5yZXNldExpdmVTdGFydFdoZW5Ob3RMb2FkZWQoci5sZXZlbCkpcmV0dXJuO3ZhciBhPU1hdGgubWluKE1hdGgucG93KDIsdGhpcy5mcmFnTG9hZEVycm9yKSppLmZyYWdMb2FkaW5nUmV0cnlEZWxheSxpLmZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0KTt0aGlzLndhcm4oXCJGcmFnbWVudCBcIityLnNuK1wiIG9mIFwiK3QrXCIgXCIrci5sZXZlbCtcIiBmYWlsZWQgdG8gbG9hZCwgcmV0cnlpbmcgaW4gXCIrYStcIm1zXCIpLHRoaXMucmV0cnlEYXRlPXNlbGYucGVyZm9ybWFuY2Uubm93KCkrYSx0aGlzLmZyYWdMb2FkRXJyb3IrKyx0aGlzLnN0YXRlPXh0fWVsc2UgZS5sZXZlbFJldHJ5Pyh0PT09Xy5iLkFVRElPJiYodGhpcy5mcmFnQ3VycmVudD1udWxsKSx0aGlzLmZyYWdMb2FkRXJyb3I9MCx0aGlzLnN0YXRlPUR0KTooby5iLmVycm9yKGUuZGV0YWlscytcIiByZWFjaGVzIG1heCByZXRyeSwgcmVkaXNwYXRjaCBhcyBmYXRhbCAuLi5cIiksZS5mYXRhbD0hMCx0aGlzLmhscy5zdG9wTG9hZCgpLHRoaXMuc3RhdGU9UHQpfX19LGguYWZ0ZXJCdWZmZXJGbHVzaGVkPWZ1bmN0aW9uKHQsZSxyKXtpZih0KXt2YXIgaT1hdC5nZXRCdWZmZXJlZCh0KTt0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGUsaSxyKSx0aGlzLnN0YXRlPT09SXQmJnRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKX19LGgucmVzZXRMb2FkaW5nU3RhdGU9ZnVuY3Rpb24oKXt0aGlzLmZyYWdDdXJyZW50PW51bGwsdGhpcy5mcmFnUHJldmlvdXM9bnVsbCx0aGlzLnN0YXRlPUR0fSxoLnJlc2V0TGl2ZVN0YXJ0V2hlbk5vdExvYWRlZD1mdW5jdGlvbih0KXtpZighdGhpcy5sb2FkZWRtZXRhZGF0YSl7dGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQ9ITE7dmFyIGU9dGhpcy5sZXZlbHM/dGhpcy5sZXZlbHNbdF0uZGV0YWlsczpudWxsO2lmKG51bGwhPWUmJmUubGl2ZSlyZXR1cm4gdGhpcy5zdGFydFBvc2l0aW9uPS0xLHRoaXMuc2V0U3RhcnRQb3NpdGlvbihlLDApLHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKSwhMDt0aGlzLm5leHRMb2FkUG9zaXRpb249dGhpcy5zdGFydFBvc2l0aW9ufXJldHVybiExfSxoLnVwZGF0ZUxldmVsVGltaW5nPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXRoaXMscz1yLmRldGFpbHM7T2JqZWN0LmtleXModC5lbGVtZW50YXJ5U3RyZWFtcykucmVkdWNlKChmdW5jdGlvbihlLG8pe3ZhciBsPXQuZWxlbWVudGFyeVN0cmVhbXNbb107aWYobCl7dmFyIHU9bC5lbmRQVFMtbC5zdGFydFBUUztpZih1PD0wKXJldHVybiBhLndhcm4oXCJDb3VsZCBub3QgcGFyc2UgZnJhZ21lbnQgXCIrdC5zbitcIiBcIitvK1wiIGR1cmF0aW9uIHJlbGlhYmx5IChcIit1K1wiKSByZXNldHRpbmcgdHJhbnNtdXhlciB0byBmYWxsYmFjayB0byBwbGF5bGlzdCB0aW1pbmdcIiksYS5yZXNldFRyYW5zbXV4ZXIoKSxlfHwhMTt2YXIgZD1pPzA6SyhzLHQsbC5zdGFydFBUUyxsLmVuZFBUUyxsLnN0YXJ0RFRTLGwuZW5kRFRTKTtyZXR1cm4gYS5obHMudHJpZ2dlcihuLmEuTEVWRUxfUFRTX1VQREFURUQse2RldGFpbHM6cyxsZXZlbDpyLGRyaWZ0OmQsdHlwZTpvLGZyYWc6dCxzdGFydDpsLnN0YXJ0UFRTLGVuZDpsLmVuZFBUU30pLCEwfXJldHVybiBlfSksITEpPyh0aGlzLnN0YXRlPUN0LHRoaXMuaGxzLnRyaWdnZXIobi5hLkZSQUdfUEFSU0VELHtmcmFnOnQscGFydDplfSkpOnRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKX0saC5yZXNldFRyYW5zbXV4ZXI9ZnVuY3Rpb24oKXt0aGlzLnRyYW5zbXV4ZXImJih0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpLHRoaXMudHJhbnNtdXhlcj1udWxsKX0sdT1pLChkPVt7a2V5Olwic3RhdGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhdGV9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9zdGF0ZTtlIT09dCYmKHRoaXMuX3N0YXRlPXQsdGhpcy5sb2coZStcIi0+XCIrdCkpfX1dKSYmTHQodS5wcm90b3R5cGUsZCksaX0ocnQpO2Z1bmN0aW9uIE50KCl7cmV0dXJuIHNlbGYuTWVkaWFTb3VyY2V8fHNlbGYuV2ViS2l0TWVkaWFTb3VyY2V9ZnVuY3Rpb24gQnQoKXtyZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXJ8fHNlbGYuV2ViS2l0U291cmNlQnVmZmVyfXZhciBVdD1yKDE3KSxHdD1yKDkpLGp0PXIoMTMpLEh0PU50KCl8fHtpc1R5cGVTdXBwb3J0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX19LEt0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscixpKXt2YXIgYT10aGlzO3RoaXMuaGxzPXZvaWQgMCx0aGlzLmlkPXZvaWQgMCx0aGlzLm9ic2VydmVyPXZvaWQgMCx0aGlzLmZyYWc9bnVsbCx0aGlzLnBhcnQ9bnVsbCx0aGlzLndvcmtlcj12b2lkIDAsdGhpcy5vbndtc2c9dm9pZCAwLHRoaXMudHJhbnNtdXhlcj1udWxsLHRoaXMub25UcmFuc211eENvbXBsZXRlPXZvaWQgMCx0aGlzLm9uRmx1c2g9dm9pZCAwLHRoaXMuaGxzPXQsdGhpcy5pZD1lLHRoaXMub25UcmFuc211eENvbXBsZXRlPXIsdGhpcy5vbkZsdXNoPWk7dmFyIGw9dC5jb25maWcsdT1mdW5jdGlvbihlLHIpeyhyPXJ8fHt9KS5mcmFnPWEuZnJhZyxyLmlkPWEuaWQsdC50cmlnZ2VyKGUscil9O3RoaXMub2JzZXJ2ZXI9bmV3IGp0LkV2ZW50RW1pdHRlcix0aGlzLm9ic2VydmVyLm9uKG4uYS5GUkFHX0RFQ1JZUFRFRCx1KSx0aGlzLm9ic2VydmVyLm9uKG4uYS5FUlJPUix1KTt2YXIgZD17bXA0Okh0LmlzVHlwZVN1cHBvcnRlZChcInZpZGVvL21wNFwiKSxtcGVnOkh0LmlzVHlwZVN1cHBvcnRlZChcImF1ZGlvL21wZWdcIiksbXAzOkh0LmlzVHlwZVN1cHBvcnRlZCgnYXVkaW8vbXA0OyBjb2RlY3M9XCJtcDNcIicpfSxoPW5hdmlnYXRvci52ZW5kb3I7aWYobC5lbmFibGVXb3JrZXImJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBXb3JrZXIpe3ZhciBmO28uYi5sb2coXCJkZW11eGluZyBpbiB3ZWJ3b3JrZXJcIik7dHJ5e2Y9dGhpcy53b3JrZXI9VXQoMTgpLHRoaXMub253bXNnPXRoaXMub25Xb3JrZXJNZXNzYWdlLmJpbmQodGhpcyksZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMub253bXNnKSxmLm9uZXJyb3I9ZnVuY3Rpb24oZSl7dC50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuT1RIRVJfRVJST1IsZGV0YWlsczpzLmEuSU5URVJOQUxfRVhDRVBUSU9OLGZhdGFsOiEwLGV2ZW50OlwiZGVtdXhlcldvcmtlclwiLGVycm9yOm5ldyBFcnJvcihlLm1lc3NhZ2UrXCIgIChcIitlLmZpbGVuYW1lK1wiOlwiK2UubGluZW5vK1wiKVwiKX0pfSxmLnBvc3RNZXNzYWdlKHtjbWQ6XCJpbml0XCIsdHlwZVN1cHBvcnRlZDpkLHZlbmRvcjpoLGlkOmUsY29uZmlnOkpTT04uc3RyaW5naWZ5KGwpfSl9Y2F0Y2godCl7by5iLndhcm4oXCJFcnJvciBpbiB3b3JrZXI6XCIsdCksby5iLmVycm9yKFwiRXJyb3Igd2hpbGUgaW5pdGlhbGl6aW5nIERlbXV4ZXJXb3JrZXIsIGZhbGxiYWNrIHRvIGlubGluZVwiKSxmJiZzZWxmLlVSTC5yZXZva2VPYmplY3RVUkwoZi5vYmplY3RVUkwpLHRoaXMudHJhbnNtdXhlcj1uZXcgR3QuYyh0aGlzLm9ic2VydmVyLGQsbCxoLGUpLHRoaXMud29ya2VyPW51bGx9fWVsc2UgdGhpcy50cmFuc211eGVyPW5ldyBHdC5jKHRoaXMub2JzZXJ2ZXIsZCxsLGgsZSl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciB0PXRoaXMud29ya2VyO2lmKHQpdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMub253bXNnKSx0LnRlcm1pbmF0ZSgpLHRoaXMud29ya2VyPW51bGw7ZWxzZXt2YXIgZT10aGlzLnRyYW5zbXV4ZXI7ZSYmKGUuZGVzdHJveSgpLHRoaXMudHJhbnNtdXhlcj1udWxsKX12YXIgcj10aGlzLm9ic2VydmVyO3ImJnIucmVtb3ZlQWxsTGlzdGVuZXJzKCksdGhpcy5vYnNlcnZlcj1udWxsfSxlLnB1c2g9ZnVuY3Rpb24odCxlLHIsaSxhLG4scyxsLHUsZCl7dmFyIGgsZixjPXRoaXM7dS50cmFuc211eGluZy5zdGFydD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO3ZhciB2PXRoaXMudHJhbnNtdXhlcixnPXRoaXMud29ya2VyLHA9bj9uLnN0YXJ0OmEuc3RhcnQsbT1hLmRlY3J5cHRkYXRhLHk9dGhpcy5mcmFnLGI9ISh5JiZhLmNjPT09eS5jYyksVD0hKHkmJnUubGV2ZWw9PT15LmxldmVsKSxFPXk/dS5zbi15LnNuOi0xLFM9dGhpcy5wYXJ0P3UucGFydC10aGlzLnBhcnQuaW5kZXg6MSxMPSFUJiYoMT09PUV8fDA9PT1FJiYxPT09UyksQT1zZWxmLnBlcmZvcm1hbmNlLm5vdygpOyhUfHxFfHwwPT09YS5zdGF0cy5wYXJzaW5nLnN0YXJ0KSYmKGEuc3RhdHMucGFyc2luZy5zdGFydD1BKSwhbnx8IVMmJkx8fChuLnN0YXRzLnBhcnNpbmcuc3RhcnQ9QSk7dmFyIFI9ISh5JiYobnVsbD09PShoPWEuaW5pdFNlZ21lbnQpfHx2b2lkIDA9PT1oP3ZvaWQgMDpoLnVybCk9PT0obnVsbD09PShmPXkuaW5pdFNlZ21lbnQpfHx2b2lkIDA9PT1mP3ZvaWQgMDpmLnVybCkpLEQ9bmV3IEd0LmIoYixMLGwsVCxwLFIpO2lmKCFMfHxifHxSKXtvLmIubG9nKFwiW3RyYW5zbXV4ZXItaW50ZXJmYWNlLCBcIithLnR5cGUrXCJdOiBTdGFydGluZyBuZXcgdHJhbnNtdXggc2Vzc2lvbiBmb3Igc246IFwiK3Uuc24rXCIgcDogXCIrdS5wYXJ0K1wiIGxldmVsOiBcIit1LmxldmVsK1wiIGlkOiBcIit1LmlkK1wiXFxuICAgICAgICBkaXNjb250aW51aXR5OiBcIitiK1wiXFxuICAgICAgICB0cmFja1N3aXRjaDogXCIrVCtcIlxcbiAgICAgICAgY29udGlndW91czogXCIrTCtcIlxcbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBcIitsK1wiXFxuICAgICAgICB0aW1lT2Zmc2V0OiBcIitwK1wiXFxuICAgICAgICBpbml0U2VnbWVudENoYW5nZTogXCIrUik7dmFyIF89bmV3IEd0LmEocixpLGUscyxkKTt0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIoXyl9aWYodGhpcy5mcmFnPWEsdGhpcy5wYXJ0PW4sZylnLnBvc3RNZXNzYWdlKHtjbWQ6XCJkZW11eFwiLGRhdGE6dCxkZWNyeXB0ZGF0YTptLGNodW5rTWV0YTp1LHN0YXRlOkR9LHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9bdF06W10pO2Vsc2UgaWYodil7dmFyIGs9di5wdXNoKHQsbSx1LEQpO09iamVjdChHdC5kKShrKT9rLnRoZW4oKGZ1bmN0aW9uKHQpe2MuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZSh0KX0pKTp0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoayl9fSxlLmZsdXNoPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7dC50cmFuc211eGluZy5zdGFydD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO3ZhciByPXRoaXMudHJhbnNtdXhlcixpPXRoaXMud29ya2VyO2lmKGkpaS5wb3N0TWVzc2FnZSh7Y21kOlwiZmx1c2hcIixjaHVua01ldGE6dH0pO2Vsc2UgaWYocil7dmFyIGE9ci5mbHVzaCh0KTtPYmplY3QoR3QuZCkoYSk/YS50aGVuKChmdW5jdGlvbihyKXtlLmhhbmRsZUZsdXNoUmVzdWx0KHIsdCl9KSk6dGhpcy5oYW5kbGVGbHVzaFJlc3VsdChhLHQpfX0sZS5oYW5kbGVGbHVzaFJlc3VsdD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7dC5mb3JFYWNoKChmdW5jdGlvbih0KXtyLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUodCl9KSksdGhpcy5vbkZsdXNoKGUpfSxlLm9uV29ya2VyTWVzc2FnZT1mdW5jdGlvbih0KXt2YXIgZT10LmRhdGEscj10aGlzLmhscztzd2l0Y2goZS5ldmVudCl7Y2FzZVwiaW5pdFwiOnNlbGYuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLndvcmtlci5vYmplY3RVUkwpO2JyZWFrO2Nhc2VcInRyYW5zbXV4Q29tcGxldGVcIjp0aGlzLmhhbmRsZVRyYW5zbXV4Q29tcGxldGUoZS5kYXRhKTticmVhaztjYXNlXCJmbHVzaFwiOnRoaXMub25GbHVzaChlLmRhdGEpO2JyZWFrO2RlZmF1bHQ6ZS5kYXRhPWUuZGF0YXx8e30sZS5kYXRhLmZyYWc9dGhpcy5mcmFnLGUuZGF0YS5pZD10aGlzLmlkLHIudHJpZ2dlcihlLmV2ZW50LGUuZGF0YSl9fSxlLmNvbmZpZ3VyZVRyYW5zbXV4ZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy53b3JrZXIscj10aGlzLnRyYW5zbXV4ZXI7ZT9lLnBvc3RNZXNzYWdlKHtjbWQ6XCJjb25maWd1cmVcIixjb25maWc6dH0pOnImJnIuY29uZmlndXJlKHQpfSxlLmhhbmRsZVRyYW5zbXV4Q29tcGxldGU9ZnVuY3Rpb24odCl7dC5jaHVua01ldGEudHJhbnNtdXhpbmcuZW5kPXNlbGYucGVyZm9ybWFuY2Uubm93KCksdGhpcy5vblRyYW5zbXV4Q29tcGxldGUodCl9LHR9KCksVnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyLGkpe3RoaXMuY29uZmlnPXZvaWQgMCx0aGlzLm1lZGlhPXZvaWQgMCx0aGlzLmZyYWdtZW50VHJhY2tlcj12b2lkIDAsdGhpcy5obHM9dm9pZCAwLHRoaXMubnVkZ2VSZXRyeT0wLHRoaXMuc3RhbGxSZXBvcnRlZD0hMSx0aGlzLnN0YWxsZWQ9bnVsbCx0aGlzLm1vdmVkPSExLHRoaXMuc2Vla2luZz0hMSx0aGlzLmNvbmZpZz10LHRoaXMubWVkaWE9ZSx0aGlzLmZyYWdtZW50VHJhY2tlcj1yLHRoaXMuaGxzPWl9dmFyIGU9dC5wcm90b3R5cGU7cmV0dXJuIGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuaGxzPXRoaXMuZnJhZ21lbnRUcmFja2VyPXRoaXMubWVkaWE9bnVsbH0sZS5wb2xsPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29uZmlnLHI9dGhpcy5tZWRpYSxpPXRoaXMuc3RhbGxlZCxhPXIuY3VycmVudFRpbWUsbj1yLnNlZWtpbmcscz10aGlzLnNlZWtpbmcmJiFuLGw9IXRoaXMuc2Vla2luZyYmbjtpZih0aGlzLnNlZWtpbmc9bixhPT09dCl7aWYoKGx8fHMpJiYodGhpcy5zdGFsbGVkPW51bGwpLCFyLnBhdXNlZCYmIXIuZW5kZWQmJjAhPT1yLnBsYXliYWNrUmF0ZSYmYXQuZ2V0QnVmZmVyZWQocikubGVuZ3RoKXt2YXIgdT1hdC5idWZmZXJJbmZvKHIsYSwwKSxkPXUubGVuPjAsaD11Lm5leHRTdGFydHx8MDtpZihkfHxoKXtpZihuKXt2YXIgZj11Lmxlbj4yLGM9IWh8fGgtYT4yJiYhdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0UGFydGlhbEZyYWdtZW50KGEpO2lmKGZ8fGMpcmV0dXJuO3RoaXMubW92ZWQ9ITF9aWYoIXRoaXMubW92ZWQmJm51bGwhPT10aGlzLnN0YWxsZWQpe3ZhciB2LGc9TWF0aC5tYXgoaCx1LnN0YXJ0fHwwKS1hLHA9dGhpcy5obHMubGV2ZWxzP3RoaXMuaGxzLmxldmVsc1t0aGlzLmhscy5jdXJyZW50TGV2ZWxdOm51bGwsbT0obnVsbD09cHx8bnVsbD09PSh2PXAuZGV0YWlscyl8fHZvaWQgMD09PXY/dm9pZCAwOnYubGl2ZSk/MipwLmRldGFpbHMudGFyZ2V0ZHVyYXRpb246MjtpZihnPjAmJmc8PW0pcmV0dXJuIHZvaWQgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUobnVsbCl9dmFyIHk9c2VsZi5wZXJmb3JtYW5jZS5ub3coKTtpZihudWxsIT09aSl7dmFyIGI9eS1pOyFuJiZiPj0yNTAmJnRoaXMuX3JlcG9ydFN0YWxsKHUubGVuKTt2YXIgVD1hdC5idWZmZXJJbmZvKHIsYSxlLm1heEJ1ZmZlckhvbGUpO3RoaXMuX3RyeUZpeEJ1ZmZlclN0YWxsKFQsYil9ZWxzZSB0aGlzLnN0YWxsZWQ9eX19fWVsc2UgaWYodGhpcy5tb3ZlZD0hMCxudWxsIT09aSl7aWYodGhpcy5zdGFsbFJlcG9ydGVkKXt2YXIgRT1zZWxmLnBlcmZvcm1hbmNlLm5vdygpLWk7by5iLndhcm4oXCJwbGF5YmFjayBub3Qgc3R1Y2sgYW55bW9yZSBAXCIrYStcIiwgYWZ0ZXIgXCIrTWF0aC5yb3VuZChFKStcIm1zXCIpLHRoaXMuc3RhbGxSZXBvcnRlZD0hMX10aGlzLnN0YWxsZWQ9bnVsbCx0aGlzLm51ZGdlUmV0cnk9MH19LGUuX3RyeUZpeEJ1ZmZlclN0YWxsPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5jb25maWcsaT10aGlzLmZyYWdtZW50VHJhY2tlcixhPXRoaXMubWVkaWEuY3VycmVudFRpbWUsbj1pLmdldFBhcnRpYWxGcmFnbWVudChhKTtuJiZ0aGlzLl90cnlTa2lwQnVmZmVySG9sZShuKXx8dC5sZW4+ci5tYXhCdWZmZXJIb2xlJiZlPjFlMypyLmhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZCYmKG8uYi53YXJuKFwiVHJ5aW5nIHRvIG51ZGdlIHBsYXloZWFkIG92ZXIgYnVmZmVyLWhvbGVcIiksdGhpcy5zdGFsbGVkPW51bGwsdGhpcy5fdHJ5TnVkZ2VCdWZmZXIoKSl9LGUuX3JlcG9ydFN0YWxsPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaGxzLHI9dGhpcy5tZWRpYTt0aGlzLnN0YWxsUmVwb3J0ZWR8fCh0aGlzLnN0YWxsUmVwb3J0ZWQ9ITAsby5iLndhcm4oXCJQbGF5YmFjayBzdGFsbGluZyBhdCBAXCIrci5jdXJyZW50VGltZStcIiBkdWUgdG8gbG93IGJ1ZmZlciAoYnVmZmVyPVwiK3QrXCIpXCIpLGUudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk1FRElBX0VSUk9SLGRldGFpbHM6cy5hLkJVRkZFUl9TVEFMTEVEX0VSUk9SLGZhdGFsOiExLGJ1ZmZlcjp0fSkpfSxlLl90cnlTa2lwQnVmZmVySG9sZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5jb25maWcscj10aGlzLmhscyxpPXRoaXMubWVkaWEsYT1pLmN1cnJlbnRUaW1lLGw9MCx1PWF0LmdldEJ1ZmZlcmVkKGkpLGQ9MDtkPHUubGVuZ3RoO2QrKyl7dmFyIGg9dS5zdGFydChkKTtpZihhK2UubWF4QnVmZmVySG9sZT49bCYmYTxoKXt2YXIgZj1NYXRoLm1heChoKy4wNSxpLmN1cnJlbnRUaW1lKy4xKTtyZXR1cm4gby5iLndhcm4oXCJza2lwcGluZyBob2xlLCBhZGp1c3RpbmcgY3VycmVudFRpbWUgZnJvbSBcIithK1wiIHRvIFwiK2YpLHRoaXMubW92ZWQ9ITAsdGhpcy5zdGFsbGVkPW51bGwsaS5jdXJyZW50VGltZT1mLHQmJnIudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk1FRElBX0VSUk9SLGRldGFpbHM6cy5hLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxmYXRhbDohMSxyZWFzb246XCJmcmFnbWVudCBsb2FkZWQgd2l0aCBidWZmZXIgaG9sZXMsIHNlZWtpbmcgZnJvbSBcIithK1wiIHRvIFwiK2YsZnJhZzp0fSksZn1sPXUuZW5kKGQpfXJldHVybiAwfSxlLl90cnlOdWRnZUJ1ZmZlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuY29uZmlnLGU9dGhpcy5obHMscj10aGlzLm1lZGlhLGk9ci5jdXJyZW50VGltZSxhPSh0aGlzLm51ZGdlUmV0cnl8fDApKzE7aWYodGhpcy5udWRnZVJldHJ5PWEsYTx0Lm51ZGdlTWF4UmV0cnkpe3ZhciBsPWkrYSp0Lm51ZGdlT2Zmc2V0O28uYi53YXJuKFwiTnVkZ2luZyAnY3VycmVudFRpbWUnIGZyb20gXCIraStcIiB0byBcIitsKSxyLmN1cnJlbnRUaW1lPWwsZS50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTUVESUFfRVJST1IsZGV0YWlsczpzLmEuQlVGRkVSX05VREdFX09OX1NUQUxMLGZhdGFsOiExfSl9ZWxzZSBvLmIuZXJyb3IoXCJQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEBcIitpK1wiIGFmdGVyIFwiK3QubnVkZ2VNYXhSZXRyeStcIiBudWRnZXNcIiksZS50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTUVESUFfRVJST1IsZGV0YWlsczpzLmEuQlVGRkVSX1NUQUxMRURfRVJST1IsZmF0YWw6ITB9KX0sdH0oKTtmdW5jdGlvbiBXdCh0LGUpe2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgaT1lW3JdO2kuZW51bWVyYWJsZT1pLmVudW1lcmFibGV8fCExLGkuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIGkmJihpLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLmtleSxpKX19ZnVuY3Rpb24gWXQodCxlKXtyZXR1cm4oWXQ9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfXZhciBYdD1mdW5jdGlvbih0KXt2YXIgZSxyO2Z1bmN0aW9uIGkoZSxyKXt2YXIgaTtyZXR1cm4oaT10LmNhbGwodGhpcyxlLHIsXCJbc3RyZWFtLWNvbnRyb2xsZXJdXCIpfHx0aGlzKS5hdWRpb0NvZGVjU3dhcD0hMSxpLmdhcENvbnRyb2xsZXI9bnVsbCxpLmxldmVsPS0xLGkuX2ZvcmNlU3RhcnRMb2FkPSExLGkuYWx0QXVkaW89ITEsaS5hdWRpb09ubHk9ITEsaS5mcmFnUGxheWluZz1udWxsLGkub252cGxheWluZz1udWxsLGkub252c2Vla2VkPW51bGwsaS5mcmFnTGFzdEticHM9MCxpLnN0YWxsZWQ9ITEsaS5jb3VsZEJhY2t0cmFjaz0hMSxpLmF1ZGlvQ29kZWNTd2l0Y2g9ITEsaS52aWRlb0J1ZmZlcj1udWxsLGkuX3JlZ2lzdGVyTGlzdGVuZXJzKCksaX1yPXQsKGU9aSkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoci5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsWXQoZSxyKTt2YXIgbCxkLGg9aS5wcm90b3R5cGU7cmV0dXJuIGguX3JlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vbihuLmEuTUVESUFfQVRUQUNIRUQsdGhpcy5vbk1lZGlhQXR0YWNoZWQsdGhpcyksdC5vbihuLmEuTUVESUFfREVUQUNISU5HLHRoaXMub25NZWRpYURldGFjaGluZyx0aGlzKSx0Lm9uKG4uYS5NQU5JRkVTVF9MT0FESU5HLHRoaXMub25NYW5pZmVzdExvYWRpbmcsdGhpcyksdC5vbihuLmEuTUFOSUZFU1RfUEFSU0VELHRoaXMub25NYW5pZmVzdFBhcnNlZCx0aGlzKSx0Lm9uKG4uYS5MRVZFTF9MT0FESU5HLHRoaXMub25MZXZlbExvYWRpbmcsdGhpcyksdC5vbihuLmEuTEVWRUxfTE9BREVELHRoaXMub25MZXZlbExvYWRlZCx0aGlzKSx0Lm9uKG4uYS5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCx0aGlzKSx0Lm9uKG4uYS5FUlJPUix0aGlzLm9uRXJyb3IsdGhpcyksdC5vbihuLmEuQVVESU9fVFJBQ0tfU1dJVENISU5HLHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLHRoaXMpLHQub24obi5hLkFVRElPX1RSQUNLX1NXSVRDSEVELHRoaXMub25BdWRpb1RyYWNrU3dpdGNoZWQsdGhpcyksdC5vbihuLmEuQlVGRkVSX0NSRUFURUQsdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsdGhpcyksdC5vbihuLmEuQlVGRkVSX0ZMVVNIRUQsdGhpcy5vbkJ1ZmZlckZsdXNoZWQsdGhpcyksdC5vbihuLmEuTEVWRUxTX1VQREFURUQsdGhpcy5vbkxldmVsc1VwZGF0ZWQsdGhpcyksdC5vbihuLmEuRlJBR19CVUZGRVJFRCx0aGlzLm9uRnJhZ0J1ZmZlcmVkLHRoaXMpfSxoLl91bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLk1FRElBX0FUVEFDSEVELHRoaXMub25NZWRpYUF0dGFjaGVkLHRoaXMpLHQub2ZmKG4uYS5NRURJQV9ERVRBQ0hJTkcsdGhpcy5vbk1lZGlhRGV0YWNoaW5nLHRoaXMpLHQub2ZmKG4uYS5NQU5JRkVTVF9MT0FESU5HLHRoaXMub25NYW5pZmVzdExvYWRpbmcsdGhpcyksdC5vZmYobi5hLk1BTklGRVNUX1BBUlNFRCx0aGlzLm9uTWFuaWZlc3RQYXJzZWQsdGhpcyksdC5vZmYobi5hLkxFVkVMX0xPQURFRCx0aGlzLm9uTGV2ZWxMb2FkZWQsdGhpcyksdC5vZmYobi5hLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCx0aGlzLm9uRnJhZ0xvYWRFbWVyZ2VuY3lBYm9ydGVkLHRoaXMpLHQub2ZmKG4uYS5FUlJPUix0aGlzLm9uRXJyb3IsdGhpcyksdC5vZmYobi5hLkFVRElPX1RSQUNLX1NXSVRDSElORyx0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZyx0aGlzKSx0Lm9mZihuLmEuQVVESU9fVFJBQ0tfU1dJVENIRUQsdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hlZCx0aGlzKSx0Lm9mZihuLmEuQlVGRkVSX0NSRUFURUQsdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9GTFVTSEVELHRoaXMub25CdWZmZXJGbHVzaGVkLHRoaXMpLHQub2ZmKG4uYS5MRVZFTFNfVVBEQVRFRCx0aGlzLm9uTGV2ZWxzVXBkYXRlZCx0aGlzKSx0Lm9mZihuLmEuRlJBR19CVUZGRVJFRCx0aGlzLm9uRnJhZ0J1ZmZlcmVkLHRoaXMpfSxoLm9uSGFuZGxlckRlc3Ryb3lpbmc9ZnVuY3Rpb24oKXt0aGlzLl91bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5vbk1lZGlhRGV0YWNoaW5nKCl9LGguc3RhcnRMb2FkPWZ1bmN0aW9uKHQpe2lmKHRoaXMubGV2ZWxzKXt2YXIgZT10aGlzLmxhc3RDdXJyZW50VGltZSxyPXRoaXMuaGxzO2lmKHRoaXMuc3RvcExvYWQoKSx0aGlzLnNldEludGVydmFsKDEwMCksdGhpcy5sZXZlbD0tMSx0aGlzLmZyYWdMb2FkRXJyb3I9MCwhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpe3ZhciBpPXIuc3RhcnRMZXZlbDstMT09PWkmJihyLmNvbmZpZy50ZXN0QmFuZHdpZHRoPyhpPTAsdGhpcy5iaXRyYXRlVGVzdD0hMCk6aT1yLm5leHRBdXRvTGV2ZWwpLHRoaXMubGV2ZWw9ci5uZXh0TG9hZExldmVsPWksdGhpcy5sb2FkZWRtZXRhZGF0YT0hMX1lPjAmJi0xPT09dCYmKHRoaXMubG9nKFwiT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAXCIrZS50b0ZpeGVkKDMpKSx0PWUpLHRoaXMuc3RhdGU9RHQsdGhpcy5uZXh0TG9hZFBvc2l0aW9uPXRoaXMuc3RhcnRQb3NpdGlvbj10aGlzLmxhc3RDdXJyZW50VGltZT10LHRoaXMudGljaygpfWVsc2UgdGhpcy5fZm9yY2VTdGFydExvYWQ9ITAsdGhpcy5zdGF0ZT1SdH0saC5zdG9wTG9hZD1mdW5jdGlvbigpe3RoaXMuX2ZvcmNlU3RhcnRMb2FkPSExLHQucHJvdG90eXBlLnN0b3BMb2FkLmNhbGwodGhpcyl9LGguZG9UaWNrPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2UgRHQ6dGhpcy5kb1RpY2tJZGxlKCk7YnJlYWs7Y2FzZSBGdDp2YXIgdCxlPXRoaXMubGV2ZWxzLHI9dGhpcy5sZXZlbCxpPW51bGw9PWV8fG51bGw9PT0odD1lW3JdKXx8dm9pZCAwPT09dD92b2lkIDA6dC5kZXRhaWxzO2lmKGkmJighaS5saXZlfHx0aGlzLmxldmVsTGFzdExvYWRlZD09PXRoaXMubGV2ZWwpKXtpZih0aGlzLndhaXRGb3JDZG5UdW5lSW4oaSkpYnJlYWs7dGhpcy5zdGF0ZT1EdDticmVha31icmVhaztjYXNlIHh0OnZhciBhLG49c2VsZi5wZXJmb3JtYW5jZS5ub3coKSxzPXRoaXMucmV0cnlEYXRlOyghc3x8bj49c3x8bnVsbCE9PShhPXRoaXMubWVkaWEpJiZ2b2lkIDAhPT1hJiZhLnNlZWtpbmcpJiYodGhpcy5sb2coXCJyZXRyeURhdGUgcmVhY2hlZCwgc3dpdGNoIGJhY2sgdG8gSURMRSBzdGF0ZVwiKSx0aGlzLnN0YXRlPUR0KX10aGlzLm9uVGlja0VuZCgpfSxoLm9uVGlja0VuZD1mdW5jdGlvbigpe3QucHJvdG90eXBlLm9uVGlja0VuZC5jYWxsKHRoaXMpLHRoaXMuY2hlY2tCdWZmZXIoKSx0aGlzLmNoZWNrRnJhZ21lbnRDaGFuZ2VkKCl9LGguZG9UaWNrSWRsZT1mdW5jdGlvbigpe3ZhciB0LGUscj10aGlzLmhscyxpPXRoaXMubGV2ZWxMYXN0TG9hZGVkLGE9dGhpcy5sZXZlbHMscz10aGlzLm1lZGlhLG89ci5jb25maWcsbD1yLm5leHRMb2FkTGV2ZWw7aWYobnVsbCE9PWkmJihzfHwhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQmJm8uc3RhcnRGcmFnUHJlZmV0Y2gpJiYoIXRoaXMuYWx0QXVkaW98fCF0aGlzLmF1ZGlvT25seSkmJmEmJmFbbF0pe3ZhciBkPWFbbF07dGhpcy5sZXZlbD1yLm5leHRMb2FkTGV2ZWw9bDt2YXIgaD1kLmRldGFpbHM7aWYoIWh8fHRoaXMuc3RhdGU9PT1GdHx8aC5saXZlJiZ0aGlzLmxldmVsTGFzdExvYWRlZCE9PWwpdGhpcy5zdGF0ZT1GdDtlbHNle3ZhciBmPXRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyP3RoaXMubWVkaWFCdWZmZXI6cyxfLmIuTUFJTik7aWYobnVsbCE9PWYmJiEoZi5sZW4+PXRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKGQubWF4Qml0cmF0ZSkpKXtpZih0aGlzLl9zdHJlYW1FbmRlZChmLGgpKXt2YXIgYz17fTtyZXR1cm4gdGhpcy5hbHRBdWRpbyYmKGMudHlwZT1cInZpZGVvXCIpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkJVRkZFUl9FT1MsYyksdm9pZCh0aGlzLnN0YXRlPUl0KX12YXIgdj1mLmVuZCxnPXRoaXMuZ2V0TmV4dEZyYWdtZW50KHYsaCk7aWYodGhpcy5jb3VsZEJhY2t0cmFjayYmIXRoaXMuZnJhZ1ByZXZpb3VzJiZnJiZcImluaXRTZWdtZW50XCIhPT1nLnNuKXt2YXIgcD1nLnNuLWguc3RhcnRTTjtwPjEmJihnPWguZnJhZ21lbnRzW3AtMV0sdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoZykpfWlmKGcmJnRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGcpPT09US5PSyYmdGhpcy5uZXh0TG9hZFBvc2l0aW9uPnYpe3ZhciBtPXRoaXMuYXVkaW9Pbmx5JiYhdGhpcy5hbHRBdWRpbz91LmEuQVVESU86dS5hLlZJREVPO3RoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKHMsbSxfLmIuTUFJTiksZz10aGlzLmdldE5leHRGcmFnbWVudCh0aGlzLm5leHRMb2FkUG9zaXRpb24saCl9ZyYmKCFnLmluaXRTZWdtZW50fHxnLmluaXRTZWdtZW50LmRhdGF8fHRoaXMuYml0cmF0ZVRlc3R8fChnPWcuaW5pdFNlZ21lbnQpLFwiaWRlbnRpdHlcIiE9PShudWxsPT09KHQ9Zy5kZWNyeXB0ZGF0YSl8fHZvaWQgMD09PXQ/dm9pZCAwOnQua2V5Rm9ybWF0KXx8bnVsbCE9PShlPWcuZGVjcnlwdGRhdGEpJiZ2b2lkIDAhPT1lJiZlLmtleT90aGlzLmxvYWRGcmFnbWVudChnLGgsdik6dGhpcy5sb2FkS2V5KGcsaCkpfX19fSxoLmxvYWRGcmFnbWVudD1mdW5jdGlvbihlLHIsaSl7dmFyIGEsbj10aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShlKTtpZih0aGlzLmZyYWdDdXJyZW50PWUsbj09PVEuQkFDS1RSQUNLRUQpe3ZhciBzPXRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJhY2t0cmFja0RhdGEoZSk7aWYocylyZXR1cm4gdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3Mocyksdm9pZCB0aGlzLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShzKTtuPVEuTk9UX0xPQURFRH1uPT09US5OT1RfTE9BREVEfHxuPT09US5QQVJUSUFMP1wiaW5pdFNlZ21lbnRcIj09PWUuc24/dGhpcy5fbG9hZEluaXRTZWdtZW50KGUpOnRoaXMuYml0cmF0ZVRlc3Q/KGUuYml0cmF0ZVRlc3Q9ITAsdGhpcy5sb2coXCJGcmFnbWVudCBcIitlLnNuK1wiIG9mIGxldmVsIFwiK2UubGV2ZWwrXCIgaXMgYmVpbmcgZG93bmxvYWRlZCB0byB0ZXN0IGJpdHJhdGUgYW5kIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpLHRoaXMuX2xvYWRCaXRyYXRlVGVzdEZyYWcoZSkpOih0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZD0hMCx0LnByb3RvdHlwZS5sb2FkRnJhZ21lbnQuY2FsbCh0aGlzLGUscixpKSk6bj09PVEuQVBQRU5ESU5HP3RoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGUuZHVyYXRpb24pJiZ0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChlKTowPT09KG51bGw9PT0oYT10aGlzLm1lZGlhKXx8dm9pZCAwPT09YT92b2lkIDA6YS5idWZmZXJlZC5sZW5ndGgpJiZ0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKX0saC5nZXRBcHBlbmRlZEZyYWc9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHQsXy5iLk1BSU4pO3JldHVybiBlJiZcImZyYWdtZW50XCJpbiBlP2UuZnJhZ21lbnQ6ZX0saC5nZXRCdWZmZXJlZEZyYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldEJ1ZmZlcmVkRnJhZyh0LF8uYi5NQUlOKX0saC5mb2xsb3dpbmdCdWZmZXJlZEZyYWc9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/dGhpcy5nZXRCdWZmZXJlZEZyYWcodC5lbmQrLjUpOm51bGx9LGguaW1tZWRpYXRlTGV2ZWxTd2l0Y2g9ZnVuY3Rpb24oKXt0aGlzLmFib3J0Q3VycmVudEZyYWcoKSx0aGlzLmZsdXNoTWFpbkJ1ZmZlcigwLE51bWJlci5QT1NJVElWRV9JTkZJTklUWSl9LGgubmV4dExldmVsU3dpdGNoPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZXZlbHMsZT10aGlzLm1lZGlhO2lmKG51bGwhPWUmJmUucmVhZHlTdGF0ZSl7dmFyIHIsaT10aGlzLmdldEFwcGVuZGVkRnJhZyhlLmN1cnJlbnRUaW1lKTtpZihpJiZpLnN0YXJ0PjEmJnRoaXMuZmx1c2hNYWluQnVmZmVyKDAsaS5zdGFydC0xKSwhZS5wYXVzZWQmJnQpe3ZhciBhPXRbdGhpcy5obHMubmV4dExvYWRMZXZlbF0sbj10aGlzLmZyYWdMYXN0S2JwcztyPW4mJnRoaXMuZnJhZ0N1cnJlbnQ/dGhpcy5mcmFnQ3VycmVudC5kdXJhdGlvbiphLm1heEJpdHJhdGUvKDFlMypuKSsxOjB9ZWxzZSByPTA7dmFyIHM9dGhpcy5nZXRCdWZmZXJlZEZyYWcoZS5jdXJyZW50VGltZStyKTtpZihzKXt2YXIgbz10aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhzKTtpZihvKXt0aGlzLmFib3J0Q3VycmVudEZyYWcoKTt2YXIgbD1vLm1heFN0YXJ0UFRTP28ubWF4U3RhcnRQVFM6by5zdGFydCx1PW8uZHVyYXRpb24sZD1NYXRoLm1heChzLmVuZCxsK01hdGgubWluKE1hdGgubWF4KHUtdGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSwuNSp1KSwuNzUqdSkpO3RoaXMuZmx1c2hNYWluQnVmZmVyKGQsTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKX19fX0saC5hYm9ydEN1cnJlbnRGcmFnPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5mcmFnQ3VycmVudDt0aGlzLmZyYWdDdXJyZW50PW51bGwsbnVsbCE9dCYmdC5sb2FkZXImJnQubG9hZGVyLmFib3J0KCksdGhpcy5zdGF0ZT09PV90JiYodGhpcy5zdGF0ZT1EdCksdGhpcy5uZXh0TG9hZFBvc2l0aW9uPXRoaXMuZ2V0TG9hZFBvc2l0aW9uKCl9LGguZmx1c2hNYWluQnVmZmVyPWZ1bmN0aW9uKGUscil7dC5wcm90b3R5cGUuZmx1c2hNYWluQnVmZmVyLmNhbGwodGhpcyxlLHIsdGhpcy5hbHRBdWRpbz9cInZpZGVvXCI6bnVsbCl9LGgub25NZWRpYUF0dGFjaGVkPWZ1bmN0aW9uKGUscil7dC5wcm90b3R5cGUub25NZWRpYUF0dGFjaGVkLmNhbGwodGhpcyxlLHIpO3ZhciBpPXIubWVkaWE7dGhpcy5vbnZwbGF5aW5nPXRoaXMub25NZWRpYVBsYXlpbmcuYmluZCh0aGlzKSx0aGlzLm9udnNlZWtlZD10aGlzLm9uTWVkaWFTZWVrZWQuYmluZCh0aGlzKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsdGhpcy5vbnZwbGF5aW5nKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIix0aGlzLm9udnNlZWtlZCksdGhpcy5nYXBDb250cm9sbGVyPW5ldyBWdCh0aGlzLmNvbmZpZyxpLHRoaXMuZnJhZ21lbnRUcmFja2VyLHRoaXMuaGxzKX0saC5vbk1lZGlhRGV0YWNoaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5tZWRpYTtlJiYoZS5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLHRoaXMub252cGxheWluZyksZS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsdGhpcy5vbnZzZWVrZWQpLHRoaXMub252cGxheWluZz10aGlzLm9udnNlZWtlZD1udWxsLHRoaXMudmlkZW9CdWZmZXI9bnVsbCksdGhpcy5mcmFnUGxheWluZz1udWxsLHRoaXMuZ2FwQ29udHJvbGxlciYmKHRoaXMuZ2FwQ29udHJvbGxlci5kZXN0cm95KCksdGhpcy5nYXBDb250cm9sbGVyPW51bGwpLHQucHJvdG90eXBlLm9uTWVkaWFEZXRhY2hpbmcuY2FsbCh0aGlzKX0saC5vbk1lZGlhUGxheWluZz1mdW5jdGlvbigpe3RoaXMudGljaygpfSxoLm9uTWVkaWFTZWVrZWQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhLGU9dD90LmN1cnJlbnRUaW1lOm51bGw7T2JqZWN0KGEuYSkoZSkmJnRoaXMubG9nKFwiTWVkaWEgc2Vla2VkIHRvIFwiK2UudG9GaXhlZCgzKSksdGhpcy50aWNrKCl9LGgub25NYW5pZmVzdExvYWRpbmc9ZnVuY3Rpb24oKXt0aGlzLmxvZyhcIlRyaWdnZXIgQlVGRkVSX1JFU0VUXCIpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkJVRkZFUl9SRVNFVCx2b2lkIDApLHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpLHRoaXMuY291bGRCYWNrdHJhY2s9dGhpcy5zdGFsbGVkPSExLHRoaXMuc3RhcnRQb3NpdGlvbj10aGlzLmxhc3RDdXJyZW50VGltZT0wLHRoaXMuZnJhZ1BsYXlpbmc9bnVsbH0saC5vbk1hbmlmZXN0UGFyc2VkPWZ1bmN0aW9uKHQsZSl7dmFyIHIsaSxhLG49ITEscz0hMTtlLmxldmVscy5mb3JFYWNoKChmdW5jdGlvbih0KXsocj10LmF1ZGlvQ29kZWMpJiYoLTEhPT1yLmluZGV4T2YoXCJtcDRhLjQwLjJcIikmJihuPSEwKSwtMSE9PXIuaW5kZXhPZihcIm1wNGEuNDAuNVwiKSYmKHM9ITApKX0pKSx0aGlzLmF1ZGlvQ29kZWNTd2l0Y2g9biYmcyYmIShcImZ1bmN0aW9uXCI9PXR5cGVvZihudWxsPT0oYT1CdCgpKXx8bnVsbD09PShpPWEucHJvdG90eXBlKXx8dm9pZCAwPT09aT92b2lkIDA6aS5jaGFuZ2VUeXBlKSksdGhpcy5hdWRpb0NvZGVjU3dpdGNoJiZ0aGlzLmxvZyhcIkJvdGggQUFDL0hFLUFBQyBhdWRpbyBmb3VuZCBpbiBsZXZlbHM7IGRlY2xhcmluZyBsZXZlbCBjb2RlYyBhcyBIRS1BQUNcIiksdGhpcy5sZXZlbHM9ZS5sZXZlbHMsdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQ9ITF9LGgub25MZXZlbExvYWRpbmc9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLmxldmVscztpZihyJiZ0aGlzLnN0YXRlPT09RHQpe3ZhciBpPXJbZS5sZXZlbF07KCFpLmRldGFpbHN8fGkuZGV0YWlscy5saXZlJiZ0aGlzLmxldmVsTGFzdExvYWRlZCE9PWUubGV2ZWx8fHRoaXMud2FpdEZvckNkblR1bmVJbihpLmRldGFpbHMpKSYmKHRoaXMuc3RhdGU9RnQpfX0saC5vbkxldmVsTG9hZGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHIsaT10aGlzLmxldmVscyxhPWUubGV2ZWwscz1lLmRldGFpbHMsbz1zLnRvdGFsZHVyYXRpb247aWYoaSl7dGhpcy5sb2coXCJMZXZlbCBcIithK1wiIGxvYWRlZCBbXCIrcy5zdGFydFNOK1wiLFwiK3MuZW5kU04rXCJdLCBjYyBbXCIrcy5zdGFydENDK1wiLCBcIitzLmVuZENDK1wiXSBkdXJhdGlvbjpcIitvKTt2YXIgbD10aGlzLmZyYWdDdXJyZW50OyFsfHx0aGlzLnN0YXRlIT09a3QmJnRoaXMuc3RhdGUhPT14dHx8bC5sZXZlbCE9PWUubGV2ZWwmJmwubG9hZGVyJiYodGhpcy5zdGF0ZT1EdCxsLmxvYWRlci5hYm9ydCgpKTt2YXIgdT1pW2FdLGQ9MDtpZihzLmxpdmV8fG51bGwhPT0ocj11LmRldGFpbHMpJiZ2b2lkIDAhPT1yJiZyLmxpdmUpe2lmKHMuZnJhZ21lbnRzWzBdfHwocy5kZWx0YVVwZGF0ZUZhaWxlZD0hMCkscy5kZWx0YVVwZGF0ZUZhaWxlZClyZXR1cm47ZD10aGlzLmFsaWduUGxheWxpc3RzKHMsdS5kZXRhaWxzKX1pZih1LmRldGFpbHM9cyx0aGlzLmxldmVsTGFzdExvYWRlZD1hLHRoaXMuaGxzLnRyaWdnZXIobi5hLkxFVkVMX1VQREFURUQse2RldGFpbHM6cyxsZXZlbDphfSksdGhpcy5zdGF0ZT09PUZ0KXtpZih0aGlzLndhaXRGb3JDZG5UdW5lSW4ocykpcmV0dXJuO3RoaXMuc3RhdGU9RHR9dGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQ/cy5saXZlJiZ0aGlzLnN5bmNocm9uaXplVG9MaXZlRWRnZShzKTp0aGlzLnNldFN0YXJ0UG9zaXRpb24ocyxkKSx0aGlzLnRpY2soKX1lbHNlIHRoaXMud2FybihcIkxldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgXCIrYSl9LGguX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzPWZ1bmN0aW9uKHQpe3ZhciBlLHI9dC5mcmFnLGk9dC5wYXJ0LGE9dC5wYXlsb2FkLG49dGhpcy5sZXZlbHM7aWYobil7dmFyIHM9bltyLmxldmVsXSxvPXMuZGV0YWlscztpZihvKXt2YXIgbD1zLnZpZGVvQ29kZWMsdT1vLlBUU0tub3dufHwhby5saXZlLGQ9bnVsbD09PShlPXIuaW5pdFNlZ21lbnQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmRhdGEsaD10aGlzLl9nZXRBdWRpb0NvZGVjKHMpLGY9dGhpcy50cmFuc211eGVyPXRoaXMudHJhbnNtdXhlcnx8bmV3IEt0KHRoaXMuaGxzLF8uYi5NQUlOLHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSx0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSksYz1pP2kuaW5kZXg6LTEsdj0tMSE9PWMsZz1uZXcgbnQoci5sZXZlbCxyLnNuLHIuc3RhdHMuY2h1bmtDb3VudCxhLmJ5dGVMZW5ndGgsYyx2KSxwPXRoaXMuaW5pdFBUU1tyLmNjXTtmLnB1c2goYSxkLGgsbCxyLGksby50b3RhbGR1cmF0aW9uLHUsZyxwKX1lbHNlIHRoaXMud2FybihcIkRyb3BwaW5nIGZyYWdtZW50IFwiK3Iuc24rXCIgb2YgbGV2ZWwgXCIrci5sZXZlbCtcIiBhZnRlciBsZXZlbCBkZXRhaWxzIHdlcmUgcmVzZXRcIil9ZWxzZSB0aGlzLndhcm4oXCJMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgXCIrci5zbitcIiBvZiBsZXZlbCBcIityLmxldmVsK1wiIHdpbGwgbm90IGJlIGJ1ZmZlcmVkXCIpfSxoLm9uQXVkaW9UcmFja1N3aXRjaGluZz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuYWx0QXVkaW8saT0hIWUudXJsLGE9ZS5pZDtpZighaSl7aWYodGhpcy5tZWRpYUJ1ZmZlciE9PXRoaXMubWVkaWEpe3RoaXMubG9nKFwiU3dpdGNoaW5nIG9uIG1haW4gYXVkaW8sIHVzZSBtZWRpYS5idWZmZXJlZCB0byBzY2hlZHVsZSBtYWluIGZyYWdtZW50IGxvYWRpbmdcIiksdGhpcy5tZWRpYUJ1ZmZlcj10aGlzLm1lZGlhO3ZhciBzPXRoaXMuZnJhZ0N1cnJlbnQ7bnVsbCE9cyYmcy5sb2FkZXImJih0aGlzLmxvZyhcIlN3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkXCIpLHMubG9hZGVyLmFib3J0KCkpLHRoaXMucmVzZXRUcmFuc211eGVyKCksdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpfWVsc2UgdGhpcy5hdWRpb09ubHkmJnRoaXMucmVzZXRUcmFuc211eGVyKCk7dmFyIG89dGhpcy5obHM7ciYmby50cmlnZ2VyKG4uYS5CVUZGRVJfRkxVU0hJTkcse3N0YXJ0T2Zmc2V0OjAsZW5kT2Zmc2V0Ok51bWJlci5QT1NJVElWRV9JTkZJTklUWSx0eXBlOlwiYXVkaW9cIn0pLG8udHJpZ2dlcihuLmEuQVVESU9fVFJBQ0tfU1dJVENIRUQse2lkOmF9KX19LGgub25BdWRpb1RyYWNrU3dpdGNoZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLmlkLGk9ISF0aGlzLmhscy5hdWRpb1RyYWNrc1tyXS51cmw7aWYoaSl7dmFyIGE9dGhpcy52aWRlb0J1ZmZlcjthJiZ0aGlzLm1lZGlhQnVmZmVyIT09YSYmKHRoaXMubG9nKFwiU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ1wiKSx0aGlzLm1lZGlhQnVmZmVyPWEpfXRoaXMuYWx0QXVkaW89aSx0aGlzLnRpY2soKX0saC5vbkJ1ZmZlckNyZWF0ZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcixpLGE9ZS50cmFja3Msbj0hMTtmb3IodmFyIHMgaW4gYSl7dmFyIG89YVtzXTtpZihcIm1haW5cIj09PW8uaWQpe2lmKGk9cyxyPW8sXCJ2aWRlb1wiPT09cyl7dmFyIGw9YVtzXTtsJiYodGhpcy52aWRlb0J1ZmZlcj1sLmJ1ZmZlcil9fWVsc2Ugbj0hMH1uJiZyPyh0aGlzLmxvZyhcIkFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlIFwiK2krXCIuYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nXCIpLHRoaXMubWVkaWFCdWZmZXI9ci5idWZmZXIpOnRoaXMubWVkaWFCdWZmZXI9dGhpcy5tZWRpYX0saC5vbkZyYWdCdWZmZXJlZD1mdW5jdGlvbih0LGUpe3ZhciByPWUuZnJhZyxpPWUucGFydDtpZighcnx8ci50eXBlPT09Xy5iLk1BSU4pe2lmKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKHIpKXJldHVybiB0aGlzLndhcm4oXCJGcmFnbWVudCBcIityLnNuKyhpP1wiIHA6IFwiK2kuaW5kZXg6XCJcIikrXCIgb2YgbGV2ZWwgXCIrci5sZXZlbCtcIiBmaW5pc2hlZCBidWZmZXJpbmcsIGJ1dCB3YXMgYWJvcnRlZC4gc3RhdGU6IFwiK3RoaXMuc3RhdGUpLHZvaWQodGhpcy5zdGF0ZT09PUN0JiYodGhpcy5zdGF0ZT1EdCkpO3ZhciBhPWk/aS5zdGF0czpyLnN0YXRzO3RoaXMuZnJhZ0xhc3RLYnBzPU1hdGgucm91bmQoOCphLnRvdGFsLyhhLmJ1ZmZlcmluZy5lbmQtYS5sb2FkaW5nLmZpcnN0KSksXCJpbml0U2VnbWVudFwiIT09ci5zbiYmKHRoaXMuZnJhZ1ByZXZpb3VzPXIpLHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUocixpKX19LGgub25FcnJvcj1mdW5jdGlvbih0LGUpe3N3aXRjaChlLmRldGFpbHMpe2Nhc2Ugcy5hLkZSQUdfTE9BRF9FUlJPUjpjYXNlIHMuYS5GUkFHX0xPQURfVElNRU9VVDpjYXNlIHMuYS5LRVlfTE9BRF9FUlJPUjpjYXNlIHMuYS5LRVlfTE9BRF9USU1FT1VUOnRoaXMub25GcmFnbWVudE9yS2V5TG9hZEVycm9yKF8uYi5NQUlOLGUpO2JyZWFrO2Nhc2Ugcy5hLkxFVkVMX0xPQURfRVJST1I6Y2FzZSBzLmEuTEVWRUxfTE9BRF9USU1FT1VUOnRoaXMuc3RhdGUhPT1QdCYmKGUuZmF0YWw/KHRoaXMud2FybihcIlwiK2UuZGV0YWlscyksdGhpcy5zdGF0ZT1QdCk6ZS5sZXZlbFJldHJ5fHx0aGlzLnN0YXRlIT09RnR8fCh0aGlzLnN0YXRlPUR0KSk7YnJlYWs7Y2FzZSBzLmEuQlVGRkVSX0ZVTExfRVJST1I6aWYoXCJtYWluXCI9PT1lLnBhcmVudCYmKHRoaXMuc3RhdGU9PT13dHx8dGhpcy5zdGF0ZT09PUN0KSl7dmFyIHI9ITAsaT10aGlzLmdldEZ3ZEJ1ZmZlckluZm8odGhpcy5tZWRpYSxfLmIuTUFJTik7aSYmaS5sZW4+LjUmJihyPSF0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChpLmxlbikpLHImJih0aGlzLndhcm4oXCJidWZmZXIgZnVsbCBlcnJvciBhbHNvIG1lZGlhLmN1cnJlbnRUaW1lIGlzIG5vdCBidWZmZXJlZCwgZmx1c2ggbWFpblwiKSx0aGlzLmltbWVkaWF0ZUxldmVsU3dpdGNoKCkpLHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKX19fSxoLmNoZWNrQnVmZmVyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tZWRpYSxlPXRoaXMuZ2FwQ29udHJvbGxlcjtpZih0JiZlJiZ0LnJlYWR5U3RhdGUpe3ZhciByPWF0LmdldEJ1ZmZlcmVkKHQpOyF0aGlzLmxvYWRlZG1ldGFkYXRhJiZyLmxlbmd0aD8odGhpcy5sb2FkZWRtZXRhZGF0YT0hMCx0aGlzLnNlZWtUb1N0YXJ0UG9zKCkpOmUucG9sbCh0aGlzLmxhc3RDdXJyZW50VGltZSksdGhpcy5sYXN0Q3VycmVudFRpbWU9dC5jdXJyZW50VGltZX19LGgub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQ9ZnVuY3Rpb24oKXt0aGlzLnN0YXRlPUR0LHRoaXMubG9hZGVkbWV0YWRhdGF8fCh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZD0hMSx0aGlzLm5leHRMb2FkUG9zaXRpb249dGhpcy5zdGFydFBvc2l0aW9uKSx0aGlzLnRpY2tJbW1lZGlhdGUoKX0saC5vbkJ1ZmZlckZsdXNoZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1lLnR5cGU7aWYociE9PXUuYS5BVURJT3x8dGhpcy5hdWRpb09ubHkmJiF0aGlzLmFsdEF1ZGlvKXt2YXIgaT0ocj09PXUuYS5WSURFTz90aGlzLnZpZGVvQnVmZmVyOnRoaXMubWVkaWFCdWZmZXIpfHx0aGlzLm1lZGlhO3RoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKGkscixfLmIuTUFJTil9fSxoLm9uTGV2ZWxzVXBkYXRlZD1mdW5jdGlvbih0LGUpe3RoaXMubGV2ZWxzPWUubGV2ZWxzfSxoLnN3YXBBdWRpb0NvZGVjPWZ1bmN0aW9uKCl7dGhpcy5hdWRpb0NvZGVjU3dhcD0hdGhpcy5hdWRpb0NvZGVjU3dhcH0saC5zZWVrVG9TdGFydFBvcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWEsZT10LmN1cnJlbnRUaW1lLHI9dGhpcy5zdGFydFBvc2l0aW9uO2lmKHI+PTAmJmU8cil7aWYodC5zZWVraW5nKXJldHVybiB2b2lkIG8uYi5sb2coXCJjb3VsZCBub3Qgc2VlayB0byBcIityK1wiLCBhbHJlYWR5IHNlZWtpbmcgYXQgXCIrZSk7dmFyIGk9YXQuZ2V0QnVmZmVyZWQodCksYT0oaS5sZW5ndGg/aS5zdGFydCgwKTowKS1yO2E+MCYmKGE8dGhpcy5jb25maWcubWF4QnVmZmVySG9sZXx8YTx0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSYmKG8uYi5sb2coXCJhZGp1c3Rpbmcgc3RhcnQgcG9zaXRpb24gYnkgXCIrYStcIiB0byBtYXRjaCBidWZmZXIgc3RhcnRcIikscis9YSx0aGlzLnN0YXJ0UG9zaXRpb249ciksdGhpcy5sb2coXCJzZWVrIHRvIHRhcmdldCBzdGFydCBwb3NpdGlvbiBcIityK1wiIGZyb20gY3VycmVudCB0aW1lIFwiK2UpLHQuY3VycmVudFRpbWU9cn19LGguX2dldEF1ZGlvQ29kZWM9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb25maWcuZGVmYXVsdEF1ZGlvQ29kZWN8fHQuYXVkaW9Db2RlYztyZXR1cm4gdGhpcy5hdWRpb0NvZGVjU3dhcCYmZSYmKHRoaXMubG9nKFwiU3dhcHBpbmcgYXVkaW8gY29kZWNcIiksZT0tMSE9PWUuaW5kZXhPZihcIm1wNGEuNDAuNVwiKT9cIm1wNGEuNDAuMlwiOlwibXA0YS40MC41XCIpLGV9LGguX2xvYWRCaXRyYXRlVGVzdEZyYWc9ZnVuY3Rpb24odCl7dmFyIGU9dGhpczt0aGlzLl9kb0ZyYWdMb2FkKHQpLnRoZW4oKGZ1bmN0aW9uKHIpe3ZhciBpPWUuaGxzO2lmKHImJiFpLm5leHRMb2FkTGV2ZWwmJiFlLmZyYWdDb250ZXh0Q2hhbmdlZCh0KSl7ZS5mcmFnTG9hZEVycm9yPTAsZS5zdGF0ZT1EdCxlLnN0YXJ0RnJhZ1JlcXVlc3RlZD0hMSxlLmJpdHJhdGVUZXN0PSExO3ZhciBhPXQuc3RhdHM7YS5wYXJzaW5nLnN0YXJ0PWEucGFyc2luZy5lbmQ9YS5idWZmZXJpbmcuc3RhcnQ9YS5idWZmZXJpbmcuZW5kPXNlbGYucGVyZm9ybWFuY2Uubm93KCksaS50cmlnZ2VyKG4uYS5GUkFHX0xPQURFRCxyKX19KSl9LGguX2hhbmRsZVRyYW5zbXV4Q29tcGxldGU9ZnVuY3Rpb24odCl7dmFyIGUscj1cIm1haW5cIixpPXRoaXMuaGxzLHM9dC5yZW11eFJlc3VsdCxvPXQuY2h1bmtNZXRhLGw9dGhpcy5nZXRDdXJyZW50Q29udGV4dChvKTtpZighbClyZXR1cm4gdGhpcy53YXJuKFwiVGhlIGxvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBmcmFnbWVudCBcIitvLnNuK1wiIG9mIGxldmVsIFwiK28ubGV2ZWwrXCIuIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuXCIpLHZvaWQgdGhpcy5yZXNldExpdmVTdGFydFdoZW5Ob3RMb2FkZWQoby5sZXZlbCk7dmFyIGQ9bC5mcmFnLGg9bC5wYXJ0LGY9bC5sZXZlbCxjPXMudmlkZW8sdj1zLnRleHQsZz1zLmlkMyxwPXMuaW5pdFNlZ21lbnQsbT10aGlzLmFsdEF1ZGlvP3ZvaWQgMDpzLmF1ZGlvO2lmKCF0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChkKSl7aWYodGhpcy5zdGF0ZT13dCxwKXtwLnRyYWNrcyYmKHRoaXMuX2J1ZmZlckluaXRTZWdtZW50KGYscC50cmFja3MsZCxvKSxpLnRyaWdnZXIobi5hLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQse2ZyYWc6ZCxpZDpyLHRyYWNrczpwLnRyYWNrc30pKTt2YXIgeT1wLmluaXRQVFMsYj1wLnRpbWVzY2FsZTtPYmplY3QoYS5hKSh5KSYmKHRoaXMuaW5pdFBUU1tkLmNjXT15LGkudHJpZ2dlcihuLmEuSU5JVF9QVFNfRk9VTkQse2ZyYWc6ZCxpZDpyLGluaXRQVFM6eSx0aW1lc2NhbGU6Yn0pKX1pZihjJiYhMSE9PXMuaW5kZXBlbmRlbnQpe2lmKGYuZGV0YWlscyl7dmFyIFQ9Yy5zdGFydFBUUyxFPWMuZW5kUFRTLFM9Yy5zdGFydERUUyxMPWMuZW5kRFRTO2lmKGgpaC5lbGVtZW50YXJ5U3RyZWFtc1tjLnR5cGVdPXtzdGFydFBUUzpULGVuZFBUUzpFLHN0YXJ0RFRTOlMsZW5kRFRTOkx9O2Vsc2UgaWYoYy5maXJzdEtleUZyYW1lJiZjLmluZGVwZW5kZW50JiYodGhpcy5jb3VsZEJhY2t0cmFjaz0hMCksYy5kcm9wcGVkJiZjLmluZGVwZW5kZW50KXtpZih0aGlzLmdldExvYWRQb3NpdGlvbigpK3RoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGU8VClyZXR1cm4gdm9pZCB0aGlzLmJhY2t0cmFjayhkKTtkLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKGMudHlwZSxkLnN0YXJ0LEUsZC5zdGFydCxMLCEwKX1kLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKGMudHlwZSxULEUsUyxMKSx0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShjLGQsaCxvKX19ZWxzZSBpZighMT09PXMuaW5kZXBlbmRlbnQpcmV0dXJuIHZvaWQgdGhpcy5iYWNrdHJhY2soZCk7aWYobSl7dmFyIEE9bS5zdGFydFBUUyxSPW0uZW5kUFRTLEQ9bS5zdGFydERUUyxfPW0uZW5kRFRTO2gmJihoLmVsZW1lbnRhcnlTdHJlYW1zW3UuYS5BVURJT109e3N0YXJ0UFRTOkEsZW5kUFRTOlIsc3RhcnREVFM6RCxlbmREVFM6X30pLGQuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8odS5hLkFVRElPLEEsUixELF8pLHRoaXMuYnVmZmVyRnJhZ21lbnREYXRhKG0sZCxoLG8pfWlmKG51bGwhPWcmJm51bGwhPT0oZT1nLnNhbXBsZXMpJiZ2b2lkIDAhPT1lJiZlLmxlbmd0aCl7dmFyIGs9e2ZyYWc6ZCxpZDpyLHNhbXBsZXM6Zy5zYW1wbGVzfTtpLnRyaWdnZXIobi5hLkZSQUdfUEFSU0lOR19NRVRBREFUQSxrKX1pZih2KXt2YXIgeD17ZnJhZzpkLGlkOnIsc2FtcGxlczp2LnNhbXBsZXN9O2kudHJpZ2dlcihuLmEuRlJBR19QQVJTSU5HX1VTRVJEQVRBLHgpfX19LGguX2J1ZmZlckluaXRTZWdtZW50PWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBhPXRoaXM7aWYodGhpcy5zdGF0ZT09PXd0KXt0aGlzLmF1ZGlvT25seT0hIWUuYXVkaW8mJiFlLnZpZGVvLHRoaXMuYWx0QXVkaW8mJiF0aGlzLmF1ZGlvT25seSYmZGVsZXRlIGUuYXVkaW87dmFyIHM9ZS5hdWRpbyxvPWUudmlkZW8sbD1lLmF1ZGlvdmlkZW87aWYocyl7dmFyIHU9dC5hdWRpb0NvZGVjLGQ9bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO3RoaXMuYXVkaW9Db2RlY1N3aXRjaCYmKHUmJih1PS0xIT09dS5pbmRleE9mKFwibXA0YS40MC41XCIpP1wibXA0YS40MC4yXCI6XCJtcDRhLjQwLjVcIiksMSE9PXMubWV0YWRhdGEuY2hhbm5lbENvdW50JiYtMT09PWQuaW5kZXhPZihcImZpcmVmb3hcIikmJih1PVwibXA0YS40MC41XCIpKSwtMSE9PWQuaW5kZXhPZihcImFuZHJvaWRcIikmJlwiYXVkaW8vbXBlZ1wiIT09cy5jb250YWluZXImJih1PVwibXA0YS40MC4yXCIsdGhpcy5sb2coXCJBbmRyb2lkOiBmb3JjZSBhdWRpbyBjb2RlYyB0byBcIit1KSksdC5hdWRpb0NvZGVjJiZ0LmF1ZGlvQ29kZWMhPT11JiZ0aGlzLmxvZygnU3dhcHBpbmcgbWFuaWZlc3QgYXVkaW8gY29kZWMgXCInK3QuYXVkaW9Db2RlYysnXCIgZm9yIFwiJyt1KydcIicpLHMubGV2ZWxDb2RlYz11LHMuaWQ9XCJtYWluXCIsdGhpcy5sb2coXCJJbml0IGF1ZGlvIGJ1ZmZlciwgY29udGFpbmVyOlwiK3MuY29udGFpbmVyK1wiLCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bXCIrKHV8fFwiXCIpK1wiL1wiKyh0LmF1ZGlvQ29kZWN8fFwiXCIpK1wiL1wiK3MuY29kZWMrXCJdXCIpfW8mJihvLmxldmVsQ29kZWM9dC52aWRlb0NvZGVjLG8uaWQ9XCJtYWluXCIsdGhpcy5sb2coXCJJbml0IHZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOlwiK28uY29udGFpbmVyK1wiLCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIrKHQudmlkZW9Db2RlY3x8XCJcIikrXCIvXCIrby5jb2RlYytcIl1cIikpLGwmJnRoaXMubG9nKFwiSW5pdCBhdWRpb3ZpZGVvIGJ1ZmZlciwgY29udGFpbmVyOlwiK2wuY29udGFpbmVyK1wiLCBjb2RlY3NbbGV2ZWwvcGFyc2VkXT1bXCIrKHQuYXR0cnMuQ09ERUNTfHxcIlwiKStcIi9cIitsLmNvZGVjK1wiXVwiKSx0aGlzLmhscy50cmlnZ2VyKG4uYS5CVUZGRVJfQ09ERUNTLGUpLE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBzPWVbdF0uaW5pdFNlZ21lbnQ7bnVsbCE9cyYmcy5ieXRlTGVuZ3RoJiZhLmhscy50cmlnZ2VyKG4uYS5CVUZGRVJfQVBQRU5ESU5HLHt0eXBlOnQsZGF0YTpzLGZyYWc6cixwYXJ0Om51bGwsY2h1bmtNZXRhOmkscGFyZW50OnIudHlwZX0pfSkpLHRoaXMudGljaygpfX0saC5iYWNrdHJhY2s9ZnVuY3Rpb24odCl7dGhpcy5jb3VsZEJhY2t0cmFjaz0hMCx0aGlzLnJlc2V0VHJhbnNtdXhlcigpLHRoaXMuZmx1c2hCdWZmZXJHYXAodCk7dmFyIGU9dGhpcy5mcmFnbWVudFRyYWNrZXIuYmFja3RyYWNrKHQpO3RoaXMuZnJhZ1ByZXZpb3VzPW51bGwsdGhpcy5uZXh0TG9hZFBvc2l0aW9uPXQuc3RhcnQsZT90aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKHQpOnRoaXMuc3RhdGU9T3R9LGguY2hlY2tGcmFnbWVudENoYW5nZWQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhLGU9bnVsbDtpZih0JiZ0LnJlYWR5U3RhdGU+MSYmITE9PT10LnNlZWtpbmcpe3ZhciByPXQuY3VycmVudFRpbWU7aWYoYXQuaXNCdWZmZXJlZCh0LHIpP2U9dGhpcy5nZXRBcHBlbmRlZEZyYWcocik6YXQuaXNCdWZmZXJlZCh0LHIrLjEpJiYoZT10aGlzLmdldEFwcGVuZGVkRnJhZyhyKy4xKSksZSl7dmFyIGk9dGhpcy5mcmFnUGxheWluZyxhPWUubGV2ZWw7aSYmZS5zbj09PWkuc24mJmkubGV2ZWw9PT1hJiZlLnVybElkPT09aS51cmxJZHx8KHRoaXMuaGxzLnRyaWdnZXIobi5hLkZSQUdfQ0hBTkdFRCx7ZnJhZzplfSksaSYmaS5sZXZlbD09PWF8fHRoaXMuaGxzLnRyaWdnZXIobi5hLkxFVkVMX1NXSVRDSEVELHtsZXZlbDphfSksdGhpcy5mcmFnUGxheWluZz1lKX19fSxsPWksKGQ9W3trZXk6XCJuZXh0TGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm5leHRCdWZmZXJlZEZyYWc7cmV0dXJuIHQ/dC5sZXZlbDotMX19LHtrZXk6XCJjdXJyZW50TGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhO2lmKHQpe3ZhciBlPXRoaXMuZ2V0QXBwZW5kZWRGcmFnKHQuY3VycmVudFRpbWUpO2lmKGUpcmV0dXJuIGUubGV2ZWx9cmV0dXJuLTF9fSx7a2V5OlwibmV4dEJ1ZmZlcmVkRnJhZ1wiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWE7aWYodCl7dmFyIGU9dGhpcy5nZXRBcHBlbmRlZEZyYWcodC5jdXJyZW50VGltZSk7cmV0dXJuIHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGUpfXJldHVybiBudWxsfX0se2tleTpcImZvcmNlU3RhcnRMb2FkXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ZvcmNlU3RhcnRMb2FkfX1dKSYmV3QobC5wcm90b3R5cGUsZCksaX0oTXQpLHF0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUscil7dm9pZCAwPT09ZSYmKGU9MCksdm9pZCAwPT09ciYmKHI9MCksdGhpcy5oYWxmTGlmZT12b2lkIDAsdGhpcy5hbHBoYV89dm9pZCAwLHRoaXMuZXN0aW1hdGVfPXZvaWQgMCx0aGlzLnRvdGFsV2VpZ2h0Xz12b2lkIDAsdGhpcy5oYWxmTGlmZT10LHRoaXMuYWxwaGFfPXQ/TWF0aC5leHAoTWF0aC5sb2coLjUpL3QpOjAsdGhpcy5lc3RpbWF0ZV89ZSx0aGlzLnRvdGFsV2VpZ2h0Xz1yfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnNhbXBsZT1mdW5jdGlvbih0LGUpe3ZhciByPU1hdGgucG93KHRoaXMuYWxwaGFfLHQpO3RoaXMuZXN0aW1hdGVfPWUqKDEtcikrcip0aGlzLmVzdGltYXRlXyx0aGlzLnRvdGFsV2VpZ2h0Xys9dH0sZS5nZXRUb3RhbFdlaWdodD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvdGFsV2VpZ2h0X30sZS5nZXRFc3RpbWF0ZT1mdW5jdGlvbigpe2lmKHRoaXMuYWxwaGFfKXt2YXIgdD0xLU1hdGgucG93KHRoaXMuYWxwaGFfLHRoaXMudG90YWxXZWlnaHRfKTtpZih0KXJldHVybiB0aGlzLmVzdGltYXRlXy90fXJldHVybiB0aGlzLmVzdGltYXRlX30sdH0oKSx6dD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIpe3RoaXMuZGVmYXVsdEVzdGltYXRlXz12b2lkIDAsdGhpcy5taW5XZWlnaHRfPXZvaWQgMCx0aGlzLm1pbkRlbGF5TXNfPXZvaWQgMCx0aGlzLnNsb3dfPXZvaWQgMCx0aGlzLmZhc3RfPXZvaWQgMCx0aGlzLmRlZmF1bHRFc3RpbWF0ZV89cix0aGlzLm1pbldlaWdodF89LjAwMSx0aGlzLm1pbkRlbGF5TXNfPTUwLHRoaXMuc2xvd189bmV3IHF0KHQpLHRoaXMuZmFzdF89bmV3IHF0KGUpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnVwZGF0ZT1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuc2xvd18saT10aGlzLmZhc3RfO3RoaXMuc2xvd18uaGFsZkxpZmUhPT10JiYodGhpcy5zbG93Xz1uZXcgcXQodCxyLmdldEVzdGltYXRlKCksci5nZXRUb3RhbFdlaWdodCgpKSksdGhpcy5mYXN0Xy5oYWxmTGlmZSE9PWUmJih0aGlzLmZhc3RfPW5ldyBxdChlLGkuZ2V0RXN0aW1hdGUoKSxpLmdldFRvdGFsV2VpZ2h0KCkpKX0sZS5zYW1wbGU9ZnVuY3Rpb24odCxlKXt2YXIgcj0odD1NYXRoLm1heCh0LHRoaXMubWluRGVsYXlNc18pKS8xZTMsaT04KmUvcjt0aGlzLmZhc3RfLnNhbXBsZShyLGkpLHRoaXMuc2xvd18uc2FtcGxlKHIsaSl9LGUuY2FuRXN0aW1hdGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmZhc3RfO3JldHVybiB0JiZ0LmdldFRvdGFsV2VpZ2h0KCk+PXRoaXMubWluV2VpZ2h0X30sZS5nZXRFc3RpbWF0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNhbkVzdGltYXRlKCk/TWF0aC5taW4odGhpcy5mYXN0Xy5nZXRFc3RpbWF0ZSgpLHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSk6dGhpcy5kZWZhdWx0RXN0aW1hdGVffSxlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt9LHR9KCk7ZnVuY3Rpb24gUXQodCxlKXtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl7dmFyIGk9ZVtyXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fXZhciAkdD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5obHM9dm9pZCAwLHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbD0wLHRoaXMuX25leHRBdXRvTGV2ZWw9LTEsdGhpcy50aW1lcj12b2lkIDAsdGhpcy5vbkNoZWNrPXRoaXMuX2FiYW5kb25SdWxlc0NoZWNrLmJpbmQodGhpcyksdGhpcy5mcmFnQ3VycmVudD1udWxsLHRoaXMucGFydEN1cnJlbnQ9bnVsbCx0aGlzLmJpdHJhdGVUZXN0RGVsYXk9MCx0aGlzLmJ3RXN0aW1hdG9yPXZvaWQgMCx0aGlzLmhscz10O3ZhciBlPXQuY29uZmlnO3RoaXMuYndFc3RpbWF0b3I9bmV3IHp0KGUuYWJyRXdtYVNsb3dWb0QsZS5hYnJFd21hRmFzdFZvRCxlLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpLHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKX12YXIgZSxyLGk9dC5wcm90b3R5cGU7cmV0dXJuIGkucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhsczt0Lm9uKG4uYS5GUkFHX0xPQURJTkcsdGhpcy5vbkZyYWdMb2FkaW5nLHRoaXMpLHQub24obi5hLkZSQUdfTE9BREVELHRoaXMub25GcmFnTG9hZGVkLHRoaXMpLHQub24obi5hLkZSQUdfQlVGRkVSRUQsdGhpcy5vbkZyYWdCdWZmZXJlZCx0aGlzKSx0Lm9uKG4uYS5MRVZFTF9MT0FERUQsdGhpcy5vbkxldmVsTG9hZGVkLHRoaXMpLHQub24obi5hLkVSUk9SLHRoaXMub25FcnJvcix0aGlzKX0saS51bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5obHM7dC5vZmYobi5hLkZSQUdfTE9BRElORyx0aGlzLm9uRnJhZ0xvYWRpbmcsdGhpcyksdC5vZmYobi5hLkZSQUdfTE9BREVELHRoaXMub25GcmFnTG9hZGVkLHRoaXMpLHQub2ZmKG4uYS5GUkFHX0JVRkZFUkVELHRoaXMub25GcmFnQnVmZmVyZWQsdGhpcyksdC5vZmYobi5hLkxFVkVMX0xPQURFRCx0aGlzLm9uTGV2ZWxMb2FkZWQsdGhpcyksdC5vZmYobi5hLkVSUk9SLHRoaXMub25FcnJvcix0aGlzKX0saS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5jbGVhclRpbWVyKCksdGhpcy5obHM9dGhpcy5vbkNoZWNrPW51bGwsdGhpcy5mcmFnQ3VycmVudD10aGlzLnBhcnRDdXJyZW50PW51bGx9LGkub25GcmFnTG9hZGluZz1mdW5jdGlvbih0LGUpe3ZhciByLGk9ZS5mcmFnO2kudHlwZT09PV8uYi5NQUlOJiYodGhpcy50aW1lcnx8KHRoaXMuZnJhZ0N1cnJlbnQ9aSx0aGlzLnBhcnRDdXJyZW50PW51bGwhPShyPWUucGFydCk/cjpudWxsLHRoaXMudGltZXI9c2VsZi5zZXRJbnRlcnZhbCh0aGlzLm9uQ2hlY2ssMTAwKSkpfSxpLm9uTGV2ZWxMb2FkZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLmhscy5jb25maWc7ZS5kZXRhaWxzLmxpdmU/dGhpcy5id0VzdGltYXRvci51cGRhdGUoci5hYnJFd21hU2xvd0xpdmUsci5hYnJFd21hRmFzdExpdmUpOnRoaXMuYndFc3RpbWF0b3IudXBkYXRlKHIuYWJyRXdtYVNsb3dWb0Qsci5hYnJFd21hRmFzdFZvRCl9LGkuX2FiYW5kb25SdWxlc0NoZWNrPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5mcmFnQ3VycmVudCxlPXRoaXMucGFydEN1cnJlbnQscj10aGlzLmhscyxpPXIuYXV0b0xldmVsRW5hYmxlZCxzPXIuY29uZmlnLGw9ci5tZWRpYTtpZih0JiZsKXt2YXIgdT1lP2Uuc3RhdHM6dC5zdGF0cyxkPWU/ZS5kdXJhdGlvbjp0LmR1cmF0aW9uO2lmKHUuYWJvcnRlZClyZXR1cm4gby5iLndhcm4oXCJmcmFnIGxvYWRlciBkZXN0cm95IG9yIGFib3J0ZWQsIGRpc2FybSBhYmFuZG9uUnVsZXNcIiksdGhpcy5jbGVhclRpbWVyKCksdm9pZCh0aGlzLl9uZXh0QXV0b0xldmVsPS0xKTtpZihpJiYhbC5wYXVzZWQmJmwucGxheWJhY2tSYXRlJiZsLnJlYWR5U3RhdGUpe3ZhciBoPXBlcmZvcm1hbmNlLm5vdygpLXUubG9hZGluZy5zdGFydCxmPU1hdGguYWJzKGwucGxheWJhY2tSYXRlKTtpZighKGg8PTUwMCpkL2YpKXt2YXIgYz1yLmxldmVscyx2PXIubWluQXV0b0xldmVsLGc9Y1t0LmxldmVsXSxwPXUudG90YWx8fE1hdGgubWF4KHUubG9hZGVkLE1hdGgucm91bmQoZCpnLm1heEJpdHJhdGUvOCkpLG09TWF0aC5tYXgoMSx1LmJ3RXN0aW1hdGU/dS5id0VzdGltYXRlLzg6MWUzKnUubG9hZGVkL2gpLHk9KHAtdS5sb2FkZWQpL20sYj1sLmN1cnJlbnRUaW1lLFQ9KGF0LmJ1ZmZlckluZm8obCxiLHMubWF4QnVmZmVySG9sZSkuZW5kLWIpL2Y7aWYoIShUPj0yKmQvZnx8eTw9VCkpe3ZhciBFLFM9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO2ZvcihFPXQubGV2ZWwtMTtFPnYmJiEoKFM9ZCpjW0VdLm1heEJpdHJhdGUvKDYuNCptKSk8VCk7RS0tKTtpZighKFM+PXkpKXt2YXIgTD10aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCk7by5iLndhcm4oXCJGcmFnbWVudCBcIit0LnNuKyhlP1wiIHBhcnQgXCIrZS5pbmRleDpcIlwiKStcIiBvZiBsZXZlbCBcIit0LmxldmVsK1wiIGlzIGxvYWRpbmcgdG9vIHNsb3dseSBhbmQgd2lsbCBjYXVzZSBhbiB1bmRlcmJ1ZmZlcjsgYWJvcnRpbmcgYW5kIHN3aXRjaGluZyB0byBsZXZlbCBcIitFK1wiXFxuICAgICAgQ3VycmVudCBCVyBlc3RpbWF0ZTogXCIrKE9iamVjdChhLmEpKEwpPyhMLzEwMjQpLnRvRml4ZWQoMyk6XCJVbmtub3duXCIpK1wiIEtiL3NcXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBjdXJyZW50IGZyYWdtZW50OiBcIit5LnRvRml4ZWQoMykrXCIgc1xcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIHRoZSBuZXh0IGZyYWdtZW50OiBcIitTLnRvRml4ZWQoMykrXCIgc1xcbiAgICAgIFRpbWUgdG8gdW5kZXJidWZmZXI6IFwiK1QudG9GaXhlZCgzKStcIiBzXCIpLHIubmV4dExvYWRMZXZlbD1FLHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKGgsdS5sb2FkZWQpLHRoaXMuY2xlYXJUaW1lcigpLHQubG9hZGVyJiYodGhpcy5mcmFnQ3VycmVudD10aGlzLnBhcnRDdXJyZW50PW51bGwsdC5sb2FkZXIuYWJvcnQoKSksci50cmlnZ2VyKG4uYS5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQse2ZyYWc6dCxwYXJ0OmUsc3RhdHM6dX0pfX19fX19LGkub25GcmFnTG9hZGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ZS5wYXJ0O2lmKHIudHlwZT09PV8uYi5NQUlOJiZPYmplY3QoYS5hKShyLnNuKSl7dmFyIHM9aT9pLnN0YXRzOnIuc3RhdHMsbz1pP2kuZHVyYXRpb246ci5kdXJhdGlvbjtpZih0aGlzLmNsZWFyVGltZXIoKSx0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWw9ci5sZXZlbCx0aGlzLl9uZXh0QXV0b0xldmVsPS0xLHRoaXMuaGxzLmNvbmZpZy5hYnJNYXhXaXRoUmVhbEJpdHJhdGUpe3ZhciBsPXRoaXMuaGxzLmxldmVsc1tyLmxldmVsXSx1PShsLmxvYWRlZD9sLmxvYWRlZC5ieXRlczowKStzLmxvYWRlZCxkPShsLmxvYWRlZD9sLmxvYWRlZC5kdXJhdGlvbjowKStvO2wubG9hZGVkPXtieXRlczp1LGR1cmF0aW9uOmR9LGwucmVhbEJpdHJhdGU9TWF0aC5yb3VuZCg4KnUvZCl9aWYoci5iaXRyYXRlVGVzdCl7dmFyIGg9e3N0YXRzOnMsZnJhZzpyLHBhcnQ6aSxpZDpyLnR5cGV9O3RoaXMub25GcmFnQnVmZmVyZWQobi5hLkZSQUdfQlVGRkVSRUQsaCksci5iaXRyYXRlVGVzdD0hMX19fSxpLm9uRnJhZ0J1ZmZlcmVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5mcmFnLGk9ZS5wYXJ0LGE9aT9pLnN0YXRzOnIuc3RhdHM7aWYoIWEuYWJvcnRlZCYmci50eXBlPT09Xy5iLk1BSU4mJlwiaW5pdFNlZ21lbnRcIiE9PXIuc24pe3ZhciBuPWEucGFyc2luZy5lbmQtYS5sb2FkaW5nLnN0YXJ0O3RoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKG4sYS5sb2FkZWQpLGEuYndFc3RpbWF0ZT10aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlKCksci5iaXRyYXRlVGVzdD90aGlzLmJpdHJhdGVUZXN0RGVsYXk9bi8xZTM6dGhpcy5iaXRyYXRlVGVzdERlbGF5PTB9fSxpLm9uRXJyb3I9ZnVuY3Rpb24odCxlKXtzd2l0Y2goZS5kZXRhaWxzKXtjYXNlIHMuYS5GUkFHX0xPQURfRVJST1I6Y2FzZSBzLmEuRlJBR19MT0FEX1RJTUVPVVQ6dGhpcy5jbGVhclRpbWVyKCl9fSxpLmNsZWFyVGltZXI9ZnVuY3Rpb24oKXtzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lciksdGhpcy50aW1lcj12b2lkIDB9LGkuZ2V0TmV4dEFCUkF1dG9MZXZlbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZnJhZ0N1cnJlbnQsZT10aGlzLnBhcnRDdXJyZW50LHI9dGhpcy5obHMsaT1yLm1heEF1dG9MZXZlbCxhPXIuY29uZmlnLG49ci5taW5BdXRvTGV2ZWwscz1yLm1lZGlhLGw9ZT9lLmR1cmF0aW9uOnQ/dC5kdXJhdGlvbjowLHU9cz9zLmN1cnJlbnRUaW1lOjAsZD1zJiYwIT09cy5wbGF5YmFja1JhdGU/TWF0aC5hYnMocy5wbGF5YmFja1JhdGUpOjEsaD10aGlzLmJ3RXN0aW1hdG9yP3RoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGUoKTphLmFickV3bWFEZWZhdWx0RXN0aW1hdGUsZj0oYXQuYnVmZmVySW5mbyhzLHUsYS5tYXhCdWZmZXJIb2xlKS5lbmQtdSkvZCxjPXRoaXMuZmluZEJlc3RMZXZlbChoLG4saSxmLGEuYWJyQmFuZFdpZHRoRmFjdG9yLGEuYWJyQmFuZFdpZHRoVXBGYWN0b3IpO2lmKGM+PTApcmV0dXJuIGM7by5iLnRyYWNlKChmP1wicmVidWZmZXJpbmcgZXhwZWN0ZWRcIjpcImJ1ZmZlciBpcyBlbXB0eVwiKStcIiwgZmluZGluZyBvcHRpbWFsIHF1YWxpdHkgbGV2ZWxcIik7dmFyIHY9bD9NYXRoLm1pbihsLGEubWF4U3RhcnZhdGlvbkRlbGF5KTphLm1heFN0YXJ2YXRpb25EZWxheSxnPWEuYWJyQmFuZFdpZHRoRmFjdG9yLHA9YS5hYnJCYW5kV2lkdGhVcEZhY3RvcjtpZighZil7dmFyIG09dGhpcy5iaXRyYXRlVGVzdERlbGF5O20mJih2PShsP01hdGgubWluKGwsYS5tYXhMb2FkaW5nRGVsYXkpOmEubWF4TG9hZGluZ0RlbGF5KS1tLG8uYi50cmFjZShcImJpdHJhdGUgdGVzdCB0b29rIFwiK01hdGgucm91bmQoMWUzKm0pK1wibXMsIHNldCBmaXJzdCBmcmFnbWVudCBtYXggZmV0Y2hEdXJhdGlvbiB0byBcIitNYXRoLnJvdW5kKDFlMyp2KStcIiBtc1wiKSxnPXA9MSl9cmV0dXJuIGM9dGhpcy5maW5kQmVzdExldmVsKGgsbixpLGYrdixnLHApLE1hdGgubWF4KGMsMCl9LGkuZmluZEJlc3RMZXZlbD1mdW5jdGlvbih0LGUscixpLGEsbil7Zm9yKHZhciBzLGw9dGhpcy5mcmFnQ3VycmVudCx1PXRoaXMucGFydEN1cnJlbnQsZD10aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwsaD10aGlzLmhscy5sZXZlbHMsZj1oW2RdLGM9IShudWxsPT1mfHxudWxsPT09KHM9Zi5kZXRhaWxzKXx8dm9pZCAwPT09c3x8IXMubGl2ZSksdj1udWxsPT1mP3ZvaWQgMDpmLmNvZGVjU2V0LGc9dT91LmR1cmF0aW9uOmw/bC5kdXJhdGlvbjowLHA9cjtwPj1lO3AtLSl7dmFyIG09aFtwXTtpZihtJiYoIXZ8fG0uY29kZWNTZXQ9PT12KSl7dmFyIHksYj1tLmRldGFpbHMsVD0odT9udWxsPT1iP3ZvaWQgMDpiLnBhcnRUYXJnZXQ6bnVsbD09Yj92b2lkIDA6Yi5hdmVyYWdldGFyZ2V0ZHVyYXRpb24pfHxnO3k9cDw9ZD9hKnQ6bip0O3ZhciBFPWhbcF0ubWF4Qml0cmF0ZSxTPUUqVC95O2lmKG8uYi50cmFjZShcImxldmVsL2FkanVzdGVkYncvYml0cmF0ZS9hdmdEdXJhdGlvbi9tYXhGZXRjaER1cmF0aW9uL2ZldGNoRHVyYXRpb246IFwiK3ArXCIvXCIrTWF0aC5yb3VuZCh5KStcIi9cIitFK1wiL1wiK1QrXCIvXCIraStcIi9cIitTKSx5PkUmJighU3x8YyYmIXRoaXMuYml0cmF0ZVRlc3REZWxheXx8UzxpKSlyZXR1cm4gcH19cmV0dXJuLTF9LGU9dCwocj1be2tleTpcIm5leHRBdXRvTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9uZXh0QXV0b0xldmVsLGU9dGhpcy5id0VzdGltYXRvcjtpZighKC0xPT09dHx8ZSYmZS5jYW5Fc3RpbWF0ZSgpKSlyZXR1cm4gdDt2YXIgcj10aGlzLmdldE5leHRBQlJBdXRvTGV2ZWwoKTtyZXR1cm4tMSE9PXQmJihyPU1hdGgubWluKHQscikpLHJ9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9uZXh0QXV0b0xldmVsPXR9fV0pJiZRdChlLnByb3RvdHlwZSxyKSx0fSgpLFp0PXIoMTApLEp0PXIubihadCksdGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuYnVmZmVycz12b2lkIDAsdGhpcy5xdWV1ZXM9e3ZpZGVvOltdLGF1ZGlvOltdLGF1ZGlvdmlkZW86W119LHRoaXMuYnVmZmVycz10fXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmFwcGVuZD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMucXVldWVzW2VdO3IucHVzaCh0KSwxPT09ci5sZW5ndGgmJnRoaXMuYnVmZmVyc1tlXSYmdGhpcy5leGVjdXRlTmV4dChlKX0sZS5pbnNlcnRBYm9ydD1mdW5jdGlvbih0LGUpe3RoaXMucXVldWVzW2VdLnVuc2hpZnQodCksdGhpcy5leGVjdXRlTmV4dChlKX0sZS5hcHBlbmRCbG9ja2VyPWZ1bmN0aW9uKHQpe3ZhciBlLHI9bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe2U9dH0pKSxpPXtleGVjdXRlOmUsb25TdGFydDpmdW5jdGlvbigpe30sb25Db21wbGV0ZTpmdW5jdGlvbigpe30sb25FcnJvcjpmdW5jdGlvbigpe319O3JldHVybiB0aGlzLmFwcGVuZChpLHQpLHJ9LGUuZXhlY3V0ZU5leHQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5idWZmZXJzLHI9dGhpcy5xdWV1ZXMsaT1lW3RdLGE9clt0XTtpZihhLmxlbmd0aCl7dmFyIG49YVswXTt0cnl7bi5leGVjdXRlKCl9Y2F0Y2goZSl7by5iLndhcm4oXCJbYnVmZmVyLW9wZXJhdGlvbi1xdWV1ZV06IFVuaGFuZGxlZCBleGNlcHRpb24gZXhlY3V0aW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvblwiKSxuLm9uRXJyb3IoZSksaSYmaS51cGRhdGluZ3x8KGEuc2hpZnQoKSx0aGlzLmV4ZWN1dGVOZXh0KHQpKX19fSxlLnNoaWZ0QW5kRXhlY3V0ZU5leHQ9ZnVuY3Rpb24odCl7dGhpcy5xdWV1ZXNbdF0uc2hpZnQoKSx0aGlzLmV4ZWN1dGVOZXh0KHQpfSxlLmN1cnJlbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucXVldWVzW3RdWzBdfSx0fSgpLGVlPU50KCkscmU9LyhbaGFddmMuKSg/OlxcLlteLixdKykrLyxpZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGU9dGhpczt0aGlzLmRldGFpbHM9bnVsbCx0aGlzLl9vYmplY3RVcmw9bnVsbCx0aGlzLm9wZXJhdGlvblF1ZXVlPXZvaWQgMCx0aGlzLmxpc3RlbmVycz12b2lkIDAsdGhpcy5obHM9dm9pZCAwLHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZD0wLHRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw9MCx0aGlzLm1lZGlhPW51bGwsdGhpcy5tZWRpYVNvdXJjZT1udWxsLHRoaXMuYXBwZW5kRXJyb3I9MCx0aGlzLnRyYWNrcz17fSx0aGlzLnBlbmRpbmdUcmFja3M9e30sdGhpcy5zb3VyY2VCdWZmZXI9dm9pZCAwLHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuPWZ1bmN0aW9uKCl7dmFyIHQ9ZS5obHMscj1lLm1lZGlhLGk9ZS5tZWRpYVNvdXJjZTtvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIG9wZW5lZFwiKSxyJiYoZS51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbigpLHQudHJpZ2dlcihuLmEuTUVESUFfQVRUQUNIRUQse21lZGlhOnJ9KSksaSYmaS5yZW1vdmVFdmVudExpc3RlbmVyKFwic291cmNlb3BlblwiLGUuX29uTWVkaWFTb3VyY2VPcGVuKSxlLmNoZWNrUGVuZGluZ1RyYWNrcygpfSx0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2U9ZnVuY3Rpb24oKXtvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogTWVkaWEgc291cmNlIGNsb3NlZFwiKX0sdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkPWZ1bmN0aW9uKCl7by5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IE1lZGlhIHNvdXJjZSBlbmRlZFwiKX0sdGhpcy5obHM9dCx0aGlzLl9pbml0U291cmNlQnVmZmVyKCksdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmhhc1NvdXJjZVR5cGVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGg+MHx8T2JqZWN0LmtleXModGhpcy5wZW5kaW5nVHJhY2tzKS5sZW5ndGg+MH0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksdGhpcy5kZXRhaWxzPW51bGx9LGUucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmhsczt0Lm9uKG4uYS5NRURJQV9BVFRBQ0hJTkcsdGhpcy5vbk1lZGlhQXR0YWNoaW5nLHRoaXMpLHQub24obi5hLk1FRElBX0RFVEFDSElORyx0aGlzLm9uTWVkaWFEZXRhY2hpbmcsdGhpcyksdC5vbihuLmEuTUFOSUZFU1RfUEFSU0VELHRoaXMub25NYW5pZmVzdFBhcnNlZCx0aGlzKSx0Lm9uKG4uYS5CVUZGRVJfUkVTRVQsdGhpcy5vbkJ1ZmZlclJlc2V0LHRoaXMpLHQub24obi5hLkJVRkZFUl9BUFBFTkRJTkcsdGhpcy5vbkJ1ZmZlckFwcGVuZGluZyx0aGlzKSx0Lm9uKG4uYS5CVUZGRVJfQ09ERUNTLHRoaXMub25CdWZmZXJDb2RlY3MsdGhpcyksdC5vbihuLmEuQlVGRkVSX0VPUyx0aGlzLm9uQnVmZmVyRW9zLHRoaXMpLHQub24obi5hLkJVRkZFUl9GTFVTSElORyx0aGlzLm9uQnVmZmVyRmx1c2hpbmcsdGhpcyksdC5vbihuLmEuTEVWRUxfVVBEQVRFRCx0aGlzLm9uTGV2ZWxVcGRhdGVkLHRoaXMpLHQub24obi5hLkZSQUdfUEFSU0VELHRoaXMub25GcmFnUGFyc2VkLHRoaXMpLHQub24obi5hLkZSQUdfQ0hBTkdFRCx0aGlzLm9uRnJhZ0NoYW5nZWQsdGhpcyl9LGUudW5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub2ZmKG4uYS5NRURJQV9BVFRBQ0hJTkcsdGhpcy5vbk1lZGlhQXR0YWNoaW5nLHRoaXMpLHQub2ZmKG4uYS5NRURJQV9ERVRBQ0hJTkcsdGhpcy5vbk1lZGlhRGV0YWNoaW5nLHRoaXMpLHQub2ZmKG4uYS5NQU5JRkVTVF9QQVJTRUQsdGhpcy5vbk1hbmlmZXN0UGFyc2VkLHRoaXMpLHQub2ZmKG4uYS5CVUZGRVJfUkVTRVQsdGhpcy5vbkJ1ZmZlclJlc2V0LHRoaXMpLHQub2ZmKG4uYS5CVUZGRVJfQVBQRU5ESU5HLHRoaXMub25CdWZmZXJBcHBlbmRpbmcsdGhpcyksdC5vZmYobi5hLkJVRkZFUl9DT0RFQ1MsdGhpcy5vbkJ1ZmZlckNvZGVjcyx0aGlzKSx0Lm9mZihuLmEuQlVGRkVSX0VPUyx0aGlzLm9uQnVmZmVyRW9zLHRoaXMpLHQub2ZmKG4uYS5CVUZGRVJfRkxVU0hJTkcsdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLHRoaXMpLHQub2ZmKG4uYS5MRVZFTF9VUERBVEVELHRoaXMub25MZXZlbFVwZGF0ZWQsdGhpcyksdC5vZmYobi5hLkZSQUdfUEFSU0VELHRoaXMub25GcmFnUGFyc2VkLHRoaXMpLHQub2ZmKG4uYS5GUkFHX0NIQU5HRUQsdGhpcy5vbkZyYWdDaGFuZ2VkLHRoaXMpfSxlLl9pbml0U291cmNlQnVmZmVyPWZ1bmN0aW9uKCl7dGhpcy5zb3VyY2VCdWZmZXI9e30sdGhpcy5vcGVyYXRpb25RdWV1ZT1uZXcgdGUodGhpcy5zb3VyY2VCdWZmZXIpLHRoaXMubGlzdGVuZXJzPXthdWRpbzpbXSx2aWRlbzpbXSxhdWRpb3ZpZGVvOltdfX0sZS5vbk1hbmlmZXN0UGFyc2VkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9MjsoZS5hdWRpbyYmIWUudmlkZW98fCFlLmFsdEF1ZGlvKSYmKHI9MSksdGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkPXRoaXMuX2J1ZmZlckNvZGVjRXZlbnRzVG90YWw9cix0aGlzLmRldGFpbHM9bnVsbCxvLmIubG9nKHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZCtcIiBidWZmZXJDb2RlYyBldmVudChzKSBleHBlY3RlZFwiKX0sZS5vbk1lZGlhQXR0YWNoaW5nPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5tZWRpYT1lLm1lZGlhO2lmKHImJmVlKXt2YXIgaT10aGlzLm1lZGlhU291cmNlPW5ldyBlZTtpLmFkZEV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pLGkuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZWVuZGVkXCIsdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJzb3VyY2VjbG9zZVwiLHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSksci5zcmM9c2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGkpLHRoaXMuX29iamVjdFVybD1yLnNyY319LGUub25NZWRpYURldGFjaGluZz1mdW5jdGlvbigpe3ZhciB0PXRoaXMubWVkaWEsZT10aGlzLm1lZGlhU291cmNlLHI9dGhpcy5fb2JqZWN0VXJsO2lmKGUpe2lmKG8uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBtZWRpYSBzb3VyY2UgZGV0YWNoaW5nXCIpLFwib3BlblwiPT09ZS5yZWFkeVN0YXRlKXRyeXtlLmVuZE9mU3RyZWFtKCl9Y2F0Y2godCl7by5iLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBvbk1lZGlhRGV0YWNoaW5nOiBcIit0Lm1lc3NhZ2UrXCIgd2hpbGUgY2FsbGluZyBlbmRPZlN0cmVhbVwiKX10aGlzLm9uQnVmZmVyUmVzZXQoKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pLGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNvdXJjZWVuZGVkXCIsdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKSxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzb3VyY2VjbG9zZVwiLHRoaXMuX29uTWVkaWFTb3VyY2VDbG9zZSksdCYmKHImJnNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChyKSx0LnNyYz09PXI/KHQucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpLHQubG9hZCgpKTpvLmIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IG1lZGlhLnNyYyB3YXMgY2hhbmdlZCBieSBhIHRoaXJkIHBhcnR5IC0gc2tpcCBjbGVhbnVwXCIpKSx0aGlzLm1lZGlhU291cmNlPW51bGwsdGhpcy5tZWRpYT1udWxsLHRoaXMuX29iamVjdFVybD1udWxsLHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZD10aGlzLl9idWZmZXJDb2RlY0V2ZW50c1RvdGFsLHRoaXMucGVuZGluZ1RyYWNrcz17fSx0aGlzLnRyYWNrcz17fX10aGlzLmhscy50cmlnZ2VyKG4uYS5NRURJQV9ERVRBQ0hFRCx2b2lkIDApfSxlLm9uQnVmZmVyUmVzZXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgcj10LnNvdXJjZUJ1ZmZlcltlXTt0cnl7ciYmKHQucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKGUpLHQubWVkaWFTb3VyY2UmJnQubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHIpLHQuc291cmNlQnVmZmVyW2VdPXZvaWQgMCl9Y2F0Y2godCl7by5iLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBGYWlsZWQgdG8gcmVzZXQgdGhlIFwiK2UrXCIgYnVmZmVyXCIsdCl9fSkpLHRoaXMuX2luaXRTb3VyY2VCdWZmZXIoKX0sZS5vbkJ1ZmZlckNvZGVjcz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsaT10aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCkubGVuZ3RoO09iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKGkpe3ZhciBhPXIudHJhY2tzW3RdO2lmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEuYnVmZmVyLmNoYW5nZVR5cGUpe3ZhciBuPWVbdF0scz1uLmNvZGVjLG89bi5sZXZlbENvZGVjLGw9bi5jb250YWluZXI7aWYoKGEubGV2ZWxDb2RlY3x8YS5jb2RlYykucmVwbGFjZShyZSxcIiQxXCIpIT09KG98fHMpLnJlcGxhY2UocmUsXCIkMVwiKSl7dmFyIHU9bCtcIjtjb2RlY3M9XCIrKG98fHMpO3IuYXBwZW5kQ2hhbmdlVHlwZSh0LHUpfX19ZWxzZSByLnBlbmRpbmdUcmFja3NbdF09ZVt0XX0pKSxpfHwodGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkPU1hdGgubWF4KHRoaXMuYnVmZmVyQ29kZWNFdmVudHNFeHBlY3RlZC0xLDApLHRoaXMubWVkaWFTb3VyY2UmJlwib3BlblwiPT09dGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlJiZ0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpKX0sZS5hcHBlbmRDaGFuZ2VUeXBlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxpPXRoaXMub3BlcmF0aW9uUXVldWUsYT17ZXhlY3V0ZTpmdW5jdGlvbigpe3ZhciBhPXIuc291cmNlQnVmZmVyW3RdO2EmJihvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogY2hhbmdpbmcgXCIrdCtcIiBzb3VyY2VCdWZmZXIgdHlwZSB0byBcIitlKSxhLmNoYW5nZVR5cGUoZSkpLGkuc2hpZnRBbmRFeGVjdXRlTmV4dCh0KX0sb25TdGFydDpmdW5jdGlvbigpe30sb25Db21wbGV0ZTpmdW5jdGlvbigpe30sb25FcnJvcjpmdW5jdGlvbihlKXtvLmIud2FybihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCB0byBjaGFuZ2UgXCIrdCtcIiBTb3VyY2VCdWZmZXIgdHlwZVwiLGUpfX07aS5hcHBlbmQoYSx0KX0sZS5vbkJ1ZmZlckFwcGVuZGluZz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsaT10aGlzLmhscyxhPXRoaXMub3BlcmF0aW9uUXVldWUsbD10aGlzLnRyYWNrcyx1PWUuZGF0YSxkPWUudHlwZSxoPWUuZnJhZyxmPWUucGFydCxjPWUuY2h1bmtNZXRhLHY9Yy5idWZmZXJpbmdbZF0sZz1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO3Yuc3RhcnQ9Zzt2YXIgcD1oLnN0YXRzLmJ1ZmZlcmluZyxtPWY/Zi5zdGF0cy5idWZmZXJpbmc6bnVsbDswPT09cC5zdGFydCYmKHAuc3RhcnQ9ZyksbSYmMD09PW0uc3RhcnQmJihtLnN0YXJ0PWcpO3ZhciB5PWwuYXVkaW8sYj1cImF1ZGlvXCI9PT1kJiYxPT09Yy5pZCYmXCJhdWRpby9tcGVnXCI9PT0obnVsbD09eT92b2lkIDA6eS5jb250YWluZXIpLFQ9e2V4ZWN1dGU6ZnVuY3Rpb24oKXtpZih2LmV4ZWN1dGVTdGFydD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpLGIpe3ZhciB0PXIuc291cmNlQnVmZmVyW2RdO2lmKHQpe3ZhciBlPWguc3RhcnQtdC50aW1lc3RhbXBPZmZzZXQ7TWF0aC5hYnMoZSk+PS4xJiYoby5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFVwZGF0aW5nIGF1ZGlvIFNvdXJjZUJ1ZmZlciB0aW1lc3RhbXBPZmZzZXQgdG8gXCIraC5zdGFydCtcIiAoZGVsdGE6IFwiK2UrXCIpIHNuOiBcIitoLnNuK1wiKVwiKSx0LnRpbWVzdGFtcE9mZnNldD1oLnN0YXJ0KX19ci5hcHBlbmRFeGVjdXRvcih1LGQpfSxvblN0YXJ0OmZ1bmN0aW9uKCl7fSxvbkNvbXBsZXRlOmZ1bmN0aW9uKCl7dmFyIHQ9c2VsZi5wZXJmb3JtYW5jZS5ub3coKTt2LmV4ZWN1dGVFbmQ9di5lbmQ9dCwwPT09cC5maXJzdCYmKHAuZmlyc3Q9dCksbSYmMD09PW0uZmlyc3QmJihtLmZpcnN0PXQpO3ZhciBlPXIuc291cmNlQnVmZmVyLGk9e307Zm9yKHZhciBhIGluIGUpaVthXT1hdC5nZXRCdWZmZXJlZChlW2FdKTtyLmFwcGVuZEVycm9yPTAsci5obHMudHJpZ2dlcihuLmEuQlVGRkVSX0FQUEVOREVELHt0eXBlOmQsZnJhZzpoLHBhcnQ6ZixjaHVua01ldGE6YyxwYXJlbnQ6aC50eXBlLHRpbWVSYW5nZXM6aX0pfSxvbkVycm9yOmZ1bmN0aW9uKHQpe28uYi5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IEVycm9yIGVuY291bnRlcmVkIHdoaWxlIHRyeWluZyB0byBhcHBlbmQgdG8gdGhlIFwiK2QrXCIgU291cmNlQnVmZmVyXCIsdCk7dmFyIGU9e3R5cGU6cy5iLk1FRElBX0VSUk9SLHBhcmVudDpoLnR5cGUsZGV0YWlsczpzLmEuQlVGRkVSX0FQUEVORF9FUlJPUixlcnI6dCxmYXRhbDohMX07dC5jb2RlPT09RE9NRXhjZXB0aW9uLlFVT1RBX0VYQ0VFREVEX0VSUj9lLmRldGFpbHM9cy5hLkJVRkZFUl9GVUxMX0VSUk9SOihyLmFwcGVuZEVycm9yKyssZS5kZXRhaWxzPXMuYS5CVUZGRVJfQVBQRU5EX0VSUk9SLHIuYXBwZW5kRXJyb3I+aS5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeSYmKG8uYi5lcnJvcihcIltidWZmZXItY29udHJvbGxlcl06IEZhaWxlZCBcIitpLmNvbmZpZy5hcHBlbmRFcnJvck1heFJldHJ5K1wiIHRpbWVzIHRvIGFwcGVuZCBzZWdtZW50IGluIHNvdXJjZUJ1ZmZlclwiKSxlLmZhdGFsPSEwKSksaS50cmlnZ2VyKG4uYS5FUlJPUixlKX19O2EuYXBwZW5kKFQsZCl9LGUub25CdWZmZXJGbHVzaGluZz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsaT10aGlzLm9wZXJhdGlvblF1ZXVlLGE9ZnVuY3Rpb24odCl7cmV0dXJue2V4ZWN1dGU6ci5yZW1vdmVFeGVjdXRvci5iaW5kKHIsdCxlLnN0YXJ0T2Zmc2V0LGUuZW5kT2Zmc2V0KSxvblN0YXJ0OmZ1bmN0aW9uKCl7fSxvbkNvbXBsZXRlOmZ1bmN0aW9uKCl7ci5obHMudHJpZ2dlcihuLmEuQlVGRkVSX0ZMVVNIRUQse3R5cGU6dH0pfSxvbkVycm9yOmZ1bmN0aW9uKGUpe28uYi53YXJuKFwiW2J1ZmZlci1jb250cm9sbGVyXTogRmFpbGVkIHRvIHJlbW92ZSBmcm9tIFwiK3QrXCIgU291cmNlQnVmZmVyXCIsZSl9fX07ZS50eXBlP2kuYXBwZW5kKGEoZS50eXBlKSxlLnR5cGUpOnRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5mb3JFYWNoKChmdW5jdGlvbih0KXtpLmFwcGVuZChhKHQpLHQpfSkpfSxlLm9uRnJhZ1BhcnNlZD1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMsaT1lLmZyYWcsYT1lLnBhcnQscz1bXSxsPWE/YS5lbGVtZW50YXJ5U3RyZWFtczppLmVsZW1lbnRhcnlTdHJlYW1zO2xbdS5hLkFVRElPVklERU9dP3MucHVzaChcImF1ZGlvdmlkZW9cIik6KGxbdS5hLkFVRElPXSYmcy5wdXNoKFwiYXVkaW9cIiksbFt1LmEuVklERU9dJiZzLnB1c2goXCJ2aWRlb1wiKSksMD09PXMubGVuZ3RoJiZvLmIud2FybihcIkZyYWdtZW50cyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIEVsZW1lbnRhcnlTdHJlYW1UeXBlIHNldC4gdHlwZTogXCIraS50eXBlK1wiIGxldmVsOiBcIitpLmxldmVsK1wiIHNuOiBcIitpLnNuKSx0aGlzLmJsb2NrQnVmZmVycygoZnVuY3Rpb24oKXt2YXIgdD1zZWxmLnBlcmZvcm1hbmNlLm5vdygpO2kuc3RhdHMuYnVmZmVyaW5nLmVuZD10LGEmJihhLnN0YXRzLmJ1ZmZlcmluZy5lbmQ9dCk7dmFyIGU9YT9hLnN0YXRzOmkuc3RhdHM7ci5obHMudHJpZ2dlcihuLmEuRlJBR19CVUZGRVJFRCx7ZnJhZzppLHBhcnQ6YSxzdGF0czplLGlkOmkudHlwZX0pfSkscyl9LGUub25GcmFnQ2hhbmdlZD1mdW5jdGlvbih0LGUpe3RoaXMuZmx1c2hCYWNrQnVmZmVyKCl9LGUub25CdWZmZXJFb3M9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzO3RoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsaSl7dmFyIGE9ci5zb3VyY2VCdWZmZXJbaV07cmV0dXJuIGUudHlwZSYmZS50eXBlIT09aXx8YSYmIWEuZW5kZWQmJihhLmVuZGVkPSEwLG8uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBcIitpK1wiIHNvdXJjZUJ1ZmZlciBub3cgRU9TXCIpKSx0JiYhKGEmJiFhLmVuZGVkKX0pLCEwKSYmdGhpcy5ibG9ja0J1ZmZlcnMoKGZ1bmN0aW9uKCl7dmFyIHQ9ci5tZWRpYVNvdXJjZTt0JiZcIm9wZW5cIj09PXQucmVhZHlTdGF0ZSYmdC5lbmRPZlN0cmVhbSgpfSkpfSxlLm9uTGV2ZWxVcGRhdGVkPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kZXRhaWxzO3IuZnJhZ21lbnRzLmxlbmd0aCYmKHRoaXMuZGV0YWlscz1yLHRoaXMuZ2V0U291cmNlQnVmZmVyVHlwZXMoKS5sZW5ndGg/dGhpcy5ibG9ja0J1ZmZlcnModGhpcy51cGRhdGVNZWRpYUVsZW1lbnREdXJhdGlvbi5iaW5kKHRoaXMpKTp0aGlzLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uKCkpfSxlLmZsdXNoQmFja0J1ZmZlcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzLGU9dGhpcy5kZXRhaWxzLHI9dGhpcy5tZWRpYSxpPXRoaXMuc291cmNlQnVmZmVyO2lmKHImJm51bGwhPT1lKXt2YXIgcz10aGlzLmdldFNvdXJjZUJ1ZmZlclR5cGVzKCk7aWYocy5sZW5ndGgpe3ZhciBvPWUubGl2ZSYmbnVsbCE9PXQuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoP3QuY29uZmlnLmxpdmVCYWNrQnVmZmVyTGVuZ3RoOnQuY29uZmlnLmJhY2tCdWZmZXJMZW5ndGg7aWYoT2JqZWN0KGEuYSkobykmJiEobzwwKSl7dmFyIGw9ci5jdXJyZW50VGltZSx1PWUubGV2ZWxUYXJnZXREdXJhdGlvbixkPU1hdGgubWF4KG8sdSksaD1NYXRoLmZsb29yKGwvdSkqdS1kO3MuZm9yRWFjaCgoZnVuY3Rpb24ocil7dmFyIGE9aVtyXTtpZihhKXt2YXIgcz1hdC5nZXRCdWZmZXJlZChhKTtzLmxlbmd0aD4wJiZoPnMuc3RhcnQoMCkmJih0LnRyaWdnZXIobi5hLkJBQ0tfQlVGRkVSX1JFQUNIRUQse2J1ZmZlckVuZDpofSksZS5saXZlJiZ0LnRyaWdnZXIobi5hLkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRCx7YnVmZmVyRW5kOmh9KSx0LnRyaWdnZXIobi5hLkJVRkZFUl9GTFVTSElORyx7c3RhcnRPZmZzZXQ6MCxlbmRPZmZzZXQ6aCx0eXBlOnJ9KSl9fSkpfX19fSxlLnVwZGF0ZU1lZGlhRWxlbWVudER1cmF0aW9uPWZ1bmN0aW9uKCl7aWYodGhpcy5kZXRhaWxzJiZ0aGlzLm1lZGlhJiZ0aGlzLm1lZGlhU291cmNlJiZcIm9wZW5cIj09PXRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSl7dmFyIHQ9dGhpcy5kZXRhaWxzLGU9dGhpcy5obHMscj10aGlzLm1lZGlhLGk9dGhpcy5tZWRpYVNvdXJjZSxuPXQuZnJhZ21lbnRzWzBdLnN0YXJ0K3QudG90YWxkdXJhdGlvbixzPXIuZHVyYXRpb24sbD1PYmplY3QoYS5hKShpLmR1cmF0aW9uKT9pLmR1cmF0aW9uOjA7dC5saXZlJiZlLmNvbmZpZy5saXZlRHVyYXRpb25JbmZpbml0eT8oby5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IE1lZGlhIFNvdXJjZSBkdXJhdGlvbiBpcyBzZXQgdG8gSW5maW5pdHlcIiksaS5kdXJhdGlvbj0xLzAsdGhpcy51cGRhdGVTZWVrYWJsZVJhbmdlKHQpKToobj5sJiZuPnN8fCFPYmplY3QoYS5hKShzKSkmJihvLmIubG9nKFwiW2J1ZmZlci1jb250cm9sbGVyXTogVXBkYXRpbmcgTWVkaWEgU291cmNlIGR1cmF0aW9uIHRvIFwiK24udG9GaXhlZCgzKSksaS5kdXJhdGlvbj1uKX19LGUudXBkYXRlU2Vla2FibGVSYW5nZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm1lZGlhU291cmNlLHI9dC5mcmFnbWVudHM7aWYoci5sZW5ndGgmJnQubGl2ZSYmbnVsbCE9ZSYmZS5zZXRMaXZlU2Vla2FibGVSYW5nZSl7dmFyIGk9TWF0aC5tYXgoMCxyWzBdLnN0YXJ0KSxhPU1hdGgubWF4KGksaSt0LnRvdGFsZHVyYXRpb24pO2Uuc2V0TGl2ZVNlZWthYmxlUmFuZ2UoaSxhKX19LGUuY2hlY2tQZW5kaW5nVHJhY2tzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5idWZmZXJDb2RlY0V2ZW50c0V4cGVjdGVkLGU9dGhpcy5vcGVyYXRpb25RdWV1ZSxyPXRoaXMucGVuZGluZ1RyYWNrcyxpPU9iamVjdC5rZXlzKHIpLmxlbmd0aDtpZihpJiYhdHx8Mj09PWkpe3RoaXMuY3JlYXRlU291cmNlQnVmZmVycyhyKSx0aGlzLnBlbmRpbmdUcmFja3M9e307dmFyIGE9dGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpO2lmKDA9PT1hLmxlbmd0aClyZXR1cm4gdm9pZCB0aGlzLmhscy50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTUVESUFfRVJST1IsZGV0YWlsczpzLmEuQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsZmF0YWw6ITAscmVhc29uOlwiY291bGQgbm90IGNyZWF0ZSBzb3VyY2UgYnVmZmVyIGZvciBtZWRpYSBjb2RlYyhzKVwifSk7YS5mb3JFYWNoKChmdW5jdGlvbih0KXtlLmV4ZWN1dGVOZXh0KHQpfSkpfX0sZS5jcmVhdGVTb3VyY2VCdWZmZXJzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc291cmNlQnVmZmVyLHI9dGhpcy5tZWRpYVNvdXJjZTtpZighcil0aHJvdyBFcnJvcihcImNyZWF0ZVNvdXJjZUJ1ZmZlcnMgY2FsbGVkIHdoZW4gbWVkaWFTb3VyY2Ugd2FzIG51bGxcIik7dmFyIGk9MDtmb3IodmFyIGEgaW4gdClpZighZVthXSl7dmFyIGw9dFthXTtpZighbCl0aHJvdyBFcnJvcihcInNvdXJjZSBidWZmZXIgZXhpc3RzIGZvciB0cmFjayBcIithK1wiLCBob3dldmVyIHRyYWNrIGRvZXMgbm90XCIpO3ZhciB1PWwubGV2ZWxDb2RlY3x8bC5jb2RlYyxkPWwuY29udGFpbmVyK1wiO2NvZGVjcz1cIit1O28uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBjcmVhdGluZyBzb3VyY2VCdWZmZXIoXCIrZCtcIilcIik7dHJ5e3ZhciBoPWVbYV09ci5hZGRTb3VyY2VCdWZmZXIoZCksZj1hO3RoaXMuYWRkQnVmZmVyTGlzdGVuZXIoZixcInVwZGF0ZXN0YXJ0XCIsdGhpcy5fb25TQlVwZGF0ZVN0YXJ0KSx0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKGYsXCJ1cGRhdGVlbmRcIix0aGlzLl9vblNCVXBkYXRlRW5kKSx0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKGYsXCJlcnJvclwiLHRoaXMuX29uU0JVcGRhdGVFcnJvciksdGhpcy50cmFja3NbYV09e2J1ZmZlcjpoLGNvZGVjOnUsY29udGFpbmVyOmwuY29udGFpbmVyLGxldmVsQ29kZWM6bC5sZXZlbENvZGVjLGlkOmwuaWR9LGkrK31jYXRjaCh0KXtvLmIuZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gYWRkIHNvdXJjZUJ1ZmZlcjogXCIrdC5tZXNzYWdlKSx0aGlzLmhscy50cmlnZ2VyKG4uYS5FUlJPUix7dHlwZTpzLmIuTUVESUFfRVJST1IsZGV0YWlsczpzLmEuQlVGRkVSX0FERF9DT0RFQ19FUlJPUixmYXRhbDohMSxlcnJvcjp0LG1pbWVUeXBlOmR9KX19aSYmdGhpcy5obHMudHJpZ2dlcihuLmEuQlVGRkVSX0NSRUFURUQse3RyYWNrczp0aGlzLnRyYWNrc30pfSxlLl9vblNCVXBkYXRlU3RhcnQ9ZnVuY3Rpb24odCl7dGhpcy5vcGVyYXRpb25RdWV1ZS5jdXJyZW50KHQpLm9uU3RhcnQoKX0sZS5fb25TQlVwZGF0ZUVuZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLm9wZXJhdGlvblF1ZXVlO2UuY3VycmVudCh0KS5vbkNvbXBsZXRlKCksZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KHQpfSxlLl9vblNCVXBkYXRlRXJyb3I9ZnVuY3Rpb24odCxlKXtvLmIuZXJyb3IoXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBcIit0K1wiIFNvdXJjZUJ1ZmZlciBlcnJvclwiLGUpLHRoaXMuaGxzLnRyaWdnZXIobi5hLkVSUk9SLHt0eXBlOnMuYi5NRURJQV9FUlJPUixkZXRhaWxzOnMuYS5CVUZGRVJfQVBQRU5ESU5HX0VSUk9SLGZhdGFsOiExfSk7dmFyIHI9dGhpcy5vcGVyYXRpb25RdWV1ZS5jdXJyZW50KHQpO3ImJnIub25FcnJvcihlKX0sZS5yZW1vdmVFeGVjdXRvcj1mdW5jdGlvbih0LGUscil7dmFyIGk9dGhpcy5tZWRpYSxuPXRoaXMubWVkaWFTb3VyY2Uscz10aGlzLm9wZXJhdGlvblF1ZXVlLGw9dGhpcy5zb3VyY2VCdWZmZXJbdF07aWYoIWl8fCFufHwhbClyZXR1cm4gby5iLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBBdHRlbXB0aW5nIHRvIHJlbW92ZSBmcm9tIHRoZSBcIit0K1wiIFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0XCIpLHZvaWQgcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHQpO3ZhciB1PU9iamVjdChhLmEpKGkuZHVyYXRpb24pP2kuZHVyYXRpb246MS8wLGQ9T2JqZWN0KGEuYSkobi5kdXJhdGlvbik/bi5kdXJhdGlvbjoxLzAsaD1NYXRoLm1heCgwLGUpLGY9TWF0aC5taW4ocix1LGQpO2Y+aD8oby5iLmxvZyhcIltidWZmZXItY29udHJvbGxlcl06IFJlbW92aW5nIFtcIitoK1wiLFwiK2YrXCJdIGZyb20gdGhlIFwiK3QrXCIgU291cmNlQnVmZmVyXCIpLGwucmVtb3ZlKGgsZikpOnMuc2hpZnRBbmRFeGVjdXRlTmV4dCh0KX0sZS5hcHBlbmRFeGVjdXRvcj1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMub3BlcmF0aW9uUXVldWUsaT10aGlzLnNvdXJjZUJ1ZmZlcltlXTtpZighaSlyZXR1cm4gby5iLndhcm4oXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBBdHRlbXB0aW5nIHRvIGFwcGVuZCB0byB0aGUgXCIrZStcIiBTb3VyY2VCdWZmZXIsIGJ1dCBpdCBkb2VzIG5vdCBleGlzdFwiKSx2b2lkIHIuc2hpZnRBbmRFeGVjdXRlTmV4dChlKTtpLmVuZGVkPSExLGkuYXBwZW5kQnVmZmVyKHQpfSxlLmJsb2NrQnVmZmVycz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7aWYodm9pZCAwPT09ZSYmKGU9dGhpcy5nZXRTb3VyY2VCdWZmZXJUeXBlcygpKSwhZS5sZW5ndGgpcmV0dXJuIG8uYi5sb2coXCJbYnVmZmVyLWNvbnRyb2xsZXJdOiBCbG9ja2luZyBvcGVyYXRpb24gcmVxdWVzdGVkLCBidXQgbm8gU291cmNlQnVmZmVycyBleGlzdFwiKSx2b2lkIFByb21pc2UucmVzb2x2ZSh0KTt2YXIgaT10aGlzLm9wZXJhdGlvblF1ZXVlLGE9ZS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiBpLmFwcGVuZEJsb2NrZXIodCl9KSk7UHJvbWlzZS5hbGwoYSkudGhlbigoZnVuY3Rpb24oKXt0KCksZS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT1yLnNvdXJjZUJ1ZmZlclt0XTtlJiZlLnVwZGF0aW5nfHxpLnNoaWZ0QW5kRXhlY3V0ZU5leHQodCl9KSl9KSl9LGUuZ2V0U291cmNlQnVmZmVyVHlwZXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5zb3VyY2VCdWZmZXIpfSxlLmFkZEJ1ZmZlckxpc3RlbmVyPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT10aGlzLnNvdXJjZUJ1ZmZlclt0XTtpZihpKXt2YXIgYT1yLmJpbmQodGhpcyx0KTt0aGlzLmxpc3RlbmVyc1t0XS5wdXNoKHtldmVudDplLGxpc3RlbmVyOmF9KSxpLmFkZEV2ZW50TGlzdGVuZXIoZSxhKX19LGUucmVtb3ZlQnVmZmVyTGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc291cmNlQnVmZmVyW3RdO2UmJnRoaXMubGlzdGVuZXJzW3RdLmZvckVhY2goKGZ1bmN0aW9uKHQpe2UucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LmV2ZW50LHQubGlzdGVuZXIpfSkpfSx0fSgpO2Z1bmN0aW9uIGFlKHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBpPWVbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX12YXIgbmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuYXV0b0xldmVsQ2FwcGluZz12b2lkIDAsdGhpcy5maXJzdExldmVsPXZvaWQgMCx0aGlzLm1lZGlhPXZvaWQgMCx0aGlzLnJlc3RyaWN0ZWRMZXZlbHM9dm9pZCAwLHRoaXMudGltZXI9dm9pZCAwLHRoaXMuaGxzPXZvaWQgMCx0aGlzLnN0cmVhbUNvbnRyb2xsZXI9dm9pZCAwLHRoaXMuY2xpZW50UmVjdD12b2lkIDAsdGhpcy5obHM9dCx0aGlzLmF1dG9MZXZlbENhcHBpbmc9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHRoaXMuZmlyc3RMZXZlbD0tMSx0aGlzLm1lZGlhPW51bGwsdGhpcy5yZXN0cmljdGVkTGV2ZWxzPVtdLHRoaXMudGltZXI9dm9pZCAwLHRoaXMuY2xpZW50UmVjdD1udWxsLHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKX12YXIgZSxyLGksYT10LnByb3RvdHlwZTtyZXR1cm4gYS5zZXRTdHJlYW1Db250cm9sbGVyPWZ1bmN0aW9uKHQpe3RoaXMuc3RyZWFtQ29udHJvbGxlcj10fSxhLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcigpLHRoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSYmdGhpcy5zdG9wQ2FwcGluZygpLHRoaXMubWVkaWE9bnVsbCx0aGlzLmNsaWVudFJlY3Q9bnVsbCx0aGlzLmhscz10aGlzLnN0cmVhbUNvbnRyb2xsZXI9bnVsbH0sYS5yZWdpc3Rlckxpc3RlbmVycz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub24obi5hLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsdGhpcy5vbkZwc0Ryb3BMZXZlbENhcHBpbmcsdGhpcyksdC5vbihuLmEuTUVESUFfQVRUQUNISU5HLHRoaXMub25NZWRpYUF0dGFjaGluZyx0aGlzKSx0Lm9uKG4uYS5NQU5JRkVTVF9QQVJTRUQsdGhpcy5vbk1hbmlmZXN0UGFyc2VkLHRoaXMpLHQub24obi5hLkJVRkZFUl9DT0RFQ1MsdGhpcy5vbkJ1ZmZlckNvZGVjcyx0aGlzKSx0Lm9uKG4uYS5NRURJQV9ERVRBQ0hJTkcsdGhpcy5vbk1lZGlhRGV0YWNoaW5nLHRoaXMpfSxhLnVucmVnaXN0ZXJMaXN0ZW5lcj1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaGxzO3Qub2ZmKG4uYS5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLHRoaXMpLHQub2ZmKG4uYS5NRURJQV9BVFRBQ0hJTkcsdGhpcy5vbk1lZGlhQXR0YWNoaW5nLHRoaXMpLHQub2ZmKG4uYS5NQU5JRkVTVF9QQVJTRUQsdGhpcy5vbk1hbmlmZXN0UGFyc2VkLHRoaXMpLHQub2ZmKG4uYS5CVUZGRVJfQ09ERUNTLHRoaXMub25CdWZmZXJDb2RlY3MsdGhpcyksdC5vZmYobi5hLk1FRElBX0RFVEFDSElORyx0aGlzLm9uTWVkaWFEZXRhY2hpbmcsdGhpcyl9LGEub25GcHNEcm9wTGV2ZWxDYXBwaW5nPWZ1bmN0aW9uKGUscil7dC5pc0xldmVsQWxsb3dlZChyLmRyb3BwZWRMZXZlbCx0aGlzLnJlc3RyaWN0ZWRMZXZlbHMpJiZ0aGlzLnJlc3RyaWN0ZWRMZXZlbHMucHVzaChyLmRyb3BwZWRMZXZlbCl9LGEub25NZWRpYUF0dGFjaGluZz1mdW5jdGlvbih0LGUpe3RoaXMubWVkaWE9ZS5tZWRpYSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ/ZS5tZWRpYTpudWxsfSxhLm9uTWFuaWZlc3RQYXJzZWQ9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLmhsczt0aGlzLnJlc3RyaWN0ZWRMZXZlbHM9W10sdGhpcy5maXJzdExldmVsPWUuZmlyc3RMZXZlbCxyLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSYmZS52aWRlbyYmdGhpcy5zdGFydENhcHBpbmcoKX0sYS5vbkJ1ZmZlckNvZGVjcz1mdW5jdGlvbih0LGUpe3RoaXMuaGxzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZSYmZS52aWRlbyYmdGhpcy5zdGFydENhcHBpbmcoKX0sYS5vbk1lZGlhRGV0YWNoaW5nPWZ1bmN0aW9uKCl7dGhpcy5zdG9wQ2FwcGluZygpfSxhLmRldGVjdFBsYXllclNpemU9ZnVuY3Rpb24oKXtpZih0aGlzLm1lZGlhJiZ0aGlzLm1lZGlhSGVpZ2h0PjAmJnRoaXMubWVkaWFXaWR0aD4wKXt2YXIgdD10aGlzLmhscy5sZXZlbHM7aWYodC5sZW5ndGgpe3ZhciBlPXRoaXMuaGxzO2UuYXV0b0xldmVsQ2FwcGluZz10aGlzLmdldE1heExldmVsKHQubGVuZ3RoLTEpLGUuYXV0b0xldmVsQ2FwcGluZz50aGlzLmF1dG9MZXZlbENhcHBpbmcmJnRoaXMuc3RyZWFtQ29udHJvbGxlciYmdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpLHRoaXMuYXV0b0xldmVsQ2FwcGluZz1lLmF1dG9MZXZlbENhcHBpbmd9fX0sYS5nZXRNYXhMZXZlbD1mdW5jdGlvbihlKXt2YXIgcj10aGlzLGk9dGhpcy5obHMubGV2ZWxzO2lmKCFpLmxlbmd0aClyZXR1cm4tMTt2YXIgYT1pLmZpbHRlcigoZnVuY3Rpb24oaSxhKXtyZXR1cm4gdC5pc0xldmVsQWxsb3dlZChhLHIucmVzdHJpY3RlZExldmVscykmJmE8PWV9KSk7cmV0dXJuIHRoaXMuY2xpZW50UmVjdD1udWxsLHQuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShhLHRoaXMubWVkaWFXaWR0aCx0aGlzLm1lZGlhSGVpZ2h0KX0sYS5zdGFydENhcHBpbmc9ZnVuY3Rpb24oKXt0aGlzLnRpbWVyfHwodGhpcy5hdXRvTGV2ZWxDYXBwaW5nPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSx0aGlzLmhscy5maXJzdExldmVsPXRoaXMuZ2V0TWF4TGV2ZWwodGhpcy5maXJzdExldmVsKSxzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lciksdGhpcy50aW1lcj1zZWxmLnNldEludGVydmFsKHRoaXMuZGV0ZWN0UGxheWVyU2l6ZS5iaW5kKHRoaXMpLDFlMyksdGhpcy5kZXRlY3RQbGF5ZXJTaXplKCkpfSxhLnN0b3BDYXBwaW5nPWZ1bmN0aW9uKCl7dGhpcy5yZXN0cmljdGVkTGV2ZWxzPVtdLHRoaXMuZmlyc3RMZXZlbD0tMSx0aGlzLmF1dG9MZXZlbENhcHBpbmc9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHRoaXMudGltZXImJihzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy50aW1lciksdGhpcy50aW1lcj12b2lkIDApfSxhLmdldERpbWVuc2lvbnM9ZnVuY3Rpb24oKXtpZih0aGlzLmNsaWVudFJlY3QpcmV0dXJuIHRoaXMuY2xpZW50UmVjdDt2YXIgdD10aGlzLm1lZGlhLGU9e3dpZHRoOjAsaGVpZ2h0OjB9O2lmKHQpe3ZhciByPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7ZS53aWR0aD1yLndpZHRoLGUuaGVpZ2h0PXIuaGVpZ2h0LGUud2lkdGh8fGUuaGVpZ2h0fHwoZS53aWR0aD1yLnJpZ2h0LXIubGVmdHx8dC53aWR0aHx8MCxlLmhlaWdodD1yLmJvdHRvbS1yLnRvcHx8dC5oZWlnaHR8fDApfXJldHVybiB0aGlzLmNsaWVudFJlY3Q9ZSxlfSx0LmlzTGV2ZWxBbGxvd2VkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVtdKSwtMT09PWUuaW5kZXhPZih0KX0sdC5nZXRNYXhMZXZlbEJ5TWVkaWFTaXplPWZ1bmN0aW9uKHQsZSxyKXtpZighdHx8IXQubGVuZ3RoKXJldHVybi0xO2Zvcih2YXIgaSxhLG49dC5sZW5ndGgtMSxzPTA7czx0Lmxlbmd0aDtzKz0xKXt2YXIgbz10W3NdO2lmKChvLndpZHRoPj1lfHxvLmhlaWdodD49cikmJihpPW8sIShhPXRbcysxXSl8fGkud2lkdGghPT1hLndpZHRofHxpLmhlaWdodCE9PWEuaGVpZ2h0KSl7bj1zO2JyZWFrfX1yZXR1cm4gbn0sZT10LGk9W3trZXk6XCJjb250ZW50U2NhbGVGYWN0b3JcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD0xO3RyeXt0PXNlbGYuZGV2aWNlUGl4ZWxSYXRpb31jYXRjaCh0KXt9cmV0dXJuIHR9fV0sKHI9W3trZXk6XCJtZWRpYVdpZHRoXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLndpZHRoKnQuY29udGVudFNjYWxlRmFjdG9yfX0se2tleTpcIm1lZGlhSGVpZ2h0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLmhlaWdodCp0LmNvbnRlbnRTY2FsZUZhY3Rvcn19XSkmJmFlKGUucHJvdG90eXBlLHIpLGkmJmFlKGUsaSksdH0oKSxzZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5obHM9dm9pZCAwLHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZT0hMSx0aGlzLnRpbWVyPXZvaWQgMCx0aGlzLm1lZGlhPW51bGwsdGhpcy5sYXN0VGltZT12b2lkIDAsdGhpcy5sYXN0RHJvcHBlZEZyYW1lcz0wLHRoaXMubGFzdERlY29kZWRGcmFtZXM9MCx0aGlzLnN0cmVhbUNvbnRyb2xsZXI9dm9pZCAwLHRoaXMuaGxzPXQsdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLnNldFN0cmVhbUNvbnRyb2xsZXI9ZnVuY3Rpb24odCl7dGhpcy5zdHJlYW1Db250cm9sbGVyPXR9LGUucmVnaXN0ZXJMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt0aGlzLmhscy5vbihuLmEuTUVESUFfQVRUQUNISU5HLHRoaXMub25NZWRpYUF0dGFjaGluZyx0aGlzKX0sZS51bnJlZ2lzdGVyTGlzdGVuZXJzPWZ1bmN0aW9uKCl7dGhpcy5obHMub2ZmKG4uYS5NRURJQV9BVFRBQ0hJTkcsdGhpcy5vbk1lZGlhQXR0YWNoaW5nKX0sZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy50aW1lciYmY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSx0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKSx0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGU9ITEsdGhpcy5tZWRpYT1udWxsfSxlLm9uTWVkaWFBdHRhY2hpbmc9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLmhscy5jb25maWc7aWYoci5jYXBMZXZlbE9uRlBTRHJvcCl7dmFyIGk9ZS5tZWRpYSBpbnN0YW5jZW9mIHNlbGYuSFRNTFZpZGVvRWxlbWVudD9lLm1lZGlhOm51bGw7dGhpcy5tZWRpYT1pLGkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGkuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkmJih0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGU9ITApLHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSx0aGlzLnRpbWVyPXNlbGYuc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksci5mcHNEcm9wcGVkTW9uaXRvcmluZ1BlcmlvZCl9fSxlLmNoZWNrRlBTPWZ1bmN0aW9uKHQsZSxyKXt2YXIgaT1wZXJmb3JtYW5jZS5ub3coKTtpZihlKXtpZih0aGlzLmxhc3RUaW1lKXt2YXIgYT1pLXRoaXMubGFzdFRpbWUscz1yLXRoaXMubGFzdERyb3BwZWRGcmFtZXMsbD1lLXRoaXMubGFzdERlY29kZWRGcmFtZXMsdT0xZTMqcy9hLGQ9dGhpcy5obHM7aWYoZC50cmlnZ2VyKG4uYS5GUFNfRFJPUCx7Y3VycmVudERyb3BwZWQ6cyxjdXJyZW50RGVjb2RlZDpsLHRvdGFsRHJvcHBlZEZyYW1lczpyfSksdT4wJiZzPmQuY29uZmlnLmZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkKmwpe3ZhciBoPWQuY3VycmVudExldmVsO28uYi53YXJuKFwiZHJvcCBGUFMgcmF0aW8gZ3JlYXRlciB0aGFuIG1heCBhbGxvd2VkIHZhbHVlIGZvciBjdXJyZW50TGV2ZWw6IFwiK2gpLGg+MCYmKC0xPT09ZC5hdXRvTGV2ZWxDYXBwaW5nfHxkLmF1dG9MZXZlbENhcHBpbmc+PWgpJiYoaC09MSxkLnRyaWdnZXIobi5hLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcse2xldmVsOmgsZHJvcHBlZExldmVsOmQuY3VycmVudExldmVsfSksZC5hdXRvTGV2ZWxDYXBwaW5nPWgsdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpKX19dGhpcy5sYXN0VGltZT1pLHRoaXMubGFzdERyb3BwZWRGcmFtZXM9cix0aGlzLmxhc3REZWNvZGVkRnJhbWVzPWV9fSxlLmNoZWNrRlBTSW50ZXJ2YWw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1lZGlhO2lmKHQpaWYodGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlKXt2YXIgZT10LmdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCk7dGhpcy5jaGVja0ZQUyh0LGUudG90YWxWaWRlb0ZyYW1lcyxlLmRyb3BwZWRWaWRlb0ZyYW1lcyl9ZWxzZSB0aGlzLmNoZWNrRlBTKHQsdC53ZWJraXREZWNvZGVkRnJhbWVDb3VudCx0LndlYmtpdERyb3BwZWRGcmFtZUNvdW50KX0sdH0oKSxvZT1yKDEyKSxsZT0vXmFnZTpcXHMqW1xcZC5dK1xccyokL20sdWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMueGhyU2V0dXA9dm9pZCAwLHRoaXMucmVxdWVzdFRpbWVvdXQ9dm9pZCAwLHRoaXMucmV0cnlUaW1lb3V0PXZvaWQgMCx0aGlzLnJldHJ5RGVsYXk9dm9pZCAwLHRoaXMuY29uZmlnPW51bGwsdGhpcy5jYWxsYmFja3M9bnVsbCx0aGlzLmNvbnRleHQ9dm9pZCAwLHRoaXMubG9hZGVyPW51bGwsdGhpcy5zdGF0cz12b2lkIDAsdGhpcy54aHJTZXR1cD10P3QueGhyU2V0dXA6bnVsbCx0aGlzLnN0YXRzPW5ldyBvZS5hLHRoaXMucmV0cnlEZWxheT0wfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmNhbGxiYWNrcz1udWxsLHRoaXMuYWJvcnRJbnRlcm5hbCgpLHRoaXMubG9hZGVyPW51bGwsdGhpcy5jb25maWc9bnVsbH0sZS5hYm9ydEludGVybmFsPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sb2FkZXI7c2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCksc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpLHQmJih0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLHQub25wcm9ncmVzcz1udWxsLDQhPT10LnJlYWR5U3RhdGUmJih0aGlzLnN0YXRzLmFib3J0ZWQ9ITAsdC5hYm9ydCgpKSl9LGUuYWJvcnQ9ZnVuY3Rpb24oKXt2YXIgdDt0aGlzLmFib3J0SW50ZXJuYWwoKSxudWxsIT09KHQ9dGhpcy5jYWxsYmFja3MpJiZ2b2lkIDAhPT10JiZ0Lm9uQWJvcnQmJnRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cyx0aGlzLmNvbnRleHQsdGhpcy5sb2FkZXIpfSxlLmxvYWQ9ZnVuY3Rpb24odCxlLHIpe2lmKHRoaXMuc3RhdHMubG9hZGluZy5zdGFydCl0aHJvdyBuZXcgRXJyb3IoXCJMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLlwiKTt0aGlzLnN0YXRzLmxvYWRpbmcuc3RhcnQ9c2VsZi5wZXJmb3JtYW5jZS5ub3coKSx0aGlzLmNvbnRleHQ9dCx0aGlzLmNvbmZpZz1lLHRoaXMuY2FsbGJhY2tzPXIsdGhpcy5yZXRyeURlbGF5PWUucmV0cnlEZWxheSx0aGlzLmxvYWRJbnRlcm5hbCgpfSxlLmxvYWRJbnRlcm5hbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuY29uZmlnLGU9dGhpcy5jb250ZXh0O2lmKHQpe3ZhciByPXRoaXMubG9hZGVyPW5ldyBzZWxmLlhNTEh0dHBSZXF1ZXN0LGk9dGhpcy5zdGF0cztpLmxvYWRpbmcuZmlyc3Q9MCxpLmxvYWRlZD0wO3ZhciBhPXRoaXMueGhyU2V0dXA7dHJ5e2lmKGEpdHJ5e2EocixlLnVybCl9Y2F0Y2godCl7ci5vcGVuKFwiR0VUXCIsZS51cmwsITApLGEocixlLnVybCl9ci5yZWFkeVN0YXRlfHxyLm9wZW4oXCJHRVRcIixlLnVybCwhMCk7dmFyIG49dGhpcy5jb250ZXh0LmhlYWRlcnM7aWYobilmb3IodmFyIHMgaW4gbilyLnNldFJlcXVlc3RIZWFkZXIocyxuW3NdKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCB0aGlzLmNhbGxiYWNrcy5vbkVycm9yKHtjb2RlOnIuc3RhdHVzLHRleHQ6dC5tZXNzYWdlfSxlLHIpfWUucmFuZ2VFbmQmJnIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsXCJieXRlcz1cIitlLnJhbmdlU3RhcnQrXCItXCIrKGUucmFuZ2VFbmQtMSkpLHIub25yZWFkeXN0YXRlY2hhbmdlPXRoaXMucmVhZHlzdGF0ZWNoYW5nZS5iaW5kKHRoaXMpLHIub25wcm9ncmVzcz10aGlzLmxvYWRwcm9ncmVzcy5iaW5kKHRoaXMpLHIucmVzcG9uc2VUeXBlPWUucmVzcG9uc2VUeXBlLHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpLHRoaXMucmVxdWVzdFRpbWVvdXQ9c2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZHRpbWVvdXQuYmluZCh0aGlzKSx0LnRpbWVvdXQpLHIuc2VuZCgpfX0sZS5yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb250ZXh0LGU9dGhpcy5sb2FkZXIscj10aGlzLnN0YXRzO2lmKHQmJmUpe3ZhciBpPWUucmVhZHlTdGF0ZSxhPXRoaXMuY29uZmlnO2lmKCFyLmFib3J0ZWQmJmk+PTIpaWYoc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCksMD09PXIubG9hZGluZy5maXJzdCYmKHIubG9hZGluZy5maXJzdD1NYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLHIubG9hZGluZy5zdGFydCkpLDQ9PT1pKXtlLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLGUub25wcm9ncmVzcz1udWxsO3ZhciBuPWUuc3RhdHVzO2lmKG4+PTIwMCYmbjwzMDApe3ZhciBzLGw7aWYoci5sb2FkaW5nLmVuZD1NYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLHIubG9hZGluZy5maXJzdCksbD1cImFycmF5YnVmZmVyXCI9PT10LnJlc3BvbnNlVHlwZT8ocz1lLnJlc3BvbnNlKS5ieXRlTGVuZ3RoOihzPWUucmVzcG9uc2VUZXh0KS5sZW5ndGgsci5sb2FkZWQ9ci50b3RhbD1sLCF0aGlzLmNhbGxiYWNrcylyZXR1cm47dmFyIHU9dGhpcy5jYWxsYmFja3Mub25Qcm9ncmVzcztpZih1JiZ1KHIsdCxzLGUpLCF0aGlzLmNhbGxiYWNrcylyZXR1cm47dmFyIGQ9e3VybDplLnJlc3BvbnNlVVJMLGRhdGE6c307dGhpcy5jYWxsYmFja3Mub25TdWNjZXNzKGQscix0LGUpfWVsc2Ugci5yZXRyeT49YS5tYXhSZXRyeXx8bj49NDAwJiZuPDQ5OT8oby5iLmVycm9yKG4rXCIgd2hpbGUgbG9hZGluZyBcIit0LnVybCksdGhpcy5jYWxsYmFja3Mub25FcnJvcih7Y29kZTpuLHRleHQ6ZS5zdGF0dXNUZXh0fSx0LGUpKTooby5iLndhcm4obitcIiB3aGlsZSBsb2FkaW5nIFwiK3QudXJsK1wiLCByZXRyeWluZyBpbiBcIit0aGlzLnJldHJ5RGVsYXkrXCIuLi5cIiksdGhpcy5hYm9ydEludGVybmFsKCksdGhpcy5sb2FkZXI9bnVsbCxzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZW91dCksdGhpcy5yZXRyeVRpbWVvdXQ9c2VsZi5zZXRUaW1lb3V0KHRoaXMubG9hZEludGVybmFsLmJpbmQodGhpcyksdGhpcy5yZXRyeURlbGF5KSx0aGlzLnJldHJ5RGVsYXk9TWF0aC5taW4oMip0aGlzLnJldHJ5RGVsYXksYS5tYXhSZXRyeURlbGF5KSxyLnJldHJ5KyspfWVsc2Ugc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCksdGhpcy5yZXF1ZXN0VGltZW91dD1zZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLGEudGltZW91dCl9fSxlLmxvYWR0aW1lb3V0PWZ1bmN0aW9uKCl7by5iLndhcm4oXCJ0aW1lb3V0IHdoaWxlIGxvYWRpbmcgXCIrdGhpcy5jb250ZXh0LnVybCk7dmFyIHQ9dGhpcy5jYWxsYmFja3M7dCYmKHRoaXMuYWJvcnRJbnRlcm5hbCgpLHQub25UaW1lb3V0KHRoaXMuc3RhdHMsdGhpcy5jb250ZXh0LHRoaXMubG9hZGVyKSl9LGUubG9hZHByb2dyZXNzPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc3RhdHM7ZS5sb2FkZWQ9dC5sb2FkZWQsdC5sZW5ndGhDb21wdXRhYmxlJiYoZS50b3RhbD10LnRvdGFsKX0sZS5nZXRDYWNoZUFnZT1mdW5jdGlvbigpe3ZhciB0PW51bGw7aWYodGhpcy5sb2FkZXImJmxlLnRlc3QodGhpcy5sb2FkZXIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpKXt2YXIgZT10aGlzLmxvYWRlci5nZXRSZXNwb25zZUhlYWRlcihcImFnZVwiKTt0PWU/cGFyc2VGbG9hdChlKTpudWxsfXJldHVybiB0fSx0fSgpLGRlPXIoMTYpO2Z1bmN0aW9uIGhlKHQpe3ZhciBlPVwiZnVuY3Rpb25cIj09dHlwZW9mIE1hcD9uZXcgTWFwOnZvaWQgMDtyZXR1cm4oaGU9ZnVuY3Rpb24odCl7aWYobnVsbD09PXR8fChyPXQsLTE9PT1GdW5jdGlvbi50b1N0cmluZy5jYWxsKHIpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpKSlyZXR1cm4gdDt2YXIgcjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT1lKXtpZihlLmhhcyh0KSlyZXR1cm4gZS5nZXQodCk7ZS5zZXQodCxpKX1mdW5jdGlvbiBpKCl7cmV0dXJuIGZlKHQsYXJndW1lbnRzLGdlKHRoaXMpLmNvbnN0cnVjdG9yKX1yZXR1cm4gaS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmksZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdmUoaSx0KX0pKHQpfWZ1bmN0aW9uIGZlKHQsZSxyKXtyZXR1cm4oZmU9Y2UoKT9SZWZsZWN0LmNvbnN0cnVjdDpmdW5jdGlvbih0LGUscil7dmFyIGk9W251bGxdO2kucHVzaC5hcHBseShpLGUpO3ZhciBhPW5ldyhGdW5jdGlvbi5iaW5kLmFwcGx5KHQsaSkpO3JldHVybiByJiZ2ZShhLHIucHJvdG90eXBlKSxhfSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfWZ1bmN0aW9uIGNlKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sW10sKGZ1bmN0aW9uKCl7fSkpKSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19ZnVuY3Rpb24gdmUodCxlKXtyZXR1cm4odmU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9KSh0LGUpfWZ1bmN0aW9uIGdlKHQpe3JldHVybihnZT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0Ll9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfSkodCl9ZnVuY3Rpb24gcGUoKXtyZXR1cm4ocGU9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHI9YXJndW1lbnRzW2VdO2Zvcih2YXIgaSBpbiByKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGkpJiYodFtpXT1yW2ldKX1yZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgbWU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe3RoaXMuZmV0Y2hTZXR1cD12b2lkIDAsdGhpcy5yZXF1ZXN0VGltZW91dD12b2lkIDAsdGhpcy5yZXF1ZXN0PXZvaWQgMCx0aGlzLnJlc3BvbnNlPXZvaWQgMCx0aGlzLmNvbnRyb2xsZXI9dm9pZCAwLHRoaXMuY29udGV4dD12b2lkIDAsdGhpcy5jb25maWc9bnVsbCx0aGlzLmNhbGxiYWNrcz1udWxsLHRoaXMuc3RhdHM9dm9pZCAwLHRoaXMubG9hZGVyPW51bGwsdGhpcy5mZXRjaFNldHVwPXQuZmV0Y2hTZXR1cHx8eWUsdGhpcy5jb250cm9sbGVyPW5ldyBzZWxmLkFib3J0Q29udHJvbGxlcix0aGlzLnN0YXRzPW5ldyBvZS5hfXZhciBlPXQucHJvdG90eXBlO3JldHVybiBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmxvYWRlcj10aGlzLmNhbGxiYWNrcz1udWxsLHRoaXMuYWJvcnRJbnRlcm5hbCgpfSxlLmFib3J0SW50ZXJuYWw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJlc3BvbnNlO3QmJnQub2t8fCh0aGlzLnN0YXRzLmFib3J0ZWQ9ITAsdGhpcy5jb250cm9sbGVyLmFib3J0KCkpfSxlLmFib3J0PWZ1bmN0aW9uKCl7dmFyIHQ7dGhpcy5hYm9ydEludGVybmFsKCksbnVsbCE9PSh0PXRoaXMuY2FsbGJhY2tzKSYmdm9pZCAwIT09dCYmdC5vbkFib3J0JiZ0aGlzLmNhbGxiYWNrcy5vbkFib3J0KHRoaXMuc3RhdHMsdGhpcy5jb250ZXh0LHRoaXMucmVzcG9uc2UpfSxlLmxvYWQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBpPXRoaXMsbj10aGlzLnN0YXRzO2lmKG4ubG9hZGluZy5zdGFydCl0aHJvdyBuZXcgRXJyb3IoXCJMb2FkZXIgY2FuIG9ubHkgYmUgdXNlZCBvbmNlLlwiKTtuLmxvYWRpbmcuc3RhcnQ9c2VsZi5wZXJmb3JtYW5jZS5ub3coKTt2YXIgcz1mdW5jdGlvbih0LGUpe3ZhciByPXttZXRob2Q6XCJHRVRcIixtb2RlOlwiY29yc1wiLGNyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIixzaWduYWw6ZSxoZWFkZXJzOm5ldyBzZWxmLkhlYWRlcnMocGUoe30sdC5oZWFkZXJzKSl9O3JldHVybiB0LnJhbmdlRW5kJiZyLmhlYWRlcnMuc2V0KFwiUmFuZ2VcIixcImJ5dGVzPVwiK3QucmFuZ2VTdGFydCtcIi1cIitTdHJpbmcodC5yYW5nZUVuZC0xKSkscn0odCx0aGlzLmNvbnRyb2xsZXIuc2lnbmFsKSxvPXIub25Qcm9ncmVzcyxsPVwiYXJyYXlidWZmZXJcIj09PXQucmVzcG9uc2VUeXBlLHU9bD9cImJ5dGVMZW5ndGhcIjpcImxlbmd0aFwiO3RoaXMuY29udGV4dD10LHRoaXMuY29uZmlnPWUsdGhpcy5jYWxsYmFja3M9cix0aGlzLnJlcXVlc3Q9dGhpcy5mZXRjaFNldHVwKHQscyksc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCksdGhpcy5yZXF1ZXN0VGltZW91dD1zZWxmLnNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aS5hYm9ydEludGVybmFsKCksci5vblRpbWVvdXQobix0LGkucmVzcG9uc2UpfSksZS50aW1lb3V0KSxzZWxmLmZldGNoKHRoaXMucmVxdWVzdCkudGhlbigoZnVuY3Rpb24ocil7aWYoaS5yZXNwb25zZT1pLmxvYWRlcj1yLCFyLm9rKXt2YXIgcz1yLnN0YXR1cyx1PXIuc3RhdHVzVGV4dDt0aHJvdyBuZXcgVGUodXx8XCJmZXRjaCwgYmFkIG5ldHdvcmsgcmVzcG9uc2VcIixzLHIpfXJldHVybiBuLmxvYWRpbmcuZmlyc3Q9TWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSxuLmxvYWRpbmcuc3RhcnQpLG4udG90YWw9cGFyc2VJbnQoci5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpfHxcIjBcIiksbyYmT2JqZWN0KGEuYSkoZS5oaWdoV2F0ZXJNYXJrKT9pLmxvYWRQcm9ncmVzc2l2ZWx5KHIsbix0LGUuaGlnaFdhdGVyTWFyayxvKTpsP3IuYXJyYXlCdWZmZXIoKTpyLnRleHQoKX0pKS50aGVuKChmdW5jdGlvbihzKXt2YXIgbD1pLnJlc3BvbnNlO3NlbGYuY2xlYXJUaW1lb3V0KGkucmVxdWVzdFRpbWVvdXQpLG4ubG9hZGluZy5lbmQ9TWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSxuLmxvYWRpbmcuZmlyc3QpLG4ubG9hZGVkPW4udG90YWw9c1t1XTt2YXIgZD17dXJsOmwudXJsLGRhdGE6c307byYmIU9iamVjdChhLmEpKGUuaGlnaFdhdGVyTWFyaykmJm8obix0LHMsbCksci5vblN1Y2Nlc3MoZCxuLHQsbCl9KSkuY2F0Y2goKGZ1bmN0aW9uKGUpe2lmKHNlbGYuY2xlYXJUaW1lb3V0KGkucmVxdWVzdFRpbWVvdXQpLCFuLmFib3J0ZWQpe3ZhciBhPWUuY29kZXx8MDtyLm9uRXJyb3Ioe2NvZGU6YSx0ZXh0OmUubWVzc2FnZX0sdCxlLmRldGFpbHMpfX0pKX0sZS5nZXRDYWNoZUFnZT1mdW5jdGlvbigpe3ZhciB0PW51bGw7aWYodGhpcy5yZXNwb25zZSl7dmFyIGU9dGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChcImFnZVwiKTt0PWU/cGFyc2VGbG9hdChlKTpudWxsfXJldHVybiB0fSxlLmxvYWRQcm9ncmVzc2l2ZWx5PWZ1bmN0aW9uKHQsZSxyLGksYSl7dm9pZCAwPT09aSYmKGk9MCk7dmFyIG49bmV3IGRlLmEscz10LmJvZHkuZ2V0UmVhZGVyKCk7cmV0dXJuIGZ1bmN0aW9uIG8oKXtyZXR1cm4gcy5yZWFkKCkudGhlbigoZnVuY3Rpb24ocyl7aWYocy5kb25lKXJldHVybiBuLmRhdGFMZW5ndGgmJmEoZSxyLG4uZmx1c2goKSx0KSxQcm9taXNlLnJlc29sdmUobmV3IEFycmF5QnVmZmVyKDApKTt2YXIgbD1zLnZhbHVlLHU9bC5sZW5ndGg7cmV0dXJuIGUubG9hZGVkKz11LHU8aXx8bi5kYXRhTGVuZ3RoPyhuLnB1c2gobCksbi5kYXRhTGVuZ3RoPj1pJiZhKGUscixuLmZsdXNoKCksdCkpOmEoZSxyLGwsdCksbygpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlamVjdCgpfSkpfSgpfSx0fSgpO2Z1bmN0aW9uIHllKHQsZSl7cmV0dXJuIG5ldyBzZWxmLlJlcXVlc3QodC51cmwsZSl9dmFyIGJlLFRlPWZ1bmN0aW9uKHQpe3ZhciBlLHI7ZnVuY3Rpb24gaShlLHIsaSl7dmFyIGE7cmV0dXJuKGE9dC5jYWxsKHRoaXMsZSl8fHRoaXMpLmNvZGU9dm9pZCAwLGEuZGV0YWlscz12b2lkIDAsYS5jb2RlPXIsYS5kZXRhaWxzPWksYX1yZXR1cm4gcj10LChlPWkpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHIucHJvdG90eXBlKSxlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lLHZlKGUsciksaX0oaGUoRXJyb3IpKSxFZT1tZTshZnVuY3Rpb24odCl7dC5XSURFVklORT1cImNvbS53aWRldmluZS5hbHBoYVwiLHQuUExBWVJFQURZPVwiY29tLm1pY3Jvc29mdC5wbGF5cmVhZHlcIn0oYmV8fChiZT17fSkpO3ZhciBTZT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmc2VsZi5uYXZpZ2F0b3ImJnNlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcz9zZWxmLm5hdmlnYXRvci5yZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3MuYmluZChzZWxmLm5hdmlnYXRvcik6bnVsbDtmdW5jdGlvbiBMZSgpe3JldHVybihMZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcj1hcmd1bWVudHNbZV07Zm9yKHZhciBpIGluIHIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsaSkmJih0W2ldPXJbaV0pfXJldHVybiB0fSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIEFlKHQsZSl7dmFyIHI9T2JqZWN0LmtleXModCk7aWYoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyl7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0KTtlJiYoaT1pLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxlKS5lbnVtZXJhYmxlfSkpKSxyLnB1c2guYXBwbHkocixpKX1yZXR1cm4gcn1mdW5jdGlvbiBSZSh0KXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgcj1udWxsIT1hcmd1bWVudHNbZV0/YXJndW1lbnRzW2VdOnt9O2UlMj9BZShPYmplY3QociksITApLmZvckVhY2goKGZ1bmN0aW9uKGUpe0RlKHQsZSxyW2VdKX0pKTpPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycz9PYmplY3QuZGVmaW5lUHJvcGVydGllcyh0LE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHIpKTpBZShPYmplY3QocikpLmZvckVhY2goKGZ1bmN0aW9uKGUpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGUpKX0pKX1yZXR1cm4gdH1mdW5jdGlvbiBEZSh0LGUscil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1yLHR9dmFyIF9lPVJlKFJlKHthdXRvU3RhcnRMb2FkOiEwLHN0YXJ0UG9zaXRpb246LTEsZGVmYXVsdEF1ZGlvQ29kZWM6dm9pZCAwLGRlYnVnOiExLGNhcExldmVsT25GUFNEcm9wOiExLGNhcExldmVsVG9QbGF5ZXJTaXplOiExLGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOjEsbWF4QnVmZmVyTGVuZ3RoOjMwLGJhY2tCdWZmZXJMZW5ndGg6MS8wLG1heEJ1ZmZlclNpemU6NmU3LG1heEJ1ZmZlckhvbGU6LjEsaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kOjIsbnVkZ2VPZmZzZXQ6LjEsbnVkZ2VNYXhSZXRyeTozLG1heEZyYWdMb29rVXBUb2xlcmFuY2U6LjI1LGxpdmVTeW5jRHVyYXRpb25Db3VudDozLGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudDoxLzAsbGl2ZVN5bmNEdXJhdGlvbjp2b2lkIDAsbGl2ZU1heExhdGVuY3lEdXJhdGlvbjp2b2lkIDAsbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6MSxsaXZlRHVyYXRpb25JbmZpbml0eTohMSxsaXZlQmFja0J1ZmZlckxlbmd0aDpudWxsLG1heE1heEJ1ZmZlckxlbmd0aDo2MDAsZW5hYmxlV29ya2VyOiEwLGVuYWJsZVNvZnR3YXJlQUVTOiEwLG1hbmlmZXN0TG9hZGluZ1RpbWVPdXQ6MWU0LG1hbmlmZXN0TG9hZGluZ01heFJldHJ5OjEsbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheToxZTMsbWFuaWZlc3RMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OjY0ZTMsc3RhcnRMZXZlbDp2b2lkIDAsbGV2ZWxMb2FkaW5nVGltZU91dDoxZTQsbGV2ZWxMb2FkaW5nTWF4UmV0cnk6NCxsZXZlbExvYWRpbmdSZXRyeURlbGF5OjFlMyxsZXZlbExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6NjRlMyxmcmFnTG9hZGluZ1RpbWVPdXQ6MmU0LGZyYWdMb2FkaW5nTWF4UmV0cnk6NixmcmFnTG9hZGluZ1JldHJ5RGVsYXk6MWUzLGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OjY0ZTMsc3RhcnRGcmFnUHJlZmV0Y2g6ITEsZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6NWUzLGZwc0Ryb3BwZWRNb25pdG9yaW5nVGhyZXNob2xkOi4yLGFwcGVuZEVycm9yTWF4UmV0cnk6Myxsb2FkZXI6dWUsZkxvYWRlcjp2b2lkIDAscExvYWRlcjp2b2lkIDAseGhyU2V0dXA6dm9pZCAwLGxpY2Vuc2VYaHJTZXR1cDp2b2lkIDAsbGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s6dm9pZCAwLGFickNvbnRyb2xsZXI6JHQsYnVmZmVyQ29udHJvbGxlcjppZSxjYXBMZXZlbENvbnRyb2xsZXI6bmUsZnBzQ29udHJvbGxlcjpzZSxzdHJldGNoU2hvcnRWaWRlb1RyYWNrOiExLG1heEF1ZGlvRnJhbWVzRHJpZnQ6MSxmb3JjZUtleUZyYW1lT25EaXNjb250aW51aXR5OiEwLGFickV3bWFGYXN0TGl2ZTozLGFickV3bWFTbG93TGl2ZTo5LGFickV3bWFGYXN0Vm9EOjMsYWJyRXdtYVNsb3dWb0Q6OSxhYnJFd21hRGVmYXVsdEVzdGltYXRlOjVlNSxhYnJCYW5kV2lkdGhGYWN0b3I6Ljk1LGFickJhbmRXaWR0aFVwRmFjdG9yOi43LGFick1heFdpdGhSZWFsQml0cmF0ZTohMSxtYXhTdGFydmF0aW9uRGVsYXk6NCxtYXhMb2FkaW5nRGVsYXk6NCxtaW5BdXRvQml0cmF0ZTowLGVtZUVuYWJsZWQ6ITEsd2lkZXZpbmVMaWNlbnNlVXJsOnZvaWQgMCxkcm1TeXN0ZW1PcHRpb25zOnt9LHJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmM6U2UsdGVzdEJhbmR3aWR0aDohMCxwcm9ncmVzc2l2ZTohMSxsb3dMYXRlbmN5TW9kZTohMCxjbWNkOnZvaWQgMH0se2N1ZUhhbmRsZXI6SnQuYSxlbmFibGVDRUE3MDhDYXB0aW9uczohMSxlbmFibGVXZWJWVFQ6ITEsZW5hYmxlSU1TQzE6ITEsY2FwdGlvbnNUZXh0VHJhY2sxTGFiZWw6XCJFbmdsaXNoXCIsY2FwdGlvbnNUZXh0VHJhY2sxTGFuZ3VhZ2VDb2RlOlwiZW5cIixjYXB0aW9uc1RleHRUcmFjazJMYWJlbDpcIlNwYW5pc2hcIixjYXB0aW9uc1RleHRUcmFjazJMYW5ndWFnZUNvZGU6XCJlc1wiLGNhcHRpb25zVGV4dFRyYWNrM0xhYmVsOlwiVW5rbm93biBDQ1wiLGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTpcIlwiLGNhcHRpb25zVGV4dFRyYWNrNExhYmVsOlwiVW5rbm93biBDQ1wiLGNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZTpcIlwiLHJlbmRlclRleHRUcmFja3NOYXRpdmVseTohMH0pLHt9LHtzdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI6dm9pZCAwLHN1YnRpdGxlVHJhY2tDb250cm9sbGVyOnZvaWQgMCx0aW1lbGluZUNvbnRyb2xsZXI6dm9pZCAwLGF1ZGlvU3RyZWFtQ29udHJvbGxlcjp2b2lkIDAsYXVkaW9UcmFja0NvbnRyb2xsZXI6dm9pZCAwLGVtZUNvbnRyb2xsZXI6dm9pZCAwLGNtY2RDb250cm9sbGVyOnZvaWQgMH0pO2Z1bmN0aW9uIGtlKHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBpPWVbcl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX12YXIgeGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3ZvaWQgMD09PWUmJihlPXt9KSx0aGlzLmNvbmZpZz12b2lkIDAsdGhpcy51c2VyQ29uZmlnPXZvaWQgMCx0aGlzLmNvcmVDb21wb25lbnRzPXZvaWQgMCx0aGlzLm5ldHdvcmtDb250cm9sbGVycz12b2lkIDAsdGhpcy5fZW1pdHRlcj1uZXcganQuRXZlbnRFbWl0dGVyLHRoaXMuX2F1dG9MZXZlbENhcHBpbmc9dm9pZCAwLHRoaXMuYWJyQ29udHJvbGxlcj12b2lkIDAsdGhpcy5idWZmZXJDb250cm9sbGVyPXZvaWQgMCx0aGlzLmNhcExldmVsQ29udHJvbGxlcj12b2lkIDAsdGhpcy5sYXRlbmN5Q29udHJvbGxlcj12b2lkIDAsdGhpcy5sZXZlbENvbnRyb2xsZXI9dm9pZCAwLHRoaXMuc3RyZWFtQ29udHJvbGxlcj12b2lkIDAsdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcj12b2lkIDAsdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcj12b2lkIDAsdGhpcy5lbWVDb250cm9sbGVyPXZvaWQgMCx0aGlzLmNtY2RDb250cm9sbGVyPXZvaWQgMCx0aGlzLl9tZWRpYT1udWxsLHRoaXMudXJsPW51bGw7dmFyIHI9dGhpcy5jb25maWc9ZnVuY3Rpb24odCxlKXtpZigoZS5saXZlU3luY0R1cmF0aW9uQ291bnR8fGUubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50KSYmKGUubGl2ZVN5bmNEdXJhdGlvbnx8ZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uKSl0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGhscy5qcyBjb25maWc6IGRvbid0IG1peCB1cCBsaXZlU3luY0R1cmF0aW9uQ291bnQvbGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50IGFuZCBsaXZlU3luY0R1cmF0aW9uL2xpdmVNYXhMYXRlbmN5RHVyYXRpb25cIik7aWYodm9pZCAwIT09ZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQmJih2b2lkIDA9PT1lLmxpdmVTeW5jRHVyYXRpb25Db3VudHx8ZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ8PWUubGl2ZVN5bmNEdXJhdGlvbkNvdW50KSl0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnRcIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcImxpdmVTeW5jRHVyYXRpb25Db3VudFwiJyk7aWYodm9pZCAwIT09ZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uJiYodm9pZCAwPT09ZS5saXZlU3luY0R1cmF0aW9ufHxlLmxpdmVNYXhMYXRlbmN5RHVyYXRpb248PWUubGl2ZVN5bmNEdXJhdGlvbikpdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGhscy5qcyBjb25maWc6IFwibGl2ZU1heExhdGVuY3lEdXJhdGlvblwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvblwiJyk7cmV0dXJuIExlKHt9LHQsZSl9KHQuRGVmYXVsdENvbmZpZyxlKTt0aGlzLnVzZXJDb25maWc9ZSxPYmplY3Qoby5hKShyLmRlYnVnKSx0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nPS0xLHIucHJvZ3Jlc3NpdmUmJmZ1bmN0aW9uKHQpe3ZhciBlPXQubG9hZGVyO2UhPT1FZSYmZSE9PXVlPyhvLmIubG9nKFwiW2NvbmZpZ106IEN1c3RvbSBsb2FkZXIgZGV0ZWN0ZWQsIGNhbm5vdCBlbmFibGUgcHJvZ3Jlc3NpdmUgc3RyZWFtaW5nXCIpLHQucHJvZ3Jlc3NpdmU9ITEpOmZ1bmN0aW9uKCl7aWYoc2VsZi5mZXRjaCYmc2VsZi5BYm9ydENvbnRyb2xsZXImJnNlbGYuUmVhZGFibGVTdHJlYW0mJnNlbGYuUmVxdWVzdCl0cnl7cmV0dXJuIG5ldyBzZWxmLlJlYWRhYmxlU3RyZWFtKHt9KSwhMH1jYXRjaCh0KXt9cmV0dXJuITF9KCkmJih0LmxvYWRlcj1FZSx0LnByb2dyZXNzaXZlPSEwLHQuZW5hYmxlU29mdHdhcmVBRVM9ITAsby5iLmxvZyhcIltjb25maWddOiBQcm9ncmVzc2l2ZSBzdHJlYW1pbmcgZW5hYmxlZCwgdXNpbmcgRmV0Y2hMb2FkZXJcIikpfShyKTt2YXIgaT1yLmFickNvbnRyb2xsZXIsYT1yLmJ1ZmZlckNvbnRyb2xsZXIsbj1yLmNhcExldmVsQ29udHJvbGxlcixzPXIuZnBzQ29udHJvbGxlcixsPXRoaXMuYWJyQ29udHJvbGxlcj1uZXcgaSh0aGlzKSx1PXRoaXMuYnVmZmVyQ29udHJvbGxlcj1uZXcgYSh0aGlzKSxkPXRoaXMuY2FwTGV2ZWxDb250cm9sbGVyPW5ldyBuKHRoaXMpLGg9bmV3IHModGhpcyksZj1uZXcgeCh0aGlzKSxjPW5ldyB3KHRoaXMpLHY9bmV3IEkodGhpcyksZz10aGlzLmxldmVsQ29udHJvbGxlcj1uZXcgWih0aGlzKSxwPW5ldyBKKHRoaXMpLG09dGhpcy5zdHJlYW1Db250cm9sbGVyPW5ldyBYdCh0aGlzLHApO2Quc2V0U3RyZWFtQ29udHJvbGxlcihtKSxoLnNldFN0cmVhbUNvbnRyb2xsZXIobSk7dmFyIHk9W2csbV07dGhpcy5uZXR3b3JrQ29udHJvbGxlcnM9eTt2YXIgYj1bZixjLGwsdSxkLGgsdixwXTt0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyPXRoaXMuY3JlYXRlQ29udHJvbGxlcihyLmF1ZGlvVHJhY2tDb250cm9sbGVyLG51bGwseSksdGhpcy5jcmVhdGVDb250cm9sbGVyKHIuYXVkaW9TdHJlYW1Db250cm9sbGVyLHAseSksdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcj10aGlzLmNyZWF0ZUNvbnRyb2xsZXIoci5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcixudWxsLHkpLHRoaXMuY3JlYXRlQ29udHJvbGxlcihyLnN1YnRpdGxlU3RyZWFtQ29udHJvbGxlcixwLHkpLHRoaXMuY3JlYXRlQ29udHJvbGxlcihyLnRpbWVsaW5lQ29udHJvbGxlcixudWxsLGIpLHRoaXMuZW1lQ29udHJvbGxlcj10aGlzLmNyZWF0ZUNvbnRyb2xsZXIoci5lbWVDb250cm9sbGVyLG51bGwsYiksdGhpcy5jbWNkQ29udHJvbGxlcj10aGlzLmNyZWF0ZUNvbnRyb2xsZXIoci5jbWNkQ29udHJvbGxlcixudWxsLGIpLHRoaXMubGF0ZW5jeUNvbnRyb2xsZXI9dGhpcy5jcmVhdGVDb250cm9sbGVyKE0sbnVsbCxiKSx0aGlzLmNvcmVDb21wb25lbnRzPWJ9dC5pc1N1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PU50KCk7aWYoIXQpcmV0dXJuITE7dmFyIGU9QnQoKSxyPXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuaXNUeXBlU3VwcG9ydGVkJiZ0LmlzVHlwZVN1cHBvcnRlZCgndmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyRTAxRSxtcDRhLjQwLjJcIicpLGk9IWV8fGUucHJvdG90eXBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnByb3RvdHlwZS5hcHBlbmRCdWZmZXImJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUucHJvdG90eXBlLnJlbW92ZTtyZXR1cm4hIXImJiEhaX0oKX07dmFyIGUscixhLGw9dC5wcm90b3R5cGU7cmV0dXJuIGwuY3JlYXRlQ29udHJvbGxlcj1mdW5jdGlvbih0LGUscil7aWYodCl7dmFyIGk9ZT9uZXcgdCh0aGlzLGUpOm5ldyB0KHRoaXMpO3JldHVybiByJiZyLnB1c2goaSksaX1yZXR1cm4gbnVsbH0sbC5vbj1mdW5jdGlvbih0LGUscil7dm9pZCAwPT09ciYmKHI9dGhpcyksdGhpcy5fZW1pdHRlci5vbih0LGUscil9LGwub25jZT1mdW5jdGlvbih0LGUscil7dm9pZCAwPT09ciYmKHI9dGhpcyksdGhpcy5fZW1pdHRlci5vbmNlKHQsZSxyKX0sbC5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24odCl7dGhpcy5fZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnModCl9LGwub2ZmPWZ1bmN0aW9uKHQsZSxyLGkpe3ZvaWQgMD09PXImJihyPXRoaXMpLHRoaXMuX2VtaXR0ZXIub2ZmKHQsZSxyLGkpfSxsLmxpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lcnModCl9LGwuZW1pdD1mdW5jdGlvbih0LGUscil7cmV0dXJuIHRoaXMuX2VtaXR0ZXIuZW1pdCh0LGUscil9LGwudHJpZ2dlcj1mdW5jdGlvbih0LGUpe2lmKHRoaXMuY29uZmlnLmRlYnVnKXJldHVybiB0aGlzLmVtaXQodCx0LGUpO3RyeXtyZXR1cm4gdGhpcy5lbWl0KHQsdCxlKX1jYXRjaChlKXtvLmIuZXJyb3IoXCJBbiBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBoYW5kbGluZyBldmVudCBcIit0KycuIEVycm9yIG1lc3NhZ2U6IFwiJytlLm1lc3NhZ2UrJ1wiLiBIZXJlIGlzIGEgc3RhY2t0cmFjZTonLGUpLHRoaXMudHJpZ2dlcihuLmEuRVJST1Ise3R5cGU6cy5iLk9USEVSX0VSUk9SLGRldGFpbHM6cy5hLklOVEVSTkFMX0VYQ0VQVElPTixmYXRhbDohMSxldmVudDp0LGVycm9yOmV9KX1yZXR1cm4hMX0sbC5saXN0ZW5lckNvdW50PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9lbWl0dGVyLmxpc3RlbmVyQ291bnQodCl9LGwuZGVzdHJveT1mdW5jdGlvbigpe28uYi5sb2coXCJkZXN0cm95XCIpLHRoaXMudHJpZ2dlcihuLmEuREVTVFJPWUlORyx2b2lkIDApLHRoaXMuZGV0YWNoTWVkaWEoKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpLHRoaXMuX2F1dG9MZXZlbENhcHBpbmc9LTEsdGhpcy51cmw9bnVsbCx0aGlzLm5ldHdvcmtDb250cm9sbGVycy5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXN0cm95KCl9KSksdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoPTAsdGhpcy5jb3JlQ29tcG9uZW50cy5mb3JFYWNoKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kZXN0cm95KCl9KSksdGhpcy5jb3JlQ29tcG9uZW50cy5sZW5ndGg9MH0sbC5hdHRhY2hNZWRpYT1mdW5jdGlvbih0KXtvLmIubG9nKFwiYXR0YWNoTWVkaWFcIiksdGhpcy5fbWVkaWE9dCx0aGlzLnRyaWdnZXIobi5hLk1FRElBX0FUVEFDSElORyx7bWVkaWE6dH0pfSxsLmRldGFjaE1lZGlhPWZ1bmN0aW9uKCl7by5iLmxvZyhcImRldGFjaE1lZGlhXCIpLHRoaXMudHJpZ2dlcihuLmEuTUVESUFfREVUQUNISU5HLHZvaWQgMCksdGhpcy5fbWVkaWE9bnVsbH0sbC5sb2FkU291cmNlPWZ1bmN0aW9uKHQpe3RoaXMuc3RvcExvYWQoKTt2YXIgZT10aGlzLm1lZGlhLHI9dGhpcy51cmwsYT10aGlzLnVybD1pLmJ1aWxkQWJzb2x1dGVVUkwoc2VsZi5sb2NhdGlvbi5ocmVmLHQse2Fsd2F5c05vcm1hbGl6ZTohMH0pO28uYi5sb2coXCJsb2FkU291cmNlOlwiK2EpLGUmJnImJnIhPT1hJiZ0aGlzLmJ1ZmZlckNvbnRyb2xsZXIuaGFzU291cmNlVHlwZXMoKSYmKHRoaXMuZGV0YWNoTWVkaWEoKSx0aGlzLmF0dGFjaE1lZGlhKGUpKSx0aGlzLnRyaWdnZXIobi5hLk1BTklGRVNUX0xPQURJTkcse3VybDp0fSl9LGwuc3RhcnRMb2FkPWZ1bmN0aW9uKHQpe3ZvaWQgMD09PXQmJih0PS0xKSxvLmIubG9nKFwic3RhcnRMb2FkKFwiK3QrXCIpXCIpLHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goKGZ1bmN0aW9uKGUpe2Uuc3RhcnRMb2FkKHQpfSkpfSxsLnN0b3BMb2FkPWZ1bmN0aW9uKCl7by5iLmxvZyhcInN0b3BMb2FkXCIpLHRoaXMubmV0d29ya0NvbnRyb2xsZXJzLmZvckVhY2goKGZ1bmN0aW9uKHQpe3Quc3RvcExvYWQoKX0pKX0sbC5zd2FwQXVkaW9Db2RlYz1mdW5jdGlvbigpe28uYi5sb2coXCJzd2FwQXVkaW9Db2RlY1wiKSx0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKX0sbC5yZWNvdmVyTWVkaWFFcnJvcj1mdW5jdGlvbigpe28uYi5sb2coXCJyZWNvdmVyTWVkaWFFcnJvclwiKTt2YXIgdD10aGlzLl9tZWRpYTt0aGlzLmRldGFjaE1lZGlhKCksdCYmdGhpcy5hdHRhY2hNZWRpYSh0KX0sbC5yZW1vdmVMZXZlbD1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPTApLHRoaXMubGV2ZWxDb250cm9sbGVyLnJlbW92ZUxldmVsKHQsZSl9LGU9dCxhPVt7a2V5OlwidmVyc2lvblwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiMS4xLjVcIn19LHtrZXk6XCJFdmVudHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5hfX0se2tleTpcIkVycm9yVHlwZXNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5ifX0se2tleTpcIkVycm9yRGV0YWlsc1wiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLmF9fSx7a2V5OlwiRGVmYXVsdENvbmZpZ1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHRDb25maWc/dC5kZWZhdWx0Q29uZmlnOl9lfSxzZXQ6ZnVuY3Rpb24oZSl7dC5kZWZhdWx0Q29uZmlnPWV9fV0sKHI9W3trZXk6XCJsZXZlbHNcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzfHxbXX19LHtrZXk6XCJjdXJyZW50TGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbH0sc2V0OmZ1bmN0aW9uKHQpe28uYi5sb2coXCJzZXQgY3VycmVudExldmVsOlwiK3QpLHRoaXMubG9hZExldmVsPXQsdGhpcy5hYnJDb250cm9sbGVyLmNsZWFyVGltZXIoKSx0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW1tZWRpYXRlTGV2ZWxTd2l0Y2goKX19LHtrZXk6XCJuZXh0TGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbH0sc2V0OmZ1bmN0aW9uKHQpe28uYi5sb2coXCJzZXQgbmV4dExldmVsOlwiK3QpLHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsPXQsdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpfX0se2tleTpcImxvYWRMZXZlbFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5sZXZlbH0sc2V0OmZ1bmN0aW9uKHQpe28uYi5sb2coXCJzZXQgbG9hZExldmVsOlwiK3QpLHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsPXR9fSx7a2V5OlwibmV4dExvYWRMZXZlbFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxldmVsQ29udHJvbGxlci5uZXh0TG9hZExldmVsfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5sZXZlbENvbnRyb2xsZXIubmV4dExvYWRMZXZlbD10fX0se2tleTpcImZpcnN0TGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCx0aGlzLm1pbkF1dG9MZXZlbCl9LHNldDpmdW5jdGlvbih0KXtvLmIubG9nKFwic2V0IGZpcnN0TGV2ZWw6XCIrdCksdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbD10fX0se2tleTpcInN0YXJ0TGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbH0sc2V0OmZ1bmN0aW9uKHQpe28uYi5sb2coXCJzZXQgc3RhcnRMZXZlbDpcIit0KSwtMSE9PXQmJih0PU1hdGgubWF4KHQsdGhpcy5taW5BdXRvTGV2ZWwpKSx0aGlzLmxldmVsQ29udHJvbGxlci5zdGFydExldmVsPXR9fSx7a2V5OlwiY2FwTGV2ZWxUb1BsYXllclNpemVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemV9LHNldDpmdW5jdGlvbih0KXt2YXIgZT0hIXQ7ZSE9PXRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplJiYoZT90aGlzLmNhcExldmVsQ29udHJvbGxlci5zdGFydENhcHBpbmcoKToodGhpcy5jYXBMZXZlbENvbnRyb2xsZXIuc3RvcENhcHBpbmcoKSx0aGlzLmF1dG9MZXZlbENhcHBpbmc9LTEsdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpKSx0aGlzLmNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZT1lKX19LHtrZXk6XCJhdXRvTGV2ZWxDYXBwaW5nXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmd9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nIT09dCYmKG8uYi5sb2coXCJzZXQgYXV0b0xldmVsQ2FwcGluZzpcIit0KSx0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nPXQpfX0se2tleTpcImJhbmR3aWR0aEVzdGltYXRlXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5hYnJDb250cm9sbGVyLmJ3RXN0aW1hdG9yO3JldHVybiB0P3QuZ2V0RXN0aW1hdGUoKTpOYU59fSx7a2V5OlwiYXV0b0xldmVsRW5hYmxlZFwiLGdldDpmdW5jdGlvbigpe3JldHVybi0xPT09dGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWx9fSx7a2V5OlwibWFudWFsTGV2ZWxcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWx9fSx7a2V5OlwibWluQXV0b0xldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZXZlbHMsZT10aGlzLmNvbmZpZy5taW5BdXRvQml0cmF0ZTtpZighdClyZXR1cm4gMDtmb3IodmFyIHI9dC5sZW5ndGgsaT0wO2k8cjtpKyspaWYodFtpXS5tYXhCaXRyYXRlPmUpcmV0dXJuIGk7cmV0dXJuIDB9fSx7a2V5OlwibWF4QXV0b0xldmVsXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sZXZlbHMsZT10aGlzLmF1dG9MZXZlbENhcHBpbmc7cmV0dXJuLTE9PT1lJiZ0JiZ0Lmxlbmd0aD90Lmxlbmd0aC0xOmV9fSx7a2V5OlwibmV4dEF1dG9MZXZlbFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1pbihNYXRoLm1heCh0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbCx0aGlzLm1pbkF1dG9MZXZlbCksdGhpcy5tYXhBdXRvTGV2ZWwpfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5hYnJDb250cm9sbGVyLm5leHRBdXRvTGV2ZWw9TWF0aC5tYXgodGhpcy5taW5BdXRvTGV2ZWwsdCl9fSx7a2V5OlwiYXVkaW9UcmFja3NcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO3JldHVybiB0P3QuYXVkaW9UcmFja3M6W119fSx7a2V5OlwiYXVkaW9UcmFja1wiLGdldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXI7cmV0dXJuIHQ/dC5hdWRpb1RyYWNrOi0xfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtlJiYoZS5hdWRpb1RyYWNrPXQpfX0se2tleTpcInN1YnRpdGxlVHJhY2tzXCIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlcjtyZXR1cm4gdD90LnN1YnRpdGxlVHJhY2tzOltdfX0se2tleTpcInN1YnRpdGxlVHJhY2tcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO3JldHVybiB0P3Quc3VidGl0bGVUcmFjazotMX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7ZSYmKGUuc3VidGl0bGVUcmFjaz10KX19LHtrZXk6XCJtZWRpYVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tZWRpYX19LHtrZXk6XCJzdWJ0aXRsZURpc3BsYXlcIixnZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO3JldHVybiEhdCYmdC5zdWJ0aXRsZURpc3BsYXl9LHNldDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO2UmJihlLnN1YnRpdGxlRGlzcGxheT10KX19LHtrZXk6XCJsb3dMYXRlbmN5TW9kZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlPXR9fSx7a2V5OlwibGl2ZVN5bmNQb3NpdGlvblwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxpdmVTeW5jUG9zaXRpb259fSx7a2V5OlwibGF0ZW5jeVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLmxhdGVuY3l9fSx7a2V5OlwibWF4TGF0ZW5jeVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLm1heExhdGVuY3l9fSx7a2V5OlwidGFyZ2V0TGF0ZW5jeVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3l9fSx7a2V5OlwiZHJpZnRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5kcmlmdH19LHtrZXk6XCJmb3JjZVN0YXJ0TG9hZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZm9yY2VTdGFydExvYWR9fV0pJiZrZShlLnByb3RvdHlwZSxyKSxhJiZrZShlLGEpLHR9KCk7eGUuZGVmYXVsdENvbmZpZz12b2lkIDB9XSkuZGVmYXVsdCl9fSxlPXt9O2Z1bmN0aW9uIHIoaSl7dmFyIGE9ZVtpXTtpZih2b2lkIDAhPT1hKXJldHVybiBhLmV4cG9ydHM7dmFyIG49ZVtpXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbaV0uY2FsbChuLmV4cG9ydHMsbixuLmV4cG9ydHMsciksbi5leHBvcnRzfXIubj10PT57dmFyIGU9dCYmdC5fX2VzTW9kdWxlPygpPT50LmRlZmF1bHQ6KCk9PnQ7cmV0dXJuIHIuZChlLHthOmV9KSxlfSxyLmQ9KHQsZSk9Pntmb3IodmFyIGkgaW4gZSlyLm8oZSxpKSYmIXIubyh0LGkpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxpLHtlbnVtZXJhYmxlOiEwLGdldDplW2ldfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSk7dmFyIGk9e307cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ci5kKGkse2RlZmF1bHQ6KCk9PmF9KTt2YXIgdD1yKDE4MiksZT1yLm4odCk7Y2xhc3MgYSBleHRlbmRzIEF1ZGlve2NvbnN0cnVjdG9yKCl7c3VwZXIoKTtjb25zdCB0PVwicnBsYXllci12b2x1bWVcIjt0aGlzLmhscz1udWxsLGxvY2FsU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eSh0KT90aGlzLnZvbHVtZT1sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0KTp0aGlzLnZvbHVtZT0uMix0aGlzLm9udm9sdW1lY2hhbmdlPSgpPT57bG9jYWxTdG9yYWdlLnNldEl0ZW0odCx0aGlzLnZvbHVtZSl9fXJld2luZCh0KXt0aGlzLmN1cnJlbnRUaW1lPXRoaXMuY3VycmVudFRpbWUtdH1wbGF5U3JjKHQpe2NvbnN0IHI9dC5pbmRleE9mKFwiLm0zdThcIik+MDt0aGlzLnN0b3AoKSxlKCkuaXNTdXBwb3J0ZWQoKSYmcj8odGhpcy5obHM9bmV3KGUoKSksdGhpcy5obHMubG9hZFNvdXJjZSh0KSx0aGlzLmhscy5hdHRhY2hNZWRpYSh0aGlzKSx0aGlzLmhscy5vbihlKCkuRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwoKCk9Pnt0aGlzLnBsYXkoKX0pKSk6KHRoaXMuY2FuUGxheVR5cGUoXCJhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3VybFwiKXx8ZSgpLmlzU3VwcG9ydGVkKCkmJiFyKSYmKHRoaXMuc3JjPXQsdGhpcy5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwoKCk9Pnt0aGlzLnBsYXkoKX0pKSl9bXV0ZSgpe3RoaXMubXV0ZWQ9IXRoaXMubXV0ZWR9c3RvcCgpe3RoaXMucGF1c2UoKSx0aGlzLmN1cnJlbnRUaW1lPTAsdGhpcy5obHMmJih0aGlzLmhscy5kZXN0cm95KCksdGhpcy5obHM9bnVsbCl9dXBWb2x1bWUoKXt0aGlzLiN0KHRoaXMudm9sdW1lKy4xKX1kb3duVm9sdW1lKCl7dGhpcy4jdCh0aGlzLnZvbHVtZS0uMSl9I3QodCl7dD49MCYmdDw9MSYmKHRoaXMudm9sdW1lPU51bWJlcih0KS50b0ZpeGVkKDEpKX1nZXQgaXNIbHMoKXtyZXR1cm4gdGhpcy5obHMgaW5zdGFuY2VvZiBlKCl9Z2V0IHVybCgpe3JldHVybiB0aGlzLmlzSGxzP3RoaXMuaGxzLnVybDp0aGlzLnNyY31nZXQgcGxheWluZygpe3JldHVybiB0aGlzLmN1cnJlbnRUaW1lPjAmJiF0aGlzLnBhdXNlZCYmIXRoaXMuZW5kZWQmJnRoaXMucmVhZHlTdGF0ZT4yfX19KSgpLGkuZGVmYXVsdH0pKCkpKTsiLCIvKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKiBJTVBPUlRBTlQ6IGFsbCBjYWxscyBvZiB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgcHJlZml4ZWQgd2l0aFxyXG4gKiBcXC9cXCojXFxfXFxfUFVSRVxcX1xcX1xcKlxcL1xyXG4gKiBTbyB0aGF0IHJvbGx1cCBjYW4gdHJlZS1zaGFrZSB0aGVtIGlmIG5lY2Vzc2FyeS5cclxuICovXHJcbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XHJcbiAgICBjb25zdCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgY29uc3QgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+ICEhbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXSA6IHZhbCA9PiAhIW1hcFt2YWxdO1xyXG59XG5cbmNvbnN0IEdMT0JBTFNfV0hJVEVfTElTVEVEID0gJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksJyArXHJcbiAgICAnZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSwnICtcclxuICAgICdPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCc7XHJcbmNvbnN0IGlzR2xvYmFsbHlXaGl0ZWxpc3RlZCA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChHTE9CQUxTX1dISVRFX0xJU1RFRCk7XG5cbi8qKlxyXG4gKiBPbiB0aGUgY2xpZW50IHdlIG9ubHkgbmVlZCB0byBvZmZlciBzcGVjaWFsIGNhc2VzIGZvciBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdFxyXG4gKiBoYXZlIGRpZmZlcmVudCBuYW1lcyBmcm9tIHRoZWlyIGNvcnJlc3BvbmRpbmcgZG9tIHByb3BlcnRpZXM6XHJcbiAqIC0gaXRlbXNjb3BlIC0+IE4vQVxyXG4gKiAtIGFsbG93ZnVsbHNjcmVlbiAtPiBhbGxvd0Z1bGxzY3JlZW5cclxuICogLSBmb3Jtbm92YWxpZGF0ZSAtPiBmb3JtTm9WYWxpZGF0ZVxyXG4gKiAtIGlzbWFwIC0+IGlzTWFwXHJcbiAqIC0gbm9tb2R1bGUgLT4gbm9Nb2R1bGVcclxuICogLSBub3ZhbGlkYXRlIC0+IG5vVmFsaWRhdGVcclxuICogLSByZWFkb25seSAtPiByZWFkT25seVxyXG4gKi9cclxuY29uc3Qgc3BlY2lhbEJvb2xlYW5BdHRycyA9IGBpdGVtc2NvcGUsYWxsb3dmdWxsc2NyZWVuLGZvcm1ub3ZhbGlkYXRlLGlzbWFwLG5vbW9kdWxlLG5vdmFsaWRhdGUscmVhZG9ubHlgO1xyXG5jb25zdCBpc1NwZWNpYWxCb29sZWFuQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChzcGVjaWFsQm9vbGVhbkF0dHJzKTtcclxuLyoqXHJcbiAqIEJvb2xlYW4gYXR0cmlidXRlcyBzaG91bGQgYmUgaW5jbHVkZWQgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBvciAnJy5cclxuICogZS5nLiBgPHNlbGVjdCBtdWx0aXBsZT5gIGNvbXBpbGVzIHRvIGB7IG11bHRpcGxlOiAnJyB9YFxyXG4gKi9cclxuZnVuY3Rpb24gaW5jbHVkZUJvb2xlYW5BdHRyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISF2YWx1ZSB8fCB2YWx1ZSA9PT0gJyc7XHJcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUodmFsdWUpIHtcclxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gaXNTdHJpbmcoaXRlbSlcclxuICAgICAgICAgICAgICAgID8gcGFyc2VTdHJpbmdTdHlsZShpdGVtKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVTdHlsZShpdGVtKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZWRba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGxpc3REZWxpbWl0ZXJSRSA9IC87KD8hW14oXSpcXCkpL2c7XHJcbmNvbnN0IHByb3BlcnR5RGVsaW1pdGVyUkUgPSAvOiguKykvO1xyXG5mdW5jdGlvbiBwYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyUkUpLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlclJFKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJldFt0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzcyh2YWx1ZSkge1xyXG4gICAgbGV0IHJlcyA9ICcnO1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHJlcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVDbGFzcyh2YWx1ZVtpXSk7XHJcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgKz0gbm9ybWFsaXplZCArICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJlcyArPSBuYW1lICsgJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcy50cmltKCk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMocHJvcHMpIHtcclxuICAgIGlmICghcHJvcHMpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBsZXQgeyBjbGFzczoga2xhc3MsIHN0eWxlIH0gPSBwcm9wcztcclxuICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgcHJvcHMuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhrbGFzcyk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGUpIHtcclxuICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxuXG4vLyBUaGVzZSB0YWcgY29uZmlncyBhcmUgc2hhcmVkIGJldHdlZW4gY29tcGlsZXItZG9tIGFuZCBydW50aW1lLWRvbSwgc28gdGhleVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcclxuY29uc3QgSFRNTF9UQUdTID0gJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsJyArXHJcbiAgICAnaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLCcgK1xyXG4gICAgJ2ZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLCcgK1xyXG4gICAgJ2RhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydWJ5LHMsc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLCcgK1xyXG4gICAgJ3RpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLGVtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsJyArXHJcbiAgICAnY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLGNhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLCcgK1xyXG4gICAgJ3RoLHRyLGJ1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCwnICtcclxuICAgICdvcHRpb24sb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSxkZXRhaWxzLGRpYWxvZyxtZW51LCcgK1xyXG4gICAgJ3N1bW1hcnksdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnO1xyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudFxyXG5jb25zdCBTVkdfVEFHUyA9ICdzdmcsYW5pbWF0ZSxhbmltYXRlTW90aW9uLGFuaW1hdGVUcmFuc2Zvcm0sY2lyY2xlLGNsaXBQYXRoLGNvbG9yLXByb2ZpbGUsJyArXHJcbiAgICAnZGVmcyxkZXNjLGRpc2NhcmQsZWxsaXBzZSxmZUJsZW5kLGZlQ29sb3JNYXRyaXgsZmVDb21wb25lbnRUcmFuc2ZlciwnICtcclxuICAgICdmZUNvbXBvc2l0ZSxmZUNvbnZvbHZlTWF0cml4LGZlRGlmZnVzZUxpZ2h0aW5nLGZlRGlzcGxhY2VtZW50TWFwLCcgK1xyXG4gICAgJ2ZlRGlzdGFuY2VMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLCcgK1xyXG4gICAgJ2ZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsJyArXHJcbiAgICAnZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlciwnICtcclxuICAgICdmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssJyArXHJcbiAgICAnbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLCcgK1xyXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsJyArXHJcbiAgICAndGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3JztcclxuLyoqXHJcbiAqIENvbXBpbGVyIG9ubHkuXHJcbiAqIERvIE5PVCB1c2UgaW4gcnVudGltZSBjb2RlIHBhdGhzIHVubGVzcyBiZWhpbmQgYChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKWAgZmxhZy5cclxuICovXHJcbmNvbnN0IGlzSFRNTFRhZyA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcChIVE1MX1RBR1MpO1xyXG4vKipcclxuICogQ29tcGlsZXIgb25seS5cclxuICogRG8gTk9UIHVzZSBpbiBydW50aW1lIGNvZGUgcGF0aHMgdW5sZXNzIGJlaGluZCBgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpYCBmbGFnLlxyXG4gKi9cclxuY29uc3QgaXNTVkdUYWcgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoU1ZHX1RBR1MpO1xuXG5mdW5jdGlvbiBsb29zZUNvbXBhcmVBcnJheXMoYSwgYikge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBsZXQgZXF1YWwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGVxdWFsICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXF1YWwgPSBsb29zZUVxdWFsKGFbaV0sIGJbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVxdWFsO1xyXG59XHJcbmZ1bmN0aW9uIGxvb3NlRXF1YWwoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBsZXQgYVZhbGlkVHlwZSA9IGlzRGF0ZShhKTtcclxuICAgIGxldCBiVmFsaWRUeXBlID0gaXNEYXRlKGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIHJldHVybiBhVmFsaWRUeXBlICYmIGJWYWxpZFR5cGUgPyBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCkgOiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc1N5bWJvbChhKTtcclxuICAgIGJWYWxpZFR5cGUgPSBpc1N5bWJvbChiKTtcclxuICAgIGlmIChhVmFsaWRUeXBlIHx8IGJWYWxpZFR5cGUpIHtcclxuICAgICAgICByZXR1cm4gYSA9PT0gYjtcclxuICAgIH1cclxuICAgIGFWYWxpZFR5cGUgPSBpc0FycmF5KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzQXJyYXkoYik7XHJcbiAgICBpZiAoYVZhbGlkVHlwZSB8fCBiVmFsaWRUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFWYWxpZFR5cGUgJiYgYlZhbGlkVHlwZSA/IGxvb3NlQ29tcGFyZUFycmF5cyhhLCBiKSA6IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYVZhbGlkVHlwZSA9IGlzT2JqZWN0KGEpO1xyXG4gICAgYlZhbGlkVHlwZSA9IGlzT2JqZWN0KGIpO1xyXG4gICAgaWYgKGFWYWxpZFR5cGUgfHwgYlZhbGlkVHlwZSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGhpcyBpZiB3aWxsIHByb2JhYmx5IG5ldmVyIGJlIGNhbGxlZCAqL1xyXG4gICAgICAgIGlmICghYVZhbGlkVHlwZSB8fCAhYlZhbGlkVHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFLZXlzQ291bnQgPSBPYmplY3Qua2V5cyhhKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYktleXNDb3VudCA9IE9iamVjdC5rZXlzKGIpLmxlbmd0aDtcclxuICAgICAgICBpZiAoYUtleXNDb3VudCAhPT0gYktleXNDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcclxuICAgICAgICAgICAgY29uc3QgYUhhc0tleSA9IGEuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgY29uc3QgYkhhc0tleSA9IGIuaGFzT3duUHJvcGVydHkoa2V5KTtcclxuICAgICAgICAgICAgaWYgKChhSGFzS2V5ICYmICFiSGFzS2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgKCFhSGFzS2V5ICYmIGJIYXNLZXkpIHx8XHJcbiAgICAgICAgICAgICAgICAhbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcclxufVxyXG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcclxuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGl0ZW0gPT4gbG9vc2VFcXVhbChpdGVtLCB2YWwpKTtcclxufVxuXG4vKipcclxuICogRm9yIGNvbnZlcnRpbmcge3sgaW50ZXJwb2xhdGlvbiB9fSB2YWx1ZXMgdG8gZGlzcGxheWVkIHN0cmluZ3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0Rpc3BsYXlTdHJpbmcgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmcodmFsKVxyXG4gICAgICAgID8gdmFsXHJcbiAgICAgICAgOiB2YWwgPT0gbnVsbFxyXG4gICAgICAgICAgICA/ICcnXHJcbiAgICAgICAgICAgIDogaXNBcnJheSh2YWwpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh2YWwudG9TdHJpbmcgPT09IG9iamVjdFRvU3RyaW5nIHx8ICFpc0Z1bmN0aW9uKHZhbC50b1N0cmluZykpKVxyXG4gICAgICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxyXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcclxufTtcclxuY29uc3QgcmVwbGFjZXIgPSAoX2tleSwgdmFsKSA9PiB7XHJcbiAgICAvLyBjYW4ndCB1c2UgaXNSZWYgaGVyZSBzaW5jZSBAdnVlL3NoYXJlZCBoYXMgbm8gZGVwc1xyXG4gICAgaWYgKHZhbCAmJiB2YWwuX192X2lzUmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyKF9rZXksIHZhbC52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc01hcCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BNYXAoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwuZW50cmllcygpXS5yZWR1Y2UoKGVudHJpZXMsIFtrZXksIHZhbF0pID0+IHtcclxuICAgICAgICAgICAgICAgIGVudHJpZXNbYCR7a2V5fSA9PmBdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJpZXM7XHJcbiAgICAgICAgICAgIH0sIHt9KVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgW2BTZXQoJHt2YWwuc2l6ZX0pYF06IFsuLi52YWwudmFsdWVzKCldXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzQXJyYXkodmFsKSAmJiAhaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufTtcblxuY29uc3QgRU1QVFlfT0JKID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICA/IE9iamVjdC5mcmVlemUoe30pXHJcbiAgICA6IHt9O1xyXG5jb25zdCBFTVBUWV9BUlIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBPYmplY3QuZnJlZXplKFtdKSA6IFtdO1xyXG5jb25zdCBOT09QID0gKCkgPT4geyB9O1xyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbmNvbnN0IE5PID0gKCkgPT4gZmFsc2U7XHJcbmNvbnN0IG9uUkUgPSAvXm9uW15hLXpdLztcclxuY29uc3QgaXNPbiA9IChrZXkpID0+IG9uUkUudGVzdChrZXkpO1xyXG5jb25zdCBpc01vZGVsTGlzdGVuZXIgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aCgnb25VcGRhdGU6Jyk7XHJcbmNvbnN0IGV4dGVuZCA9IE9iamVjdC5hc3NpZ247XHJcbmNvbnN0IHJlbW92ZSA9IChhcnIsIGVsKSA9PiB7XHJcbiAgICBjb25zdCBpID0gYXJyLmluZGV4T2YoZWwpO1xyXG4gICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuY29uc3QgaGFzT3duID0gKHZhbCwga2V5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwga2V5KTtcclxuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbmNvbnN0IGlzTWFwID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IE1hcF0nO1xyXG5jb25zdCBpc1NldCA9ICh2YWwpID0+IHRvVHlwZVN0cmluZyh2YWwpID09PSAnW29iamVjdCBTZXRdJztcclxuY29uc3QgaXNEYXRlID0gKHZhbCkgPT4gdG9UeXBlU3RyaW5nKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcclxuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XHJcbmNvbnN0IGlzU3RyaW5nID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XHJcbmNvbnN0IGlzU3ltYm9sID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N5bWJvbCc7XHJcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xyXG5jb25zdCBpc1Byb21pc2UgPSAodmFsKSA9PiB7XHJcbiAgICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC50aGVuKSAmJiBpc0Z1bmN0aW9uKHZhbC5jYXRjaCk7XHJcbn07XHJcbmNvbnN0IG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuY29uc3QgdG9UeXBlU3RyaW5nID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcclxuY29uc3QgdG9SYXdUeXBlID0gKHZhbHVlKSA9PiB7XHJcbiAgICAvLyBleHRyYWN0IFwiUmF3VHlwZVwiIGZyb20gc3RyaW5ncyBsaWtlIFwiW29iamVjdCBSYXdUeXBlXVwiXHJcbiAgICByZXR1cm4gdG9UeXBlU3RyaW5nKHZhbHVlKS5zbGljZSg4LCAtMSk7XHJcbn07XHJcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsKSA9PiB0b1R5cGVTdHJpbmcodmFsKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbmNvbnN0IGlzSW50ZWdlcktleSA9IChrZXkpID0+IGlzU3RyaW5nKGtleSkgJiZcclxuICAgIGtleSAhPT0gJ05hTicgJiZcclxuICAgIGtleVswXSAhPT0gJy0nICYmXHJcbiAgICAnJyArIHBhcnNlSW50KGtleSwgMTApID09PSBrZXk7XHJcbmNvbnN0IGlzUmVzZXJ2ZWRQcm9wID0gLyojX19QVVJFX18qLyBtYWtlTWFwKFxyXG4vLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXHJcbicsa2V5LHJlZixyZWZfZm9yLHJlZl9rZXksJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZU1vdW50LG9uVm5vZGVNb3VudGVkLCcgK1xyXG4gICAgJ29uVm5vZGVCZWZvcmVVcGRhdGUsb25Wbm9kZVVwZGF0ZWQsJyArXHJcbiAgICAnb25Wbm9kZUJlZm9yZVVubW91bnQsb25Wbm9kZVVubW91bnRlZCcpO1xyXG5jb25zdCBpc0J1aWx0SW5EaXJlY3RpdmUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ2JpbmQsY2xvYWssZWxzZS1pZixlbHNlLGZvcixodG1sLGlmLG1vZGVsLG9uLG9uY2UscHJlLHNob3csc2xvdCx0ZXh0LG1lbW8nKTtcclxuY29uc3QgY2FjaGVTdHJpbmdGdW5jdGlvbiA9IChmbikgPT4ge1xyXG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgcmV0dXJuICgoc3RyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcclxuICAgICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSk7XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlU3RyaW5nRnVuY3Rpb24oKHN0cikgPT4ge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XHJcbn0pO1xyXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaHlwaGVuYXRlID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCkpO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNhcGl0YWxpemUgPSBjYWNoZVN0cmluZ0Z1bmN0aW9uKChzdHIpID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgdG9IYW5kbGVyS2V5ID0gY2FjaGVTdHJpbmdGdW5jdGlvbigoc3RyKSA9PiBzdHIgPyBgb24ke2NhcGl0YWxpemUoc3RyKX1gIDogYGApO1xyXG4vLyBjb21wYXJlIHdoZXRoZXIgYSB2YWx1ZSBoYXMgY2hhbmdlZCwgYWNjb3VudGluZyBmb3IgTmFOLlxyXG5jb25zdCBoYXNDaGFuZ2VkID0gKHZhbHVlLCBvbGRWYWx1ZSkgPT4gIU9iamVjdC5pcyh2YWx1ZSwgb2xkVmFsdWUpO1xyXG5jb25zdCBpbnZva2VBcnJheUZucyA9IChmbnMsIGFyZykgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBmbnNbaV0oYXJnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgZGVmID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIHZhbHVlXHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgdG9OdW1iZXIgPSAodmFsKSA9PiB7XHJcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufTtcclxubGV0IF9nbG9iYWxUaGlzO1xyXG5jb25zdCBnZXRHbG9iYWxUaGlzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChfZ2xvYmFsVGhpcyB8fFxyXG4gICAgICAgIChfZ2xvYmFsVGhpcyA9XHJcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgPyBnbG9iYWxUaGlzXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZlxyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB3aW5kb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBnbG9iYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30pKTtcclxufTtcblxuZnVuY3Rpb24gd2Fybihtc2csIC4uLmFyZ3MpIHtcclxuICAgIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke21zZ31gLCAuLi5hcmdzKTtcclxufVxuXG5sZXQgYWN0aXZlRWZmZWN0U2NvcGU7XHJcbmNsYXNzIEVmZmVjdFNjb3BlIHtcclxuICAgIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGVhbnVwcyA9IFtdO1xyXG4gICAgICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleCA9XHJcbiAgICAgICAgICAgICAgICAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzIHx8IChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgPSBbXSkpLnB1c2godGhpcykgLSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJ1bihmbikge1xyXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYGNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIG9uKCkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIG9mZigpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xyXG4gICAgfVxyXG4gICAgc3RvcChmcm9tUGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGxldCBpLCBsO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5lc3RlZCBzY29wZSwgZGVyZWZlcmVuY2UgZnJvbSBwYXJlbnQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIE8oMSkgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY29wZXNbdGhpcy5pbmRleF0gPSBsYXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcclxufVxyXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgIGlmIChzY29wZSAmJiBzY29wZS5hY3RpdmUpIHtcclxuICAgICAgICBzY29wZS5lZmZlY3RzLnB1c2goZWZmZWN0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XHJcbiAgICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XHJcbn1cclxuZnVuY3Rpb24gb25TY29wZURpc3Bvc2UoZm4pIHtcclxuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xyXG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlLmNsZWFudXBzLnB1c2goZm4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2Fybihgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlYCArXHJcbiAgICAgICAgICAgIGAgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLmApO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGNyZWF0ZURlcCA9IChlZmZlY3RzKSA9PiB7XHJcbiAgICBjb25zdCBkZXAgPSBuZXcgU2V0KGVmZmVjdHMpO1xyXG4gICAgZGVwLncgPSAwO1xyXG4gICAgZGVwLm4gPSAwO1xyXG4gICAgcmV0dXJuIGRlcDtcclxufTtcclxuY29uc3Qgd2FzVHJhY2tlZCA9IChkZXApID0+IChkZXAudyAmIHRyYWNrT3BCaXQpID4gMDtcclxuY29uc3QgbmV3VHJhY2tlZCA9IChkZXApID0+IChkZXAubiAmIHRyYWNrT3BCaXQpID4gMDtcclxuY29uc3QgaW5pdERlcE1hcmtlcnMgPSAoeyBkZXBzIH0pID0+IHtcclxuICAgIGlmIChkZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZXBzW2ldLncgfD0gdHJhY2tPcEJpdDsgLy8gc2V0IHdhcyB0cmFja2VkXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBmaW5hbGl6ZURlcE1hcmtlcnMgPSAoZWZmZWN0KSA9PiB7XHJcbiAgICBjb25zdCB7IGRlcHMgfSA9IGVmZmVjdDtcclxuICAgIGlmIChkZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGxldCBwdHIgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkZXAgPSBkZXBzW2ldO1xyXG4gICAgICAgICAgICBpZiAod2FzVHJhY2tlZChkZXApICYmICFuZXdUcmFja2VkKGRlcCkpIHtcclxuICAgICAgICAgICAgICAgIGRlcC5kZWxldGUoZWZmZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlcHNbcHRyKytdID0gZGVwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNsZWFyIGJpdHNcclxuICAgICAgICAgICAgZGVwLncgJj0gfnRyYWNrT3BCaXQ7XHJcbiAgICAgICAgICAgIGRlcC5uICY9IH50cmFja09wQml0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZXBzLmxlbmd0aCA9IHB0cjtcclxuICAgIH1cclxufTtcblxuY29uc3QgdGFyZ2V0TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuLy8gVGhlIG51bWJlciBvZiBlZmZlY3RzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkIHJlY3Vyc2l2ZWx5LlxyXG5sZXQgZWZmZWN0VHJhY2tEZXB0aCA9IDA7XHJcbmxldCB0cmFja09wQml0ID0gMTtcclxuLyoqXHJcbiAqIFRoZSBiaXR3aXNlIHRyYWNrIG1hcmtlcnMgc3VwcG9ydCBhdCBtb3N0IDMwIGxldmVscyBvZiByZWN1cnNpb24uXHJcbiAqIFRoaXMgdmFsdWUgaXMgY2hvc2VuIHRvIGVuYWJsZSBtb2Rlcm4gSlMgZW5naW5lcyB0byB1c2UgYSBTTUkgb24gYWxsIHBsYXRmb3Jtcy5cclxuICogV2hlbiByZWN1cnNpb24gZGVwdGggaXMgZ3JlYXRlciwgZmFsbCBiYWNrIHRvIHVzaW5nIGEgZnVsbCBjbGVhbnVwLlxyXG4gKi9cclxuY29uc3QgbWF4TWFya2VyQml0cyA9IDMwO1xyXG5sZXQgYWN0aXZlRWZmZWN0O1xyXG5jb25zdCBJVEVSQVRFX0tFWSA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnaXRlcmF0ZScgOiAnJyk7XHJcbmNvbnN0IE1BUF9LRVlfSVRFUkFURV9LRVkgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ01hcCBrZXkgaXRlcmF0ZScgOiAnJyk7XHJcbmNsYXNzIFJlYWN0aXZlRWZmZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKGZuLCBzY2hlZHVsZXIgPSBudWxsLCBzY29wZSkge1xyXG4gICAgICAgIHRoaXMuZm4gPSBmbjtcclxuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kZXBzID0gW107XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmVjb3JkRWZmZWN0U2NvcGUodGhpcywgc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgcnVuKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBhcmVudCA9IGFjdGl2ZUVmZmVjdDtcclxuICAgICAgICBsZXQgbGFzdFNob3VsZFRyYWNrID0gc2hvdWxkVHJhY2s7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBhY3RpdmVFZmZlY3Q7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgdHJhY2tPcEJpdCA9IDEgPDwgKytlZmZlY3RUcmFja0RlcHRoO1xyXG4gICAgICAgICAgICBpZiAoZWZmZWN0VHJhY2tEZXB0aCA8PSBtYXhNYXJrZXJCaXRzKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0RGVwTWFya2Vycyh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsZWFudXBFZmZlY3QodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIGlmIChlZmZlY3RUcmFja0RlcHRoIDw9IG1heE1hcmtlckJpdHMpIHtcclxuICAgICAgICAgICAgICAgIGZpbmFsaXplRGVwTWFya2Vycyh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cmFja09wQml0ID0gMSA8PCAtLWVmZmVjdFRyYWNrRGVwdGg7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVmZmVjdCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICBzaG91bGRUcmFjayA9IGxhc3RTaG91bGRUcmFjaztcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmVyU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIC8vIHN0b3BwZWQgd2hpbGUgcnVubmluZyBpdHNlbGYgLSBkZWZlciB0aGUgY2xlYW51cFxyXG4gICAgICAgIGlmIChhY3RpdmVFZmZlY3QgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZlclN0b3AgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBjbGVhbnVwRWZmZWN0KHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vblN0b3ApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25TdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2xlYW51cEVmZmVjdChlZmZlY3QpIHtcclxuICAgIGNvbnN0IHsgZGVwcyB9ID0gZWZmZWN0O1xyXG4gICAgaWYgKGRlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlcHNbaV0uZGVsZXRlKGVmZmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlcHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBlZmZlY3QoZm4sIG9wdGlvbnMpIHtcclxuICAgIGlmIChmbi5lZmZlY3QpIHtcclxuICAgICAgICBmbiA9IGZuLmVmZmVjdC5mbjtcclxuICAgIH1cclxuICAgIGNvbnN0IF9lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoZm4pO1xyXG4gICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICBleHRlbmQoX2VmZmVjdCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NvcGUpXHJcbiAgICAgICAgICAgIHJlY29yZEVmZmVjdFNjb3BlKF9lZmZlY3QsIG9wdGlvbnMuc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmxhenkpIHtcclxuICAgICAgICBfZWZmZWN0LnJ1bigpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcnVubmVyID0gX2VmZmVjdC5ydW4uYmluZChfZWZmZWN0KTtcclxuICAgIHJ1bm5lci5lZmZlY3QgPSBfZWZmZWN0O1xyXG4gICAgcmV0dXJuIHJ1bm5lcjtcclxufVxyXG5mdW5jdGlvbiBzdG9wKHJ1bm5lcikge1xyXG4gICAgcnVubmVyLmVmZmVjdC5zdG9wKCk7XHJcbn1cclxubGV0IHNob3VsZFRyYWNrID0gdHJ1ZTtcclxuY29uc3QgdHJhY2tTdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwYXVzZVRyYWNraW5nKCkge1xyXG4gICAgdHJhY2tTdGFjay5wdXNoKHNob3VsZFRyYWNrKTtcclxuICAgIHNob3VsZFRyYWNrID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRUcmFja2luZygpIHtcclxuICAgIGNvbnN0IGxhc3QgPSB0cmFja1N0YWNrLnBvcCgpO1xyXG4gICAgc2hvdWxkVHJhY2sgPSBsYXN0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogbGFzdDtcclxufVxyXG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHR5cGUsIGtleSkge1xyXG4gICAgaWYgKHNob3VsZFRyYWNrICYmIGFjdGl2ZUVmZmVjdCkge1xyXG4gICAgICAgIGxldCBkZXBzTWFwID0gdGFyZ2V0TWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghZGVwc01hcCkge1xyXG4gICAgICAgICAgICB0YXJnZXRNYXAuc2V0KHRhcmdldCwgKGRlcHNNYXAgPSBuZXcgTWFwKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRlcCA9IGRlcHNNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFkZXApIHtcclxuICAgICAgICAgICAgZGVwc01hcC5zZXQoa2V5LCAoZGVwID0gY3JlYXRlRGVwKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRJbmZvID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgID8geyBlZmZlY3Q6IGFjdGl2ZUVmZmVjdCwgdGFyZ2V0LCB0eXBlLCBrZXkgfVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgICAgICB0cmFja0VmZmVjdHMoZGVwLCBldmVudEluZm8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYWNrRWZmZWN0cyhkZXAsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pIHtcclxuICAgIGxldCBzaG91bGRUcmFjayA9IGZhbHNlO1xyXG4gICAgaWYgKGVmZmVjdFRyYWNrRGVwdGggPD0gbWF4TWFya2VyQml0cykge1xyXG4gICAgICAgIGlmICghbmV3VHJhY2tlZChkZXApKSB7XHJcbiAgICAgICAgICAgIGRlcC5uIHw9IHRyYWNrT3BCaXQ7IC8vIHNldCBuZXdseSB0cmFja2VkXHJcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gIXdhc1RyYWNrZWQoZGVwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBGdWxsIGNsZWFudXAgbW9kZS5cclxuICAgICAgICBzaG91bGRUcmFjayA9ICFkZXAuaGFzKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2hvdWxkVHJhY2spIHtcclxuICAgICAgICBkZXAuYWRkKGFjdGl2ZUVmZmVjdCk7XHJcbiAgICAgICAgYWN0aXZlRWZmZWN0LmRlcHMucHVzaChkZXApO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYWN0aXZlRWZmZWN0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgYWN0aXZlRWZmZWN0Lm9uVHJhY2soT2JqZWN0LmFzc2lnbih7IGVmZmVjdDogYWN0aXZlRWZmZWN0IH0sIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlcih0YXJnZXQsIHR5cGUsIGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlLCBvbGRUYXJnZXQpIHtcclxuICAgIGNvbnN0IGRlcHNNYXAgPSB0YXJnZXRNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoIWRlcHNNYXApIHtcclxuICAgICAgICAvLyBuZXZlciBiZWVuIHRyYWNrZWRcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZGVwcyA9IFtdO1xyXG4gICAgaWYgKHR5cGUgPT09IFwiY2xlYXJcIiAvKiBDTEVBUiAqLykge1xyXG4gICAgICAgIC8vIGNvbGxlY3Rpb24gYmVpbmcgY2xlYXJlZFxyXG4gICAgICAgIC8vIHRyaWdnZXIgYWxsIGVmZmVjdHMgZm9yIHRhcmdldFxyXG4gICAgICAgIGRlcHMgPSBbLi4uZGVwc01hcC52YWx1ZXMoKV07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgIGRlcHNNYXAuZm9yRWFjaCgoZGVwLCBrZXkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcgfHwga2V5ID49IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc2NoZWR1bGUgcnVucyBmb3IgU0VUIHwgQUREIHwgREVMRVRFXHJcbiAgICAgICAgaWYgKGtleSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGRlcHMucHVzaChkZXBzTWFwLmdldChrZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWxzbyBydW4gZm9yIGl0ZXJhdGlvbiBrZXkgb24gQUREIHwgREVMRVRFIHwgTWFwLlNFVFxyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYWRkXCIgLyogQUREICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzLnB1c2goZGVwc01hcC5nZXQoTUFQX0tFWV9JVEVSQVRFX0tFWSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZWdlcktleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3IGluZGV4IGFkZGVkIHRvIGFycmF5IC0+IGxlbmd0aCBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KCdsZW5ndGgnKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiIC8qIERFTEVURSAqLzpcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheSh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KE1BUF9LRVlfSVRFUkFURV9LRVkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInNldFwiIC8qIFNFVCAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChpc01hcCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGRlcHNNYXAuZ2V0KElURVJBVEVfS0VZKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBldmVudEluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IHsgdGFyZ2V0LCB0eXBlLCBrZXksIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgb2xkVGFyZ2V0IH1cclxuICAgICAgICA6IHVuZGVmaW5lZDtcclxuICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGlmIChkZXBzWzBdKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKGRlcHNbMF0sIGV2ZW50SW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhkZXBzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGVmZmVjdHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzKSB7XHJcbiAgICAgICAgICAgIGlmIChkZXApIHtcclxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaCguLi5kZXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpLCBldmVudEluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdHMoY3JlYXRlRGVwKGVmZmVjdHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlckVmZmVjdHMoZGVwLCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XHJcbiAgICAvLyBzcHJlYWQgaW50byBhcnJheSBmb3Igc3RhYmlsaXphdGlvblxyXG4gICAgY29uc3QgZWZmZWN0cyA9IGlzQXJyYXkoZGVwKSA/IGRlcCA6IFsuLi5kZXBdO1xyXG4gICAgZm9yIChjb25zdCBlZmZlY3Qgb2YgZWZmZWN0cykge1xyXG4gICAgICAgIGlmIChlZmZlY3QuY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckVmZmVjdChlZmZlY3QsIGRlYnVnZ2VyRXZlbnRFeHRyYUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcclxuICAgICAgICBpZiAoIWVmZmVjdC5jb21wdXRlZCkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0KGVmZmVjdCwgZGVidWdnZXJFdmVudEV4dHJhSW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJFZmZlY3QoZWZmZWN0LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSB7XHJcbiAgICBpZiAoZWZmZWN0ICE9PSBhY3RpdmVFZmZlY3QgfHwgZWZmZWN0LmFsbG93UmVjdXJzZSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgZWZmZWN0Lm9uVHJpZ2dlcikge1xyXG4gICAgICAgICAgICBlZmZlY3Qub25UcmlnZ2VyKGV4dGVuZCh7IGVmZmVjdCB9LCBkZWJ1Z2dlckV2ZW50RXh0cmFJbmZvKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlZmZlY3Quc2NoZWR1bGVyKSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5zY2hlZHVsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVmZmVjdC5ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgaXNOb25UcmFja2FibGVLZXlzID0gLyojX19QVVJFX18qLyBtYWtlTWFwKGBfX3Byb3RvX18sX192X2lzUmVmLF9faXNWdWVgKTtcclxuY29uc3QgYnVpbHRJblN5bWJvbHMgPSBuZXcgU2V0KFxyXG4vKiNfX1BVUkVfXyovXHJcbk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKFN5bWJvbClcclxuICAgIC8vIGlvczEwLnggT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKSBjYW4gZW51bWVyYXRlICdhcmd1bWVudHMnIGFuZCAnY2FsbGVyJ1xyXG4gICAgLy8gYnV0IGFjY2Vzc2luZyB0aGVtIG9uIFN5bWJvbCBsZWFkcyB0byBUeXBlRXJyb3IgYmVjYXVzZSBTeW1ib2wgaXMgYSBzdHJpY3QgbW9kZVxyXG4gICAgLy8gZnVuY3Rpb25cclxuICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ2FyZ3VtZW50cycgJiYga2V5ICE9PSAnY2FsbGVyJylcclxuICAgIC5tYXAoa2V5ID0+IFN5bWJvbFtrZXldKVxyXG4gICAgLmZpbHRlcihpc1N5bWJvbCkpO1xyXG5jb25zdCBnZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcigpO1xyXG5jb25zdCBzaGFsbG93R2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVHZXR0ZXIoZmFsc2UsIHRydWUpO1xyXG5jb25zdCByZWFkb25seUdldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlR2V0dGVyKHRydWUpO1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlHZXQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZUdldHRlcih0cnVlLCB0cnVlKTtcclxuY29uc3QgYXJyYXlJbnN0cnVtZW50YXRpb25zID0gLyojX19QVVJFX18qLyBjcmVhdGVBcnJheUluc3RydW1lbnRhdGlvbnMoKTtcclxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJbnN0cnVtZW50YXRpb25zKCkge1xyXG4gICAgY29uc3QgaW5zdHJ1bWVudGF0aW9ucyA9IHt9O1xyXG4gICAgWydpbmNsdWRlcycsICdpbmRleE9mJywgJ2xhc3RJbmRleE9mJ10uZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIGluc3RydW1lbnRhdGlvbnNba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyciA9IHRvUmF3KHRoaXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhhcnIsIFwiZ2V0XCIgLyogR0VUICovLCBpICsgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdlIHJ1biB0aGUgbWV0aG9kIHVzaW5nIHRoZSBvcmlnaW5hbCBhcmdzIGZpcnN0ICh3aGljaCBtYXkgYmUgcmVhY3RpdmUpXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGFycltrZXldKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICBpZiAocmVzID09PSAtMSB8fCByZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGRpZG4ndCB3b3JrLCBydW4gaXQgYWdhaW4gdXNpbmcgcmF3IHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJba2V5XSguLi5hcmdzLm1hcCh0b1JhdykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAndW5zaGlmdCcsICdzcGxpY2UnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgaW5zdHJ1bWVudGF0aW9uc1trZXldID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgICAgICBjb25zdCByZXMgPSB0b1Jhdyh0aGlzKVtrZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGluc3RydW1lbnRhdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlR2V0dGVyKGlzUmVhZG9ubHkgPSBmYWxzZSwgc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChrZXkgPT09IFwiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gIWlzUmVhZG9ubHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzU2hhbGxvd1wiIC8qIElTX1NIQUxMT1cgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJfX3ZfcmF3XCIgLyogUkFXICovICYmXHJcbiAgICAgICAgICAgIHJlY2VpdmVyID09PVxyXG4gICAgICAgICAgICAgICAgKGlzUmVhZG9ubHlcclxuICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzaGFsbG93UmVhZG9ubHlNYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWFkb25seU1hcFxyXG4gICAgICAgICAgICAgICAgICAgIDogc2hhbGxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNoYWxsb3dSZWFjdGl2ZU1hcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlYWN0aXZlTWFwKS5nZXQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0YXJnZXRJc0FycmF5ID0gaXNBcnJheSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghaXNSZWFkb25seSAmJiB0YXJnZXRJc0FycmF5ICYmIGhhc093bihhcnJheUluc3RydW1lbnRhdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGFycmF5SW5zdHJ1bWVudGF0aW9ucywga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcyA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCByZWNlaXZlcik7XHJcbiAgICAgICAgaWYgKGlzU3ltYm9sKGtleSkgPyBidWlsdEluU3ltYm9scy5oYXMoa2V5KSA6IGlzTm9uVHJhY2thYmxlS2V5cyhrZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNSZWFkb25seSkge1xyXG4gICAgICAgICAgICB0cmFjayh0YXJnZXQsIFwiZ2V0XCIgLyogR0VUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2hhbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYocmVzKSkge1xyXG4gICAgICAgICAgICAvLyByZWYgdW53cmFwcGluZyAtIHNraXAgdW53cmFwIGZvciBBcnJheSArIGludGVnZXIga2V5LlxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0SXNBcnJheSAmJiBpc0ludGVnZXJLZXkoa2V5KSA/IHJlcyA6IHJlcy52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcclxuICAgICAgICAgICAgLy8gQ29udmVydCByZXR1cm5lZCB2YWx1ZSBpbnRvIGEgcHJveHkgYXMgd2VsbC4gd2UgZG8gdGhlIGlzT2JqZWN0IGNoZWNrXHJcbiAgICAgICAgICAgIC8vIGhlcmUgdG8gYXZvaWQgaW52YWxpZCB2YWx1ZSB3YXJuaW5nLiBBbHNvIG5lZWQgdG8gbGF6eSBhY2Nlc3MgcmVhZG9ubHlcclxuICAgICAgICAgICAgLy8gYW5kIHJlYWN0aXZlIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeS5cclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVhZG9ubHkgPyByZWFkb25seShyZXMpIDogcmVhY3RpdmUocmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbn1cclxuY29uc3Qgc2V0ID0gLyojX19QVVJFX18qLyBjcmVhdGVTZXR0ZXIoKTtcclxuY29uc3Qgc2hhbGxvd1NldCA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU2V0dGVyKHRydWUpO1xyXG5mdW5jdGlvbiBjcmVhdGVTZXR0ZXIoc2hhbGxvdyA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcclxuICAgICAgICBsZXQgb2xkVmFsdWUgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICBpZiAoaXNSZWFkb25seShvbGRWYWx1ZSkgJiYgaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNoYWxsb3cgJiYgIWlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNTaGFsbG93KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHRvUmF3KG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSAmJiBpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhZEtleSA9IGlzQXJyYXkodGFyZ2V0KSAmJiBpc0ludGVnZXJLZXkoa2V5KVxyXG4gICAgICAgICAgICA/IE51bWJlcihrZXkpIDwgdGFyZ2V0Lmxlbmd0aFxyXG4gICAgICAgICAgICA6IGhhc093bih0YXJnZXQsIGtleSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCByZWNlaXZlcik7XHJcbiAgICAgICAgLy8gZG9uJ3QgdHJpZ2dlciBpZiB0YXJnZXQgaXMgc29tZXRoaW5nIHVwIGluIHRoZSBwcm90b3R5cGUgY2hhaW4gb2Ygb3JpZ2luYWxcclxuICAgICAgICBpZiAodGFyZ2V0ID09PSB0b1JhdyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgY29uc3QgaGFkS2V5ID0gaGFzT3duKHRhcmdldCwga2V5KTtcclxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGFyZ2V0W2tleV07XHJcbiAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcclxuICAgIGlmIChyZXN1bHQgJiYgaGFkS2V5KSB7XHJcbiAgICAgICAgdHJpZ2dlcih0YXJnZXQsIFwiZGVsZXRlXCIgLyogREVMRVRFICovLCBrZXksIHVuZGVmaW5lZCwgb2xkVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBoYXModGFyZ2V0LCBrZXkpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuaGFzKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaXNTeW1ib2woa2V5KSB8fCAhYnVpbHRJblN5bWJvbHMuaGFzKGtleSkpIHtcclxuICAgICAgICB0cmFjayh0YXJnZXQsIFwiaGFzXCIgLyogSEFTICovLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xyXG4gICAgdHJhY2sodGFyZ2V0LCBcIml0ZXJhdGVcIiAvKiBJVEVSQVRFICovLCBpc0FycmF5KHRhcmdldCkgPyAnbGVuZ3RoJyA6IElURVJBVEVfS0VZKTtcclxuICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcclxufVxyXG5jb25zdCBtdXRhYmxlSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQsXHJcbiAgICBzZXQsXHJcbiAgICBkZWxldGVQcm9wZXJ0eSxcclxuICAgIGhhcyxcclxuICAgIG93bktleXNcclxufTtcclxuY29uc3QgcmVhZG9ubHlIYW5kbGVycyA9IHtcclxuICAgIGdldDogcmVhZG9ubHlHZXQsXHJcbiAgICBzZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4oYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcoa2V5KX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLCB0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybihgRGVsZXRlIG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhrZXkpfVwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBtdXRhYmxlSGFuZGxlcnMsIHtcclxuICAgIGdldDogc2hhbGxvd0dldCxcclxuICAgIHNldDogc2hhbGxvd1NldFxyXG59KTtcclxuLy8gUHJvcHMgaGFuZGxlcnMgYXJlIHNwZWNpYWwgaW4gdGhlIHNlbnNlIHRoYXQgaXQgc2hvdWxkIG5vdCB1bndyYXAgdG9wLWxldmVsXHJcbi8vIHJlZnMgKGluIG9yZGVyIHRvIGFsbG93IHJlZnMgdG8gYmUgZXhwbGljaXRseSBwYXNzZWQgZG93biksIGJ1dCBzaG91bGRcclxuLy8gcmV0YWluIHRoZSByZWFjdGl2aXR5IG9mIHRoZSBub3JtYWwgcmVhZG9ubHkgb2JqZWN0LlxyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlIYW5kbGVycyA9IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCByZWFkb25seUhhbmRsZXJzLCB7XHJcbiAgICBnZXQ6IHNoYWxsb3dSZWFkb25seUdldFxyXG59KTtcblxuY29uc3QgdG9TaGFsbG93ID0gKHZhbHVlKSA9PiB2YWx1ZTtcclxuY29uc3QgZ2V0UHJvdG8gPSAodikgPT4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZih2KTtcclxuZnVuY3Rpb24gZ2V0JDEodGFyZ2V0LCBrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSwgaXNTaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIC8vICMxNzcyOiByZWFkb25seShyZWFjdGl2ZShNYXApKSBzaG91bGQgcmV0dXJuIHJlYWRvbmx5ICsgcmVhY3RpdmUgdmVyc2lvblxyXG4gICAgLy8gb2YgdGhlIHZhbHVlXHJcbiAgICB0YXJnZXQgPSB0YXJnZXRbXCJfX3ZfcmF3XCIgLyogUkFXICovXTtcclxuICAgIGNvbnN0IHJhd1RhcmdldCA9IHRvUmF3KHRhcmdldCk7XHJcbiAgICBjb25zdCByYXdLZXkgPSB0b1JhdyhrZXkpO1xyXG4gICAgaWYgKCFpc1JlYWRvbmx5KSB7XHJcbiAgICAgICAgaWYgKGtleSAhPT0gcmF3S2V5KSB7XHJcbiAgICAgICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyYWNrKHJhd1RhcmdldCwgXCJnZXRcIiAvKiBHRVQgKi8sIHJhd0tleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IGhhcyB9ID0gZ2V0UHJvdG8ocmF3VGFyZ2V0KTtcclxuICAgIGNvbnN0IHdyYXAgPSBpc1NoYWxsb3cgPyB0b1NoYWxsb3cgOiBpc1JlYWRvbmx5ID8gdG9SZWFkb25seSA6IHRvUmVhY3RpdmU7XHJcbiAgICBpZiAoaGFzLmNhbGwocmF3VGFyZ2V0LCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0LmdldChrZXkpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhcy5jYWxsKHJhd1RhcmdldCwgcmF3S2V5KSkge1xyXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldC5nZXQocmF3S2V5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YXJnZXQgIT09IHJhd1RhcmdldCkge1xyXG4gICAgICAgIC8vICMzNjAyIHJlYWRvbmx5KHJlYWN0aXZlKE1hcCkpXHJcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG5lc3RlZCByZWFjdGl2ZSBgTWFwYCBjYW4gZG8gdHJhY2tpbmcgZm9yIGl0c2VsZlxyXG4gICAgICAgIHRhcmdldC5nZXQoa2V5KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXMkMShrZXksIGlzUmVhZG9ubHkgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpc1tcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAoIWlzUmVhZG9ubHkpIHtcclxuICAgICAgICBpZiAoa2V5ICE9PSByYXdLZXkpIHtcclxuICAgICAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJhY2socmF3VGFyZ2V0LCBcImhhc1wiIC8qIEhBUyAqLywgcmF3S2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBrZXkgPT09IHJhd0tleVxyXG4gICAgICAgID8gdGFyZ2V0LmhhcyhrZXkpXHJcbiAgICAgICAgOiB0YXJnZXQuaGFzKGtleSkgfHwgdGFyZ2V0LmhhcyhyYXdLZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNpemUodGFyZ2V0LCBpc1JlYWRvbmx5ID0gZmFsc2UpIHtcclxuICAgIHRhcmdldCA9IHRhcmdldFtcIl9fdl9yYXdcIiAvKiBSQVcgKi9dO1xyXG4gICAgIWlzUmVhZG9ubHkgJiYgdHJhY2sodG9SYXcodGFyZ2V0KSwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgJ3NpemUnLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xyXG4gICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICBjb25zdCB0YXJnZXQgPSB0b1Jhdyh0aGlzKTtcclxuICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGNvbnN0IGhhZEtleSA9IHByb3RvLmhhcy5jYWxsKHRhcmdldCwgdmFsdWUpO1xyXG4gICAgaWYgKCFoYWRLZXkpIHtcclxuICAgICAgICB0YXJnZXQuYWRkKHZhbHVlKTtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJhZGRcIiAvKiBBREQgKi8sIHZhbHVlLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufVxyXG5mdW5jdGlvbiBzZXQkMShrZXksIHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9IHRvUmF3KHZhbHVlKTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHRvUmF3KHRoaXMpO1xyXG4gICAgY29uc3QgeyBoYXMsIGdldCB9ID0gZ2V0UHJvdG8odGFyZ2V0KTtcclxuICAgIGxldCBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIGtleSA9IHRvUmF3KGtleSk7XHJcbiAgICAgICAgaGFkS2V5ID0gaGFzLmNhbGwodGFyZ2V0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY2hlY2tJZGVudGl0eUtleXModGFyZ2V0LCBoYXMsIGtleSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldC5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIHRhcmdldC5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICBpZiAoIWhhZEtleSkge1xyXG4gICAgICAgIHRyaWdnZXIodGFyZ2V0LCBcImFkZFwiIC8qIEFERCAqLywga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXNDaGFuZ2VkKHZhbHVlLCBvbGRWYWx1ZSkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmZ1bmN0aW9uIGRlbGV0ZUVudHJ5KGtleSkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCB7IGhhcywgZ2V0IH0gPSBnZXRQcm90byh0YXJnZXQpO1xyXG4gICAgbGV0IGhhZEtleSA9IGhhcy5jYWxsKHRhcmdldCwga2V5KTtcclxuICAgIGlmICghaGFkS2V5KSB7XHJcbiAgICAgICAga2V5ID0gdG9SYXcoa2V5KTtcclxuICAgICAgICBoYWRLZXkgPSBoYXMuY2FsbCh0YXJnZXQsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjaGVja0lkZW50aXR5S2V5cyh0YXJnZXQsIGhhcywga2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9sZFZhbHVlID0gZ2V0ID8gZ2V0LmNhbGwodGFyZ2V0LCBrZXkpIDogdW5kZWZpbmVkO1xyXG4gICAgLy8gZm9yd2FyZCB0aGUgb3BlcmF0aW9uIGJlZm9yZSBxdWV1ZWluZyByZWFjdGlvbnNcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldC5kZWxldGUoa2V5KTtcclxuICAgIGlmIChoYWRLZXkpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJkZWxldGVcIiAvKiBERUxFVEUgKi8sIGtleSwgdW5kZWZpbmVkLCBvbGRWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gdG9SYXcodGhpcyk7XHJcbiAgICBjb25zdCBoYWRJdGVtcyA9IHRhcmdldC5zaXplICE9PSAwO1xyXG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBpc01hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgID8gbmV3IE1hcCh0YXJnZXQpXHJcbiAgICAgICAgICAgIDogbmV3IFNldCh0YXJnZXQpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyBmb3J3YXJkIHRoZSBvcGVyYXRpb24gYmVmb3JlIHF1ZXVlaW5nIHJlYWN0aW9uc1xyXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0LmNsZWFyKCk7XHJcbiAgICBpZiAoaGFkSXRlbXMpIHtcclxuICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJjbGVhclwiIC8qIENMRUFSICovLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb2xkVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRm9yRWFjaChpc1JlYWRvbmx5LCBpc1NoYWxsb3cpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZWQgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB3cmFwID0gaXNTaGFsbG93ID8gdG9TaGFsbG93IDogaXNSZWFkb25seSA/IHRvUmVhZG9ubHkgOiB0b1JlYWN0aXZlO1xyXG4gICAgICAgICFpc1JlYWRvbmx5ICYmIHRyYWNrKHJhd1RhcmdldCwgXCJpdGVyYXRlXCIgLyogSVRFUkFURSAqLywgSVRFUkFURV9LRVkpO1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IG1ha2Ugc3VyZSB0aGUgY2FsbGJhY2sgaXNcclxuICAgICAgICAgICAgLy8gMS4gaW52b2tlZCB3aXRoIHRoZSByZWFjdGl2ZSBtYXAgYXMgYHRoaXNgIGFuZCAzcmQgYXJnXHJcbiAgICAgICAgICAgIC8vIDIuIHRoZSB2YWx1ZSByZWNlaXZlZCBzaG91bGQgYmUgYSBjb3JyZXNwb25kaW5nIHJlYWN0aXZlL3JlYWRvbmx5LlxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB3cmFwKHZhbHVlKSwgd3JhcChrZXkpLCBvYnNlcnZlZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgaXNSZWFkb25seSwgaXNTaGFsbG93KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICAgICAgY29uc3QgcmF3VGFyZ2V0ID0gdG9SYXcodGFyZ2V0KTtcclxuICAgICAgICBjb25zdCB0YXJnZXRJc01hcCA9IGlzTWFwKHJhd1RhcmdldCk7XHJcbiAgICAgICAgY29uc3QgaXNQYWlyID0gbWV0aG9kID09PSAnZW50cmllcycgfHwgKG1ldGhvZCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIHRhcmdldElzTWFwKTtcclxuICAgICAgICBjb25zdCBpc0tleU9ubHkgPSBtZXRob2QgPT09ICdrZXlzJyAmJiB0YXJnZXRJc01hcDtcclxuICAgICAgICBjb25zdCBpbm5lckl0ZXJhdG9yID0gdGFyZ2V0W21ldGhvZF0oLi4uYXJncyk7XHJcbiAgICAgICAgY29uc3Qgd3JhcCA9IGlzU2hhbGxvdyA/IHRvU2hhbGxvdyA6IGlzUmVhZG9ubHkgPyB0b1JlYWRvbmx5IDogdG9SZWFjdGl2ZTtcclxuICAgICAgICAhaXNSZWFkb25seSAmJlxyXG4gICAgICAgICAgICB0cmFjayhyYXdUYXJnZXQsIFwiaXRlcmF0ZVwiIC8qIElURVJBVEUgKi8sIGlzS2V5T25seSA/IE1BUF9LRVlfSVRFUkFURV9LRVkgOiBJVEVSQVRFX0tFWSk7XHJcbiAgICAgICAgLy8gcmV0dXJuIGEgd3JhcHBlZCBpdGVyYXRvciB3aGljaCByZXR1cm5zIG9ic2VydmVkIHZlcnNpb25zIG9mIHRoZVxyXG4gICAgICAgIC8vIHZhbHVlcyBlbWl0dGVkIGZyb20gdGhlIHJlYWwgaXRlcmF0b3JcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBpdGVyYXRvciBwcm90b2NvbFxyXG4gICAgICAgICAgICBuZXh0KCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gaW5uZXJJdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZVxyXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZSwgZG9uZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpc1BhaXIgPyBbd3JhcCh2YWx1ZVswXSksIHdyYXAodmFsdWVbMV0pXSA6IHdyYXAodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gaXRlcmFibGUgcHJvdG9jb2xcclxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRvbmx5TWV0aG9kKHR5cGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXJnc1swXSA/IGBvbiBrZXkgXCIke2FyZ3NbMF19XCIgYCA6IGBgO1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Y2FwaXRhbGl6ZSh0eXBlKX0gb3BlcmF0aW9uICR7a2V5fWZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LmAsIHRvUmF3KHRoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFwiZGVsZXRlXCIgLyogREVMRVRFICovID8gZmFsc2UgOiB0aGlzO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCkge1xyXG4gICAgY29uc3QgbXV0YWJsZUluc3RydW1lbnRhdGlvbnMgPSB7XHJcbiAgICAgICAgZ2V0KGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEodGhpcywga2V5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhczogaGFzJDEsXHJcbiAgICAgICAgYWRkLFxyXG4gICAgICAgIHNldDogc2V0JDEsXHJcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgICAgICBjbGVhcixcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCBmYWxzZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGhhczogaGFzJDEsXHJcbiAgICAgICAgYWRkLFxyXG4gICAgICAgIHNldDogc2V0JDEsXHJcbiAgICAgICAgZGVsZXRlOiBkZWxldGVFbnRyeSxcclxuICAgICAgICBjbGVhcixcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKGZhbHNlLCB0cnVlKVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyA9IHtcclxuICAgICAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQkMSh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFzJDEuY2FsbCh0aGlzLCBrZXksIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImFkZFwiIC8qIEFERCAqLyksXHJcbiAgICAgICAgc2V0OiBjcmVhdGVSZWFkb25seU1ldGhvZChcInNldFwiIC8qIFNFVCAqLyksXHJcbiAgICAgICAgZGVsZXRlOiBjcmVhdGVSZWFkb25seU1ldGhvZChcImRlbGV0ZVwiIC8qIERFTEVURSAqLyksXHJcbiAgICAgICAgY2xlYXI6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiY2xlYXJcIiAvKiBDTEVBUiAqLyksXHJcbiAgICAgICAgZm9yRWFjaDogY3JlYXRlRm9yRWFjaCh0cnVlLCBmYWxzZSlcclxuICAgIH07XHJcbiAgICBjb25zdCBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zID0ge1xyXG4gICAgICAgIGdldChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMsIGtleSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpemUodGhpcywgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBoYXMkMS5jYWxsKHRoaXMsIGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiYWRkXCIgLyogQUREICovKSxcclxuICAgICAgICBzZXQ6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwic2V0XCIgLyogU0VUICovKSxcclxuICAgICAgICBkZWxldGU6IGNyZWF0ZVJlYWRvbmx5TWV0aG9kKFwiZGVsZXRlXCIgLyogREVMRVRFICovKSxcclxuICAgICAgICBjbGVhcjogY3JlYXRlUmVhZG9ubHlNZXRob2QoXCJjbGVhclwiIC8qIENMRUFSICovKSxcclxuICAgICAgICBmb3JFYWNoOiBjcmVhdGVGb3JFYWNoKHRydWUsIHRydWUpXHJcbiAgICB9O1xyXG4gICAgY29uc3QgaXRlcmF0b3JNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJywgU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGl0ZXJhdG9yTWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiB7XHJcbiAgICAgICAgbXV0YWJsZUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICByZWFkb25seUluc3RydW1lbnRhdGlvbnNbbWV0aG9kXSA9IGNyZWF0ZUl0ZXJhYmxlTWV0aG9kKG1ldGhvZCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIHNoYWxsb3dJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zW21ldGhvZF0gPSBjcmVhdGVJdGVyYWJsZU1ldGhvZChtZXRob2QsIHRydWUsIHRydWUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIG11dGFibGVJbnN0cnVtZW50YXRpb25zLFxyXG4gICAgICAgIHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucyxcclxuICAgICAgICBzaGFsbG93UmVhZG9ubHlJbnN0cnVtZW50YXRpb25zXHJcbiAgICBdO1xyXG59XHJcbmNvbnN0IFttdXRhYmxlSW5zdHJ1bWVudGF0aW9ucywgcmVhZG9ubHlJbnN0cnVtZW50YXRpb25zLCBzaGFsbG93SW5zdHJ1bWVudGF0aW9ucywgc2hhbGxvd1JlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc10gPSAvKiAjX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25zKCk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihpc1JlYWRvbmx5LCBzaGFsbG93KSB7XHJcbiAgICBjb25zdCBpbnN0cnVtZW50YXRpb25zID0gc2hhbGxvd1xyXG4gICAgICAgID8gaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHNoYWxsb3dSZWFkb25seUluc3RydW1lbnRhdGlvbnNcclxuICAgICAgICAgICAgOiBzaGFsbG93SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgIDogaXNSZWFkb25seVxyXG4gICAgICAgICAgICA/IHJlYWRvbmx5SW5zdHJ1bWVudGF0aW9uc1xyXG4gICAgICAgICAgICA6IG11dGFibGVJbnN0cnVtZW50YXRpb25zO1xyXG4gICAgcmV0dXJuICh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBpZiAoa2V5ID09PSBcIl9fdl9pc1JlYWN0aXZlXCIgLyogSVNfUkVBQ1RJVkUgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuICFpc1JlYWRvbmx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqLykge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNSZWFkb25seTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcIl9fdl9yYXdcIiAvKiBSQVcgKi8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KGhhc093bihpbnN0cnVtZW50YXRpb25zLCBrZXkpICYmIGtleSBpbiB0YXJnZXRcclxuICAgICAgICAgICAgPyBpbnN0cnVtZW50YXRpb25zXHJcbiAgICAgICAgICAgIDogdGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgbXV0YWJsZUNvbGxlY3Rpb25IYW5kbGVycyA9IHtcclxuICAgIGdldDogLyojX19QVVJFX18qLyBjcmVhdGVJbnN0cnVtZW50YXRpb25HZXR0ZXIoZmFsc2UsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93Q29sbGVjdGlvbkhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAvKiNfX1BVUkVfXyovIGNyZWF0ZUluc3RydW1lbnRhdGlvbkdldHRlcihmYWxzZSwgdHJ1ZSlcclxufTtcclxuY29uc3QgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIGZhbHNlKVxyXG59O1xyXG5jb25zdCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMgPSB7XHJcbiAgICBnZXQ6IC8qI19fUFVSRV9fKi8gY3JlYXRlSW5zdHJ1bWVudGF0aW9uR2V0dGVyKHRydWUsIHRydWUpXHJcbn07XHJcbmZ1bmN0aW9uIGNoZWNrSWRlbnRpdHlLZXlzKHRhcmdldCwgaGFzLCBrZXkpIHtcclxuICAgIGNvbnN0IHJhd0tleSA9IHRvUmF3KGtleSk7XHJcbiAgICBpZiAocmF3S2V5ICE9PSBrZXkgJiYgaGFzLmNhbGwodGFyZ2V0LCByYXdLZXkpKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRvUmF3VHlwZSh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgUmVhY3RpdmUgJHt0eXBlfSBjb250YWlucyBib3RoIHRoZSByYXcgYW5kIHJlYWN0aXZlIGAgK1xyXG4gICAgICAgICAgICBgdmVyc2lvbnMgb2YgdGhlIHNhbWUgb2JqZWN0JHt0eXBlID09PSBgTWFwYCA/IGAgYXMga2V5c2AgOiBgYH0sIGAgK1xyXG4gICAgICAgICAgICBgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBgICtcclxuICAgICAgICAgICAgYEF2b2lkIGRpZmZlcmVudGlhdGluZyBiZXR3ZWVuIHRoZSByYXcgYW5kIHJlYWN0aXZlIHZlcnNpb25zIGAgK1xyXG4gICAgICAgICAgICBgb2YgYW4gb2JqZWN0IGFuZCBvbmx5IHVzZSB0aGUgcmVhY3RpdmUgdmVyc2lvbiBpZiBwb3NzaWJsZS5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCByZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNoYWxsb3dSZWFjdGl2ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHJlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2hhbGxvd1JlYWRvbmx5TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gdGFyZ2V0VHlwZU1hcChyYXdUeXBlKSB7XHJcbiAgICBzd2l0Y2ggKHJhd1R5cGUpIHtcclxuICAgICAgICBjYXNlICdPYmplY3QnOlxyXG4gICAgICAgIGNhc2UgJ0FycmF5JzpcclxuICAgICAgICAgICAgcmV0dXJuIDEgLyogQ09NTU9OICovO1xyXG4gICAgICAgIGNhc2UgJ01hcCc6XHJcbiAgICAgICAgY2FzZSAnU2V0JzpcclxuICAgICAgICBjYXNlICdXZWFrTWFwJzpcclxuICAgICAgICBjYXNlICdXZWFrU2V0JzpcclxuICAgICAgICAgICAgcmV0dXJuIDIgLyogQ09MTEVDVElPTiAqLztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMCAvKiBJTlZBTElEICovO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFRhcmdldFR5cGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZVtcIl9fdl9za2lwXCIgLyogU0tJUCAqL10gfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpXHJcbiAgICAgICAgPyAwIC8qIElOVkFMSUQgKi9cclxuICAgICAgICA6IHRhcmdldFR5cGVNYXAodG9SYXdUeXBlKHZhbHVlKSk7XHJcbn1cclxuZnVuY3Rpb24gcmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICAvLyBpZiB0cnlpbmcgdG8gb2JzZXJ2ZSBhIHJlYWRvbmx5IHByb3h5LCByZXR1cm4gdGhlIHJlYWRvbmx5IHZlcnNpb24uXHJcbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBtdXRhYmxlSGFuZGxlcnMsIG11dGFibGVDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIGEgc2hhbGxvd2x5LXJlYWN0aXZlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdFxyXG4gKiBsZXZlbCBwcm9wZXJ0aWVzIGFyZSByZWFjdGl2ZS4gSXQgYWxzbyBkb2VzIG5vdCBhdXRvLXVud3JhcCByZWZzIChldmVuIGF0IHRoZVxyXG4gKiByb290IGxldmVsKS5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIGZhbHNlLCBzaGFsbG93UmVhY3RpdmVIYW5kbGVycywgc2hhbGxvd0NvbGxlY3Rpb25IYW5kbGVycywgc2hhbGxvd1JlYWN0aXZlTWFwKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHJlYWRvbmx5IGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdC4gTm90ZSB0aGUgcmV0dXJuZWQgY29weSBpcyBub3RcclxuICogbWFkZSByZWFjdGl2ZSwgYnV0IGByZWFkb25seWAgY2FuIGJlIGNhbGxlZCBvbiBhbiBhbHJlYWR5IHJlYWN0aXZlIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlYWRvbmx5KHRhcmdldCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWN0aXZlT2JqZWN0KHRhcmdldCwgdHJ1ZSwgcmVhZG9ubHlIYW5kbGVycywgcmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHJlYWRvbmx5TWFwKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHJlYWN0aXZlLWNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdCBsZXZlbFxyXG4gKiBwcm9wZXJ0aWVzIGFyZSByZWFkb25seSwgYW5kIGRvZXMgTk9UIHVud3JhcCByZWZzIG5vciByZWN1cnNpdmVseSBjb252ZXJ0XHJcbiAqIHJldHVybmVkIHByb3BlcnRpZXMuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpbmcgdGhlIHByb3BzIHByb3h5IG9iamVjdCBmb3Igc3RhdGVmdWwgY29tcG9uZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIHNoYWxsb3dSZWFkb25seSh0YXJnZXQpIHtcclxuICAgIHJldHVybiBjcmVhdGVSZWFjdGl2ZU9iamVjdCh0YXJnZXQsIHRydWUsIHNoYWxsb3dSZWFkb25seUhhbmRsZXJzLCBzaGFsbG93UmVhZG9ubHlDb2xsZWN0aW9uSGFuZGxlcnMsIHNoYWxsb3dSZWFkb25seU1hcCk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhY3RpdmVPYmplY3QodGFyZ2V0LCBpc1JlYWRvbmx5LCBiYXNlSGFuZGxlcnMsIGNvbGxlY3Rpb25IYW5kbGVycywgcHJveHlNYXApIHtcclxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB2YWx1ZSBjYW5ub3QgYmUgbWFkZSByZWFjdGl2ZTogJHtTdHJpbmcodGFyZ2V0KX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBpcyBhbHJlYWR5IGEgUHJveHksIHJldHVybiBpdC5cclxuICAgIC8vIGV4Y2VwdGlvbjogY2FsbGluZyByZWFkb25seSgpIG9uIGEgcmVhY3RpdmUgb2JqZWN0XHJcbiAgICBpZiAodGFyZ2V0W1wiX192X3Jhd1wiIC8qIFJBVyAqL10gJiZcclxuICAgICAgICAhKGlzUmVhZG9ubHkgJiYgdGFyZ2V0W1wiX192X2lzUmVhY3RpdmVcIiAvKiBJU19SRUFDVElWRSAqL10pKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIHRhcmdldCBhbHJlYWR5IGhhcyBjb3JyZXNwb25kaW5nIFByb3h5XHJcbiAgICBjb25zdCBleGlzdGluZ1Byb3h5ID0gcHJveHlNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gICAgfVxyXG4gICAgLy8gb25seSBzcGVjaWZpYyB2YWx1ZSB0eXBlcyBjYW4gYmUgb2JzZXJ2ZWQuXHJcbiAgICBjb25zdCB0YXJnZXRUeXBlID0gZ2V0VGFyZ2V0VHlwZSh0YXJnZXQpO1xyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09IDAgLyogSU5WQUxJRCAqLykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIHRhcmdldFR5cGUgPT09IDIgLyogQ09MTEVDVElPTiAqLyA/IGNvbGxlY3Rpb25IYW5kbGVycyA6IGJhc2VIYW5kbGVycyk7XHJcbiAgICBwcm94eU1hcC5zZXQodGFyZ2V0LCBwcm94eSk7XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xyXG4gICAgaWYgKGlzUmVhZG9ubHkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWVbXCJfX3ZfcmF3XCIgLyogUkFXICovXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWVbXCJfX3ZfaXNSZWFjdGl2ZVwiIC8qIElTX1JFQUNUSVZFICovXSk7XHJcbn1cclxuZnVuY3Rpb24gaXNSZWFkb25seSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzUmVhZG9ubHlcIiAvKiBJU19SRUFET05MWSAqL10pO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlW1wiX192X2lzU2hhbGxvd1wiIC8qIElTX1NIQUxMT1cgKi9dKTtcclxufVxyXG5mdW5jdGlvbiBpc1Byb3h5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZSkgfHwgaXNSZWFkb25seSh2YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gdG9SYXcob2JzZXJ2ZWQpIHtcclxuICAgIGNvbnN0IHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJBVyAqL107XHJcbiAgICByZXR1cm4gcmF3ID8gdG9SYXcocmF3KSA6IG9ic2VydmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtSYXcodmFsdWUpIHtcclxuICAgIGRlZih2YWx1ZSwgXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi8sIHRydWUpO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmNvbnN0IHRvUmVhY3RpdmUgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSA/IHJlYWN0aXZlKHZhbHVlKSA6IHZhbHVlO1xyXG5jb25zdCB0b1JlYWRvbmx5ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgPyByZWFkb25seSh2YWx1ZSkgOiB2YWx1ZTtcblxuZnVuY3Rpb24gdHJhY2tSZWZWYWx1ZShyZWYpIHtcclxuICAgIGlmIChzaG91bGRUcmFjayAmJiBhY3RpdmVFZmZlY3QpIHtcclxuICAgICAgICByZWYgPSB0b1JhdyhyZWYpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgdHJhY2tFZmZlY3RzKHJlZi5kZXAgfHwgKHJlZi5kZXAgPSBjcmVhdGVEZXAoKSksIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBHRVQgKi8sXHJcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFja0VmZmVjdHMocmVmLmRlcCB8fCAocmVmLmRlcCA9IGNyZWF0ZURlcCgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWZWYWx1ZShyZWYsIG5ld1ZhbCkge1xyXG4gICAgcmVmID0gdG9SYXcocmVmKTtcclxuICAgIGlmIChyZWYuZGVwKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyRWZmZWN0cyhyZWYuZGVwLCB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIgLyogU0VUICovLFxyXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnLFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXJFZmZlY3RzKHJlZi5kZXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1JlZihyKSB7XHJcbiAgICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcmVmKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XHJcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWZJbXBsKHJhd1ZhbHVlLCBzaGFsbG93KTtcclxufVxyXG5jbGFzcyBSZWZJbXBsIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBfX3ZfaXNTaGFsbG93KSB7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNTaGFsbG93ID0gX192X2lzU2hhbGxvdztcclxuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmF3VmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfX3ZfaXNTaGFsbG93ID8gdmFsdWUgOiB0b1JlYWN0aXZlKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICB0cmFja1JlZlZhbHVlKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICBuZXdWYWwgPSB0aGlzLl9fdl9pc1NoYWxsb3cgPyBuZXdWYWwgOiB0b1JhdyhuZXdWYWwpO1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKG5ld1ZhbCwgdGhpcy5fcmF3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX192X2lzU2hhbGxvdyA/IG5ld1ZhbCA6IHRvUmVhY3RpdmUobmV3VmFsKTtcclxuICAgICAgICAgICAgdHJpZ2dlclJlZlZhbHVlKHRoaXMsIG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XHJcbiAgICB0cmlnZ2VyUmVmVmFsdWUocmVmLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyByZWYudmFsdWUgOiB2b2lkIDApO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVmKHJlZikge1xyXG4gICAgcmV0dXJuIGlzUmVmKHJlZikgPyByZWYudmFsdWUgOiByZWY7XHJcbn1cclxuY29uc3Qgc2hhbGxvd1Vud3JhcEhhbmRsZXJzID0ge1xyXG4gICAgZ2V0OiAodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSA9PiB1bnJlZihSZWZsZWN0LmdldCh0YXJnZXQsIGtleSwgcmVjZWl2ZXIpKSxcclxuICAgIHNldDogKHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpID0+IHtcclxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGlmIChpc1JlZihvbGRWYWx1ZSkgJiYgIWlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBvbGRWYWx1ZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgcmV0dXJuIGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpXHJcbiAgICAgICAgPyBvYmplY3RXaXRoUmVmc1xyXG4gICAgICAgIDogbmV3IFByb3h5KG9iamVjdFdpdGhSZWZzLCBzaGFsbG93VW53cmFwSGFuZGxlcnMpO1xyXG59XHJcbmNsYXNzIEN1c3RvbVJlZkltcGwge1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9yeSkge1xyXG4gICAgICAgIHRoaXMuZGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX192X2lzUmVmID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IGdldCwgc2V0IH0gPSBmYWN0b3J5KCgpID0+IHRyYWNrUmVmVmFsdWUodGhpcyksICgpID0+IHRyaWdnZXJSZWZWYWx1ZSh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5fZ2V0ID0gZ2V0O1xyXG4gICAgICAgIHRoaXMuX3NldCA9IHNldDtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0KG5ld1ZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHJldHVybiBuZXcgQ3VzdG9tUmVmSW1wbChmYWN0b3J5KTtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1Byb3h5KG9iamVjdCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmV0ID0gaXNBcnJheShvYmplY3QpID8gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpIDoge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgICByZXRba2V5XSA9IHRvUmVmKG9iamVjdCwga2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuY2xhc3MgT2JqZWN0UmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfb2JqZWN0LCBfa2V5LCBfZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fb2JqZWN0ID0gX29iamVjdDtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IF9kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgdGhpcy5fX3ZfaXNSZWYgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMuX29iamVjdFt0aGlzLl9rZXldO1xyXG4gICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IHZhbDtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IG5ld1ZhbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICBjb25zdCB2YWwgPSBvYmplY3Rba2V5XTtcclxuICAgIHJldHVybiBpc1JlZih2YWwpXHJcbiAgICAgICAgPyB2YWxcclxuICAgICAgICA6IG5ldyBPYmplY3RSZWZJbXBsKG9iamVjdCwga2V5LCBkZWZhdWx0VmFsdWUpO1xyXG59XG5cbmNsYXNzIENvbXB1dGVkUmVmSW1wbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXR0ZXIsIF9zZXR0ZXIsIGlzUmVhZG9ubHksIGlzU1NSKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gX3NldHRlcjtcclxuICAgICAgICB0aGlzLmRlcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9fdl9pc1JlZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyUmVmVmFsdWUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmVmZmVjdC5jb21wdXRlZCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5lZmZlY3QuYWN0aXZlID0gdGhpcy5fY2FjaGVhYmxlID0gIWlzU1NSO1xyXG4gICAgICAgIHRoaXNbXCJfX3ZfaXNSZWFkb25seVwiIC8qIElTX1JFQURPTkxZICovXSA9IGlzUmVhZG9ubHk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGNvbXB1dGVkIHJlZiBtYXkgZ2V0IHdyYXBwZWQgYnkgb3RoZXIgcHJveGllcyBlLmcuIHJlYWRvbmx5KCkgIzMzNzZcclxuICAgICAgICBjb25zdCBzZWxmID0gdG9SYXcodGhpcyk7XHJcbiAgICAgICAgdHJhY2tSZWZWYWx1ZShzZWxmKTtcclxuICAgICAgICBpZiAoc2VsZi5fZGlydHkgfHwgIXNlbGYuX2NhY2hlYWJsZSkge1xyXG4gICAgICAgICAgICBzZWxmLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZWxmLl92YWx1ZSA9IHNlbGYuZWZmZWN0LnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZi5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zZXR0ZXIobmV3VmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc1NTUiA9IGZhbHNlKSB7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IHNldHRlcjtcclxuICAgIGNvbnN0IG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XHJcbiAgICBpZiAob25seUdldHRlcikge1xyXG4gICAgICAgIGdldHRlciA9IGdldHRlck9yT3B0aW9ucztcclxuICAgICAgICBzZXR0ZXIgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgPyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcclxuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY1JlZiA9IG5ldyBDb21wdXRlZFJlZkltcGwoZ2V0dGVyLCBzZXR0ZXIsIG9ubHlHZXR0ZXIgfHwgIXNldHRlciwgaXNTU1IpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBkZWJ1Z09wdGlvbnMgJiYgIWlzU1NSKSB7XHJcbiAgICAgICAgY1JlZi5lZmZlY3Qub25UcmFjayA9IGRlYnVnT3B0aW9ucy5vblRyYWNrO1xyXG4gICAgICAgIGNSZWYuZWZmZWN0Lm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY1JlZjtcclxufVxuXG5jb25zdCBzdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwdXNoV2FybmluZ0NvbnRleHQodm5vZGUpIHtcclxuICAgIHN0YWNrLnB1c2godm5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIHBvcFdhcm5pbmdDb250ZXh0KCkge1xyXG4gICAgc3RhY2sucG9wKCk7XHJcbn1cclxuZnVuY3Rpb24gd2FybiQxKG1zZywgLi4uYXJncykge1xyXG4gICAgLy8gYXZvaWQgcHJvcHMgZm9ybWF0dGluZyBvciB3YXJuIGhhbmRsZXIgdHJhY2tpbmcgZGVwcyB0aGF0IG1pZ2h0IGJlIG11dGF0ZWRcclxuICAgIC8vIGR1cmluZyBwYXRjaCwgbGVhZGluZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXHJcbiAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IHN0YWNrLmxlbmd0aCA/IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmNvbXBvbmVudCA6IG51bGw7XHJcbiAgICBjb25zdCBhcHBXYXJuSGFuZGxlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLndhcm5IYW5kbGVyO1xyXG4gICAgY29uc3QgdHJhY2UgPSBnZXRDb21wb25lbnRUcmFjZSgpO1xyXG4gICAgaWYgKGFwcFdhcm5IYW5kbGVyKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGFwcFdhcm5IYW5kbGVyLCBpbnN0YW5jZSwgMTEgLyogQVBQX1dBUk5fSEFORExFUiAqLywgW1xyXG4gICAgICAgICAgICBtc2cgKyBhcmdzLmpvaW4oJycpLFxyXG4gICAgICAgICAgICBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wcm94eSxcclxuICAgICAgICAgICAgdHJhY2VcclxuICAgICAgICAgICAgICAgIC5tYXAoKHsgdm5vZGUgfSkgPT4gYGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIHZub2RlLnR5cGUpfT5gKVxyXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpLFxyXG4gICAgICAgICAgICB0cmFjZVxyXG4gICAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgd2FybkFyZ3MgPSBbYFtWdWUgd2Fybl06ICR7bXNnfWAsIC4uLmFyZ3NdO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmICh0cmFjZS5sZW5ndGggJiZcclxuICAgICAgICAgICAgLy8gYXZvaWQgc3BhbW1pbmcgY29uc29sZSBkdXJpbmcgdGVzdHNcclxuICAgICAgICAgICAgIWZhbHNlKSB7XHJcbiAgICAgICAgICAgIHdhcm5BcmdzLnB1c2goYFxcbmAsIC4uLmZvcm1hdFRyYWNlKHRyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUud2FybiguLi53YXJuQXJncyk7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYWNraW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VHJhY2UoKSB7XHJcbiAgICBsZXQgY3VycmVudFZOb2RlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICBpZiAoIWN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIC8vIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBzdGFjayBiZWNhdXNlIGl0IHdpbGwgYmUgaW5jb21wbGV0ZSBkdXJpbmcgdXBkYXRlc1xyXG4gICAgLy8gdGhhdCBkaWQgbm90IHN0YXJ0IGZyb20gdGhlIHJvb3QuIFJlLWNvbnN0cnVjdCB0aGUgcGFyZW50IGNoYWluIHVzaW5nXHJcbiAgICAvLyBpbnN0YW5jZSBwYXJlbnQgcG9pbnRlcnMuXHJcbiAgICBjb25zdCBub3JtYWxpemVkU3RhY2sgPSBbXTtcclxuICAgIHdoaWxlIChjdXJyZW50Vk5vZGUpIHtcclxuICAgICAgICBjb25zdCBsYXN0ID0gbm9ybWFsaXplZFN0YWNrWzBdO1xyXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3Qudm5vZGUgPT09IGN1cnJlbnRWTm9kZSkge1xyXG4gICAgICAgICAgICBsYXN0LnJlY3Vyc2VDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdm5vZGU6IGN1cnJlbnRWTm9kZSxcclxuICAgICAgICAgICAgICAgIHJlY3Vyc2VDb3VudDogMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50SW5zdGFuY2UgPSBjdXJyZW50Vk5vZGUuY29tcG9uZW50ICYmIGN1cnJlbnRWTm9kZS5jb21wb25lbnQucGFyZW50O1xyXG4gICAgICAgIGN1cnJlbnRWTm9kZSA9IHBhcmVudEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlLnZub2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRTdGFjaztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRUcmFjZSh0cmFjZSkge1xyXG4gICAgY29uc3QgbG9ncyA9IFtdO1xyXG4gICAgdHJhY2UuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcclxuICAgICAgICBsb2dzLnB1c2goLi4uKGkgPT09IDAgPyBbXSA6IFtgXFxuYF0pLCAuLi5mb3JtYXRUcmFjZUVudHJ5KGVudHJ5KSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBsb2dzO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFRyYWNlRW50cnkoeyB2bm9kZSwgcmVjdXJzZUNvdW50IH0pIHtcclxuICAgIGNvbnN0IHBvc3RmaXggPSByZWN1cnNlQ291bnQgPiAwID8gYC4uLiAoJHtyZWN1cnNlQ291bnR9IHJlY3Vyc2l2ZSBjYWxscylgIDogYGA7XHJcbiAgICBjb25zdCBpc1Jvb3QgPSB2bm9kZS5jb21wb25lbnQgPyB2bm9kZS5jb21wb25lbnQucGFyZW50ID09IG51bGwgOiBmYWxzZTtcclxuICAgIGNvbnN0IG9wZW4gPSBgIGF0IDwke2Zvcm1hdENvbXBvbmVudE5hbWUodm5vZGUuY29tcG9uZW50LCB2bm9kZS50eXBlLCBpc1Jvb3QpfWA7XHJcbiAgICBjb25zdCBjbG9zZSA9IGA+YCArIHBvc3RmaXg7XHJcbiAgICByZXR1cm4gdm5vZGUucHJvcHNcclxuICAgICAgICA/IFtvcGVuLCAuLi5mb3JtYXRQcm9wcyh2bm9kZS5wcm9wcyksIGNsb3NlXVxyXG4gICAgICAgIDogW29wZW4gKyBjbG9zZV07XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gZm9ybWF0UHJvcHMocHJvcHMpIHtcclxuICAgIGNvbnN0IHJlcyA9IFtdO1xyXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKTtcclxuICAgIGtleXMuc2xpY2UoMCwgMykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgIHJlcy5wdXNoKC4uLmZvcm1hdFByb3Aoa2V5LCBwcm9wc1trZXldKSk7XHJcbiAgICB9KTtcclxuICAgIGlmIChrZXlzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICByZXMucHVzaChgIC4uLmApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBmb3JtYXRQcm9wKGtleSwgdmFsdWUsIHJhdykge1xyXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByYXcgPyB2YWx1ZSA6IFtgJHtrZXl9PSR7dmFsdWV9YF07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcclxuICAgICAgICB2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09JHt2YWx1ZX1gXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVmKHZhbHVlKSkge1xyXG4gICAgICAgIHZhbHVlID0gZm9ybWF0UHJvcChrZXksIHRvUmF3KHZhbHVlLnZhbHVlKSwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09UmVmPGAsIHZhbHVlLCBgPmBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gW2Ake2tleX09Zm4ke3ZhbHVlLm5hbWUgPyBgPCR7dmFsdWUubmFtZX0+YCA6IGBgfWBdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b1Jhdyh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHJhdyA/IHZhbHVlIDogW2Ake2tleX09YCwgdmFsdWVdO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IEVycm9yVHlwZVN0cmluZ3MgPSB7XHJcbiAgICBbXCJzcFwiIC8qIFNFUlZFUl9QUkVGRVRDSCAqL106ICdzZXJ2ZXJQcmVmZXRjaCBob29rJyxcclxuICAgIFtcImJjXCIgLyogQkVGT1JFX0NSRUFURSAqL106ICdiZWZvcmVDcmVhdGUgaG9vaycsXHJcbiAgICBbXCJjXCIgLyogQ1JFQVRFRCAqL106ICdjcmVhdGVkIGhvb2snLFxyXG4gICAgW1wiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi9dOiAnYmVmb3JlTW91bnQgaG9vaycsXHJcbiAgICBbXCJtXCIgLyogTU9VTlRFRCAqL106ICdtb3VudGVkIGhvb2snLFxyXG4gICAgW1wiYnVcIiAvKiBCRUZPUkVfVVBEQVRFICovXTogJ2JlZm9yZVVwZGF0ZSBob29rJyxcclxuICAgIFtcInVcIiAvKiBVUERBVEVEICovXTogJ3VwZGF0ZWQnLFxyXG4gICAgW1wiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi9dOiAnYmVmb3JlVW5tb3VudCBob29rJyxcclxuICAgIFtcInVtXCIgLyogVU5NT1VOVEVEICovXTogJ3VubW91bnRlZCBob29rJyxcclxuICAgIFtcImFcIiAvKiBBQ1RJVkFURUQgKi9dOiAnYWN0aXZhdGVkIGhvb2snLFxyXG4gICAgW1wiZGFcIiAvKiBERUFDVElWQVRFRCAqL106ICdkZWFjdGl2YXRlZCBob29rJyxcclxuICAgIFtcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi9dOiAnZXJyb3JDYXB0dXJlZCBob29rJyxcclxuICAgIFtcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovXTogJ3JlbmRlclRyYWNrZWQgaG9vaycsXHJcbiAgICBbXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovXTogJ3JlbmRlclRyaWdnZXJlZCBob29rJyxcclxuICAgIFswIC8qIFNFVFVQX0ZVTkNUSU9OICovXTogJ3NldHVwIGZ1bmN0aW9uJyxcclxuICAgIFsxIC8qIFJFTkRFUl9GVU5DVElPTiAqL106ICdyZW5kZXIgZnVuY3Rpb24nLFxyXG4gICAgWzIgLyogV0FUQ0hfR0VUVEVSICovXTogJ3dhdGNoZXIgZ2V0dGVyJyxcclxuICAgIFszIC8qIFdBVENIX0NBTExCQUNLICovXTogJ3dhdGNoZXIgY2FsbGJhY2snLFxyXG4gICAgWzQgLyogV0FUQ0hfQ0xFQU5VUCAqL106ICd3YXRjaGVyIGNsZWFudXAgZnVuY3Rpb24nLFxyXG4gICAgWzUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi9dOiAnbmF0aXZlIGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzYgLyogQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVIgKi9dOiAnY29tcG9uZW50IGV2ZW50IGhhbmRsZXInLFxyXG4gICAgWzcgLyogVk5PREVfSE9PSyAqL106ICd2bm9kZSBob29rJyxcclxuICAgIFs4IC8qIERJUkVDVElWRV9IT09LICovXTogJ2RpcmVjdGl2ZSBob29rJyxcclxuICAgIFs5IC8qIFRSQU5TSVRJT05fSE9PSyAqL106ICd0cmFuc2l0aW9uIGhvb2snLFxyXG4gICAgWzEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovXTogJ2FwcCBlcnJvckhhbmRsZXInLFxyXG4gICAgWzExIC8qIEFQUF9XQVJOX0hBTkRMRVIgKi9dOiAnYXBwIHdhcm5IYW5kbGVyJyxcclxuICAgIFsxMiAvKiBGVU5DVElPTl9SRUYgKi9dOiAncmVmIGZ1bmN0aW9uJyxcclxuICAgIFsxMyAvKiBBU1lOQ19DT01QT05FTlRfTE9BREVSICovXTogJ2FzeW5jIGNvbXBvbmVudCBsb2FkZXInLFxyXG4gICAgWzE0IC8qIFNDSEVEVUxFUiAqL106ICdzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuICcgK1xyXG4gICAgICAgICdQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL25ldy1pc3N1ZS52dWVqcy5vcmcvP3JlcG89dnVlanMvY29yZSdcclxufTtcclxuZnVuY3Rpb24gY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgdHlwZSwgYXJncykge1xyXG4gICAgbGV0IHJlcztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzID0gYXJncyA/IGZuKC4uLmFyZ3MpIDogZm4oKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoZm4sIGluc3RhbmNlLCB0eXBlLCBhcmdzKTtcclxuICAgICAgICBpZiAocmVzICYmIGlzUHJvbWlzZShyZXMpKSB7XHJcbiAgICAgICAgICAgIHJlcy5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzLnB1c2goY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoZm5baV0sIGluc3RhbmNlLCB0eXBlLCBhcmdzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVzO1xyXG59XHJcbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIHR5cGUsIHRocm93SW5EZXYgPSB0cnVlKSB7XHJcbiAgICBjb25zdCBjb250ZXh0Vk5vZGUgPSBpbnN0YW5jZSA/IGluc3RhbmNlLnZub2RlIDogbnVsbDtcclxuICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgIGxldCBjdXIgPSBpbnN0YW5jZS5wYXJlbnQ7XHJcbiAgICAgICAgLy8gdGhlIGV4cG9zZWQgaW5zdGFuY2UgaXMgdGhlIHJlbmRlciBwcm94eSB0byBrZWVwIGl0IGNvbnNpc3RlbnQgd2l0aCAyLnhcclxuICAgICAgICBjb25zdCBleHBvc2VkSW5zdGFuY2UgPSBpbnN0YW5jZS5wcm94eTtcclxuICAgICAgICAvLyBpbiBwcm9kdWN0aW9uIHRoZSBob29rIHJlY2VpdmVzIG9ubHkgdGhlIGVycm9yIGNvZGVcclxuICAgICAgICBjb25zdCBlcnJvckluZm8gPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBFcnJvclR5cGVTdHJpbmdzW3R5cGVdIDogdHlwZTtcclxuICAgICAgICB3aGlsZSAoY3VyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQ2FwdHVyZWRIb29rcyA9IGN1ci5lYztcclxuICAgICAgICAgICAgaWYgKGVycm9yQ2FwdHVyZWRIb29rcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvckNhcHR1cmVkSG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYXB0dXJlZEhvb2tzW2ldKGVyciwgZXhwb3NlZEluc3RhbmNlLCBlcnJvckluZm8pID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFwcC1sZXZlbCBoYW5kbGluZ1xyXG4gICAgICAgIGNvbnN0IGFwcEVycm9ySGFuZGxlciA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmVycm9ySGFuZGxlcjtcclxuICAgICAgICBpZiAoYXBwRXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhhcHBFcnJvckhhbmRsZXIsIG51bGwsIDEwIC8qIEFQUF9FUlJPUl9IQU5ETEVSICovLCBbZXJyLCBleHBvc2VkSW5zdGFuY2UsIGVycm9ySW5mb10pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nRXJyb3IoZXJyLCB0eXBlLCBjb250ZXh0Vk5vZGUsIHRocm93SW5EZXYpO1xyXG59XHJcbmZ1bmN0aW9uIGxvZ0Vycm9yKGVyciwgdHlwZSwgY29udGV4dFZOb2RlLCB0aHJvd0luRGV2ID0gdHJ1ZSkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBFcnJvclR5cGVTdHJpbmdzW3R5cGVdO1xyXG4gICAgICAgIGlmIChjb250ZXh0Vk5vZGUpIHtcclxuICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KGNvbnRleHRWTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdhcm4kMShgVW5oYW5kbGVkIGVycm9yJHtpbmZvID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aW5mb31gIDogYGB9YCk7XHJcbiAgICAgICAgaWYgKGNvbnRleHRWTm9kZSkge1xyXG4gICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmFzaCBpbiBkZXYgYnkgZGVmYXVsdCBzbyBpdCdzIG1vcmUgbm90aWNlYWJsZVxyXG4gICAgICAgIGlmICh0aHJvd0luRGV2KSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZWNvdmVyIGluIHByb2QgdG8gcmVkdWNlIHRoZSBpbXBhY3Qgb24gZW5kLXVzZXJcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICB9XHJcbn1cblxubGV0IGlzRmx1c2hpbmcgPSBmYWxzZTtcclxubGV0IGlzRmx1c2hQZW5kaW5nID0gZmFsc2U7XHJcbmNvbnN0IHF1ZXVlID0gW107XHJcbmxldCBmbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1ByZUZsdXNoQ2JzID0gW107XHJcbmxldCBhY3RpdmVQcmVGbHVzaENicyA9IG51bGw7XHJcbmxldCBwcmVGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcGVuZGluZ1Bvc3RGbHVzaENicyA9IFtdO1xyXG5sZXQgYWN0aXZlUG9zdEZsdXNoQ2JzID0gbnVsbDtcclxubGV0IHBvc3RGbHVzaEluZGV4ID0gMDtcclxuY29uc3QgcmVzb2x2ZWRQcm9taXNlID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcclxubGV0IGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xyXG5sZXQgY3VycmVudFByZUZsdXNoUGFyZW50Sm9iID0gbnVsbDtcclxuY29uc3QgUkVDVVJTSU9OX0xJTUlUID0gMTAwO1xyXG5mdW5jdGlvbiBuZXh0VGljayhmbikge1xyXG4gICAgY29uc3QgcCA9IGN1cnJlbnRGbHVzaFByb21pc2UgfHwgcmVzb2x2ZWRQcm9taXNlO1xyXG4gICAgcmV0dXJuIGZuID8gcC50aGVuKHRoaXMgPyBmbi5iaW5kKHRoaXMpIDogZm4pIDogcDtcclxufVxyXG4vLyAjMjc2OFxyXG4vLyBVc2UgYmluYXJ5LXNlYXJjaCB0byBmaW5kIGEgc3VpdGFibGUgcG9zaXRpb24gaW4gdGhlIHF1ZXVlLFxyXG4vLyBzbyB0aGF0IHRoZSBxdWV1ZSBtYWludGFpbnMgdGhlIGluY3JlYXNpbmcgb3JkZXIgb2Ygam9iJ3MgaWQsXHJcbi8vIHdoaWNoIGNhbiBwcmV2ZW50IHRoZSBqb2IgZnJvbSBiZWluZyBza2lwcGVkIGFuZCBhbHNvIGNhbiBhdm9pZCByZXBlYXRlZCBwYXRjaGluZy5cclxuZnVuY3Rpb24gZmluZEluc2VydGlvbkluZGV4KGlkKSB7XHJcbiAgICAvLyB0aGUgc3RhcnQgaW5kZXggc2hvdWxkIGJlIGBmbHVzaEluZGV4ICsgMWBcclxuICAgIGxldCBzdGFydCA9IGZsdXNoSW5kZXggKyAxO1xyXG4gICAgbGV0IGVuZCA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IChzdGFydCArIGVuZCkgPj4+IDE7XHJcbiAgICAgICAgY29uc3QgbWlkZGxlSm9iSWQgPSBnZXRJZChxdWV1ZVttaWRkbGVdKTtcclxuICAgICAgICBtaWRkbGVKb2JJZCA8IGlkID8gKHN0YXJ0ID0gbWlkZGxlICsgMSkgOiAoZW5kID0gbWlkZGxlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGFydDtcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUpvYihqb2IpIHtcclxuICAgIC8vIHRoZSBkZWR1cGUgc2VhcmNoIHVzZXMgdGhlIHN0YXJ0SW5kZXggYXJndW1lbnQgb2YgQXJyYXkuaW5jbHVkZXMoKVxyXG4gICAgLy8gYnkgZGVmYXVsdCB0aGUgc2VhcmNoIGluZGV4IGluY2x1ZGVzIHRoZSBjdXJyZW50IGpvYiB0aGF0IGlzIGJlaW5nIHJ1blxyXG4gICAgLy8gc28gaXQgY2Fubm90IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIGFnYWluLlxyXG4gICAgLy8gaWYgdGhlIGpvYiBpcyBhIHdhdGNoKCkgY2FsbGJhY2ssIHRoZSBzZWFyY2ggd2lsbCBzdGFydCB3aXRoIGEgKzEgaW5kZXggdG9cclxuICAgIC8vIGFsbG93IGl0IHJlY3Vyc2l2ZWx5IHRyaWdnZXIgaXRzZWxmIC0gaXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0b1xyXG4gICAgLy8gZW5zdXJlIGl0IGRvZXNuJ3QgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3AuXHJcbiAgICBpZiAoKCFxdWV1ZS5sZW5ndGggfHxcclxuICAgICAgICAhcXVldWUuaW5jbHVkZXMoam9iLCBpc0ZsdXNoaW5nICYmIGpvYi5hbGxvd1JlY3Vyc2UgPyBmbHVzaEluZGV4ICsgMSA6IGZsdXNoSW5kZXgpKSAmJlxyXG4gICAgICAgIGpvYiAhPT0gY3VycmVudFByZUZsdXNoUGFyZW50Sm9iKSB7XHJcbiAgICAgICAgaWYgKGpvYi5pZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goam9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShmaW5kSW5zZXJ0aW9uSW5kZXgoam9iLmlkKSwgMCwgam9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVGbHVzaCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlRmx1c2goKSB7XHJcbiAgICBpZiAoIWlzRmx1c2hpbmcgJiYgIWlzRmx1c2hQZW5kaW5nKSB7XHJcbiAgICAgICAgaXNGbHVzaFBlbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSByZXNvbHZlZFByb21pc2UudGhlbihmbHVzaEpvYnMpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGludmFsaWRhdGVKb2Ioam9iKSB7XHJcbiAgICBjb25zdCBpID0gcXVldWUuaW5kZXhPZihqb2IpO1xyXG4gICAgaWYgKGkgPiBmbHVzaEluZGV4KSB7XHJcbiAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlQ2IoY2IsIGFjdGl2ZVF1ZXVlLCBwZW5kaW5nUXVldWUsIGluZGV4KSB7XHJcbiAgICBpZiAoIWlzQXJyYXkoY2IpKSB7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVRdWV1ZSB8fFxyXG4gICAgICAgICAgICAhYWN0aXZlUXVldWUuaW5jbHVkZXMoY2IsIGNiLmFsbG93UmVjdXJzZSA/IGluZGV4ICsgMSA6IGluZGV4KSkge1xyXG4gICAgICAgICAgICBwZW5kaW5nUXVldWUucHVzaChjYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgY2IgaXMgYW4gYXJyYXksIGl0IGlzIGEgY29tcG9uZW50IGxpZmVjeWNsZSBob29rIHdoaWNoIGNhbiBvbmx5IGJlXHJcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5IGEgam9iLCB3aGljaCBpcyBhbHJlYWR5IGRlZHVwZWQgaW4gdGhlIG1haW4gcXVldWUsIHNvXHJcbiAgICAgICAgLy8gd2UgY2FuIHNraXAgZHVwbGljYXRlIGNoZWNrIGhlcmUgdG8gaW1wcm92ZSBwZXJmXHJcbiAgICAgICAgcGVuZGluZ1F1ZXVlLnB1c2goLi4uY2IpO1xyXG4gICAgfVxyXG4gICAgcXVldWVGbHVzaCgpO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXVlUHJlRmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUHJlRmx1c2hDYnMsIHBlbmRpbmdQcmVGbHVzaENicywgcHJlRmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gcXVldWVQb3N0Rmx1c2hDYihjYikge1xyXG4gICAgcXVldWVDYihjYiwgYWN0aXZlUG9zdEZsdXNoQ2JzLCBwZW5kaW5nUG9zdEZsdXNoQ2JzLCBwb3N0Rmx1c2hJbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gZmx1c2hQcmVGbHVzaENicyhzZWVuLCBwYXJlbnRKb2IgPSBudWxsKSB7XHJcbiAgICBpZiAocGVuZGluZ1ByZUZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgIGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IHBhcmVudEpvYjtcclxuICAgICAgICBhY3RpdmVQcmVGbHVzaENicyA9IFsuLi5uZXcgU2V0KHBlbmRpbmdQcmVGbHVzaENicyldO1xyXG4gICAgICAgIHBlbmRpbmdQcmVGbHVzaENicy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHByZUZsdXNoSW5kZXggPSAwOyBwcmVGbHVzaEluZGV4IDwgYWN0aXZlUHJlRmx1c2hDYnMubGVuZ3RoOyBwcmVGbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGFjdGl2ZVByZUZsdXNoQ2JzW3ByZUZsdXNoSW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnNbcHJlRmx1c2hJbmRleF0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYWN0aXZlUHJlRmx1c2hDYnMgPSBudWxsO1xyXG4gICAgICAgIHByZUZsdXNoSW5kZXggPSAwO1xyXG4gICAgICAgIGN1cnJlbnRQcmVGbHVzaFBhcmVudEpvYiA9IG51bGw7XHJcbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmx1c2ggdW50aWwgaXQgZHJhaW5zXHJcbiAgICAgICAgZmx1c2hQcmVGbHVzaENicyhzZWVuLCBwYXJlbnRKb2IpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGZsdXNoUG9zdEZsdXNoQ2JzKHNlZW4pIHtcclxuICAgIC8vIGZsdXNoIGFueSBwcmUgY2JzIHF1ZXVlZCBkdXJpbmcgdGhlIGZsdXNoIChlLmcuIHByZSB3YXRjaGVycylcclxuICAgIGZsdXNoUHJlRmx1c2hDYnMoKTtcclxuICAgIGlmIChwZW5kaW5nUG9zdEZsdXNoQ2JzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGRlZHVwZWQgPSBbLi4ubmV3IFNldChwZW5kaW5nUG9zdEZsdXNoQ2JzKV07XHJcbiAgICAgICAgcGVuZGluZ1Bvc3RGbHVzaENicy5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vICMxOTQ3IGFscmVhZHkgaGFzIGFjdGl2ZSBxdWV1ZSwgbmVzdGVkIGZsdXNoUG9zdEZsdXNoQ2JzIGNhbGxcclxuICAgICAgICBpZiAoYWN0aXZlUG9zdEZsdXNoQ2JzKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5wdXNoKC4uLmRlZHVwZWQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicyA9IGRlZHVwZWQ7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjdGl2ZVBvc3RGbHVzaENicy5zb3J0KChhLCBiKSA9PiBnZXRJZChhKSAtIGdldElkKGIpKTtcclxuICAgICAgICBmb3IgKHBvc3RGbHVzaEluZGV4ID0gMDsgcG9zdEZsdXNoSW5kZXggPCBhY3RpdmVQb3N0Rmx1c2hDYnMubGVuZ3RoOyBwb3N0Rmx1c2hJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBhY3RpdmVQb3N0Rmx1c2hDYnNbcG9zdEZsdXNoSW5kZXhdKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aXZlUG9zdEZsdXNoQ2JzW3Bvc3RGbHVzaEluZGV4XSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhY3RpdmVQb3N0Rmx1c2hDYnMgPSBudWxsO1xyXG4gICAgICAgIHBvc3RGbHVzaEluZGV4ID0gMDtcclxuICAgIH1cclxufVxyXG5jb25zdCBnZXRJZCA9IChqb2IpID0+IGpvYi5pZCA9PSBudWxsID8gSW5maW5pdHkgOiBqb2IuaWQ7XHJcbmZ1bmN0aW9uIGZsdXNoSm9icyhzZWVuKSB7XHJcbiAgICBpc0ZsdXNoUGVuZGluZyA9IGZhbHNlO1xyXG4gICAgaXNGbHVzaGluZyA9IHRydWU7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZmx1c2hQcmVGbHVzaENicyhzZWVuKTtcclxuICAgIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxyXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XHJcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXHJcbiAgICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQgc28gaXRzIHJlbmRlciBlZmZlY3Qgd2lsbCBoYXZlIHNtYWxsZXJcclxuICAgIC8vICAgIHByaW9yaXR5IG51bWJlcilcclxuICAgIC8vIDIuIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3MgdXBkYXRlLFxyXG4gICAgLy8gICAgaXRzIHVwZGF0ZSBjYW4gYmUgc2tpcHBlZC5cclxuICAgIHF1ZXVlLnNvcnQoKGEsIGIpID0+IGdldElkKGEpIC0gZ2V0SWQoYikpO1xyXG4gICAgLy8gY29uZGl0aW9uYWwgdXNhZ2Ugb2YgY2hlY2tSZWN1cnNpdmVVcGRhdGUgbXVzdCBiZSBkZXRlcm1pbmVkIG91dCBvZlxyXG4gICAgLy8gdHJ5IC4uLiBjYXRjaCBibG9jayBzaW5jZSBSb2xsdXAgYnkgZGVmYXVsdCBkZS1vcHRpbWl6ZXMgdHJlZXNoYWtpbmdcclxuICAgIC8vIGluc2lkZSB0cnktY2F0Y2guIFRoaXMgY2FuIGxlYXZlIGFsbCB3YXJuaW5nIGNvZGUgdW5zaGFrZWQuIEFsdGhvdWdoXHJcbiAgICAvLyB0aGV5IHdvdWxkIGdldCBldmVudHVhbGx5IHNoYWtlbiBieSBhIG1pbmlmaWVyIGxpa2UgdGVyc2VyLCBzb21lIG1pbmlmaWVyc1xyXG4gICAgLy8gd291bGQgZmFpbCB0byBkbyB0aGF0IChlLmcuIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9lc2J1aWxkL2lzc3Vlcy8xNjEwKVxyXG4gICAgY29uc3QgY2hlY2sgPSAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICA/IChqb2IpID0+IGNoZWNrUmVjdXJzaXZlVXBkYXRlcyhzZWVuLCBqb2IpXHJcbiAgICAgICAgOiBOT09QO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBmb3IgKGZsdXNoSW5kZXggPSAwOyBmbHVzaEluZGV4IDwgcXVldWUubGVuZ3RoOyBmbHVzaEluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3Qgam9iID0gcXVldWVbZmx1c2hJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChqb2IgJiYgam9iLmFjdGl2ZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY2hlY2soam9iKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYHJ1bm5pbmc6YCwgam9iLmlkKVxyXG4gICAgICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGpvYiwgbnVsbCwgMTQgLyogU0NIRURVTEVSICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIGZsdXNoSW5kZXggPSAwO1xyXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoc2Vlbik7XHJcbiAgICAgICAgaXNGbHVzaGluZyA9IGZhbHNlO1xyXG4gICAgICAgIGN1cnJlbnRGbHVzaFByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIC8vIHNvbWUgcG9zdEZsdXNoQ2IgcXVldWVkIGpvYnMhXHJcbiAgICAgICAgLy8ga2VlcCBmbHVzaGluZyB1bnRpbCBpdCBkcmFpbnMuXHJcbiAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICBwZW5kaW5nUHJlRmx1c2hDYnMubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIHBlbmRpbmdQb3N0Rmx1c2hDYnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZsdXNoSm9icyhzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tSZWN1cnNpdmVVcGRhdGVzKHNlZW4sIGZuKSB7XHJcbiAgICBpZiAoIXNlZW4uaGFzKGZuKSkge1xyXG4gICAgICAgIHNlZW4uc2V0KGZuLCAxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gc2Vlbi5nZXQoZm4pO1xyXG4gICAgICAgIGlmIChjb3VudCA+IFJFQ1VSU0lPTl9MSU1JVCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGZuLm93bmVySW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBpbnN0YW5jZSAmJiBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpO1xyXG4gICAgICAgICAgICB3YXJuJDEoYE1heGltdW0gcmVjdXJzaXZlIHVwZGF0ZXMgZXhjZWVkZWQke2NvbXBvbmVudE5hbWUgPyBgIGluIGNvbXBvbmVudCA8JHtjb21wb25lbnROYW1lfT5gIDogYGB9LiBgICtcclxuICAgICAgICAgICAgICAgIGBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBgICtcclxuICAgICAgICAgICAgICAgIGBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgYCArXHJcbiAgICAgICAgICAgICAgICBgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNlZW4uc2V0KGZuLCBjb3VudCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxubGV0IGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuY29uc3QgaG1yRGlydHlDb21wb25lbnRzID0gbmV3IFNldCgpO1xyXG4vLyBFeHBvc2UgdGhlIEhNUiBydW50aW1lIG9uIHRoZSBnbG9iYWwgb2JqZWN0XHJcbi8vIFRoaXMgbWFrZXMgaXQgZW50aXJlbHkgdHJlZS1zaGFrYWJsZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgZXhwb3J0cyBhbmQgbWFrZXNcclxuLy8gaXQgZWFzaWVyIHRvIGJlIHVzZWQgaW4gdG9vbGluZ3MgbGlrZSB2dWUtbG9hZGVyXHJcbi8vIE5vdGU6IGZvciBhIGNvbXBvbmVudCB0byBiZSBlbGlnaWJsZSBmb3IgSE1SIGl0IGFsc28gbmVlZHMgdGhlIF9faG1ySWQgb3B0aW9uXHJcbi8vIHRvIGJlIHNldCBzbyB0aGF0IGl0cyBpbnN0YW5jZXMgY2FuIGJlIHJlZ2lzdGVyZWQgLyByZW1vdmVkLlxyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcclxuICAgICAgICBjcmVhdGVSZWNvcmQ6IHRyeVdyYXAoY3JlYXRlUmVjb3JkKSxcclxuICAgICAgICByZXJlbmRlcjogdHJ5V3JhcChyZXJlbmRlciksXHJcbiAgICAgICAgcmVsb2FkOiB0cnlXcmFwKHJlbG9hZClcclxuICAgIH07XHJcbn1cclxuY29uc3QgbWFwID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiByZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgaWQgPSBpbnN0YW5jZS50eXBlLl9faG1ySWQ7XHJcbiAgICBsZXQgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIGNyZWF0ZVJlY29yZChpZCwgaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICB9XHJcbiAgICByZWNvcmQuaW5zdGFuY2VzLmFkZChpbnN0YW5jZSk7XHJcbn1cclxuZnVuY3Rpb24gdW5yZWdpc3RlckhNUihpbnN0YW5jZSkge1xyXG4gICAgbWFwLmdldChpbnN0YW5jZS50eXBlLl9faG1ySWQpLmluc3RhbmNlcy5kZWxldGUoaW5zdGFuY2UpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZChpZCwgaW5pdGlhbERlZikge1xyXG4gICAgaWYgKG1hcC5oYXMoaWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWFwLnNldChpZCwge1xyXG4gICAgICAgIGluaXRpYWxEZWY6IG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluaXRpYWxEZWYpLFxyXG4gICAgICAgIGluc3RhbmNlczogbmV3IFNldCgpXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSA/IGNvbXBvbmVudC5fX3ZjY09wdHMgOiBjb21wb25lbnQ7XHJcbn1cclxuZnVuY3Rpb24gcmVyZW5kZXIoaWQsIG5ld1JlbmRlcikge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHVwZGF0ZSBpbml0aWFsIHJlY29yZCAoZm9yIG5vdC15ZXQtcmVuZGVyZWQgY29tcG9uZW50KVxyXG4gICAgcmVjb3JkLmluaXRpYWxEZWYucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgWy4uLnJlY29yZC5pbnN0YW5jZXNdLmZvckVhY2goaW5zdGFuY2UgPT4ge1xyXG4gICAgICAgIGlmIChuZXdSZW5kZXIpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UucmVuZGVyID0gbmV3UmVuZGVyO1xyXG4gICAgICAgICAgICBub3JtYWxpemVDbGFzc0NvbXBvbmVudChpbnN0YW5jZS50eXBlKS5yZW5kZXIgPSBuZXdSZW5kZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlckNhY2hlID0gW107XHJcbiAgICAgICAgLy8gdGhpcyBmbGFnIGZvcmNlcyBjaGlsZCBjb21wb25lbnRzIHdpdGggc2xvdCBjb250ZW50IHRvIHVwZGF0ZVxyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlzSG1yVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlbG9hZChpZCwgbmV3Q29tcCkge1xyXG4gICAgY29uc3QgcmVjb3JkID0gbWFwLmdldChpZCk7XHJcbiAgICBpZiAoIXJlY29yZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBuZXdDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQobmV3Q29tcCk7XHJcbiAgICAvLyB1cGRhdGUgaW5pdGlhbCBkZWYgKGZvciBub3QteWV0LXJlbmRlcmVkIGNvbXBvbmVudHMpXHJcbiAgICB1cGRhdGVDb21wb25lbnREZWYocmVjb3JkLmluaXRpYWxEZWYsIG5ld0NvbXApO1xyXG4gICAgLy8gY3JlYXRlIGEgc25hcHNob3Qgd2hpY2ggYXZvaWRzIHRoZSBzZXQgYmVpbmcgbXV0YXRlZCBkdXJpbmcgdXBkYXRlc1xyXG4gICAgY29uc3QgaW5zdGFuY2VzID0gWy4uLnJlY29yZC5pbnN0YW5jZXNdO1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBjb25zdCBvbGRDb21wID0gbm9ybWFsaXplQ2xhc3NDb21wb25lbnQoaW5zdGFuY2UudHlwZSk7XHJcbiAgICAgICAgaWYgKCFobXJEaXJ0eUNvbXBvbmVudHMuaGFzKG9sZENvbXApKSB7XHJcbiAgICAgICAgICAgIC8vIDEuIFVwZGF0ZSBleGlzdGluZyBjb21wIGRlZmluaXRpb24gdG8gbWF0Y2ggbmV3IG9uZVxyXG4gICAgICAgICAgICBpZiAob2xkQ29tcCAhPT0gcmVjb3JkLmluaXRpYWxEZWYpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvbXBvbmVudERlZihvbGRDb21wLCBuZXdDb21wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAyLiBtYXJrIGRlZmluaXRpb24gZGlydHkuIFRoaXMgZm9yY2VzIHRoZSByZW5kZXJlciB0byByZXBsYWNlIHRoZVxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgb24gcGF0Y2guXHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5hZGQob2xkQ29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDMuIGludmFsaWRhdGUgb3B0aW9ucyByZXNvbHV0aW9uIGNhY2hlXHJcbiAgICAgICAgaW5zdGFuY2UuYXBwQ29udGV4dC5vcHRpb25zQ2FjaGUuZGVsZXRlKGluc3RhbmNlLnR5cGUpO1xyXG4gICAgICAgIC8vIDQuIGFjdHVhbGx5IHVwZGF0ZVxyXG4gICAgICAgIGlmIChpbnN0YW5jZS5jZVJlbG9hZCkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gZWxlbWVudFxyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuYWRkKG9sZENvbXApO1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jZVJlbG9hZChuZXdDb21wLnN0eWxlcyk7XHJcbiAgICAgICAgICAgIGhtckRpcnR5Q29tcG9uZW50cy5kZWxldGUob2xkQ29tcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyA0LiBGb3JjZSB0aGUgcGFyZW50IGluc3RhbmNlIHRvIHJlLXJlbmRlci4gVGhpcyB3aWxsIGNhdXNlIGFsbCB1cGRhdGVkXHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgdG8gYmUgdW5tb3VudGVkIGFuZCByZS1tb3VudGVkLiBRdWV1ZSB0aGUgdXBkYXRlIHNvIHRoYXQgd2VcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZW5kIHVwIGZvcmNpbmcgdGhlIHNhbWUgcGFyZW50IHRvIHJlLXJlbmRlciBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAgICAgICAgcXVldWVKb2IoaW5zdGFuY2UucGFyZW50LnVwZGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHRoZSBpbm5lciBjb21wb25lbnQgb2YgYW4gYXN5bmMgY3VzdG9tIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gaW52b2tlIHRvIHJlc2V0IHN0eWxlc1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UucGFyZW50LnR5cGUuX19hc3luY0xvYWRlciAmJlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LmNlUmVsb2FkKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wYXJlbnQuY2VSZWxvYWQobmV3Q29tcC5zdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmFwcENvbnRleHQucmVsb2FkKSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3QgaW5zdGFuY2UgbW91bnRlZCB2aWEgY3JlYXRlQXBwKCkgaGFzIGEgcmVsb2FkIG1ldGhvZFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hcHBDb250ZXh0LnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyByb290IGluc3RhbmNlIGluc2lkZSB0cmVlIGNyZWF0ZWQgdmlhIHJhdyByZW5kZXIoKS4gRm9yY2UgcmVsb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tITVJdIFJvb3Qgb3IgbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSBtb2RpZmllZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gNS4gbWFrZSBzdXJlIHRvIGNsZWFudXAgZGlydHkgaG1yIGNvbXBvbmVudHMgYWZ0ZXIgdXBkYXRlXHJcbiAgICBxdWV1ZVBvc3RGbHVzaENiKCgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xyXG4gICAgICAgICAgICBobXJEaXJ0eUNvbXBvbmVudHMuZGVsZXRlKG5vcm1hbGl6ZUNsYXNzQ29tcG9uZW50KGluc3RhbmNlLnR5cGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnREZWYob2xkQ29tcCwgbmV3Q29tcCkge1xyXG4gICAgZXh0ZW5kKG9sZENvbXAsIG5ld0NvbXApO1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2xkQ29tcCkge1xyXG4gICAgICAgIGlmIChrZXkgIT09ICdfX2ZpbGUnICYmICEoa2V5IGluIG5ld0NvbXApKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvbGRDb21wW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyeVdyYXAoZm4pIHtcclxuICAgIHJldHVybiAoaWQsIGFyZykgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihpZCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbSE1SXSBTb21ldGhpbmcgd2VudCB3cm9uZyBkdXJpbmcgVnVlIGNvbXBvbmVudCBob3QtcmVsb2FkLiBgICtcclxuICAgICAgICAgICAgICAgIGBGdWxsIHJlbG9hZCByZXF1aXJlZC5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmxldCBkZXZ0b29scztcclxubGV0IGJ1ZmZlciA9IFtdO1xyXG5sZXQgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gZW1pdChldmVudCwgLi4uYXJncykge1xyXG4gICAgaWYgKGRldnRvb2xzKSB7XHJcbiAgICAgICAgZGV2dG9vbHMuZW1pdChldmVudCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZGV2dG9vbHNOb3RJbnN0YWxsZWQpIHtcclxuICAgICAgICBidWZmZXIucHVzaCh7IGV2ZW50LCBhcmdzIH0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldERldnRvb2xzSG9vayhob29rLCB0YXJnZXQpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBkZXZ0b29scyA9IGhvb2s7XHJcbiAgICBpZiAoZGV2dG9vbHMpIHtcclxuICAgICAgICBkZXZ0b29scy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBidWZmZXIuZm9yRWFjaCgoeyBldmVudCwgYXJncyB9KSA9PiBkZXZ0b29scy5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XHJcbiAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChcclxuICAgIC8vIGhhbmRsZSBsYXRlIGRldnRvb2xzIGluamVjdGlvbiAtIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgaW4gYW4gYWN0dWFsXHJcbiAgICAvLyBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdFxyXG4gICAgLy8gKCM0ODE1KVxyXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxyXG4gICAgICAgIHdpbmRvdy5IVE1MRWxlbWVudCAmJlxyXG4gICAgICAgIC8vIGFsc28gZXhjbHVkZSBqc2RvbVxyXG4gICAgICAgICEoKF9iID0gKF9hID0gd2luZG93Lm5hdmlnYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdqc2RvbScpKSkge1xyXG4gICAgICAgIGNvbnN0IHJlcGxheSA9ICh0YXJnZXQuX19WVUVfREVWVE9PTFNfSE9PS19SRVBMQVlfXyA9XHJcbiAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fIHx8IFtdKTtcclxuICAgICAgICByZXBsYXkucHVzaCgobmV3SG9vaykgPT4ge1xyXG4gICAgICAgICAgICBzZXREZXZ0b29sc0hvb2sobmV3SG9vaywgdGFyZ2V0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjbGVhciBidWZmZXIgYWZ0ZXIgM3MgLSB0aGUgdXNlciBwcm9iYWJseSBkb2Vzbid0IGhhdmUgZGV2dG9vbHMgaW5zdGFsbGVkXHJcbiAgICAgICAgLy8gYXQgYWxsLCBhbmQga2VlcGluZyB0aGUgYnVmZmVyIHdpbGwgY2F1c2UgbWVtb3J5IGxlYWtzICgjNDczOClcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFkZXZ0b29scykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNOb3RJbnN0YWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAzMDAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vbi1icm93c2VyIGVudiwgYXNzdW1lIG5vdCBpbnN0YWxsZWRcclxuICAgICAgICBkZXZ0b29sc05vdEluc3RhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgYnVmZmVyID0gW107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbikge1xyXG4gICAgZW1pdChcImFwcDppbml0XCIgLyogQVBQX0lOSVQgKi8sIGFwcCwgdmVyc2lvbiwge1xyXG4gICAgICAgIEZyYWdtZW50LFxyXG4gICAgICAgIFRleHQsXHJcbiAgICAgICAgQ29tbWVudCxcclxuICAgICAgICBTdGF0aWNcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGRldnRvb2xzVW5tb3VudEFwcChhcHApIHtcclxuICAgIGVtaXQoXCJhcHA6dW5tb3VudFwiIC8qIEFQUF9VTk1PVU5UICovLCBhcHApO1xyXG59XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50QWRkZWQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDphZGRlZFwiIC8qIENPTVBPTkVOVF9BRERFRCAqLyk7XHJcbmNvbnN0IGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZCA9IFxyXG4vKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzQ29tcG9uZW50SG9vayhcImNvbXBvbmVudDp1cGRhdGVkXCIgLyogQ09NUE9ORU5UX1VQREFURUQgKi8pO1xyXG5jb25zdCBkZXZ0b29sc0NvbXBvbmVudFJlbW92ZWQgPSBcclxuLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc0NvbXBvbmVudEhvb2soXCJjb21wb25lbnQ6cmVtb3ZlZFwiIC8qIENPTVBPTkVOVF9SRU1PVkVEICovKTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNDb21wb25lbnRIb29rKGhvb2spIHtcclxuICAgIHJldHVybiAoY29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgZW1pdChob29rLCBjb21wb25lbnQuYXBwQ29udGV4dC5hcHAsIGNvbXBvbmVudC51aWQsIGNvbXBvbmVudC5wYXJlbnQgPyBjb21wb25lbnQucGFyZW50LnVpZCA6IHVuZGVmaW5lZCwgY29tcG9uZW50KTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgZGV2dG9vbHNQZXJmU3RhcnQgPSAvKiNfX1BVUkVfXyovIGNyZWF0ZURldnRvb2xzUGVyZm9ybWFuY2VIb29rKFwicGVyZjpzdGFydFwiIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovKTtcclxuY29uc3QgZGV2dG9vbHNQZXJmRW5kID0gLyojX19QVVJFX18qLyBjcmVhdGVEZXZ0b29sc1BlcmZvcm1hbmNlSG9vayhcInBlcmY6ZW5kXCIgLyogUEVSRk9STUFOQ0VfRU5EICovKTtcclxuZnVuY3Rpb24gY3JlYXRlRGV2dG9vbHNQZXJmb3JtYW5jZUhvb2soaG9vaykge1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQsIHR5cGUsIHRpbWUpID0+IHtcclxuICAgICAgICBlbWl0KGhvb2ssIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LnVpZCwgY29tcG9uZW50LCB0eXBlLCB0aW1lKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZGV2dG9vbHNDb21wb25lbnRFbWl0KGNvbXBvbmVudCwgZXZlbnQsIHBhcmFtcykge1xyXG4gICAgZW1pdChcImNvbXBvbmVudDplbWl0XCIgLyogQ09NUE9ORU5UX0VNSVQgKi8sIGNvbXBvbmVudC5hcHBDb250ZXh0LmFwcCwgY29tcG9uZW50LCBldmVudCwgcGFyYW1zKTtcclxufVxuXG5jb25zdCBkZXByZWNhdGlvbkRhdGEgPSB7XHJcbiAgICBbXCJHTE9CQUxfTU9VTlRcIiAvKiBHTE9CQUxfTU9VTlQgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFRoZSBnbG9iYWwgYXBwIGJvb3RzdHJhcHBpbmcgQVBJIGhhcyBjaGFuZ2VkOiB2bS4kbW91bnQoKSBhbmQgdGhlIFwiZWxcIiBgICtcclxuICAgICAgICAgICAgYG9wdGlvbiBoYXZlIGJlZW4gcmVtb3ZlZC4gVXNlIGNyZWF0ZUFwcChSb290Q29tcG9uZW50KS5tb3VudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZ2xvYmFsLWFwaS5odG1sI21vdW50aW5nLWFwcC1pbnN0YW5jZWBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfTU9VTlRfQ09OVEFJTkVSXCIgLyogR0xPQkFMX01PVU5UX0NPTlRBSU5FUiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlIGRldGVjdGVkIGRpcmVjdGl2ZXMgb24gdGhlIG1vdW50IGNvbnRhaW5lci4gYCArXHJcbiAgICAgICAgICAgIGBJbiBWdWUgMywgdGhlIGNvbnRhaW5lciBpcyBubyBsb25nZXIgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSB0ZW1wbGF0ZSBgICtcclxuICAgICAgICAgICAgYGFuZCB3aWxsIG5vdCBiZSBwcm9jZXNzZWQvcmVwbGFjZWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvbW91bnQtY2hhbmdlcy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9FWFRFTkRcIiAvKiBHTE9CQUxfRVhURU5EICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBWdWUuZXh0ZW5kKCkgaGFzIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgZGVmaW5lQ29tcG9uZW50KCkgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3Z1ZWpzLm9yZy9hcGkvZ2VuZXJhbC5odG1sI2RlZmluZWNvbXBvbmVudGBcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfUFJPVE9UWVBFXCIgLyogR0xPQkFMX1BST1RPVFlQRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLnByb3RvdHlwZSBpcyBubyBsb25nZXIgYXZhaWxhYmxlIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFVzZSBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9nbG9iYWwtYXBpLmh0bWwjdnVlLXByb3RvdHlwZS1yZXBsYWNlZC1ieS1jb25maWctZ2xvYmFscHJvcGVydGllc2BcclxuICAgIH0sXHJcbiAgICBbXCJHTE9CQUxfU0VUXCIgLyogR0xPQkFMX1NFVCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlLnNldCgpIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBTaW1wbHkgdXNlIG5hdGl2ZSBKYXZhU2NyaXB0IG11dGF0aW9ucy5gXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX0RFTEVURVwiIC8qIEdMT0JBTF9ERUxFVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS5kZWxldGUoKSBoYXMgYmVlbiByZW1vdmVkIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgU2ltcGx5IHVzZSBuYXRpdmUgSmF2YVNjcmlwdCBtdXRhdGlvbnMuYFxyXG4gICAgfSxcclxuICAgIFtcIkdMT0JBTF9PQlNFUlZBQkxFXCIgLyogR0xPQkFMX09CU0VSVkFCTEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS5vYnNlcnZhYmxlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgXFxgaW1wb3J0IHsgcmVhY3RpdmUgfSBmcm9tIFwidnVlXCJcXGAgZnJvbSBDb21wb3NpdGlvbiBBUEkgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3Z1ZWpzLm9yZy9hcGkvcmVhY3Rpdml0eS1jb3JlLmh0bWwjcmVhY3RpdmVgXHJcbiAgICB9LFxyXG4gICAgW1wiR0xPQkFMX1BSSVZBVEVfVVRJTFwiIC8qIEdMT0JBTF9QUklWQVRFX1VUSUwgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZS51dGlsIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSByZWZhY3RvciB0byBhdm9pZCBpdHMgdXNhZ2UgYCArXHJcbiAgICAgICAgICAgIGBzaW5jZSBpdCB3YXMgYW4gaW50ZXJuYWwgQVBJIGV2ZW4gaW4gVnVlIDIuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19TSUxFTlRcIiAvKiBDT05GSUdfU0lMRU5UICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcuc2lsZW50IGhhcyBiZWVuIHJlbW92ZWQgYmVjYXVzZSBpdCBpcyBub3QgZ29vZCBwcmFjdGljZSB0byBgICtcclxuICAgICAgICAgICAgYGludGVudGlvbmFsbHkgc3VwcHJlc3Mgd2FybmluZ3MuIFlvdSBjYW4gdXNlIHlvdXIgYnJvd3NlciBjb25zb2xlJ3MgYCArXHJcbiAgICAgICAgICAgIGBmaWx0ZXIgZmVhdHVyZXMgdG8gZm9jdXMgb24gcmVsZXZhbnQgbWVzc2FnZXMuYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19ERVZUT09MU1wiIC8qIENPTkZJR19ERVZUT09MUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmRldnRvb2xzIGhhcyBiZWVuIHJlbW92ZWQuIFRvIGVuYWJsZSBkZXZ0b29scyBmb3IgYCArXHJcbiAgICAgICAgICAgIGBwcm9kdWN0aW9uLCBjb25maWd1cmUgdGhlIF9fVlVFX1BST0RfREVWVE9PTFNfXyBjb21waWxlLXRpbWUgZmxhZy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvY29yZS90cmVlL21haW4vcGFja2FnZXMvdnVlI2J1bmRsZXItYnVpbGQtZmVhdHVyZS1mbGFnc2BcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfS0VZX0NPREVTXCIgLyogQ09ORklHX0tFWV9DT0RFUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLmtleUNvZGVzIGhhcyBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgSW4gVnVlIDMsIHlvdSBjYW4gZGlyZWN0bHkgdXNlIHRoZSBrZWJhYi1jYXNlIGtleSBuYW1lcyBhcyB2LW9uIG1vZGlmaWVycy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9rZXljb2RlLW1vZGlmaWVycy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkNPTkZJR19QUk9EVUNUSU9OX1RJUFwiIC8qIENPTkZJR19QUk9EVUNUSU9OX1RJUCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgY29uZmlnLnByb2R1Y3Rpb25UaXAgaGFzIGJlZW4gcmVtb3ZlZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9nbG9iYWwtYXBpLmh0bWwjY29uZmlnLXByb2R1Y3Rpb250aXAtcmVtb3ZlZGBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfSUdOT1JFRF9FTEVNRU5UU1wiIC8qIENPTkZJR19JR05PUkVEX0VMRU1FTlRTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6ICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG1zZyA9IGBjb25maWcuaWdub3JlZEVsZW1lbnRzIGhhcyBiZWVuIHJlbW92ZWQuYDtcclxuICAgICAgICAgICAgaWYgKGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgICAgICAgICAgbXNnICs9IGAgUGFzcyB0aGUgXCJpc0N1c3RvbUVsZW1lbnRcIiBvcHRpb24gdG8gQHZ1ZS9jb21waWxlci1kb20gaW5zdGVhZC5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbXNnICs9IGAgVXNlIGNvbmZpZy5pc0N1c3RvbUVsZW1lbnQgaW5zdGVhZC5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtc2c7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZ2xvYmFsLWFwaS5odG1sI2NvbmZpZy1pZ25vcmVkZWxlbWVudHMtaXMtbm93LWNvbmZpZy1pc2N1c3RvbWVsZW1lbnRgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09ORklHX1dISVRFU1BBQ0VcIiAvKiBDT05GSUdfV0hJVEVTUEFDRSAqL106IHtcclxuICAgICAgICAvLyB0aGlzIHdhcm5pbmcgaXMgb25seSByZWxldmFudCBpbiB0aGUgZnVsbCBidWlsZCB3aGVuIHVzaW5nIHJ1bnRpbWVcclxuICAgICAgICAvLyBjb21waWxhdGlvbiwgc28gaXQncyBwdXQgaW4gdGhlIHJ1bnRpbWUgY29tcGF0Q29uZmlnIGxpc3QuXHJcbiAgICAgICAgbWVzc2FnZTogYFZ1ZSAzIGNvbXBpbGVyJ3Mgd2hpdGVzcGFjZSBvcHRpb24gd2lsbCBkZWZhdWx0IHRvIFwiY29uZGVuc2VcIiBpbnN0ZWFkIG9mIGAgK1xyXG4gICAgICAgICAgICBgXCJwcmVzZXJ2ZVwiLiBUbyBzdXBwcmVzcyB0aGlzIHdhcm5pbmcsIHByb3ZpZGUgYW4gZXhwbGljaXQgdmFsdWUgZm9yIGAgK1xyXG4gICAgICAgICAgICBgXFxgY29uZmlnLmNvbXBpbGVyT3B0aW9ucy53aGl0ZXNwYWNlXFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJDT05GSUdfT1BUSU9OX01FUkdFX1NUUkFUU1wiIC8qIENPTkZJR19PUFRJT05fTUVSR0VfU1RSQVRTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzIG5vIGxvbmdlciBleHBvc2VzIGludGVybmFsIHN0cmF0ZWdpZXMuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGN1c3RvbSBtZXJnZSBmdW5jdGlvbnMgaW5zdGVhZC5gXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfU0VUXCIgLyogSU5TVEFOQ0VfU0VUICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kc2V0KCkgaGFzIGJlZW4gcmVtb3ZlZCBhcyBpdCBpcyBubyBsb25nZXIgbmVlZGVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFNpbXBseSB1c2UgbmF0aXZlIEphdmFTY3JpcHQgbXV0YXRpb25zLmBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9ERUxFVEVcIiAvKiBJTlNUQU5DRV9ERUxFVEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRkZWxldGUoKSBoYXMgYmVlbiByZW1vdmVkIGFzIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgU2ltcGx5IHVzZSBuYXRpdmUgSmF2YVNjcmlwdCBtdXRhdGlvbnMuYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0RFU1RST1lcIiAvKiBJTlNUQU5DRV9ERVNUUk9ZICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGB2bS4kZGVzdHJveSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhcHAudW5tb3VudCgpIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92dWVqcy5vcmcvYXBpL2FwcGxpY2F0aW9uLmh0bWwjYXBwLXVubW91bnRgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfRVZFTlRfRU1JVFRFUlwiIC8qIElOU1RBTkNFX0VWRU5UX0VNSVRURVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogYHZtLiRvbi8kb25jZS8kb2ZmKCkgaGF2ZSBiZWVuIHJlbW92ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGFuIGV4dGVybmFsIGV2ZW50IGVtaXR0ZXIgbGlicmFyeSBpbnN0ZWFkLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2V2ZW50cy1hcGkuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJJTlNUQU5DRV9FVkVOVF9IT09LU1wiIC8qIElOU1RBTkNFX0VWRU5UX0hPT0tTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGV2ZW50ID0+IGBcIiR7ZXZlbnR9XCIgbGlmZWN5Y2xlIGV2ZW50cyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gRnJvbSB0ZW1wbGF0ZXMsIGAgK1xyXG4gICAgICAgICAgICBgdXNlIHRoZSBcInZub2RlXCIgcHJlZml4IGluc3RlYWQgb2YgXCJob29rOlwiLiBGb3IgZXhhbXBsZSwgQCR7ZXZlbnR9IGAgK1xyXG4gICAgICAgICAgICBgc2hvdWxkIGJlIGNoYW5nZWQgdG8gQHZub2RlLSR7ZXZlbnQuc2xpY2UoNSl9LiBgICtcclxuICAgICAgICAgICAgYEZyb20gSmF2YVNjcmlwdCwgdXNlIENvbXBvc2l0aW9uIEFQSSB0byBkeW5hbWljYWxseSByZWdpc3RlciBsaWZlY3ljbGUgYCArXHJcbiAgICAgICAgICAgIGBob29rcy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92bm9kZS1saWZlY3ljbGUtZXZlbnRzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiSU5TVEFOQ0VfQ0hJTERSRU5cIiAvKiBJTlNUQU5DRV9DSElMRFJFTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJGNoaWxkcmVuIGhhcyBiZWVuIHJlbW92ZWQuIENvbnNpZGVyIHJlZmFjdG9yaW5nIHlvdXIgbG9naWMgYCArXHJcbiAgICAgICAgICAgIGB0byBhdm9pZCByZWx5aW5nIG9uIGRpcmVjdCBhY2Nlc3MgdG8gY2hpbGQgY29tcG9uZW50cy5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9jaGlsZHJlbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0xJU1RFTkVSU1wiIC8qIElOU1RBTkNFX0xJU1RFTkVSUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJGxpc3RlbmVycyBoYXMgYmVlbiByZW1vdmVkLiBJbiBWdWUgMywgcGFyZW50IHYtb24gbGlzdGVuZXJzIGFyZSBgICtcclxuICAgICAgICAgICAgYGluY2x1ZGVkIGluIHZtLiRhdHRycyBhbmQgaXQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSB0byBzZXBhcmF0ZWx5IHVzZSBgICtcclxuICAgICAgICAgICAgYHYtb249XCIkbGlzdGVuZXJzXCIgaWYgeW91IGFyZSBhbHJlYWR5IHVzaW5nIHYtYmluZD1cIiRhdHRyc1wiLiBgICtcclxuICAgICAgICAgICAgYChOb3RlOiB0aGUgVnVlIDMgYmVoYXZpb3Igb25seSBhcHBsaWVzIGlmIHRoaXMgY29tcGF0IGNvbmZpZyBpcyBkaXNhYmxlZClgLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9saXN0ZW5lcnMtcmVtb3ZlZC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX1NDT1BFRF9TTE9UU1wiIC8qIElOU1RBTkNFX1NDT1BFRF9TTE9UUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgdm0uJHNjb3BlZFNsb3RzIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2bS4kc2xvdHMgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9zbG90cy11bmlmaWNhdGlvbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIklOU1RBTkNFX0FUVFJTX0NMQVNTX1NUWUxFXCIgLyogSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEUgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogY29tcG9uZW50TmFtZSA9PiBgQ29tcG9uZW50IDwke2NvbXBvbmVudE5hbWUgfHwgJ0Fub255bW91cyd9PiBoYXMgXFxgaW5oZXJpdEF0dHJzOiBmYWxzZVxcYCBidXQgaXMgYCArXHJcbiAgICAgICAgICAgIGByZWx5aW5nIG9uIGNsYXNzL3N0eWxlIGZhbGx0aHJvdWdoIGZyb20gcGFyZW50LiBJbiBWdWUgMywgY2xhc3Mvc3R5bGUgYCArXHJcbiAgICAgICAgICAgIGBhcmUgbm93IGluY2x1ZGVkIGluICRhdHRycyBhbmQgd2lsbCBubyBsb25nZXIgZmFsbHRocm91Z2ggd2hlbiBgICtcclxuICAgICAgICAgICAgYGluaGVyaXRBdHRycyBpcyBmYWxzZS4gSWYgeW91IGFyZSBhbHJlYWR5IHVzaW5nIHYtYmluZD1cIiRhdHRyc1wiIG9uIGAgK1xyXG4gICAgICAgICAgICBgY29tcG9uZW50IHJvb3QgaXQgc2hvdWxkIHJlbmRlciB0aGUgc2FtZSBlbmQgcmVzdWx0LiBgICtcclxuICAgICAgICAgICAgYElmIHlvdSBhcmUgYmluZGluZyAkYXR0cnMgdG8gYSBub24tcm9vdCBlbGVtZW50IGFuZCBleHBlY3RpbmcgYCArXHJcbiAgICAgICAgICAgIGBjbGFzcy9zdHlsZSB0byBmYWxsdGhyb3VnaCBvbiByb290LCB5b3Ugd2lsbCBuZWVkIHRvIG5vdyBtYW51YWxseSBiaW5kIGAgK1xyXG4gICAgICAgICAgICBgdGhlbSBvbiByb290IHZpYSA6Y2xhc3M9XCIkYXR0cnMuY2xhc3NcIi5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9hdHRycy1pbmNsdWRlcy1jbGFzcy1zdHlsZS5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfREFUQV9GTlwiIC8qIE9QVElPTlNfREFUQV9GTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVGhlIFwiZGF0YVwiIG9wdGlvbiBjYW4gbm8gbG9uZ2VyIGJlIGEgcGxhaW4gb2JqZWN0LiBgICtcclxuICAgICAgICAgICAgYEFsd2F5cyB1c2UgYSBmdW5jdGlvbi5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9kYXRhLW9wdGlvbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfREFUQV9NRVJHRVwiIC8qIE9QVElPTlNfREFUQV9NRVJHRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoa2V5KSA9PiBgRGV0ZWN0ZWQgY29uZmxpY3Rpbmcga2V5IFwiJHtrZXl9XCIgd2hlbiBtZXJnaW5nIGRhdGEgb3B0aW9uIHZhbHVlcy4gYCArXHJcbiAgICAgICAgICAgIGBJbiBWdWUgMywgZGF0YSBrZXlzIGFyZSBtZXJnZWQgc2hhbGxvd2x5IGFuZCB3aWxsIG92ZXJyaWRlIG9uZSBhbm90aGVyLmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2RhdGEtb3B0aW9uLmh0bWwjbWl4aW4tbWVyZ2UtYmVoYXZpb3ItY2hhbmdlYFxyXG4gICAgfSxcclxuICAgIFtcIk9QVElPTlNfQkVGT1JFX0RFU1RST1lcIiAvKiBPUFRJT05TX0JFRk9SRV9ERVNUUk9ZICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBcXGBiZWZvcmVEZXN0cm95XFxgIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgYmVmb3JlVW5tb3VudFxcYC5gXHJcbiAgICB9LFxyXG4gICAgW1wiT1BUSU9OU19ERVNUUk9ZRURcIiAvKiBPUFRJT05TX0RFU1RST1lFRCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgXFxgZGVzdHJveWVkXFxgIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgdW5tb3VudGVkXFxgLmBcclxuICAgIH0sXHJcbiAgICBbXCJXQVRDSF9BUlJBWVwiIC8qIFdBVENIX0FSUkFZICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBcIndhdGNoXCIgb3B0aW9uIG9yIHZtLiR3YXRjaCBvbiBhbiBhcnJheSB2YWx1ZSB3aWxsIG5vIGxvbmdlciBgICtcclxuICAgICAgICAgICAgYHRyaWdnZXIgb24gYXJyYXkgbXV0YXRpb24gdW5sZXNzIHRoZSBcImRlZXBcIiBvcHRpb24gaXMgc3BlY2lmaWVkLiBgICtcclxuICAgICAgICAgICAgYElmIGN1cnJlbnQgdXNhZ2UgaXMgaW50ZW5kZWQsIHlvdSBjYW4gZGlzYWJsZSB0aGUgY29tcGF0IGJlaGF2aW9yIGFuZCBgICtcclxuICAgICAgICAgICAgYHN1cHByZXNzIHRoaXMgd2FybmluZyB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiV0FUQ0hfQVJSQVlcIiAvKiBXQVRDSF9BUlJBWSAqL306IGZhbHNlIH0pXFxuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvd2F0Y2guaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJQUk9QU19ERUZBVUxUX1RISVNcIiAvKiBQUk9QU19ERUZBVUxUX1RISVMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGtleSkgPT4gYHByb3BzIGRlZmF1bHQgdmFsdWUgZnVuY3Rpb24gbm8gbG9uZ2VyIGhhcyBhY2Nlc3MgdG8gXCJ0aGlzXCIuIFRoZSBjb21wYXQgYCArXHJcbiAgICAgICAgICAgIGBidWlsZCBvbmx5IG9mZmVycyBhY2Nlc3MgdG8gdGhpcy4kb3B0aW9ucy5gICtcclxuICAgICAgICAgICAgYChmb3VuZCBpbiBwcm9wIFwiJHtrZXl9XCIpYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvcHJvcHMtZGVmYXVsdC10aGlzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ1VTVE9NX0RJUlwiIC8qIENVU1RPTV9ESVIgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGxlZ2FjeUhvb2ssIG5ld0hvb2spID0+IGBDdXN0b20gZGlyZWN0aXZlIGhvb2sgXCIke2xlZ2FjeUhvb2t9XCIgaGFzIGJlZW4gcmVtb3ZlZC4gYCArXHJcbiAgICAgICAgICAgIGBVc2UgXCIke25ld0hvb2t9XCIgaW5zdGVhZC5gLFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9jdXN0b20tZGlyZWN0aXZlcy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlZfT05fS0VZQ09ERV9NT0RJRklFUlwiIC8qIFZfT05fS0VZQ09ERV9NT0RJRklFUiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVXNpbmcga2V5Q29kZSBhcyB2LW9uIG1vZGlmaWVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIGtlYmFiLWNhc2Uga2V5IG5hbWUgbW9kaWZpZXJzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMva2V5Y29kZS1tb2RpZmllcnMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJBVFRSX0ZBTFNFX1ZBTFVFXCIgLyogQVRUUl9GQUxTRV9WQUxVRSAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAobmFtZSkgPT4gYEF0dHJpYnV0ZSBcIiR7bmFtZX1cIiB3aXRoIHYtYmluZCB2YWx1ZSBcXGBmYWxzZVxcYCB3aWxsIHJlbmRlciBgICtcclxuICAgICAgICAgICAgYCR7bmFtZX09XCJmYWxzZVwiIGluc3RlYWQgb2YgcmVtb3ZpbmcgaXQgaW4gVnVlIDMuIFRvIHJlbW92ZSB0aGUgYXR0cmlidXRlLCBgICtcclxuICAgICAgICAgICAgYHVzZSBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYCBpbnN0ZWFkLiBJZiB0aGUgdXNhZ2UgaXMgaW50ZW5kZWQsIGAgK1xyXG4gICAgICAgICAgICBgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIHN1cHByZXNzIHRoaXMgd2FybmluZyB3aXRoOmAgK1xyXG4gICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQVRUUl9GQUxTRV9WQUxVRVwiIC8qIEFUVFJfRkFMU0VfVkFMVUUgKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2F0dHJpYnV0ZS1jb2VyY2lvbi5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTlwiIC8qIEFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAobmFtZSwgdmFsdWUsIGNvZXJjZWQpID0+IGBFbnVtZXJhdGVkIGF0dHJpYnV0ZSBcIiR7bmFtZX1cIiB3aXRoIHYtYmluZCB2YWx1ZSBcXGAke3ZhbHVlfVxcYCB3aWxsIGAgK1xyXG4gICAgICAgICAgICBgJHt2YWx1ZSA9PT0gbnVsbCA/IGBiZSByZW1vdmVkYCA6IGByZW5kZXIgdGhlIHZhbHVlIGFzLWlzYH0gaW5zdGVhZCBvZiBjb2VyY2luZyB0aGUgdmFsdWUgdG8gXCIke2NvZXJjZWR9XCIgaW4gVnVlIDMuIGAgK1xyXG4gICAgICAgICAgICBgQWx3YXlzIHVzZSBleHBsaWNpdCBcInRydWVcIiBvciBcImZhbHNlXCIgdmFsdWVzIGZvciBlbnVtZXJhdGVkIGF0dHJpYnV0ZXMuIGAgK1xyXG4gICAgICAgICAgICBgSWYgdGhlIHVzYWdlIGlzIGludGVuZGVkLCBgICtcclxuICAgICAgICAgICAgYHlvdSBjYW4gZGlzYWJsZSB0aGUgY29tcGF0IGJlaGF2aW9yIGFuZCBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgd2l0aDpgICtcclxuICAgICAgICAgICAgYFxcblxcbiAgY29uZmlndXJlQ29tcGF0KHsgJHtcIkFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTlwiIC8qIEFUVFJfRU5VTUVSQVRFRF9DT0VSQ0lPTiAqL306IGZhbHNlIH0pXFxuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvYXR0cmlidXRlLWNvZXJjaW9uLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiVFJBTlNJVElPTl9DTEFTU0VTXCIgLyogVFJBTlNJVElPTl9DTEFTU0VTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBgIC8vIHRoaXMgZmVhdHVyZSBjYW5ub3QgYmUgcnVudGltZS1kZXRlY3RlZFxyXG4gICAgfSxcclxuICAgIFtcIlRSQU5TSVRJT05fR1JPVVBfUk9PVFwiIC8qIFRSQU5TSVRJT05fR1JPVVBfUk9PVCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgPFRyYW5zaXRpb25Hcm91cD4gbm8gbG9uZ2VyIHJlbmRlcnMgYSByb290IDxzcGFuPiBlbGVtZW50IGJ5IGAgK1xyXG4gICAgICAgICAgICBgZGVmYXVsdCBpZiBubyBcInRhZ1wiIHByb3AgaXMgc3BlY2lmaWVkLiBJZiB5b3UgZG8gbm90IHJlbHkgb24gdGhlIHNwYW4gYCArXHJcbiAgICAgICAgICAgIGBmb3Igc3R5bGluZywgeW91IGNhbiBkaXNhYmxlIHRoZSBjb21wYXQgYmVoYXZpb3IgYW5kIHN1cHByZXNzIHRoaXMgYCArXHJcbiAgICAgICAgICAgIGB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJUUkFOU0lUSU9OX0dST1VQX1JPT1RcIiAvKiBUUkFOU0lUSU9OX0dST1VQX1JPT1QgKi99OiBmYWxzZSB9KVxcbmAsXHJcbiAgICAgICAgbGluazogYGh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3RyYW5zaXRpb24tZ3JvdXAuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QT05FTlRfQVNZTkNcIiAvKiBDT01QT05FTlRfQVNZTkMgKi9dOiB7XHJcbiAgICAgICAgbWVzc2FnZTogKGNvbXApID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoYEFzeW5jIGNvbXBvbmVudCR7bmFtZSA/IGAgPCR7bmFtZX0+YCA6IGBzYH0gc2hvdWxkIGJlIGV4cGxpY2l0bHkgY3JlYXRlZCB2aWEgXFxgZGVmaW5lQXN5bmNDb21wb25lbnQoKVxcYCBgICtcclxuICAgICAgICAgICAgICAgIGBpbiBWdWUgMy4gUGxhaW4gZnVuY3Rpb25zIHdpbGwgYmUgdHJlYXRlZCBhcyBmdW5jdGlvbmFsIGNvbXBvbmVudHMgaW4gYCArXHJcbiAgICAgICAgICAgICAgICBgbm9uLWNvbXBhdCBidWlsZC4gSWYgeW91IGhhdmUgYWxyZWFkeSBtaWdyYXRlZCBhbGwgYXN5bmMgY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzYWdlIGFuZCBpbnRlbmQgdG8gdXNlIHBsYWluIGZ1bmN0aW9ucyBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLCBgICtcclxuICAgICAgICAgICAgICAgIGB5b3UgY2FuIGRpc2FibGUgdGhlIGNvbXBhdCBiZWhhdmlvciBhbmQgc3VwcHJlc3MgdGhpcyBgICtcclxuICAgICAgICAgICAgICAgIGB3YXJuaW5nIHdpdGg6YCArXHJcbiAgICAgICAgICAgICAgICBgXFxuXFxuICBjb25maWd1cmVDb21wYXQoeyAke1wiQ09NUE9ORU5UX0FTWU5DXCIgLyogQ09NUE9ORU5UX0FTWU5DICovfTogZmFsc2UgfSlcXG5gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9hc3luYy1jb21wb25lbnRzLmh0bWxgXHJcbiAgICB9LFxyXG4gICAgW1wiQ09NUE9ORU5UX0ZVTkNUSU9OQUxcIiAvKiBDT01QT05FTlRfRlVOQ1RJT05BTCAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiAoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wKTtcclxuICAgICAgICAgICAgcmV0dXJuIChgRnVuY3Rpb25hbCBjb21wb25lbnQke25hbWUgPyBgIDwke25hbWV9PmAgOiBgc2B9IHNob3VsZCBiZSBkZWZpbmVkIGFzIGEgcGxhaW4gZnVuY3Rpb24gaW4gVnVlIDMuIFRoZSBcImZ1bmN0aW9uYWxcIiBgICtcclxuICAgICAgICAgICAgICAgIGBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gTk9URTogQmVmb3JlIG1pZ3JhdGluZyB0byB1c2UgcGxhaW4gYCArXHJcbiAgICAgICAgICAgICAgICBgZnVuY3Rpb25zIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIGZpcnN0IG1ha2Ugc3VyZSB0aGF0IGFsbCBhc3luYyBgICtcclxuICAgICAgICAgICAgICAgIGBjb21wb25lbnRzIHVzYWdlIGhhdmUgYmVlbiBtaWdyYXRlZCBhbmQgaXRzIGNvbXBhdCBiZWhhdmlvciBoYXMgYCArXHJcbiAgICAgICAgICAgICAgICBgYmVlbiBkaXNhYmxlZC5gKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbms6IGBodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy9mdW5jdGlvbmFsLWNvbXBvbmVudHMuaHRtbGBcclxuICAgIH0sXHJcbiAgICBbXCJDT01QT05FTlRfVl9NT0RFTFwiIC8qIENPTVBPTkVOVF9WX01PREVMICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IChjb21wKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ01zZyA9IGBvcHQtaW4gdG8gYCArXHJcbiAgICAgICAgICAgICAgICBgVnVlIDMgYmVoYXZpb3Igb24gYSBwZXItY29tcG9uZW50IGJhc2lzIHdpdGggXFxgY29tcGF0Q29uZmlnOiB7ICR7XCJDT01QT05FTlRfVl9NT0RFTFwiIC8qIENPTVBPTkVOVF9WX01PREVMICovfTogZmFsc2UgfVxcYC5gO1xyXG4gICAgICAgICAgICBpZiAoY29tcC5wcm9wcyAmJlxyXG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoY29tcC5wcm9wcylcclxuICAgICAgICAgICAgICAgICAgICA/IGNvbXAucHJvcHMuaW5jbHVkZXMoJ21vZGVsVmFsdWUnKVxyXG4gICAgICAgICAgICAgICAgICAgIDogaGFzT3duKGNvbXAucHJvcHMsICdtb2RlbFZhbHVlJykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGBDb21wb25lbnQgZGVjbGFyZXMgXCJtb2RlbFZhbHVlXCIgcHJvcCwgd2hpY2ggaXMgVnVlIDMgdXNhZ2UsIGJ1dCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaXMgcnVubmluZyB1bmRlciBWdWUgMiBjb21wYXQgdi1tb2RlbCBiZWhhdmlvci4gWW91IGNhbiAke2NvbmZpZ01zZ31gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKGB2LW1vZGVsIHVzYWdlIG9uIGNvbXBvbmVudCBoYXMgY2hhbmdlZCBpbiBWdWUgMy4gQ29tcG9uZW50IHRoYXQgZXhwZWN0cyBgICtcclxuICAgICAgICAgICAgICAgIGB0byB3b3JrIHdpdGggdi1tb2RlbCBzaG91bGQgbm93IHVzZSB0aGUgXCJtb2RlbFZhbHVlXCIgcHJvcCBhbmQgZW1pdCB0aGUgYCArXHJcbiAgICAgICAgICAgICAgICBgXCJ1cGRhdGU6bW9kZWxWYWx1ZVwiIGV2ZW50LiBZb3UgY2FuIHVwZGF0ZSB0aGUgdXNhZ2UgYW5kIHRoZW4gJHtjb25maWdNc2d9YCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvdi1tb2RlbC5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlJFTkRFUl9GVU5DVElPTlwiIC8qIFJFTkRFUl9GVU5DVElPTiAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBgVnVlIDMncyByZW5kZXIgZnVuY3Rpb24gQVBJIGhhcyBjaGFuZ2VkLiBgICtcclxuICAgICAgICAgICAgYFlvdSBjYW4gb3B0LWluIHRvIHRoZSBuZXcgQVBJIHdpdGg6YCArXHJcbiAgICAgICAgICAgIGBcXG5cXG4gIGNvbmZpZ3VyZUNvbXBhdCh7ICR7XCJSRU5ERVJfRlVOQ1RJT05cIiAvKiBSRU5ERVJfRlVOQ1RJT04gKi99OiBmYWxzZSB9KVxcbmAgK1xyXG4gICAgICAgICAgICBgXFxuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIHBlci1jb21wb25lbnQgdmlhIHRoZSBcImNvbXBhdENvbmZpZ1wiIG9wdGlvbi4pYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvcmVuZGVyLWZ1bmN0aW9uLWFwaS5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIkZJTFRFUlNcIiAvKiBGSUxURVJTICovXToge1xyXG4gICAgICAgIG1lc3NhZ2U6IGBmaWx0ZXJzIGhhdmUgYmVlbiByZW1vdmVkIGluIFZ1ZSAzLiBgICtcclxuICAgICAgICAgICAgYFRoZSBcInxcIiBzeW1ib2wgd2lsbCBiZSB0cmVhdGVkIGFzIG5hdGl2ZSBKYXZhU2NyaXB0IGJpdHdpc2UgT1Igb3BlcmF0b3IuIGAgK1xyXG4gICAgICAgICAgICBgVXNlIG1ldGhvZCBjYWxscyBvciBjb21wdXRlZCBwcm9wZXJ0aWVzIGluc3RlYWQuYCxcclxuICAgICAgICBsaW5rOiBgaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvZmlsdGVycy5odG1sYFxyXG4gICAgfSxcclxuICAgIFtcIlBSSVZBVEVfQVBJU1wiIC8qIFBSSVZBVEVfQVBJUyAqL106IHtcclxuICAgICAgICBtZXNzYWdlOiBuYW1lID0+IGBcIiR7bmFtZX1cIiBpcyBhIFZ1ZSAyIHByaXZhdGUgQVBJIHRoYXQgbm8gbG9uZ2VyIGV4aXN0cyBpbiBWdWUgMy4gYCArXHJcbiAgICAgICAgICAgIGBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIHdhcm5pbmcgb25seSBkdWUgdG8gYSBkZXBlbmRlbmN5LCB5b3UgY2FuIGAgK1xyXG4gICAgICAgICAgICBgc3VwcHJlc3MgdGhpcyB3YXJuaW5nIHZpYSB7IFBSSVZBVEVfQVBJUzogJ3N1cHByZXNzLXdhcm5pbmcnIH0uYFxyXG4gICAgfVxyXG59O1xyXG5jb25zdCBpbnN0YW5jZVdhcm5lZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmNvbnN0IHdhcm5Db3VudCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIHdhcm5EZXByZWNhdGlvbihrZXksIGluc3RhbmNlLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAoIShwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UgfHwgZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAvLyBjaGVjayB1c2VyIGNvbmZpZ1xyXG4gICAgY29uc3QgY29uZmlnID0gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KGtleSwgaW5zdGFuY2UpO1xyXG4gICAgaWYgKGNvbmZpZyA9PT0gJ3N1cHByZXNzLXdhcm5pbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZHVwS2V5ID0ga2V5ICsgYXJncy5qb2luKCcnKTtcclxuICAgIGxldCBjb21wSWQgPSBpbnN0YW5jZSAmJiBmb3JtYXRDb21wb25lbnROYW1lKGluc3RhbmNlLCBpbnN0YW5jZS50eXBlKTtcclxuICAgIGlmIChjb21wSWQgPT09ICdBbm9ueW1vdXMnICYmIGluc3RhbmNlKSB7XHJcbiAgICAgICAgY29tcElkID0gaW5zdGFuY2UudWlkO1xyXG4gICAgfVxyXG4gICAgLy8gc2tpcCBpZiB0aGUgc2FtZSB3YXJuaW5nIGlzIGVtaXR0ZWQgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0eXBlXHJcbiAgICBjb25zdCBjb21wb25lbnREdXBLZXkgPSBkdXBLZXkgKyBjb21wSWQ7XHJcbiAgICBpZiAoY29tcG9uZW50RHVwS2V5IGluIGluc3RhbmNlV2FybmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2VXYXJuZWRbY29tcG9uZW50RHVwS2V5XSA9IHRydWU7XHJcbiAgICAvLyBzYW1lIHdhcm5pbmcsIGJ1dCBkaWZmZXJlbnQgY29tcG9uZW50LiBza2lwIHRoZSBsb25nIG1lc3NhZ2UgYW5kIGp1c3RcclxuICAgIC8vIGxvZyB0aGUga2V5IGFuZCBjb3VudC5cclxuICAgIGlmIChkdXBLZXkgaW4gd2FybkNvdW50KSB7XHJcbiAgICAgICAgd2FybiQxKGAoZGVwcmVjYXRpb24gJHtrZXl9KSAoJHsrK3dhcm5Db3VudFtkdXBLZXldICsgMX0pYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgd2FybkNvdW50W2R1cEtleV0gPSAwO1xyXG4gICAgY29uc3QgeyBtZXNzYWdlLCBsaW5rIH0gPSBkZXByZWNhdGlvbkRhdGFba2V5XTtcclxuICAgIHdhcm4kMShgKGRlcHJlY2F0aW9uICR7a2V5fSkgJHt0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyA/IG1lc3NhZ2UoLi4uYXJncykgOiBtZXNzYWdlfSR7bGluayA/IGBcXG4gIERldGFpbHM6ICR7bGlua31gIDogYGB9YCk7XHJcbiAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChrZXksIGluc3RhbmNlLCB0cnVlKSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYF4gVGhlIGFib3ZlIGRlcHJlY2F0aW9uJ3MgY29tcGF0IGJlaGF2aW9yIGlzIGRpc2FibGVkIGFuZCB3aWxsIGxpa2VseSBgICtcclxuICAgICAgICAgICAgYGxlYWQgdG8gcnVudGltZSBlcnJvcnMuYCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgZ2xvYmFsQ29tcGF0Q29uZmlnID0ge1xyXG4gICAgTU9ERTogMlxyXG59O1xyXG5mdW5jdGlvbiBjb25maWd1cmVDb21wYXQoY29uZmlnKSB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVDb21wYXRDb25maWcoY29uZmlnKTtcclxuICAgIH1cclxuICAgIGV4dGVuZChnbG9iYWxDb21wYXRDb25maWcsIGNvbmZpZyk7XHJcbn1cclxuY29uc3Qgc2VlbkNvbmZpZ09iamVjdHMgPSAvKiNfX1BVUkVfXyovIG5ldyBXZWFrU2V0KCk7XHJcbmNvbnN0IHdhcm5lZEludmFsaWRLZXlzID0ge307XHJcbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcGF0Q29uZmlnKGNvbmZpZywgaW5zdGFuY2UpIHtcclxuICAgIGlmIChzZWVuQ29uZmlnT2JqZWN0cy5oYXMoY29uZmlnKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHNlZW5Db25maWdPYmplY3RzLmFkZChjb25maWcpO1xyXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xyXG4gICAgICAgIGlmIChrZXkgIT09ICdNT0RFJyAmJlxyXG4gICAgICAgICAgICAhKGtleSBpbiBkZXByZWNhdGlvbkRhdGEpICYmXHJcbiAgICAgICAgICAgICEoa2V5IGluIHdhcm5lZEludmFsaWRLZXlzKSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ0NPTVBJTEVSXycpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQxKGBEZXByZWNhdGlvbiBjb25maWcgXCIke2tleX1cIiBpcyBjb21waWxlci1zcGVjaWZpYyBhbmQgeW91IGFyZSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHJ1bm5pbmcgYSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlLiBUaGlzIGRlcHJlY2F0aW9uIHNob3VsZCBiZSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGNvbmZpZ3VyZWQgdmlhIGNvbXBpbGVyIG9wdGlvbnMgaW4geW91ciBidWlsZCBzZXR1cCBpbnN0ZWFkLlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgRGV0YWlsczogaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvbWlncmF0aW9uLWJ1aWxkLmh0bWxgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgSW52YWxpZCBkZXByZWNhdGlvbiBjb25maWcgXCIke2tleX1cIi5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3YXJuZWRJbnZhbGlkS2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaW5zdGFuY2UgJiYgY29uZmlnW1wiT1BUSU9OU19EQVRBX01FUkdFXCIgLyogT1BUSU9OU19EQVRBX01FUkdFICovXSAhPSBudWxsKSB7XHJcbiAgICAgICAgd2FybiQxKGBEZXByZWNhdGlvbiBjb25maWcgXCIke1wiT1BUSU9OU19EQVRBX01FUkdFXCIgLyogT1BUSU9OU19EQVRBX01FUkdFICovfVwiIGNhbiBvbmx5IGJlIGNvbmZpZ3VyZWQgZ2xvYmFsbHkuYCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KGtleSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGluc3RhbmNlQ29uZmlnID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZS5jb21wYXRDb25maWc7XHJcbiAgICBpZiAoaW5zdGFuY2VDb25maWcgJiYga2V5IGluIGluc3RhbmNlQ29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlQ29uZmlnW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2xvYmFsQ29tcGF0Q29uZmlnW2tleV07XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wYXRFbmFibGVkKGtleSwgaW5zdGFuY2UsIGVuYWJsZUZvckJ1aWx0SW4gPSBmYWxzZSkge1xyXG4gICAgLy8gc2tpcCBjb21wYXQgZm9yIGJ1aWx0LWluIGNvbXBvbmVudHNcclxuICAgIGlmICghZW5hYmxlRm9yQnVpbHRJbiAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9faXNCdWlsdEluKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3TW9kZSA9IGdldENvbXBhdENvbmZpZ0ZvcktleSgnTU9ERScsIGluc3RhbmNlKSB8fCAyO1xyXG4gICAgY29uc3QgdmFsID0gZ2V0Q29tcGF0Q29uZmlnRm9yS2V5KGtleSwgaW5zdGFuY2UpO1xyXG4gICAgY29uc3QgbW9kZSA9IGlzRnVuY3Rpb24ocmF3TW9kZSlcclxuICAgICAgICA/IHJhd01vZGUoaW5zdGFuY2UgJiYgaW5zdGFuY2UudHlwZSlcclxuICAgICAgICA6IHJhd01vZGU7XHJcbiAgICBpZiAobW9kZSA9PT0gMikge1xyXG4gICAgICAgIHJldHVybiB2YWwgIT09IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09ICdzdXBwcmVzcy13YXJuaW5nJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVXNlIHRoaXMgZm9yIGZlYXR1cmVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgcmVtb3ZlZCBpbiBub24tY29tcGF0IGJ1aWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0Q29tcGF0RW5hYmxlZChrZXksIGluc3RhbmNlLCAuLi5hcmdzKSB7XHJcbiAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChrZXksIGluc3RhbmNlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9IGNvbXBhdCBoYXMgYmVlbiBkaXNhYmxlZC5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5EZXByZWNhdGlvbihrZXksIGluc3RhbmNlLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVXNlIHRoaXMgZm9yIGZlYXR1cmVzIHdoZXJlIGxlZ2FjeSB1c2FnZSBpcyBzdGlsbCBwb3NzaWJsZSwgYnV0IHdpbGwgbGlrZWx5XHJcbiAqIGxlYWQgdG8gcnVudGltZSBlcnJvciBpZiBjb21wYXQgaXMgZGlzYWJsZWQuICh3YXJuIGluIGFsbCBjYXNlcylcclxuICovXHJcbmZ1bmN0aW9uIHNvZnRBc3NlcnRDb21wYXRFbmFibGVkKGtleSwgaW5zdGFuY2UsIC4uLmFyZ3MpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuRGVwcmVjYXRpb24oa2V5LCBpbnN0YW5jZSwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNDb21wYXRFbmFibGVkKGtleSwgaW5zdGFuY2UpO1xyXG59XHJcbi8qKlxyXG4gKiBVc2UgdGhpcyBmb3IgZmVhdHVyZXMgd2l0aCB0aGUgc2FtZSBzeW50YXggYnV0IHdpdGggbXV0dWFsbHkgZXhjbHVzaXZlXHJcbiAqIGJlaGF2aW9yIGluIDIgdnMgMy4gT25seSB3YXJuIGlmIGNvbXBhdCBpcyBlbmFibGVkLlxyXG4gKiBlLmcuIHJlbmRlciBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tDb21wYXRFbmFibGVkKGtleSwgaW5zdGFuY2UsIC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IGVuYWJsZWQgPSBpc0NvbXBhdEVuYWJsZWQoa2V5LCBpbnN0YW5jZSk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGVuYWJsZWQpIHtcclxuICAgICAgICB3YXJuRGVwcmVjYXRpb24oa2V5LCBpbnN0YW5jZSwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5hYmxlZDtcclxufVxuXG5jb25zdCBldmVudFJlZ2lzdHJ5TWFwID0gLyojX19QVVJFX18qLyBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBnZXRSZWdpc3RyeShpbnN0YW5jZSkge1xyXG4gICAgbGV0IGV2ZW50cyA9IGV2ZW50UmVnaXN0cnlNYXAuZ2V0KGluc3RhbmNlKTtcclxuICAgIGlmICghZXZlbnRzKSB7XHJcbiAgICAgICAgZXZlbnRSZWdpc3RyeU1hcC5zZXQoaW5zdGFuY2UsIChldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbmZ1bmN0aW9uIG9uKGluc3RhbmNlLCBldmVudCwgZm4pIHtcclxuICAgIGlmIChpc0FycmF5KGV2ZW50KSkge1xyXG4gICAgICAgIGV2ZW50LmZvckVhY2goZSA9PiBvbihpbnN0YW5jZSwgZSwgZm4pKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChldmVudC5zdGFydHNXaXRoKCdob29rOicpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydENvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9FVkVOVF9IT09LU1wiIC8qIElOU1RBTkNFX0VWRU5UX0hPT0tTICovLCBpbnN0YW5jZSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0Q29tcGF0RW5hYmxlZChcIklOU1RBTkNFX0VWRU5UX0VNSVRURVJcIiAvKiBJTlNUQU5DRV9FVkVOVF9FTUlUVEVSICovLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGdldFJlZ2lzdHJ5KGluc3RhbmNlKTtcclxuICAgICAgICAoZXZlbnRzW2V2ZW50XSB8fCAoZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5zdGFuY2UucHJveHk7XHJcbn1cclxuZnVuY3Rpb24gb25jZShpbnN0YW5jZSwgZXZlbnQsIGZuKSB7XHJcbiAgICBjb25zdCB3cmFwcGVkID0gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBvZmYoaW5zdGFuY2UsIGV2ZW50LCB3cmFwcGVkKTtcclxuICAgICAgICBmbi5jYWxsKGluc3RhbmNlLnByb3h5LCAuLi5hcmdzKTtcclxuICAgIH07XHJcbiAgICB3cmFwcGVkLmZuID0gZm47XHJcbiAgICBvbihpbnN0YW5jZSwgZXZlbnQsIHdyYXBwZWQpO1xyXG4gICAgcmV0dXJuIGluc3RhbmNlLnByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIG9mZihpbnN0YW5jZSwgZXZlbnQsIGZuKSB7XHJcbiAgICBhc3NlcnRDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfRVZFTlRfRU1JVFRFUlwiIC8qIElOU1RBTkNFX0VWRU5UX0VNSVRURVIgKi8sIGluc3RhbmNlKTtcclxuICAgIGNvbnN0IHZtID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICAvLyBhbGxcclxuICAgIGlmICghZXZlbnQpIHtcclxuICAgICAgICBldmVudFJlZ2lzdHJ5TWFwLnNldChpbnN0YW5jZSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XHJcbiAgICAgICAgcmV0dXJuIHZtO1xyXG4gICAgfVxyXG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXHJcbiAgICBpZiAoaXNBcnJheShldmVudCkpIHtcclxuICAgICAgICBldmVudC5mb3JFYWNoKGUgPT4gb2ZmKGluc3RhbmNlLCBlLCBmbikpO1xyXG4gICAgICAgIHJldHVybiB2bTtcclxuICAgIH1cclxuICAgIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgICBjb25zdCBldmVudHMgPSBnZXRSZWdpc3RyeShpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBjYnMgPSBldmVudHNbZXZlbnRdO1xyXG4gICAgaWYgKCFjYnMpIHtcclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9XHJcbiAgICBpZiAoIWZuKSB7XHJcbiAgICAgICAgZXZlbnRzW2V2ZW50XSA9IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9XHJcbiAgICBldmVudHNbZXZlbnRdID0gY2JzLmZpbHRlcihjYiA9PiAhKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pKTtcclxuICAgIHJldHVybiB2bTtcclxufVxyXG5mdW5jdGlvbiBlbWl0JDEoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKSB7XHJcbiAgICBjb25zdCBjYnMgPSBnZXRSZWdpc3RyeShpbnN0YW5jZSlbZXZlbnRdO1xyXG4gICAgaWYgKGNicykge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNicy5tYXAoY2IgPT4gY2IuYmluZChpbnN0YW5jZS5wcm94eSkpLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5zdGFuY2UucHJveHk7XHJcbn1cblxuY29uc3QgY29tcGF0TW9kZWxFdmVudFByZWZpeCA9IGBvbk1vZGVsQ29tcGF0OmA7XHJcbmNvbnN0IHdhcm5lZFR5cGVzID0gbmV3IFdlYWtTZXQoKTtcclxuZnVuY3Rpb24gY29udmVydExlZ2FjeVZNb2RlbFByb3BzKHZub2RlKSB7XHJcbiAgICBjb25zdCB7IHR5cGUsIHNoYXBlRmxhZywgcHJvcHMsIGR5bmFtaWNQcm9wcyB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBjb21wID0gdHlwZTtcclxuICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLyAmJiBwcm9wcyAmJiAnbW9kZWxWYWx1ZScgaW4gcHJvcHMpIHtcclxuICAgICAgICBpZiAoIWlzQ29tcGF0RW5hYmxlZChcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi8sIFxyXG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2Ugd2FudCB0byB1c2UgdGhlIHZub2RlIGNvbXBvbmVudCdzXHJcbiAgICAgICAgLy8gY29tcGF0IGNvbmZpZyBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHJlbmRlcmluZyBpbnN0YW5jZSAod2hpY2ggaXMgdGhlXHJcbiAgICAgICAgLy8gcGFyZW50IG9mIHRoZSBjb21wb25lbnQgdGhhdCBleHBvc2VzIHYtbW9kZWwpXHJcbiAgICAgICAgeyB0eXBlIH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhd2FybmVkVHlwZXMuaGFzKGNvbXApKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XHJcbiAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIkNPTVBPTkVOVF9WX01PREVMXCIgLyogQ09NUE9ORU5UX1ZfTU9ERUwgKi8sIHsgdHlwZSB9LCBjb21wKTtcclxuICAgICAgICAgICAgcG9wV2FybmluZ0NvbnRleHQoKTtcclxuICAgICAgICAgICAgd2FybmVkVHlwZXMuYWRkKGNvbXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB2MyBjb21waWxlZCBtb2RlbCBjb2RlIC0+IHYyIGNvbXBhdCBwcm9wc1xyXG4gICAgICAgIC8vIG1vZGVsVmFsdWUgLT4gdmFsdWVcclxuICAgICAgICAvLyBvblVwZGF0ZTptb2RlbFZhbHVlIC0+IG9uTW9kZWxDb21wYXQ6aW5wdXRcclxuICAgICAgICBjb25zdCBtb2RlbCA9IGNvbXAubW9kZWwgfHwge307XHJcbiAgICAgICAgYXBwbHlNb2RlbEZyb21NaXhpbnMobW9kZWwsIGNvbXAubWl4aW5zKTtcclxuICAgICAgICBjb25zdCB7IHByb3AgPSAndmFsdWUnLCBldmVudCA9ICdpbnB1dCcgfSA9IG1vZGVsO1xyXG4gICAgICAgIGlmIChwcm9wICE9PSAnbW9kZWxWYWx1ZScpIHtcclxuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSBwcm9wcy5tb2RlbFZhbHVlO1xyXG4gICAgICAgICAgICBkZWxldGUgcHJvcHMubW9kZWxWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW1wb3J0YW50OiB1cGRhdGUgZHluYW1pYyBwcm9wc1xyXG4gICAgICAgIGlmIChkeW5hbWljUHJvcHMpIHtcclxuICAgICAgICAgICAgZHluYW1pY1Byb3BzW2R5bmFtaWNQcm9wcy5pbmRleE9mKCdtb2RlbFZhbHVlJyldID0gcHJvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHNbY29tcGF0TW9kZWxFdmVudFByZWZpeCArIGV2ZW50XSA9IHByb3BzWydvblVwZGF0ZTptb2RlbFZhbHVlJ107XHJcbiAgICAgICAgZGVsZXRlIHByb3BzWydvblVwZGF0ZTptb2RlbFZhbHVlJ107XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlNb2RlbEZyb21NaXhpbnMobW9kZWwsIG1peGlucykge1xyXG4gICAgaWYgKG1peGlucykge1xyXG4gICAgICAgIG1peGlucy5mb3JFYWNoKG0gPT4ge1xyXG4gICAgICAgICAgICBpZiAobS5tb2RlbClcclxuICAgICAgICAgICAgICAgIGV4dGVuZChtb2RlbCwgbS5tb2RlbCk7XHJcbiAgICAgICAgICAgIGlmIChtLm1peGlucylcclxuICAgICAgICAgICAgICAgIGFwcGx5TW9kZWxGcm9tTWl4aW5zKG1vZGVsLCBtLm1peGlucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGF0TW9kZWxFbWl0KGluc3RhbmNlLCBldmVudCwgYXJncykge1xyXG4gICAgaWYgKCFpc0NvbXBhdEVuYWJsZWQoXCJDT01QT05FTlRfVl9NT0RFTFwiIC8qIENPTVBPTkVOVF9WX01PREVMICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xyXG4gICAgY29uc3QgbW9kZWxIYW5kbGVyID0gcHJvcHMgJiYgcHJvcHNbY29tcGF0TW9kZWxFdmVudFByZWZpeCArIGV2ZW50XTtcclxuICAgIGlmIChtb2RlbEhhbmRsZXIpIHtcclxuICAgICAgICBjYWxsV2l0aEVycm9ySGFuZGxpbmcobW9kZWxIYW5kbGVyLCBpbnN0YW5jZSwgNiAvKiBDT01QT05FTlRfRVZFTlRfSEFORExFUiAqLywgYXJncyk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZW1pdCQyKGluc3RhbmNlLCBldmVudCwgLi4ucmF3QXJncykge1xyXG4gICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGNvbnN0IHByb3BzID0gaW5zdGFuY2Uudm5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IHsgZW1pdHNPcHRpb25zLCBwcm9wc09wdGlvbnM6IFtwcm9wc09wdGlvbnNdIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoZW1pdHNPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghKGV2ZW50IGluIGVtaXRzT3B0aW9ucykgJiZcclxuICAgICAgICAgICAgICAgICEoKGV2ZW50LnN0YXJ0c1dpdGgoJ2hvb2s6JykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RhcnRzV2l0aChjb21wYXRNb2RlbEV2ZW50UHJlZml4KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzT3B0aW9ucyB8fCAhKHRvSGFuZGxlcktleShldmVudCkgaW4gcHJvcHNPcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgQ29tcG9uZW50IGVtaXR0ZWQgZXZlbnQgXCIke2V2ZW50fVwiIGJ1dCBpdCBpcyBuZWl0aGVyIGRlY2xhcmVkIGluIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgdGhlIGVtaXRzIG9wdGlvbiBub3IgYXMgYW4gXCIke3RvSGFuZGxlcktleShldmVudCl9XCIgcHJvcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGVtaXRzT3B0aW9uc1tldmVudF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRvciguLi5yYXdBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQxKGBJbnZhbGlkIGV2ZW50IGFyZ3VtZW50czogZXZlbnQgdmFsaWRhdGlvbiBmYWlsZWQgZm9yIGV2ZW50IFwiJHtldmVudH1cIi5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgYXJncyA9IHJhd0FyZ3M7XHJcbiAgICBjb25zdCBpc01vZGVsTGlzdGVuZXIgPSBldmVudC5zdGFydHNXaXRoKCd1cGRhdGU6Jyk7XHJcbiAgICAvLyBmb3Igdi1tb2RlbCB1cGRhdGU6eHh4IGV2ZW50cywgYXBwbHkgbW9kaWZpZXJzIG9uIGFyZ3NcclxuICAgIGNvbnN0IG1vZGVsQXJnID0gaXNNb2RlbExpc3RlbmVyICYmIGV2ZW50LnNsaWNlKDcpO1xyXG4gICAgaWYgKG1vZGVsQXJnICYmIG1vZGVsQXJnIGluIHByb3BzKSB7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZXJzS2V5ID0gYCR7bW9kZWxBcmcgPT09ICdtb2RlbFZhbHVlJyA/ICdtb2RlbCcgOiBtb2RlbEFyZ31Nb2RpZmllcnNgO1xyXG4gICAgICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBwcm9wc1ttb2RpZmllcnNLZXldIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICBhcmdzID0gcmF3QXJncy5tYXAoYSA9PiBhLnRyaW0oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudW1iZXIpIHtcclxuICAgICAgICAgICAgYXJncyA9IHJhd0FyZ3MubWFwKHRvTnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzQ29tcG9uZW50RW1pdChpbnN0YW5jZSwgZXZlbnQsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHByb3BzW3RvSGFuZGxlcktleShsb3dlckNhc2VFdmVudCldKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgRXZlbnQgXCIke2xvd2VyQ2FzZUV2ZW50fVwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZShpbnN0YW5jZSwgaW5zdGFuY2UudHlwZSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgYE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBgICtcclxuICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgaGFuZGxlck5hbWU7XHJcbiAgICBsZXQgaGFuZGxlciA9IHByb3BzWyhoYW5kbGVyTmFtZSA9IHRvSGFuZGxlcktleShldmVudCkpXSB8fFxyXG4gICAgICAgIC8vIGFsc28gdHJ5IGNhbWVsQ2FzZSBldmVudCBoYW5kbGVyICgjMjI0OSlcclxuICAgICAgICBwcm9wc1soaGFuZGxlck5hbWUgPSB0b0hhbmRsZXJLZXkoY2FtZWxpemUoZXZlbnQpKSldO1xyXG4gICAgLy8gZm9yIHYtbW9kZWwgdXBkYXRlOnh4eCBldmVudHMsIGFsc28gdHJpZ2dlciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRcclxuICAgIC8vIGZvciBwcm9wcyBwYXNzZWQgdmlhIGtlYmFiLWNhc2VcclxuICAgIGlmICghaGFuZGxlciAmJiBpc01vZGVsTGlzdGVuZXIpIHtcclxuICAgICAgICBoYW5kbGVyID0gcHJvcHNbKGhhbmRsZXJOYW1lID0gdG9IYW5kbGVyS2V5KGh5cGhlbmF0ZShldmVudCkpKV07XHJcbiAgICB9XHJcbiAgICBpZiAoaGFuZGxlcikge1xyXG4gICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9uY2VIYW5kbGVyID0gcHJvcHNbaGFuZGxlck5hbWUgKyBgT25jZWBdO1xyXG4gICAgaWYgKG9uY2VIYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5lbWl0dGVkKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmVtaXR0ZWQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UuZW1pdHRlZFtoYW5kbGVyTmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5lbWl0dGVkW2hhbmRsZXJOYW1lXSA9IHRydWU7XHJcbiAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcob25jZUhhbmRsZXIsIGluc3RhbmNlLCA2IC8qIENPTVBPTkVOVF9FVkVOVF9IQU5ETEVSICovLCBhcmdzKTtcclxuICAgIH1cclxuICAgIHtcclxuICAgICAgICBjb21wYXRNb2RlbEVtaXQoaW5zdGFuY2UsIGV2ZW50LCBhcmdzKTtcclxuICAgICAgICByZXR1cm4gZW1pdCQxKGluc3RhbmNlLCBldmVudCwgYXJncyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplRW1pdHNPcHRpb25zKGNvbXAsIGFwcENvbnRleHQsIGFzTWl4aW4gPSBmYWxzZSkge1xyXG4gICAgY29uc3QgY2FjaGUgPSBhcHBDb250ZXh0LmVtaXRzQ2FjaGU7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoY29tcCk7XHJcbiAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmF3ID0gY29tcC5lbWl0cztcclxuICAgIGxldCBub3JtYWxpemVkID0ge307XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRFbWl0cyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEZyb21FeHRlbmQgPSBub3JtYWxpemVFbWl0c09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRGcm9tRXh0ZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNFeHRlbmRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChub3JtYWxpemVkLCBub3JtYWxpemVkRnJvbUV4dGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRFbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kRW1pdHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kRW1pdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIHJhdy5mb3JFYWNoKGtleSA9PiAobm9ybWFsaXplZFtrZXldID0gbnVsbCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHJhdyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoY29tcCwgbm9ybWFsaXplZCk7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufVxyXG4vLyBDaGVjayBpZiBhbiBpbmNvbWluZyBwcm9wIGtleSBpcyBhIGRlY2xhcmVkIGVtaXQgZXZlbnQgbGlzdGVuZXIuXHJcbi8vIGUuZy4gV2l0aCBgZW1pdHM6IHsgY2xpY2s6IG51bGwgfWAsIHByb3BzIG5hbWVkIGBvbkNsaWNrYCBhbmQgYG9uY2xpY2tgIGFyZVxyXG4vLyBib3RoIGNvbnNpZGVyZWQgbWF0Y2hlZCBsaXN0ZW5lcnMuXHJcbmZ1bmN0aW9uIGlzRW1pdExpc3RlbmVyKG9wdGlvbnMsIGtleSkge1xyXG4gICAgaWYgKCFvcHRpb25zIHx8ICFpc09uKGtleSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoY29tcGF0TW9kZWxFdmVudFByZWZpeCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGtleSA9IGtleS5zbGljZSgyKS5yZXBsYWNlKC9PbmNlJC8sICcnKTtcclxuICAgIHJldHVybiAoaGFzT3duKG9wdGlvbnMsIGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKSB8fFxyXG4gICAgICAgIGhhc093bihvcHRpb25zLCBoeXBoZW5hdGUoa2V5KSkgfHxcclxuICAgICAgICBoYXNPd24ob3B0aW9ucywga2V5KSk7XHJcbn1cblxuLyoqXHJcbiAqIG1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGluc3RhbmNlIGZvciBhc3NldCByZXNvbHV0aW9uIChlLmcuXHJcbiAqIHJlc29sdmVDb21wb25lbnQsIHJlc29sdmVEaXJlY3RpdmUpIGR1cmluZyByZW5kZXJcclxuICovXHJcbmxldCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xyXG5sZXQgY3VycmVudFNjb3BlSWQgPSBudWxsO1xyXG4vKipcclxuICogTm90ZTogcmVuZGVyaW5nIGNhbGxzIG1heWJlIG5lc3RlZC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlIHBhcmVudCByZW5kZXJpbmdcclxuICogaW5zdGFuY2UgaWYgcHJlc2VudCwgd2hpY2ggc2hvdWxkIGJlIHJlc3RvcmVkIGFmdGVyIHRoZSByZW5kZXIgaXMgZG9uZTpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpKVxyXG4gKiAvLyAuLi5yZW5kZXJcclxuICogc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKHByZXYpXHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlKGluc3RhbmNlKSB7XHJcbiAgICBjb25zdCBwcmV2ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IChpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9fc2NvcGVJZCkgfHwgbnVsbDtcclxuICAgIC8vIHYyIHByZS1jb21waWxlZCBjb21wb25lbnRzIHVzZXMgX3Njb3BlSWQgaW5zdGVhZCBvZiBfX3Njb3BlSWRcclxuICAgIGlmICghY3VycmVudFNjb3BlSWQpIHtcclxuICAgICAgICBjdXJyZW50U2NvcGVJZCA9IChpbnN0YW5jZSAmJiBpbnN0YW5jZS50eXBlLl9zY29wZUlkKSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByZXY7XHJcbn1cclxuLyoqXHJcbiAqIFNldCBzY29wZSBpZCB3aGVuIGNyZWF0aW5nIGhvaXN0ZWQgdm5vZGVzLlxyXG4gKiBAcHJpdmF0ZSBjb21waWxlciBoZWxwZXJcclxuICovXHJcbmZ1bmN0aW9uIHB1c2hTY29wZUlkKGlkKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IGlkO1xyXG59XHJcbi8qKlxyXG4gKiBUZWNobmljYWxseSB3ZSBubyBsb25nZXIgbmVlZCB0aGlzIGFmdGVyIDMuMC44IGJ1dCB3ZSBuZWVkIHRvIGtlZXAgdGhlIHNhbWVcclxuICogQVBJIGZvciBiYWNrd2FyZHMgY29tcGF0IHcvIGNvZGUgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVycy5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBvcFNjb3BlSWQoKSB7XHJcbiAgICBjdXJyZW50U2NvcGVJZCA9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHdpdGhTY29wZUlkID0gKF9pZCkgPT4gd2l0aEN0eDtcclxuLyoqXHJcbiAqIFdyYXAgYSBzbG90IGZ1bmN0aW9uIHRvIG1lbW9pemUgY3VycmVudCByZW5kZXJpbmcgaW5zdGFuY2VcclxuICogQHByaXZhdGUgY29tcGlsZXIgaGVscGVyXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoQ3R4KGZuLCBjdHggPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UsIGlzTm9uU2NvcGVkU2xvdCAvLyB0cnVlIG9ubHlcclxuKSB7XHJcbiAgICBpZiAoIWN0eClcclxuICAgICAgICByZXR1cm4gZm47XHJcbiAgICAvLyBhbHJlYWR5IG5vcm1hbGl6ZWRcclxuICAgIGlmIChmbi5fbikge1xyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlbmRlckZuV2l0aENvbnRleHQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIC8vIElmIGEgdXNlciBjYWxscyBhIGNvbXBpbGVkIHNsb3QgaW5zaWRlIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiAoIzE3NDUpLCBpdFxyXG4gICAgICAgIC8vIGNhbiBtZXNzIHVwIGJsb2NrIHRyYWNraW5nLCBzbyBieSBkZWZhdWx0IHdlIGRpc2FibGUgYmxvY2sgdHJhY2tpbmcgYW5kXHJcbiAgICAgICAgLy8gZm9yY2UgYmFpbCBvdXQgd2hlbiBpbnZva2luZyBhIGNvbXBpbGVkIHNsb3QgKGluZGljYXRlZCBieSB0aGUgLl9kIGZsYWcpLlxyXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgbmVjZXNzYXJ5IGlmIHJlbmRlcmluZyBhIGNvbXBpbGVkIGA8c2xvdD5gLCBzbyB3ZSBmbGlwIHRoZVxyXG4gICAgICAgIC8vIC5fZCBmbGFnIG9mZiB3aGVuIGludm9raW5nIHRoZSB3cmFwcGVkIGZuIGluc2lkZSBgcmVuZGVyU2xvdGAuXHJcbiAgICAgICAgaWYgKHJlbmRlckZuV2l0aENvbnRleHQuX2QpIHtcclxuICAgICAgICAgICAgc2V0QmxvY2tUcmFja2luZygtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHByZXZJbnN0YW5jZSA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShjdHgpO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgIHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShwcmV2SW5zdGFuY2UpO1xyXG4gICAgICAgIGlmIChyZW5kZXJGbldpdGhDb250ZXh0Ll9kKSB7XHJcbiAgICAgICAgICAgIHNldEJsb2NrVHJhY2tpbmcoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50VXBkYXRlZChjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIC8vIG1hcmsgbm9ybWFsaXplZCB0byBhdm9pZCBkdXBsaWNhdGVkIHdyYXBwaW5nXHJcbiAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9uID0gdHJ1ZTtcclxuICAgIC8vIG1hcmsgdGhpcyBhcyBjb21waWxlZCBieSBkZWZhdWx0XHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgaW4gdm5vZGUudHMgLT4gbm9ybWFsaXplQ2hpbGRyZW4oKSB0byBzZXQgdGhlIHNsb3RcclxuICAgIC8vIHJlbmRlcmluZyBmbGFnLlxyXG4gICAgcmVuZGVyRm5XaXRoQ29udGV4dC5fYyA9IHRydWU7XHJcbiAgICAvLyBkaXNhYmxlIGJsb2NrIHRyYWNraW5nIGJ5IGRlZmF1bHRcclxuICAgIHJlbmRlckZuV2l0aENvbnRleHQuX2QgPSB0cnVlO1xyXG4gICAgLy8gY29tcGF0IGJ1aWxkIG9ubHkgZmxhZyB0byBkaXN0aW5ndWlzaCBzY29wZWQgc2xvdHMgZnJvbSBub24tc2NvcGVkIG9uZXNcclxuICAgIGlmIChpc05vblNjb3BlZFNsb3QpIHtcclxuICAgICAgICByZW5kZXJGbldpdGhDb250ZXh0Ll9ucyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVuZGVyRm5XaXRoQ29udGV4dDtcclxufVxuXG4vKipcclxuICogZGV2IG9ubHkgZmxhZyB0byB0cmFjayB3aGV0aGVyICRhdHRycyB3YXMgdXNlZCBkdXJpbmcgcmVuZGVyLlxyXG4gKiBJZiAkYXR0cnMgd2FzIHVzZWQgZHVyaW5nIHJlbmRlciB0aGVuIHRoZSB3YXJuaW5nIGZvciBmYWlsZWQgYXR0cnNcclxuICogZmFsbHRocm91Z2ggY2FuIGJlIHN1cHByZXNzZWQuXHJcbiAqL1xyXG5sZXQgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG5mdW5jdGlvbiBtYXJrQXR0cnNBY2Nlc3NlZCgpIHtcclxuICAgIGFjY2Vzc2VkQXR0cnMgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgdHlwZTogQ29tcG9uZW50LCB2bm9kZSwgcHJveHksIHdpdGhQcm94eSwgcHJvcHMsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10sIHNsb3RzLCBhdHRycywgZW1pdCwgcmVuZGVyLCByZW5kZXJDYWNoZSwgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4LCBpbmhlcml0QXR0cnMgfSA9IGluc3RhbmNlO1xyXG4gICAgbGV0IHJlc3VsdDtcclxuICAgIGxldCBmYWxsdGhyb3VnaEF0dHJzO1xyXG4gICAgY29uc3QgcHJldiA9IHNldEN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgYWNjZXNzZWRBdHRycyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgLy8gd2l0aFByb3h5IGlzIGEgcHJveHkgd2l0aCBhIGRpZmZlcmVudCBgaGFzYCB0cmFwIG9ubHkgZm9yXHJcbiAgICAgICAgICAgIC8vIHJ1bnRpbWUtY29tcGlsZWQgcmVuZGVyIGZ1bmN0aW9ucyB1c2luZyBgd2l0aGAgYmxvY2suXHJcbiAgICAgICAgICAgIGNvbnN0IHByb3h5VG9Vc2UgPSB3aXRoUHJveHkgfHwgcHJveHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vcm1hbGl6ZVZOb2RlKHJlbmRlci5jYWxsKHByb3h5VG9Vc2UsIHByb3h5VG9Vc2UsIHJlbmRlckNhY2hlLCBwcm9wcywgc2V0dXBTdGF0ZSwgZGF0YSwgY3R4KSk7XHJcbiAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyID0gQ29tcG9uZW50O1xyXG4gICAgICAgICAgICAvLyBpbiBkZXYsIG1hcmsgYXR0cnMgYWNjZXNzZWQgaWYgb3B0aW9uYWwgcHJvcHMgKGF0dHJzID09PSBwcm9wcylcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBhdHRycyA9PT0gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ID0gbm9ybWFsaXplVk5vZGUocmVuZGVyLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gcmVuZGVyKHByb3BzLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGF0dHJzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xvdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgOiB7IGF0dHJzLCBzbG90cywgZW1pdCB9KVxyXG4gICAgICAgICAgICAgICAgOiByZW5kZXIocHJvcHMsIG51bGwgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi8pKTtcclxuICAgICAgICAgICAgZmFsbHRocm91Z2hBdHRycyA9IENvbXBvbmVudC5wcm9wc1xyXG4gICAgICAgICAgICAgICAgPyBhdHRyc1xyXG4gICAgICAgICAgICAgICAgOiBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2goYXR0cnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBibG9ja1N0YWNrLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyLCBpbnN0YW5jZSwgMSAvKiBSRU5ERVJfRlVOQ1RJT04gKi8pO1xyXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLy8gYXR0ciBtZXJnaW5nXHJcbiAgICAvLyBpbiBkZXYgbW9kZSwgY29tbWVudHMgYXJlIHByZXNlcnZlZCwgYW5kIGl0J3MgcG9zc2libGUgZm9yIGEgdGVtcGxhdGVcclxuICAgIC8vIHRvIGhhdmUgY29tbWVudHMgYWxvbmcgc2lkZSB0aGUgcm9vdCBlbGVtZW50IHdoaWNoIG1ha2VzIGl0IGEgZnJhZ21lbnRcclxuICAgIGxldCByb290ID0gcmVzdWx0O1xyXG4gICAgbGV0IHNldFJvb3QgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgcmVzdWx0LnBhdGNoRmxhZyA+IDAgJiZcclxuICAgICAgICByZXN1bHQucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLykge1xyXG4gICAgICAgIFtyb290LCBzZXRSb290XSA9IGdldENoaWxkUm9vdChyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZhbGx0aHJvdWdoQXR0cnMgJiYgaW5oZXJpdEF0dHJzICE9PSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmYWxsdGhyb3VnaEF0dHJzKTtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZyB9ID0gcm9vdDtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmICgxIC8qIEVMRU1FTlQgKi8gfCA2IC8qIENPTVBPTkVOVCAqLykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wc09wdGlvbnMgJiYga2V5cy5zb21lKGlzTW9kZWxMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHYtbW9kZWwgbGlzdGVuZXIgKG9uVXBkYXRlOnh4eCkgaGFzIGEgY29ycmVzcG9uZGluZyBkZWNsYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHByb3AsIGl0IGluZGljYXRlcyB0aGlzIGNvbXBvbmVudCBleHBlY3RzIHRvIGhhbmRsZSB2LW1vZGVsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBub3QgZmFsbHRocm91Z2guXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsYXRlZDogIzE1NDMsICMxNjQzLCAjMTk4OVxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGx0aHJvdWdoQXR0cnMgPSBmaWx0ZXJNb2RlbExpc3RlbmVycyhmYWxsdGhyb3VnaEF0dHJzLCBwcm9wc09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcm9vdCA9IGNsb25lVk5vZGUocm9vdCwgZmFsbHRocm91Z2hBdHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFhY2Nlc3NlZEF0dHJzICYmIHJvb3QudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudEF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYUF0dHJzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFsbEF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFsbEF0dHJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09uKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgaGFuZGxlcnMgd2hlbiB0aGV5IGZhaWwgdG8gZmFsbHRocm91Z2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGBvbmAsIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgdG8gcmVmbGVjdCBldmVudCBjYXNpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY3VyYXRlbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50QXR0cnMucHVzaChrZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhQXR0cnMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChleHRyYUF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgRXh0cmFuZW91cyBub24tcHJvcHMgYXR0cmlidXRlcyAoYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke2V4dHJhQXR0cnMuam9pbignLCAnKX0pIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgd2VyZSBwYXNzZWQgdG8gY29tcG9uZW50IGJ1dCBjb3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBpbmhlcml0ZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChldmVudEF0dHJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgRXh0cmFuZW91cyBub24tZW1pdHMgZXZlbnQgbGlzdGVuZXJzIChgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZXZlbnRBdHRycy5qb2luKCcsICcpfSkgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYElmIHRoZSBsaXN0ZW5lciBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbXBvbmVudCBjdXN0b20gZXZlbnQgbGlzdGVuZXIgb25seSwgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBkZWNsYXJlIGl0IHVzaW5nIHRoZSBcImVtaXRzXCIgb3B0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIklOU1RBTkNFX0FUVFJTX0NMQVNTX1NUWUxFXCIgLyogSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEUgKi8sIGluc3RhbmNlKSAmJlxyXG4gICAgICAgIHZub2RlLnNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgcm9vdC5zaGFwZUZsYWcgJiAoMSAvKiBFTEVNRU5UICovIHwgNiAvKiBDT01QT05FTlQgKi8pKSB7XHJcbiAgICAgICAgY29uc3QgeyBjbGFzczogY2xzLCBzdHlsZSB9ID0gdm5vZGUucHJvcHMgfHwge307XHJcbiAgICAgICAgaWYgKGNscyB8fCBzdHlsZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5EZXByZWNhdGlvbihcIklOU1RBTkNFX0FUVFJTX0NMQVNTX1NUWUxFXCIgLyogSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEUgKi8sIGluc3RhbmNlLCBnZXRDb21wb25lbnROYW1lKGluc3RhbmNlLnR5cGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb290ID0gY2xvbmVWTm9kZShyb290LCB7XHJcbiAgICAgICAgICAgICAgICBjbGFzczogY2xzLFxyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgaWYgKHZub2RlLmRpcnMpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0VsZW1lbnRSb290KHJvb3QpKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgUnVudGltZSBkaXJlY3RpdmUgdXNlZCBvbiBjb21wb25lbnQgd2l0aCBub24tZWxlbWVudCByb290IG5vZGUuIGAgK1xyXG4gICAgICAgICAgICAgICAgYFRoZSBkaXJlY3RpdmVzIHdpbGwgbm90IGZ1bmN0aW9uIGFzIGludGVuZGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbG9uZSBiZWZvcmUgbXV0YXRpbmcgc2luY2UgdGhlIHJvb3QgbWF5IGJlIGEgaG9pc3RlZCB2bm9kZVxyXG4gICAgICAgIHJvb3QgPSBjbG9uZVZOb2RlKHJvb3QpO1xyXG4gICAgICAgIHJvb3QuZGlycyA9IHJvb3QuZGlycyA/IHJvb3QuZGlycy5jb25jYXQodm5vZGUuZGlycykgOiB2bm9kZS5kaXJzO1xyXG4gICAgfVxyXG4gICAgLy8gaW5oZXJpdCB0cmFuc2l0aW9uIGRhdGFcclxuICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNFbGVtZW50Um9vdChyb290KSkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYENvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb290LnRyYW5zaXRpb24gPSB2bm9kZS50cmFuc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBzZXRSb290KSB7XHJcbiAgICAgICAgc2V0Um9vdChyb290KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdCA9IHJvb3Q7XHJcbiAgICB9XHJcbiAgICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UocHJldik7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKiBJbiBkZXYgbW9kZSwgdGVtcGxhdGUgcm9vdCBsZXZlbCBjb21tZW50cyBhcmUgcmVuZGVyZWQsIHdoaWNoIHR1cm5zIHRoZVxyXG4gKiB0ZW1wbGF0ZSBpbnRvIGEgZnJhZ21lbnQgcm9vdCwgYnV0IHdlIG5lZWQgdG8gbG9jYXRlIHRoZSBzaW5nbGUgZWxlbWVudFxyXG4gKiByb290IGZvciBhdHRycyBhbmQgc2NvcGUgaWQgcHJvY2Vzc2luZy5cclxuICovXHJcbmNvbnN0IGdldENoaWxkUm9vdCA9ICh2bm9kZSkgPT4ge1xyXG4gICAgY29uc3QgcmF3Q2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgIGNvbnN0IGR5bmFtaWNDaGlsZHJlbiA9IHZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgIGNvbnN0IGNoaWxkUm9vdCA9IGZpbHRlclNpbmdsZVJvb3QocmF3Q2hpbGRyZW4pO1xyXG4gICAgaWYgKCFjaGlsZFJvb3QpIHtcclxuICAgICAgICByZXR1cm4gW3Zub2RlLCB1bmRlZmluZWRdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5kZXggPSByYXdDaGlsZHJlbi5pbmRleE9mKGNoaWxkUm9vdCk7XHJcbiAgICBjb25zdCBkeW5hbWljSW5kZXggPSBkeW5hbWljQ2hpbGRyZW4gPyBkeW5hbWljQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFJvb3QpIDogLTE7XHJcbiAgICBjb25zdCBzZXRSb290ID0gKHVwZGF0ZWRSb290KSA9PiB7XHJcbiAgICAgICAgcmF3Q2hpbGRyZW5baW5kZXhdID0gdXBkYXRlZFJvb3Q7XHJcbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY0luZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbltkeW5hbWljSW5kZXhdID0gdXBkYXRlZFJvb3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXBkYXRlZFJvb3QucGF0Y2hGbGFnID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gWy4uLmR5bmFtaWNDaGlsZHJlbiwgdXBkYXRlZFJvb3RdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBbbm9ybWFsaXplVk5vZGUoY2hpbGRSb290KSwgc2V0Um9vdF07XHJcbn07XHJcbmZ1bmN0aW9uIGZpbHRlclNpbmdsZVJvb3QoY2hpbGRyZW4pIHtcclxuICAgIGxldCBzaW5nbGVSb290O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgIC8vIGlnbm9yZSB1c2VyIGNvbW1lbnRcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IENvbW1lbnQgfHwgY2hpbGQuY2hpbGRyZW4gPT09ICd2LWlmJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZVJvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9yZSB0aGFuIDEgbm9uLWNvbW1lbnQgY2hpbGQsIHJldHVybiBub3dcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVSb290ID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2luZ2xlUm9vdDtcclxufVxyXG5jb25zdCBnZXRGdW5jdGlvbmFsRmFsbHRocm91Z2ggPSAoYXR0cnMpID0+IHtcclxuICAgIGxldCByZXM7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnIHx8IGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAocmVzIHx8IChyZXMgPSB7fSkpW2tleV0gPSBhdHRyc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcbmNvbnN0IGZpbHRlck1vZGVsTGlzdGVuZXJzID0gKGF0dHJzLCBwcm9wcykgPT4ge1xyXG4gICAgY29uc3QgcmVzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmICghaXNNb2RlbExpc3RlbmVyKGtleSkgfHwgIShrZXkuc2xpY2UoOSkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gYXR0cnNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5jb25zdCBpc0VsZW1lbnRSb290ID0gKHZub2RlKSA9PiB7XHJcbiAgICByZXR1cm4gKHZub2RlLnNoYXBlRmxhZyAmICg2IC8qIENPTVBPTkVOVCAqLyB8IDEgLyogRUxFTUVOVCAqLykgfHxcclxuICAgICAgICB2bm9kZS50eXBlID09PSBDb21tZW50IC8vIHBvdGVudGlhbCB2LWlmIGJyYW5jaCBzd2l0Y2hcclxuICAgICk7XHJcbn07XHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZUNvbXBvbmVudChwcmV2Vk5vZGUsIG5leHRWTm9kZSwgb3B0aW1pemVkKSB7XHJcbiAgICBjb25zdCB7IHByb3BzOiBwcmV2UHJvcHMsIGNoaWxkcmVuOiBwcmV2Q2hpbGRyZW4sIGNvbXBvbmVudCB9ID0gcHJldlZOb2RlO1xyXG4gICAgY29uc3QgeyBwcm9wczogbmV4dFByb3BzLCBjaGlsZHJlbjogbmV4dENoaWxkcmVuLCBwYXRjaEZsYWcgfSA9IG5leHRWTm9kZTtcclxuICAgIGNvbnN0IGVtaXRzID0gY29tcG9uZW50LmVtaXRzT3B0aW9ucztcclxuICAgIC8vIFBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24gd2FzIGhvdC11cGRhdGVkLiBTaW5jZSB0aGlzIG1heSBoYXZlXHJcbiAgICAvLyBjYXVzZWQgdGhlIGNoaWxkIGNvbXBvbmVudCdzIHNsb3RzIGNvbnRlbnQgdG8gaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvXHJcbiAgICAvLyBmb3JjZSB0aGUgY2hpbGQgdG8gdXBkYXRlIGFzIHdlbGwuXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIChwcmV2Q2hpbGRyZW4gfHwgbmV4dENoaWxkcmVuKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBmb3JjZSBjaGlsZCB1cGRhdGUgZm9yIHJ1bnRpbWUgZGlyZWN0aXZlIG9yIHRyYW5zaXRpb24gb24gY29tcG9uZW50IHZub2RlLlxyXG4gICAgaWYgKG5leHRWTm9kZS5kaXJzIHx8IG5leHRWTm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW1pemVkICYmIHBhdGNoRmxhZyA+PSAwKSB7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEwMjQgLyogRFlOQU1JQ19TTE9UUyAqLykge1xyXG4gICAgICAgICAgICAvLyBzbG90IGNvbnRlbnQgdGhhdCByZWZlcmVuY2VzIHZhbHVlcyB0aGF0IG1pZ2h0IGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gZS5nLiBpbiBhIHYtZm9yXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykge1xyXG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmV4dFByb3BzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByZXNlbmNlIG9mIHRoaXMgZmxhZyBpbmRpY2F0ZXMgcHJvcHMgYXJlIGFsd2F5cyBub24tbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gaGFzUHJvcHNDaGFuZ2VkKHByZXZQcm9wcywgbmV4dFByb3BzLCBlbWl0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY1Byb3BzID0gbmV4dFZOb2RlLmR5bmFtaWNQcm9wcztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkeW5hbWljUHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGR5bmFtaWNQcm9wc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHNba2V5XSAhPT0gcHJldlByb3BzW2tleV0gJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNFbWl0TGlzdGVuZXIoZW1pdHMsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHRha2VuIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgICAgIC8vIHNvIHByZXNlbmNlIG9mIGFueSBjaGlsZHJlbiBsZWFkcyB0byBhIGZvcmNlZCB1cGRhdGVcclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuIHx8IG5leHRDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAoIW5leHRDaGlsZHJlbiB8fCAhbmV4dENoaWxkcmVuLiRzdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmV2UHJvcHMgPT09IG5leHRQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcHJldlByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIW5leHRQcm9wcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFuZXh0UHJvcHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBoYXNQcm9wc0NoYW5nZWQocHJldlByb3BzLCBuZXh0UHJvcHMsIGVtaXRzT3B0aW9ucykge1xyXG4gICAgY29uc3QgbmV4dEtleXMgPSBPYmplY3Qua2V5cyhuZXh0UHJvcHMpO1xyXG4gICAgaWYgKG5leHRLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMocHJldlByb3BzKS5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXh0S2V5c1tpXTtcclxuICAgICAgICBpZiAobmV4dFByb3BzW2tleV0gIT09IHByZXZQcm9wc1trZXldICYmXHJcbiAgICAgICAgICAgICFpc0VtaXRMaXN0ZW5lcihlbWl0c09wdGlvbnMsIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUhPQ0hvc3RFbCh7IHZub2RlLCBwYXJlbnQgfSwgZWwgLy8gSG9zdE5vZGVcclxuKSB7XHJcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5zdWJUcmVlID09PSB2bm9kZSkge1xyXG4gICAgICAgICh2bm9kZSA9IHBhcmVudC52bm9kZSkuZWwgPSBlbDtcclxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGlzU3VzcGVuc2UgPSAodHlwZSkgPT4gdHlwZS5fX2lzU3VzcGVuc2U7XHJcbi8vIFN1c3BlbnNlIGV4cG9zZXMgYSBjb21wb25lbnQtbGlrZSBBUEksIGFuZCBpcyB0cmVhdGVkIGxpa2UgYSBjb21wb25lbnRcclxuLy8gaW4gdGhlIGNvbXBpbGVyLCBidXQgaW50ZXJuYWxseSBpdCdzIGEgc3BlY2lhbCBidWlsdC1pbiB0eXBlIHRoYXQgaG9va3NcclxuLy8gZGlyZWN0bHkgaW50byB0aGUgcmVuZGVyZXIuXHJcbmNvbnN0IFN1c3BlbnNlSW1wbCA9IHtcclxuICAgIG5hbWU6ICdTdXNwZW5zZScsXHJcbiAgICAvLyBJbiBvcmRlciB0byBtYWtlIFN1c3BlbnNlIHRyZWUtc2hha2FibGUsIHdlIG5lZWQgdG8gYXZvaWQgaW1wb3J0aW5nIGl0XHJcbiAgICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xyXG4gICAgLy8gb24gYSB2bm9kZSdzIHR5cGUgYW5kIGNhbGxzIHRoZSBgcHJvY2Vzc2AgbWV0aG9kLCBwYXNzaW5nIGluIHJlbmRlcmVyXHJcbiAgICAvLyBpbnRlcm5hbHMuXHJcbiAgICBfX2lzU3VzcGVuc2U6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgXHJcbiAgICAvLyBwbGF0Zm9ybS1zcGVjaWZpYyBpbXBsIHBhc3NlZCBmcm9tIHJlbmRlcmVyXHJcbiAgICByZW5kZXJlckludGVybmFscykge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50U3VzcGVuc2UobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGNoU3VzcGVuc2UobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaHlkcmF0ZTogaHlkcmF0ZVN1c3BlbnNlLFxyXG4gICAgY3JlYXRlOiBjcmVhdGVTdXNwZW5zZUJvdW5kYXJ5LFxyXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuXHJcbn07XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFN1c3BlbnNlID0gKFN1c3BlbnNlSW1wbCApO1xyXG5mdW5jdGlvbiB0cmlnZ2VyRXZlbnQodm5vZGUsIG5hbWUpIHtcclxuICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wc1tuYW1lXTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGV2ZW50TGlzdGVuZXIpKSB7XHJcbiAgICAgICAgZXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2Uodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzKSB7XHJcbiAgICBjb25zdCB7IHA6IHBhdGNoLCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9ID0gcmVuZGVyZXJJbnRlcm5hbHM7XHJcbiAgICBjb25zdCBoaWRkZW5Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0gKHZub2RlLnN1c3BlbnNlID0gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50U3VzcGVuc2UsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBoaWRkZW5Db250YWluZXIsIGFuY2hvciwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscykpO1xyXG4gICAgLy8gc3RhcnQgbW91bnRpbmcgdGhlIGNvbnRlbnQgc3VidHJlZSBpbiBhbiBvZmYtZG9tIGNvbnRhaW5lclxyXG4gICAgcGF0Y2gobnVsbCwgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSB2bm9kZS5zc0NvbnRlbnQpLCBoaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgLy8gbm93IGNoZWNrIGlmIHdlIGhhdmUgZW5jb3VudGVyZWQgYW55IGFzeW5jIGRlcHNcclxuICAgIGlmIChzdXNwZW5zZS5kZXBzID4gMCkge1xyXG4gICAgICAgIC8vIGhhcyBhc3luY1xyXG4gICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcclxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvblBlbmRpbmcnKTtcclxuICAgICAgICB0cmlnZ2VyRXZlbnQodm5vZGUsICdvbkZhbGxiYWNrJyk7XHJcbiAgICAgICAgLy8gbW91bnQgdGhlIGZhbGxiYWNrIHRyZWVcclxuICAgICAgICBwYXRjaChudWxsLCB2bm9kZS5zc0ZhbGxiYWNrLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgdm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBTdXNwZW5zZSBoYXMgbm8gYXN5bmMgZGVwcy4gSnVzdCByZXNvbHZlLlxyXG4gICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwYXRjaFN1c3BlbnNlKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCB7IHA6IHBhdGNoLCB1bTogdW5tb3VudCwgbzogeyBjcmVhdGVFbGVtZW50IH0gfSkge1xyXG4gICAgY29uc3Qgc3VzcGVuc2UgPSAobjIuc3VzcGVuc2UgPSBuMS5zdXNwZW5zZSk7XHJcbiAgICBzdXNwZW5zZS52bm9kZSA9IG4yO1xyXG4gICAgbjIuZWwgPSBuMS5lbDtcclxuICAgIGNvbnN0IG5ld0JyYW5jaCA9IG4yLnNzQ29udGVudDtcclxuICAgIGNvbnN0IG5ld0ZhbGxiYWNrID0gbjIuc3NGYWxsYmFjaztcclxuICAgIGNvbnN0IHsgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBpc0luRmFsbGJhY2ssIGlzSHlkcmF0aW5nIH0gPSBzdXNwZW5zZTtcclxuICAgIGlmIChwZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICBpZiAoaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgcGVuZGluZ0JyYW5jaCkpIHtcclxuICAgICAgICAgICAgLy8gc2FtZSByb290IHR5cGUgYnV0IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgcGF0Y2gocGVuZGluZ0JyYW5jaCwgbmV3QnJhbmNoLCBzdXNwZW5zZS5oaWRkZW5Db250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5kZXBzIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlQnJhbmNoKHN1c3BlbnNlLCBuZXdGYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRvZ2dsZWQgYmVmb3JlIHBlbmRpbmcgdHJlZSBpcyByZXNvbHZlZFxyXG4gICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQrKztcclxuICAgICAgICAgICAgaWYgKGlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0b2dnbGVkIGJlZm9yZSBoeWRyYXRpb24gaXMgZmluaXNoZWQsIHRoZSBjdXJyZW50IERPTSB0cmVlIGlzXHJcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgdmFsaWQuIHNldCBpdCBhcyB0aGUgYWN0aXZlIGJyYW5jaCBzbyBpdCB3aWxsIGJlIHVubW91bnRlZFxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiByZXNvbHZlZFxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNIeWRyYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCA9IHBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCBwZW5kaW5nIElELiB0aGlzIGlzIHVzZWQgdG8gaW52YWxpZGF0ZSBhc3luYyBjYWxsYmFja3NcclxuICAgICAgICAgICAgLy8gcmVzZXQgc3VzcGVuc2Ugc3RhdGVcclxuICAgICAgICAgICAgc3VzcGVuc2UuZGVwcyA9IDA7XHJcbiAgICAgICAgICAgIC8vIGRpc2NhcmQgZWZmZWN0cyBmcm9tIHBlbmRpbmcgYnJhbmNoXHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgLy8gZGlzY2FyZCBwcmV2aW91cyBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGlmIChpc0luRmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgaW4gZmFsbGJhY2sgc3RhdGVcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3RmFsbGJhY2ssIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIG51bGwsIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRBY3RpdmVCcmFuY2goc3VzcGVuc2UsIG5ld0ZhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlZCBcImJhY2tcIiB0byBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKGFjdGl2ZUJyYW5jaCwgbmV3QnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHJlc29sdmVcclxuICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBzd2l0Y2hlZCB0byBhIDNyZCBicmFuY2hcclxuICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmRlcHMgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChhY3RpdmVCcmFuY2ggJiYgaXNTYW1lVk5vZGVUeXBlKG5ld0JyYW5jaCwgYWN0aXZlQnJhbmNoKSkge1xyXG4gICAgICAgICAgICAvLyByb290IGRpZCBub3QgY2hhbmdlLCBqdXN0IG5vcm1hbCBwYXRjaFxyXG4gICAgICAgICAgICBwYXRjaChhY3RpdmVCcmFuY2gsIG5ld0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgbmV3QnJhbmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJvb3Qgbm9kZSB0b2dnbGVkXHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAcGVuZGluZyBldmVudFxyXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQobjIsICdvblBlbmRpbmcnKTtcclxuICAgICAgICAgICAgLy8gbW91bnQgcGVuZGluZyBicmFuY2ggaW4gb2ZmLWRvbSBjb250YWluZXJcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0JyYW5jaCA9IG5ld0JyYW5jaDtcclxuICAgICAgICAgICAgc3VzcGVuc2UucGVuZGluZ0lkKys7XHJcbiAgICAgICAgICAgIHBhdGNoKG51bGwsIG5ld0JyYW5jaCwgc3VzcGVuc2UuaGlkZGVuQ29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuZGVwcyA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmNvbWluZyBicmFuY2ggaGFzIG5vIGFzeW5jIGRlcHMsIHJlc29sdmUgbm93LlxyXG4gICAgICAgICAgICAgICAgc3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0aW1lb3V0LCBwZW5kaW5nSWQgfSA9IHN1c3BlbnNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nSWQgPT09IHBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aW1lb3V0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuZmFsbGJhY2sobmV3RmFsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcclxuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VCb3VuZGFyeSh2bm9kZSwgcGFyZW50LCBwYXJlbnRDb21wb25lbnQsIGNvbnRhaW5lciwgaGlkZGVuQ29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIGlzSHlkcmF0aW5nID0gZmFsc2UpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UgJiYgIWhhc1dhcm5lZCkge1xyXG4gICAgICAgIGhhc1dhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY29uc29sZS5pbmZvYCBjYW5ub3QgYmUgbnVsbCBlcnJvclxyXG4gICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKGA8U3VzcGVuc2U+IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBpdHMgQVBJIHdpbGwgbGlrZWx5IGNoYW5nZS5gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgcDogcGF0Y2gsIG06IG1vdmUsIHVtOiB1bm1vdW50LCBuOiBuZXh0LCBvOiB7IHBhcmVudE5vZGUsIHJlbW92ZSB9IH0gPSByZW5kZXJlckludGVybmFscztcclxuICAgIGNvbnN0IHRpbWVvdXQgPSB0b051bWJlcih2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50aW1lb3V0KTtcclxuICAgIGNvbnN0IHN1c3BlbnNlID0ge1xyXG4gICAgICAgIHZub2RlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgaXNTVkcsXHJcbiAgICAgICAgY29udGFpbmVyLFxyXG4gICAgICAgIGhpZGRlbkNvbnRhaW5lcixcclxuICAgICAgICBhbmNob3IsXHJcbiAgICAgICAgZGVwczogMCxcclxuICAgICAgICBwZW5kaW5nSWQ6IDAsXHJcbiAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInID8gdGltZW91dCA6IC0xLFxyXG4gICAgICAgIGFjdGl2ZUJyYW5jaDogbnVsbCxcclxuICAgICAgICBwZW5kaW5nQnJhbmNoOiBudWxsLFxyXG4gICAgICAgIGlzSW5GYWxsYmFjazogdHJ1ZSxcclxuICAgICAgICBpc0h5ZHJhdGluZyxcclxuICAgICAgICBpc1VubW91bnRlZDogZmFsc2UsXHJcbiAgICAgICAgZWZmZWN0czogW10sXHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bWUgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZSAmJiAhc3VzcGVuc2UucGVuZGluZ0JyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3VzcGVuc2UucmVzb2x2ZSgpIGlzIGNhbGxlZCB3aXRob3V0IGEgcGVuZGluZyBicmFuY2guYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuc2UuaXNVbm1vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgb24gYW4gYWxyZWFkeSB1bm1vdW50ZWQgc3VzcGVuc2UgYm91bmRhcnkuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeyB2bm9kZSwgYWN0aXZlQnJhbmNoLCBwZW5kaW5nQnJhbmNoLCBwZW5kaW5nSWQsIGVmZmVjdHMsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgaWYgKHN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5pc0h5ZHJhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyZXN1bWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBhY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQnJhbmNoLnRyYW5zaXRpb24ubW9kZSA9PT0gJ291dC1pbic7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUJyYW5jaC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nSWQgPT09IHN1c3BlbnNlLnBlbmRpbmdJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShwZW5kaW5nQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgMCAvKiBFTlRFUiAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBpbml0aWFsIGFuY2hvciBvbiBtb3VudFxyXG4gICAgICAgICAgICAgICAgbGV0IHsgYW5jaG9yIH0gPSBzdXNwZW5zZTtcclxuICAgICAgICAgICAgICAgIC8vIHVubW91bnQgY3VycmVudCBhY3RpdmUgdHJlZVxyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUJyYW5jaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBmYWxsYmFjayB0cmVlIHdhcyBtb3VudGVkLCBpdCBtYXkgaGF2ZSBiZWVuIG1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgcGFydCBvZiBhIHBhcmVudCBzdXNwZW5zZS4gZ2V0IHRoZSBsYXRlc3QgYW5jaG9yIGZvciBpbnNlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgc3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkZWxheUVudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBjb250ZW50IGZyb20gb2ZmLWRvbSBjb250YWluZXIgdG8gYWN0dWFsIGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgIG1vdmUocGVuZGluZ0JyYW5jaCwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgcGVuZGluZ0JyYW5jaCk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggPSBudWxsO1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5pc0luRmFsbGJhY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gZmx1c2ggYnVmZmVyZWQgZWZmZWN0c1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgcGFyZW50IHN1c3BlbnNlXHJcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBzdXNwZW5zZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCBoYXNVbnJlc29sdmVkQW5jZXN0b3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgYSBwZW5kaW5nIHBhcmVudCBzdXNwZW5zZSwgbWVyZ2UgYnVmZmVyZWQgcG9zdCBqb2JzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50byB0aGF0IHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5lZmZlY3RzLnB1c2goLi4uZWZmZWN0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5yZXNvbHZlZEFuY2VzdG9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbm8gcGVuZGluZyBwYXJlbnQgc3VzcGVuc2UsIGZsdXNoIGFsbCBqb2JzXHJcbiAgICAgICAgICAgIGlmICghaGFzVW5yZXNvbHZlZEFuY2VzdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RGbHVzaENiKGVmZmVjdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIEByZXNvbHZlIGV2ZW50XHJcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCh2bm9kZSwgJ29uUmVzb2x2ZScpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmFsbGJhY2soZmFsbGJhY2tWTm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IHZub2RlLCBhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgY29udGFpbmVyLCBpc1NWRyB9ID0gc3VzcGVuc2U7XHJcbiAgICAgICAgICAgIC8vIGludm9rZSBAZmFsbGJhY2sgZXZlbnRcclxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KHZub2RlLCAnb25GYWxsYmFjaycpO1xyXG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBuZXh0KGFjdGl2ZUJyYW5jaCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdW50RmFsbGJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1vdW50IHRoZSBmYWxsYmFjayB0cmVlXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCBmYWxsYmFja1ZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBudWxsLCAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgZmFsbGJhY2tWTm9kZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5RW50ZXIgPSBmYWxsYmFja1ZOb2RlLnRyYW5zaXRpb24gJiYgZmFsbGJhY2tWTm9kZS50cmFuc2l0aW9uLm1vZGUgPT09ICdvdXQtaW4nO1xyXG4gICAgICAgICAgICBpZiAoZGVsYXlFbnRlcikge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlQnJhbmNoLnRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSA9IG1vdW50RmFsbGJhY2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNJbkZhbGxiYWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gdW5tb3VudCBjdXJyZW50IGFjdGl2ZSBicmFuY2hcclxuICAgICAgICAgICAgdW5tb3VudChhY3RpdmVCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgbnVsbCwgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xyXG4gICAgICAgICAgICB0cnVlIC8vIHNob3VsZFJlbW92ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAoIWRlbGF5RW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50RmFsbGJhY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbW92ZShjb250YWluZXIsIGFuY2hvciwgdHlwZSkge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiZcclxuICAgICAgICAgICAgICAgIG1vdmUoc3VzcGVuc2UuYWN0aXZlQnJhbmNoLCBjb250YWluZXIsIGFuY2hvciwgdHlwZSk7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggJiYgbmV4dChzdXNwZW5zZS5hY3RpdmVCcmFuY2gpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJEZXAoaW5zdGFuY2UsIHNldHVwUmVuZGVyRWZmZWN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzSW5QZW5kaW5nU3VzcGVuc2UgPSAhIXN1c3BlbnNlLnBlbmRpbmdCcmFuY2g7XHJcbiAgICAgICAgICAgIGlmIChpc0luUGVuZGluZ1N1c3BlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdXNwZW5zZS5kZXBzKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaHlkcmF0ZWRFbCA9IGluc3RhbmNlLnZub2RlLmVsO1xyXG4gICAgICAgICAgICBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgLmFzeW5jRGVwLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jU2V0dXBSZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0cnkgd2hlbiB0aGUgc2V0dXAoKSBwcm9taXNlIHJlc29sdmVzLlxyXG4gICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBoYXZlIGJlZW4gdW5tb3VudGVkIGJlZm9yZSByZXNvbHZlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmlzVW5tb3VudGVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5wZW5kaW5nSWQgIT09IGluc3RhbmNlLnN1c3BlbnNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyByZXRyeSBmcm9tIHRoaXMgY29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5hc3luY1Jlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdm5vZGUgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dCh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXR1cFJlc3VsdChpbnN0YW5jZSwgYXN5bmNTZXR1cFJlc3VsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGh5ZHJhdGVkRWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBtYXkgaGF2ZSBiZWVuIHJlcGxhY2VkIGlmIGFuIHVwZGF0ZSBoYXBwZW5lZCBiZWZvcmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXN5bmMgZGVwIGlzIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmVsID0gaHlkcmF0ZWRFbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gIWh5ZHJhdGVkRWwgJiYgaW5zdGFuY2Uuc3ViVHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIHNldHVwUmVuZGVyRWZmZWN0KGluc3RhbmNlLCB2bm9kZSwgXHJcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEgaHlkcmF0aW9uLCBpbnN0YW5jZS5zdWJUcmVlIHdpbGwgYmUgdGhlIGNvbW1lbnRcclxuICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyLlxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZShoeWRyYXRlZEVsIHx8IGluc3RhbmNlLnN1YlRyZWUuZWwpLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvciB3aWxsIG5vdCBiZSB1c2VkIGlmIHRoaXMgaXMgaHlkcmF0aW9uLCBzbyBvbmx5IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlZEVsID8gbnVsbCA6IG5leHQoaW5zdGFuY2Uuc3ViVHJlZSksIHN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZShwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIHZub2RlLmVsKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25seSBkZWNyZWFzZSBkZXBzIGNvdW50IGlmIHN1c3BlbnNlIGlzIG5vdCBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJblBlbmRpbmdTdXNwZW5zZSAmJiAtLXN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5tb3VudChwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgc3VzcGVuc2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoc3VzcGVuc2UuYWN0aXZlQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLmFjdGl2ZUJyYW5jaCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KHN1c3BlbnNlLnBlbmRpbmdCcmFuY2gsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gc3VzcGVuc2U7XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVN1c3BlbnNlKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHJlbmRlcmVySW50ZXJuYWxzLCBoeWRyYXRlTm9kZSkge1xyXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXHJcbiAgICBjb25zdCBzdXNwZW5zZSA9ICh2bm9kZS5zdXNwZW5zZSA9IGNyZWF0ZVN1c3BlbnNlQm91bmRhcnkodm5vZGUsIHBhcmVudFN1c3BlbnNlLCBwYXJlbnRDb21wb25lbnQsIG5vZGUucGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIG51bGwsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgcmVuZGVyZXJJbnRlcm5hbHMsIHRydWUgLyogaHlkcmF0aW5nICovKSk7XHJcbiAgICAvLyB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvcyBmb3Igc2VydmVyLXJlbmRlcmVkIHN1c3BlbnNlOlxyXG4gICAgLy8gLSBzdWNjZXNzOiBzc3IgY29udGVudCBzaG91bGQgYmUgZnVsbHkgcmVzb2x2ZWRcclxuICAgIC8vIC0gZmFpbHVyZTogc3NyIGNvbnRlbnQgc2hvdWxkIGJlIHRoZSBmYWxsYmFjayBicmFuY2guXHJcbiAgICAvLyBob3dldmVyLCBvbiB0aGUgY2xpZW50IHdlIGRvbid0IHJlYWxseSBrbm93IGlmIGl0IGhhcyBmYWlsZWQgb3Igbm90XHJcbiAgICAvLyBhdHRlbXB0IHRvIGh5ZHJhdGUgdGhlIERPTSBhc3N1bWluZyBpdCBoYXMgc3VjY2VlZGVkLCBidXQgd2Ugc3RpbGxcclxuICAgIC8vIG5lZWQgdG8gY29uc3RydWN0IGEgc3VzcGVuc2UgYm91bmRhcnkgZmlyc3RcclxuICAgIGNvbnN0IHJlc3VsdCA9IGh5ZHJhdGVOb2RlKG5vZGUsIChzdXNwZW5zZS5wZW5kaW5nQnJhbmNoID0gdm5vZGUuc3NDb250ZW50KSwgcGFyZW50Q29tcG9uZW50LCBzdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgaWYgKHN1c3BlbnNlLmRlcHMgPT09IDApIHtcclxuICAgICAgICBzdXNwZW5zZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTdXNwZW5zZUNoaWxkcmVuKHZub2RlKSB7XHJcbiAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNTbG90Q2hpbGRyZW4gPSBzaGFwZUZsYWcgJiAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIHZub2RlLnNzQ29udGVudCA9IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChpc1Nsb3RDaGlsZHJlbiA/IGNoaWxkcmVuLmRlZmF1bHQgOiBjaGlsZHJlbik7XHJcbiAgICB2bm9kZS5zc0ZhbGxiYWNrID0gaXNTbG90Q2hpbGRyZW5cclxuICAgICAgICA/IG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChjaGlsZHJlbi5mYWxsYmFjaylcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN1c3BlbnNlU2xvdChzKSB7XHJcbiAgICBsZXQgYmxvY2s7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzKSkge1xyXG4gICAgICAgIGNvbnN0IHRyYWNrQmxvY2sgPSBpc0Jsb2NrVHJlZUVuYWJsZWQgJiYgcy5fYztcclxuICAgICAgICBpZiAodHJhY2tCbG9jaykge1xyXG4gICAgICAgICAgICAvLyBkaXNhYmxlVHJhY2tpbmc6IGZhbHNlXHJcbiAgICAgICAgICAgIC8vIGFsbG93IGJsb2NrIHRyYWNraW5nIGZvciBjb21waWxlZCBzbG90c1xyXG4gICAgICAgICAgICAvLyAoc2VlIC4vY29tcG9uZW50UmVuZGVyQ29udGV4dC50cylcclxuICAgICAgICAgICAgcy5fZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBvcGVuQmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHMoKTtcclxuICAgICAgICBpZiAodHJhY2tCbG9jaykge1xyXG4gICAgICAgICAgICBzLl9kID0gdHJ1ZTtcclxuICAgICAgICAgICAgYmxvY2sgPSBjdXJyZW50QmxvY2s7XHJcbiAgICAgICAgICAgIGNsb3NlQmxvY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBcnJheShzKSkge1xyXG4gICAgICAgIGNvbnN0IHNpbmdsZUNoaWxkID0gZmlsdGVyU2luZ2xlUm9vdChzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFzaW5nbGVDaGlsZCkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYDxTdXNwZW5zZT4gc2xvdHMgZXhwZWN0IGEgc2luZ2xlIHJvb3Qgbm9kZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcyA9IHNpbmdsZUNoaWxkO1xyXG4gICAgfVxyXG4gICAgcyA9IG5vcm1hbGl6ZVZOb2RlKHMpO1xyXG4gICAgaWYgKGJsb2NrICYmICFzLmR5bmFtaWNDaGlsZHJlbikge1xyXG4gICAgICAgIHMuZHluYW1pY0NoaWxkcmVuID0gYmxvY2suZmlsdGVyKGMgPT4gYyAhPT0gcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcztcclxufVxyXG5mdW5jdGlvbiBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZShmbiwgc3VzcGVuc2UpIHtcclxuICAgIGlmIChzdXNwZW5zZSAmJiBzdXNwZW5zZS5wZW5kaW5nQnJhbmNoKSB7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCguLi5mbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXNwZW5zZS5lZmZlY3RzLnB1c2goZm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHF1ZXVlUG9zdEZsdXNoQ2IoZm4pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUJyYW5jaChzdXNwZW5zZSwgYnJhbmNoKSB7XHJcbiAgICBzdXNwZW5zZS5hY3RpdmVCcmFuY2ggPSBicmFuY2g7XHJcbiAgICBjb25zdCB7IHZub2RlLCBwYXJlbnRDb21wb25lbnQgfSA9IHN1c3BlbnNlO1xyXG4gICAgY29uc3QgZWwgPSAodm5vZGUuZWwgPSBicmFuY2guZWwpO1xyXG4gICAgLy8gaW4gY2FzZSBzdXNwZW5zZSBpcyB0aGUgcm9vdCBub2RlIG9mIGEgY29tcG9uZW50LFxyXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRoZSBIT0MgZWxcclxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnN1YlRyZWUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgcGFyZW50Q29tcG9uZW50LnZub2RlLmVsID0gZWw7XHJcbiAgICAgICAgdXBkYXRlSE9DSG9zdEVsKHBhcmVudENvbXBvbmVudCwgZWwpO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgcHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByb3ZpZGVzID0gY3VycmVudEluc3RhbmNlLnByb3ZpZGVzO1xyXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQgYW4gaW5zdGFuY2UgaW5oZXJpdHMgaXRzIHBhcmVudCdzIHByb3ZpZGVzIG9iamVjdFxyXG4gICAgICAgIC8vIGJ1dCB3aGVuIGl0IG5lZWRzIHRvIHByb3ZpZGUgdmFsdWVzIG9mIGl0cyBvd24sIGl0IGNyZWF0ZXMgaXRzXHJcbiAgICAgICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cclxuICAgICAgICAvLyB0aGlzIHdheSBpbiBgaW5qZWN0YCB3ZSBjYW4gc2ltcGx5IGxvb2sgdXAgaW5qZWN0aW9ucyBmcm9tIGRpcmVjdFxyXG4gICAgICAgIC8vIHBhcmVudCBhbmQgbGV0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG8gdGhlIHdvcmsuXHJcbiAgICAgICAgY29uc3QgcGFyZW50UHJvdmlkZXMgPSBjdXJyZW50SW5zdGFuY2UucGFyZW50ICYmIGN1cnJlbnRJbnN0YW5jZS5wYXJlbnQucHJvdmlkZXM7XHJcbiAgICAgICAgaWYgKHBhcmVudFByb3ZpZGVzID09PSBwcm92aWRlcykge1xyXG4gICAgICAgICAgICBwcm92aWRlcyA9IGN1cnJlbnRJbnN0YW5jZS5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgcHJvdmlkZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcclxuICAgIC8vIGZhbGxiYWNrIHRvIGBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2VgIHNvIHRoYXQgdGhpcyBjYW4gYmUgY2FsbGVkIGluXHJcbiAgICAvLyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZSB8fCBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAvLyAjMjQwMFxyXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYGFwcC51c2VgIHBsdWdpbnMsXHJcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGluc3RhbmNlLnBhcmVudCA9PSBudWxsXHJcbiAgICAgICAgICAgID8gaW5zdGFuY2Uudm5vZGUuYXBwQ29udGV4dCAmJiBpbnN0YW5jZS52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzXHJcbiAgICAgICAgICAgIDogaW5zdGFuY2UucGFyZW50LnByb3ZpZGVzO1xyXG4gICAgICAgIGlmIChwcm92aWRlcyAmJiBrZXkgaW4gcHJvdmlkZXMpIHtcclxuICAgICAgICAgICAgLy8gVFMgZG9lc24ndCBhbGxvdyBzeW1ib2wgYXMgaW5kZXggdHlwZVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlLmNhbGwoaW5zdGFuY2UucHJveHkpXHJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgaW5qZWN0aW9uIFwiJHtTdHJpbmcoa2V5KX1cIiBub3QgZm91bmQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybiQxKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcclxuICAgIH1cclxufVxuXG4vLyBTaW1wbGUgZWZmZWN0LlxyXG5mdW5jdGlvbiB3YXRjaEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gd2F0Y2hQb3N0RWZmZWN0KGVmZmVjdCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAncG9zdCcgfSkgOiB7IGZsdXNoOiAncG9zdCcgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoU3luY0VmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3N5bmMnIH0pIDogeyBmbHVzaDogJ3N5bmMnIH0pKTtcclxufVxyXG4vLyBpbml0aWFsIHZhbHVlIGZvciB3YXRjaGVycyB0byB0cmlnZ2VyIG9uIHVuZGVmaW5lZCBpbml0aWFsIHZhbHVlc1xyXG5jb25zdCBJTklUSUFMX1dBVENIRVJfVkFMVUUgPSB7fTtcclxuLy8gaW1wbGVtZW50YXRpb25cclxuZnVuY3Rpb24gd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucykge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaXNGdW5jdGlvbihjYikpIHtcclxuICAgICAgICB3YXJuJDEoYFxcYHdhdGNoKGZuLCBvcHRpb25zPylcXGAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBgICtcclxuICAgICAgICAgICAgYFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IGAgK1xyXG4gICAgICAgICAgICBgc3VwcG9ydHMgXFxgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGRvV2F0Y2goc291cmNlLCBjYiwgeyBpbW1lZGlhdGUsIGRlZXAsIGZsdXNoLCBvblRyYWNrLCBvblRyaWdnZXIgfSA9IEVNUFRZX09CSikge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2FybiQxKGB3YXRjaCgpIFwiaW1tZWRpYXRlXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIGAgK1xyXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWVwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgd2FybiQxKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcclxuICAgICAgICAgICAgICAgIGB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHdhcm5JbnZhbGlkU291cmNlID0gKHMpID0+IHtcclxuICAgICAgICB3YXJuJDEoYEludmFsaWQgd2F0Y2ggc291cmNlOiBgLCBzLCBgQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IGZ1bmN0aW9uLCBhIHJlZiwgYCArXHJcbiAgICAgICAgICAgIGBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuYCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBsZXQgZ2V0dGVyO1xyXG4gICAgbGV0IGZvcmNlVHJpZ2dlciA9IGZhbHNlO1xyXG4gICAgbGV0IGlzTXVsdGlTb3VyY2UgPSBmYWxzZTtcclxuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLnZhbHVlO1xyXG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IGlzU2hhbGxvdyhzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzb3VyY2UpKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlO1xyXG4gICAgICAgIGRlZXAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gc291cmNlLnNvbWUocyA9PiBpc1JlYWN0aXZlKHMpIHx8IGlzU2hhbGxvdyhzKSk7XHJcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gc291cmNlLm1hcChzID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzUmVmKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcy52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhdmVyc2Uocyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxXaXRoRXJyb3JIYW5kbGluZyhzLCBpbnN0YW5jZSwgMiAvKiBXQVRDSF9HRVRURVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoY2IpIHtcclxuICAgICAgICAgICAgLy8gZ2V0dGVyIHdpdGggY2JcclxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4gY2FsbFdpdGhFcnJvckhhbmRsaW5nKHNvdXJjZSwgaW5zdGFuY2UsIDIgLyogV0FUQ0hfR0VUVEVSICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIGNiIC0+IHNpbXBsZSBlZmZlY3RcclxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLmlzVW5tb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFudXApIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoc291cmNlLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW29uQ2xlYW51cF0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IE5PT1A7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5JbnZhbGlkU291cmNlKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICAvLyAyLnggYXJyYXkgbXV0YXRpb24gd2F0Y2ggY29tcGF0XHJcbiAgICBpZiAoY2IgJiYgIWRlZXApIHtcclxuICAgICAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdmFsID0gYmFzZUdldHRlcigpO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWwpICYmXHJcbiAgICAgICAgICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJXQVRDSF9BUlJBWVwiIC8qIFdBVENIX0FSUkFZICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHRyYXZlcnNlKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGNiICYmIGRlZXApIHtcclxuICAgICAgICBjb25zdCBiYXNlR2V0dGVyID0gZ2V0dGVyO1xyXG4gICAgICAgIGdldHRlciA9ICgpID0+IHRyYXZlcnNlKGJhc2VHZXR0ZXIoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgY2xlYW51cDtcclxuICAgIGxldCBvbkNsZWFudXAgPSAoZm4pID0+IHtcclxuICAgICAgICBjbGVhbnVwID0gZWZmZWN0Lm9uU3RvcCA9ICgpID0+IHtcclxuICAgICAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKGZuLCBpbnN0YW5jZSwgNCAvKiBXQVRDSF9DTEVBTlVQICovKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIGluIFNTUiB0aGVyZSBpcyBubyBuZWVkIHRvIHNldHVwIGFuIGFjdHVhbCBlZmZlY3QsIGFuZCBpdCBzaG91bGQgYmUgbm9vcFxyXG4gICAgLy8gdW5sZXNzIGl0J3MgZWFnZXJcclxuICAgIGlmIChpc0luU1NSQ29tcG9uZW50U2V0dXApIHtcclxuICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbm90IGNhbGwgdGhlIGludmFsaWRhdGUgY2FsbGJhY2sgKCsgcnVubmVyIGlzIG5vdCBzZXQgdXApXHJcbiAgICAgICAgb25DbGVhbnVwID0gTk9PUDtcclxuICAgICAgICBpZiAoIWNiKSB7XHJcbiAgICAgICAgICAgIGdldHRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbW1lZGlhdGUpIHtcclxuICAgICAgICAgICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoY2IsIGluc3RhbmNlLCAzIC8qIFdBVENIX0NBTExCQUNLICovLCBbXHJcbiAgICAgICAgICAgICAgICBnZXR0ZXIoKSxcclxuICAgICAgICAgICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE5PT1A7XHJcbiAgICB9XHJcbiAgICBsZXQgb2xkVmFsdWUgPSBpc011bHRpU291cmNlID8gW10gOiBJTklUSUFMX1dBVENIRVJfVkFMVUU7XHJcbiAgICBjb25zdCBqb2IgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFlZmZlY3QuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoKHNvdXJjZSwgY2IpXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZWZmZWN0LnJ1bigpO1xyXG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxyXG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNNdWx0aVNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZSgodiwgaSkgPT4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNBcnJheShuZXdWYWx1ZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJXQVRDSF9BUlJBWVwiIC8qIFdBVENIX0FSUkFZICovLCBpbnN0YW5jZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGJlZm9yZSBydW5uaW5nIGNiIGFnYWluXHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGNiLCBpbnN0YW5jZSwgMyAvKiBXQVRDSF9DQUxMQkFDSyAqLywgW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxyXG4gICAgICAgICAgICBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGltcG9ydGFudDogbWFyayB0aGUgam9iIGFzIGEgd2F0Y2hlciBjYWxsYmFjayBzbyB0aGF0IHNjaGVkdWxlciBrbm93c1xyXG4gICAgLy8gaXQgaXMgYWxsb3dlZCB0byBzZWxmLXRyaWdnZXIgKCMxNzI3KVxyXG4gICAgam9iLmFsbG93UmVjdXJzZSA9ICEhY2I7XHJcbiAgICBsZXQgc2NoZWR1bGVyO1xyXG4gICAgaWYgKGZsdXNoID09PSAnc3luYycpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSBqb2I7IC8vIHRoZSBzY2hlZHVsZXIgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgZGlyZWN0bHlcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcclxuICAgICAgICBzY2hlZHVsZXIgPSAoKSA9PiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3Qoam9iLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdXNwZW5zZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBkZWZhdWx0OiAncHJlJ1xyXG4gICAgICAgIHNjaGVkdWxlciA9ICgpID0+IHF1ZXVlUHJlRmx1c2hDYihqb2IpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZWZmZWN0ID0gbmV3IFJlYWN0aXZlRWZmZWN0KGdldHRlciwgc2NoZWR1bGVyKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBlZmZlY3Qub25UcmFjayA9IG9uVHJhY2s7XHJcbiAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcclxuICAgIH1cclxuICAgIC8vIGluaXRpYWwgcnVuXHJcbiAgICBpZiAoY2IpIHtcclxuICAgICAgICBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGpvYigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSBlZmZlY3QucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmx1c2ggPT09ICdwb3N0Jykge1xyXG4gICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChlZmZlY3QucnVuLmJpbmQoZWZmZWN0KSwgaW5zdGFuY2UgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZWZmZWN0LnJ1bigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBlZmZlY3Quc3RvcCgpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5zY29wZSkge1xyXG4gICAgICAgICAgICByZW1vdmUoaW5zdGFuY2Uuc2NvcGUuZWZmZWN0cywgZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIHRoaXMuJHdhdGNoXHJcbmZ1bmN0aW9uIGluc3RhbmNlV2F0Y2goc291cmNlLCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgcHVibGljVGhpcyA9IHRoaXMucHJveHk7XHJcbiAgICBjb25zdCBnZXR0ZXIgPSBpc1N0cmluZyhzb3VyY2UpXHJcbiAgICAgICAgPyBzb3VyY2UuaW5jbHVkZXMoJy4nKVxyXG4gICAgICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywgc291cmNlKVxyXG4gICAgICAgICAgICA6ICgpID0+IHB1YmxpY1RoaXNbc291cmNlXVxyXG4gICAgICAgIDogc291cmNlLmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcyk7XHJcbiAgICBsZXQgY2I7XHJcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICBjYiA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2IgPSB2YWx1ZS5oYW5kbGVyO1xyXG4gICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0aGlzKTtcclxuICAgIGNvbnN0IHJlcyA9IGRvV2F0Y2goZ2V0dGVyLCBjYi5iaW5kKHB1YmxpY1RoaXMpLCBvcHRpb25zKTtcclxuICAgIGlmIChjdXIpIHtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoY3VyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVBhdGhHZXR0ZXIoY3R4LCBwYXRoKSB7XHJcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgbGV0IGN1ciA9IGN0eDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBjdXI7IGkrKykge1xyXG4gICAgICAgICAgICBjdXIgPSBjdXJbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWx1ZSwgc2Vlbikge1xyXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWVbXCJfX3Zfc2tpcFwiIC8qIFNLSVAgKi9dKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2VlbiA9IHNlZW4gfHwgbmV3IFNldCgpO1xyXG4gICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNlZW4uYWRkKHZhbHVlKTtcclxuICAgIGlmIChpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICB0cmF2ZXJzZSh2YWx1ZS52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWVbaV0sIHNlZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSB8fCBpc01hcCh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgICAgICAgIHRyYXZlcnNlKHYsIHNlZW4pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmF2ZXJzZSh2YWx1ZVtrZXldLCBzZWVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cblxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvblN0YXRlKCkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7XHJcbiAgICAgICAgaXNNb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc0xlYXZpbmc6IGZhbHNlLFxyXG4gICAgICAgIGlzVW5tb3VudGluZzogZmFsc2UsXHJcbiAgICAgICAgbGVhdmluZ1ZOb2RlczogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG4gICAgb25Nb3VudGVkKCgpID0+IHtcclxuICAgICAgICBzdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgfSk7XHJcbiAgICBvbkJlZm9yZVVubW91bnQoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlLmlzVW5tb3VudGluZyA9IHRydWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzdGF0ZTtcclxufVxyXG5jb25zdCBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvciA9IFtGdW5jdGlvbiwgQXJyYXldO1xyXG5jb25zdCBCYXNlVHJhbnNpdGlvbkltcGwgPSB7XHJcbiAgICBuYW1lOiBgQmFzZVRyYW5zaXRpb25gLFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBtb2RlOiBTdHJpbmcsXHJcbiAgICAgICAgYXBwZWFyOiBCb29sZWFuLFxyXG4gICAgICAgIHBlcnNpc3RlZDogQm9vbGVhbixcclxuICAgICAgICAvLyBlbnRlclxyXG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uRW50ZXI6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uQWZ0ZXJFbnRlcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25FbnRlckNhbmNlbGxlZDogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgLy8gbGVhdmVcclxuICAgICAgICBvbkJlZm9yZUxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkxlYXZlOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFmdGVyTGVhdmU6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIG9uTGVhdmVDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yLFxyXG4gICAgICAgIC8vIGFwcGVhclxyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyOiBUcmFuc2l0aW9uSG9va1ZhbGlkYXRvcixcclxuICAgICAgICBvbkFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BZnRlckFwcGVhcjogVHJhbnNpdGlvbkhvb2tWYWxpZGF0b3IsXHJcbiAgICAgICAgb25BcHBlYXJDYW5jZWxsZWQ6IFRyYW5zaXRpb25Ib29rVmFsaWRhdG9yXHJcbiAgICB9LFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldlRyYW5zaXRpb25LZXk7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzbG90cy5kZWZhdWx0ICYmIGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihzbG90cy5kZWZhdWx0KCksIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGxldCBoYXNGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1jb21tZW50IGNoaWxkXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaGFzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhcm4gbW9yZSB0aGFuIG9uZSBub24tY29tbWVudCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQxKCc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50IG9yIGNvbXBvbmVudC4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZSA8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gbmVlZCB0byB0cmFjayByZWFjdGl2aXR5IGZvciB0aGVzZSBwcm9wcyBzbyB1c2UgdGhlIHJhd1xyXG4gICAgICAgICAgICAvLyBwcm9wcyBmb3IgYSBiaXQgYmV0dGVyIHBlcmZcclxuICAgICAgICAgICAgY29uc3QgcmF3UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbW9kZSB9ID0gcmF3UHJvcHM7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIG1vZGVcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgbW9kZSAmJlxyXG4gICAgICAgICAgICAgICAgbW9kZSAhPT0gJ2luLW91dCcgJiZcclxuICAgICAgICAgICAgICAgIG1vZGUgIT09ICdvdXQtaW4nICYmXHJcbiAgICAgICAgICAgICAgICBtb2RlICE9PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJHttb2RlfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc0xlYXZpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbiB0aGUgY2FzZSBvZiA8dHJhbnNpdGlvbj48a2VlcC1hbGl2ZS8+PC90cmFuc2l0aW9uPiwgd2UgbmVlZCB0b1xyXG4gICAgICAgICAgICAvLyBjb21wYXJlIHRoZSB0eXBlIG9mIHRoZSBrZXB0LWFsaXZlIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICBjb25zdCBpbm5lckNoaWxkID0gZ2V0S2VlcEFsaXZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWlubmVyQ2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVBsYWNlaG9sZGVyKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbnRlckhvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhpbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGlubmVyQ2hpbGQsIGVudGVySG9va3MpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRDaGlsZCA9IGluc3RhbmNlLnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZElubmVyQ2hpbGQgPSBvbGRDaGlsZCAmJiBnZXRLZWVwQWxpdmVDaGlsZChvbGRDaGlsZCk7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uS2V5Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCB7IGdldFRyYW5zaXRpb25LZXkgfSA9IGlubmVyQ2hpbGQudHlwZTtcclxuICAgICAgICAgICAgaWYgKGdldFRyYW5zaXRpb25LZXkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldFRyYW5zaXRpb25LZXkoKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHJhbnNpdGlvbktleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09IHByZXZUcmFuc2l0aW9uS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlRyYW5zaXRpb25LZXkgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbktleUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtb2RlXHJcbiAgICAgICAgICAgIGlmIChvbGRJbm5lckNoaWxkICYmXHJcbiAgICAgICAgICAgICAgICBvbGRJbm5lckNoaWxkLnR5cGUgIT09IENvbW1lbnQgJiZcclxuICAgICAgICAgICAgICAgICghaXNTYW1lVk5vZGVUeXBlKGlubmVyQ2hpbGQsIG9sZElubmVyQ2hpbGQpIHx8IHRyYW5zaXRpb25LZXlDaGFuZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ0hvb2tzID0gcmVzb2x2ZVRyYW5zaXRpb25Ib29rcyhvbGRJbm5lckNoaWxkLCByYXdQcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBvbGQgdHJlZSdzIGhvb2tzIGluIGNhc2Ugb2YgZHluYW1pYyB0cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2l0aW9uSG9va3Mob2xkSW5uZXJDaGlsZCwgbGVhdmluZ0hvb2tzKTtcclxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBiZXR3ZWVuIGRpZmZlcmVudCB2aWV3c1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcclxuICAgICAgICAgICAgICAgICAgICBsZWF2aW5nSG9va3MuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXNMZWF2aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5UGxhY2Vob2xkZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcgJiYgaW5uZXJDaGlsZC50eXBlICE9PSBDb21tZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVhdmluZ0hvb2tzLmRlbGF5TGVhdmUgPSAoZWwsIGVhcmx5UmVtb3ZlLCBkZWxheWVkTGVhdmUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gZ2V0TGVhdmluZ05vZGVzRm9yVHlwZShzdGF0ZSwgb2xkSW5uZXJDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZXNDYWNoZVtTdHJpbmcob2xkSW5uZXJDaGlsZC5rZXkpXSA9IG9sZElubmVyQ2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhcmx5IHJlbW92YWwgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXJseVJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW50ZXJIb29rcy5kZWxheWVkTGVhdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVySG9va3MuZGVsYXllZExlYXZlID0gZGVsYXllZExlYXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn07XHJcbntcclxuICAgIEJhc2VUcmFuc2l0aW9uSW1wbC5fX2lzQnVpbHRJbiA9IHRydWU7XHJcbn1cclxuLy8gZXhwb3J0IHRoZSBwdWJsaWMgdHlwZSBmb3IgaC90c3ggaW5mZXJlbmNlXHJcbi8vIGFsc28gdG8gYXZvaWQgaW5saW5lIGltcG9ydCgpIGluIGdlbmVyYXRlZCBkLnRzIGZpbGVzXHJcbmNvbnN0IEJhc2VUcmFuc2l0aW9uID0gQmFzZVRyYW5zaXRpb25JbXBsO1xyXG5mdW5jdGlvbiBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSkge1xyXG4gICAgY29uc3QgeyBsZWF2aW5nVk5vZGVzIH0gPSBzdGF0ZTtcclxuICAgIGxldCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBsZWF2aW5nVk5vZGVzLmdldCh2bm9kZS50eXBlKTtcclxuICAgIGlmICghbGVhdmluZ1ZOb2Rlc0NhY2hlKSB7XHJcbiAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICBsZWF2aW5nVk5vZGVzLnNldCh2bm9kZS50eXBlLCBsZWF2aW5nVk5vZGVzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlYXZpbmdWTm9kZXNDYWNoZTtcclxufVxyXG4vLyBUaGUgdHJhbnNpdGlvbiBob29rcyBhcmUgYXR0YWNoZWQgdG8gdGhlIHZub2RlIGFzIHZub2RlLnRyYW5zaXRpb25cclxuLy8gYW5kIHdpbGwgYmUgY2FsbGVkIGF0IGFwcHJvcHJpYXRlIHRpbWluZyBpbiB0aGUgcmVuZGVyZXIuXHJcbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uSG9va3Modm5vZGUsIHByb3BzLCBzdGF0ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHsgYXBwZWFyLCBtb2RlLCBwZXJzaXN0ZWQgPSBmYWxzZSwgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25BZnRlckVudGVyLCBvbkVudGVyQ2FuY2VsbGVkLCBvbkJlZm9yZUxlYXZlLCBvbkxlYXZlLCBvbkFmdGVyTGVhdmUsIG9uTGVhdmVDYW5jZWxsZWQsIG9uQmVmb3JlQXBwZWFyLCBvbkFwcGVhciwgb25BZnRlckFwcGVhciwgb25BcHBlYXJDYW5jZWxsZWQgfSA9IHByb3BzO1xyXG4gICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICBjb25zdCBsZWF2aW5nVk5vZGVzQ2FjaGUgPSBnZXRMZWF2aW5nTm9kZXNGb3JUeXBlKHN0YXRlLCB2bm9kZSk7XHJcbiAgICBjb25zdCBjYWxsSG9vayA9IChob29rLCBhcmdzKSA9PiB7XHJcbiAgICAgICAgaG9vayAmJlxyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhob29rLCBpbnN0YW5jZSwgOSAvKiBUUkFOU0lUSU9OX0hPT0sgKi8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGNhbGxBc3luY0hvb2sgPSAoaG9vaywgYXJncykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRvbmUgPSBhcmdzWzFdO1xyXG4gICAgICAgIGNhbGxIb29rKGhvb2ssIGFyZ3MpO1xyXG4gICAgICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgICAgICAgIGlmIChob29rLmV2ZXJ5KGhvb2sgPT4gaG9vay5sZW5ndGggPD0gMSkpXHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvb2subGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBob29rcyA9IHtcclxuICAgICAgICBtb2RlLFxyXG4gICAgICAgIHBlcnNpc3RlZCxcclxuICAgICAgICBiZWZvcmVFbnRlcihlbCkge1xyXG4gICAgICAgICAgICBsZXQgaG9vayA9IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQmVmb3JlQXBwZWFyIHx8IG9uQmVmb3JlRW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZm9yIHNhbWUgZWxlbWVudCAodi1zaG93KVxyXG4gICAgICAgICAgICBpZiAoZWwuX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIGVsLl9sZWF2ZUNiKHRydWUgLyogY2FuY2VsbGVkICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3IgdG9nZ2xlZCBlbGVtZW50IHdpdGggc2FtZSBrZXkgKHYtaWYpXHJcbiAgICAgICAgICAgIGNvbnN0IGxlYXZpbmdWTm9kZSA9IGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2RlICYmXHJcbiAgICAgICAgICAgICAgICBpc1NhbWVWTm9kZVR5cGUodm5vZGUsIGxlYXZpbmdWTm9kZSkgJiZcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYikge1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgZWFybHkgcmVtb3ZhbCAobm90IGNhbmNlbGxlZClcclxuICAgICAgICAgICAgICAgIGxlYXZpbmdWTm9kZS5lbC5fbGVhdmVDYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGhvb2ssIFtlbF0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW50ZXIoZWwpIHtcclxuICAgICAgICAgICAgbGV0IGhvb2sgPSBvbkVudGVyO1xyXG4gICAgICAgICAgICBsZXQgYWZ0ZXJIb29rID0gb25BZnRlckVudGVyO1xyXG4gICAgICAgICAgICBsZXQgY2FuY2VsSG9vayA9IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgIGlmICghc3RhdGUuaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwZWFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9vayA9IG9uQXBwZWFyIHx8IG9uRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJIb29rID0gb25BZnRlckFwcGVhciB8fCBvbkFmdGVyRW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsSG9vayA9IG9uQXBwZWFyQ2FuY2VsbGVkIHx8IG9uRW50ZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9lbnRlckNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxIb29rKGNhbmNlbEhvb2ssIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2soYWZ0ZXJIb29rLCBbZWxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChob29rcy5kZWxheWVkTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rcy5kZWxheWVkTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsLl9lbnRlckNiID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGhvb2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxBc3luY0hvb2soaG9vaywgW2VsLCBkb25lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxlYXZlKGVsLCByZW1vdmUpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gU3RyaW5nKHZub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChlbC5fZW50ZXJDYikge1xyXG4gICAgICAgICAgICAgICAgZWwuX2VudGVyQ2IodHJ1ZSAvKiBjYW5jZWxsZWQgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pc1VubW91bnRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsSG9vayhvbkJlZm9yZUxlYXZlLCBbZWxdKTtcclxuICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBkb25lID0gKGVsLl9sZWF2ZUNiID0gKGNhbmNlbGxlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbEhvb2sob25MZWF2ZUNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsSG9vayhvbkFmdGVyTGVhdmUsIFtlbF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWwuX2xlYXZlQ2IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPT09IHZub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxlYXZpbmdWTm9kZXNDYWNoZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVhdmluZ1ZOb2Rlc0NhY2hlW2tleV0gPSB2bm9kZTtcclxuICAgICAgICAgICAgaWYgKG9uTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxBc3luY0hvb2sob25MZWF2ZSwgW2VsLCBkb25lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGNsb25lKHZub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKHZub2RlLCBwcm9wcywgc3RhdGUsIGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhvb2tzO1xyXG59XHJcbi8vIHRoZSBwbGFjZWhvbGRlciByZWFsbHkgb25seSBoYW5kbGVzIG9uZSBzcGVjaWFsIGNhc2U6IEtlZXBBbGl2ZVxyXG4vLyBpbiB0aGUgY2FzZSBvZiBhIEtlZXBBbGl2ZSBpbiBhIGxlYXZlIHBoYXNlIHdlIG5lZWQgdG8gcmV0dXJuIGEgS2VlcEFsaXZlXHJcbi8vIHBsYWNlaG9sZGVyIHdpdGggZW1wdHkgY29udGVudCB0byBhdm9pZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGZyb20gYmVpbmdcclxuLy8gdW5tb3VudGVkLlxyXG5mdW5jdGlvbiBlbXB0eVBsYWNlaG9sZGVyKHZub2RlKSB7XHJcbiAgICBpZiAoaXNLZWVwQWxpdmUodm5vZGUpKSB7XHJcbiAgICAgICAgdm5vZGUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEtlZXBBbGl2ZUNoaWxkKHZub2RlKSB7XHJcbiAgICByZXR1cm4gaXNLZWVwQWxpdmUodm5vZGUpXHJcbiAgICAgICAgPyB2bm9kZS5jaGlsZHJlblxyXG4gICAgICAgICAgICA/IHZub2RlLmNoaWxkcmVuWzBdXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgICAgOiB2bm9kZTtcclxufVxyXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uSG9va3Modm5vZGUsIGhvb2tzKSB7XHJcbiAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNiAvKiBDT01QT05FTlQgKi8gJiYgdm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBob29rcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICB2bm9kZS5zc0NvbnRlbnQudHJhbnNpdGlvbiA9IGhvb2tzLmNsb25lKHZub2RlLnNzQ29udGVudCk7XHJcbiAgICAgICAgdm5vZGUuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gaG9va3MuY2xvbmUodm5vZGUuc3NGYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2bm9kZS50cmFuc2l0aW9uID0gaG9va3M7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvblJhd0NoaWxkcmVuKGNoaWxkcmVuLCBrZWVwQ29tbWVudCA9IGZhbHNlLCBwYXJlbnRLZXkpIHtcclxuICAgIGxldCByZXQgPSBbXTtcclxuICAgIGxldCBrZXllZEZyYWdtZW50Q291bnQgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vICM1MzYwIGluaGVyaXQgcGFyZW50IGtleSBpbiBjYXNlIG9mIDx0ZW1wbGF0ZSB2LWZvcj5cclxuICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnRLZXkgPT0gbnVsbFxyXG4gICAgICAgICAgICA/IGNoaWxkLmtleVxyXG4gICAgICAgICAgICA6IFN0cmluZyhwYXJlbnRLZXkpICsgU3RyaW5nKGNoaWxkLmtleSAhPSBudWxsID8gY2hpbGQua2V5IDogaSk7XHJcbiAgICAgICAgLy8gaGFuZGxlIGZyYWdtZW50IGNoaWxkcmVuIGNhc2UsIGUuZy4gdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhdGNoRmxhZyAmIDEyOCAvKiBLRVlFRF9GUkFHTUVOVCAqLylcclxuICAgICAgICAgICAgICAgIGtleWVkRnJhZ21lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbihjaGlsZC5jaGlsZHJlbiwga2VlcENvbW1lbnQsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21tZW50IHBsYWNlaG9sZGVycyBzaG91bGQgYmUgc2tpcHBlZCwgZS5nLiB2LWlmXHJcbiAgICAgICAgZWxzZSBpZiAoa2VlcENvbW1lbnQgfHwgY2hpbGQudHlwZSAhPT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICByZXQucHVzaChrZXkgIT0gbnVsbCA/IGNsb25lVk5vZGUoY2hpbGQsIHsga2V5IH0pIDogY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vICMxMTI2IGlmIGEgdHJhbnNpdGlvbiBjaGlsZHJlbiBsaXN0IGNvbnRhaW5zIG11bHRpcGxlIHN1YiBmcmFnbWVudHMsIHRoZXNlXHJcbiAgICAvLyBmcmFnbWVudHMgd2lsbCBiZSBtZXJnZWQgaW50byBhIGZsYXQgY2hpbGRyZW4gYXJyYXkuIFNpbmNlIGVhY2ggdi1mb3JcclxuICAgIC8vIGZyYWdtZW50IG1heSBjb250YWluIGRpZmZlcmVudCBzdGF0aWMgYmluZGluZ3MgaW5zaWRlLCB3ZSBuZWVkIHRvIGRlLW9wXHJcbiAgICAvLyB0aGVzZSBjaGlsZHJlbiB0byBmb3JjZSBmdWxsIGRpZmZzIHRvIGVuc3VyZSBjb3JyZWN0IGJlaGF2aW9yLlxyXG4gICAgaWYgKGtleWVkRnJhZ21lbnRDb3VudCA+IDEpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0ucGF0Y2hGbGFnID0gLTIgLyogQkFJTCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8vIGltcGxlbWVudGF0aW9uLCBjbG9zZSB0byBuby1vcFxyXG5mdW5jdGlvbiBkZWZpbmVDb21wb25lbnQob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24ob3B0aW9ucykgPyB7IHNldHVwOiBvcHRpb25zLCBuYW1lOiBvcHRpb25zLm5hbWUgfSA6IG9wdGlvbnM7XHJcbn1cblxuY29uc3QgaXNBc3luY1dyYXBwZXIgPSAoaSkgPT4gISFpLnR5cGUuX19hc3luY0xvYWRlcjtcclxuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XHJcbiAgICBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgc291cmNlID0geyBsb2FkZXI6IHNvdXJjZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBsb2FkZXIsIGxvYWRpbmdDb21wb25lbnQsIGVycm9yQ29tcG9uZW50LCBkZWxheSA9IDIwMCwgdGltZW91dCwgLy8gdW5kZWZpbmVkID0gbmV2ZXIgdGltZXMgb3V0XHJcbiAgICBzdXNwZW5zaWJsZSA9IHRydWUsIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XHJcbiAgICBsZXQgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgbGV0IHJlc29sdmVkQ29tcDtcclxuICAgIGxldCByZXRyaWVzID0gMDtcclxuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHJpZXMrKztcclxuICAgICAgICBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcclxuICAgICAgICByZXR1cm4gKHBlbmRpbmdSZXF1ZXN0IHx8XHJcbiAgICAgICAgICAgICh0aGlzUmVxdWVzdCA9IHBlbmRpbmdSZXF1ZXN0ID1cclxuICAgICAgICAgICAgICAgIGxvYWRlcigpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclJldHJ5ID0gKCkgPT4gcmVzb2x2ZShyZXRyeSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoY29tcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFjb21wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMShgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXAuX19lc01vZHVsZSB8fCBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7Y29tcH1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRDb21wID0gY29tcDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICAgICAgbmFtZTogJ0FzeW5jQ29tcG9uZW50V3JhcHBlcicsXHJcbiAgICAgICAgX19hc3luY0xvYWRlcjogbG9hZCxcclxuICAgICAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRDb21wO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0dXAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgICAgICAgICAvLyBhbHJlYWR5IHJlc29sdmVkXHJcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZENvbXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAocmVzb2x2ZWRDb21wLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgaW5zdGFuY2UsIDEzIC8qIEFTWU5DX0NPTVBPTkVOVF9MT0FERVIgKi8sICFlcnJvckNvbXBvbmVudCAvKiBkbyBub3QgdGhyb3cgaW4gZGV2IGlmIHVzZXIgcHJvdmlkZWQgZXJyb3IgY29tcG9uZW50ICovKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gc3VzcGVuc2UtY29udHJvbGxlZCBvciBTU1IuXHJcbiAgICAgICAgICAgIGlmICgoc3VzcGVuc2libGUgJiYgaW5zdGFuY2Uuc3VzcGVuc2UpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNJblNTUkNvbXBvbmVudFNldHVwKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWQoKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGNvbXAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjcmVhdGVJbm5lckNvbXAoY29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVycm9yQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbG9hZGVkID0gcmVmKGZhbHNlKTtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSByZWYoKTtcclxuICAgICAgICAgICAgY29uc3QgZGVsYXllZCA9IHJlZighIWRlbGF5KTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheWVkLnZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9LCBkZWxheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQudmFsdWUgJiYgIWVycm9yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3RpbWVvdXR9bXMuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9hZCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsb2FkZWQudmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnBhcmVudCAmJiBpc0tlZXBBbGl2ZShpbnN0YW5jZS5wYXJlbnQudm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzIGtlZXAtYWxpdmUsIGZvcmNlIHVwZGF0ZSBzbyB0aGUgbG9hZGVkIGNvbXBvbmVudCdzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmFtZSBpcyB0YWtlbiBpbnRvIGFjY291bnRcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZUpvYihpbnN0YW5jZS5wYXJlbnQudXBkYXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IudmFsdWUgPSBlcnI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZC52YWx1ZSAmJiByZXNvbHZlZENvbXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW5uZXJDb21wKHJlc29sdmVkQ29tcCwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IudmFsdWUgJiYgZXJyb3JDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUoZXJyb3JDb21wb25lbnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLnZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb2FkaW5nQ29tcG9uZW50ICYmICFkZWxheWVkLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKGxvYWRpbmdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUlubmVyQ29tcChjb21wLCB7IHZub2RlOiB7IHJlZiwgcHJvcHMsIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSwgcGFyZW50IH0pIHtcclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcCwgcHJvcHMsIGNoaWxkcmVuKTtcclxuICAgIC8vIGVuc3VyZSBpbm5lciBjb21wb25lbnQgaW5oZXJpdHMgdGhlIGFzeW5jIHdyYXBwZXIncyByZWYgb3duZXJcclxuICAgIHZub2RlLnJlZiA9IHJlZjtcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxuXG5jb25zdCBpc0tlZXBBbGl2ZSA9ICh2bm9kZSkgPT4gdm5vZGUudHlwZS5fX2lzS2VlcEFsaXZlO1xyXG5jb25zdCBLZWVwQWxpdmVJbXBsID0ge1xyXG4gICAgbmFtZTogYEtlZXBBbGl2ZWAsXHJcbiAgICAvLyBNYXJrZXIgZm9yIHNwZWNpYWwgaGFuZGxpbmcgaW5zaWRlIHRoZSByZW5kZXJlci4gV2UgYXJlIG5vdCB1c2luZyBhID09PVxyXG4gICAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcclxuICAgIC8vIHdvdWxkIHByZXZlbnQgaXQgZnJvbSBiZWluZyB0cmVlLXNoYWtlbi5cclxuICAgIF9faXNLZWVwQWxpdmU6IHRydWUsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGluY2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIGV4Y2x1ZGU6IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldLFxyXG4gICAgICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxyXG4gICAgfSxcclxuICAgIHNldHVwKHByb3BzLCB7IHNsb3RzIH0pIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8vIEtlZXBBbGl2ZSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgaW5zdGFudGlhdGVkIHJlbmRlcmVyIHZpYSB0aGVcclxuICAgICAgICAvLyBjdHggd2hlcmUgdGhlIHJlbmRlcmVyIHBhc3NlcyBpbiBpdHMgaW50ZXJuYWxzLFxyXG4gICAgICAgIC8vIGFuZCB0aGUgS2VlcEFsaXZlIGluc3RhbmNlIGV4cG9zZXMgYWN0aXZhdGUvZGVhY3RpdmF0ZSBpbXBsZW1lbnRhdGlvbnMuXHJcbiAgICAgICAgLy8gVGhlIHdob2xlIHBvaW50IG9mIHRoaXMgaXMgdG8gYXZvaWQgaW1wb3J0aW5nIEtlZXBBbGl2ZSBkaXJlY3RseSBpbiB0aGVcclxuICAgICAgICAvLyByZW5kZXJlciB0byBmYWNpbGl0YXRlIHRyZWUtc2hha2luZy5cclxuICAgICAgICBjb25zdCBzaGFyZWRDb250ZXh0ID0gaW5zdGFuY2UuY3R4O1xyXG4gICAgICAgIC8vIGlmIHRoZSBpbnRlcm5hbCByZW5kZXJlciBpcyBub3QgcmVnaXN0ZXJlZCwgaXQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcsXHJcbiAgICAgICAgLy8gZm9yIEtlZXBBbGl2ZSwgd2UganVzdCBuZWVkIHRvIHJlbmRlciBpdHMgY2hpbGRyZW5cclxuICAgICAgICBpZiAoIXNoYXJlZENvbnRleHQucmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCAmJiBzbG90cy5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAxID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuX192X2NhY2hlID0gY2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudFN1c3BlbnNlID0gaW5zdGFuY2Uuc3VzcGVuc2U7XHJcbiAgICAgICAgY29uc3QgeyByZW5kZXJlcjogeyBwOiBwYXRjaCwgbTogbW92ZSwgdW06IF91bm1vdW50LCBvOiB7IGNyZWF0ZUVsZW1lbnQgfSB9IH0gPSBzaGFyZWRDb250ZXh0O1xyXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBzaGFyZWRDb250ZXh0LmFjdGl2YXRlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgbW92ZSh2bm9kZSwgY29udGFpbmVyLCBhbmNob3IsIDAgLyogRU5URVIgKi8sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgLy8gaW4gY2FzZSBwcm9wcyBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgcGF0Y2goaW5zdGFuY2Uudm5vZGUsIHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgaW5zdGFuY2UsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgdm5vZGUuc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5hKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZub2RlSG9vayA9IHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLm9uVm5vZGVNb3VudGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY29tcG9uZW50cyB0cmVlXHJcbiAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc2hhcmVkQ29udGV4dC5kZWFjdGl2YXRlID0gKHZub2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50O1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLCBzdG9yYWdlQ29udGFpbmVyLCBudWxsLCAxIC8qIExFQVZFICovLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5kYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZUhvb2sgPSB2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZub2RlSG9vaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIGluc3RhbmNlLnBhcmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuaXNEZWFjdGl2YXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb21wb25lbnRzIHRyZWVcclxuICAgICAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50QWRkZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmdW5jdGlvbiB1bm1vdW50KHZub2RlKSB7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBzaGFwZUZsYWcgc28gaXQgY2FuIGJlIHByb3Blcmx5IHVubW91bnRlZFxyXG4gICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XHJcbiAgICAgICAgICAgIF91bm1vdW50KHZub2RlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlKGZpbHRlcikge1xyXG4gICAgICAgICAgICBjYWNoZS5mb3JFYWNoKCh2bm9kZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh2bm9kZS50eXBlKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lICYmICghZmlsdGVyIHx8ICFmaWx0ZXIobmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkoa2V5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQgfHwgY2FjaGVkLnR5cGUgIT09IGN1cnJlbnQudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjYWNoZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgYWN0aXZlIGluc3RhbmNlIHNob3VsZCBubyBsb25nZXIgYmUga2VwdC1hbGl2ZS5cclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IHVubW91bnQgaXQgbm93IGJ1dCBpdCBtaWdodCBiZSBsYXRlciwgc28gcmVzZXQgaXRzIGZsYWcgbm93LlxyXG4gICAgICAgICAgICAgICAgcmVzZXRTaGFwZUZsYWcoY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBydW5lIGNhY2hlIG9uIGluY2x1ZGUvZXhjbHVkZSBwcm9wIGNoYW5nZVxyXG4gICAgICAgIHdhdGNoKCgpID0+IFtwcm9wcy5pbmNsdWRlLCBwcm9wcy5leGNsdWRlXSwgKFtpbmNsdWRlLCBleGNsdWRlXSkgPT4ge1xyXG4gICAgICAgICAgICBpbmNsdWRlICYmIHBydW5lQ2FjaGUobmFtZSA9PiBtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKTtcclxuICAgICAgICAgICAgZXhjbHVkZSAmJiBwcnVuZUNhY2hlKG5hbWUgPT4gIW1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpO1xyXG4gICAgICAgIH0sIFxyXG4gICAgICAgIC8vIHBydW5lIHBvc3QtcmVuZGVyIGFmdGVyIGBjdXJyZW50YCBoYXMgYmVlbiB1cGRhdGVkXHJcbiAgICAgICAgeyBmbHVzaDogJ3Bvc3QnLCBkZWVwOiB0cnVlIH0pO1xyXG4gICAgICAgIC8vIGNhY2hlIHN1YiB0cmVlIGFmdGVyIHJlbmRlclxyXG4gICAgICAgIGxldCBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlU3VidHJlZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgLy8gZml4ICMxNjIxLCB0aGUgcGVuZGluZ0NhY2hlS2V5IGNvdWxkIGJlIDBcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmdDYWNoZUtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQocGVuZGluZ0NhY2hlS2V5LCBnZXRJbm5lckNoaWxkKGluc3RhbmNlLnN1YlRyZWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgb25Nb3VudGVkKGNhY2hlU3VidHJlZSk7XHJcbiAgICAgICAgb25VcGRhdGVkKGNhY2hlU3VidHJlZSk7XHJcbiAgICAgICAgb25CZWZvcmVVbm1vdW50KCgpID0+IHtcclxuICAgICAgICAgICAgY2FjaGUuZm9yRWFjaChjYWNoZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdWJUcmVlLCBzdXNwZW5zZSB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2bm9kZSA9IGdldElubmVyQ2hpbGQoc3ViVHJlZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkLnR5cGUgPT09IHZub2RlLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGluc3RhbmNlIHdpbGwgYmUgdW5tb3VudGVkIGFzIHBhcnQgb2Yga2VlcC1hbGl2ZSdzIHVubW91bnRcclxuICAgICAgICAgICAgICAgICAgICByZXNldFNoYXBlRmxhZyh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGludm9rZSBpdHMgZGVhY3RpdmF0ZWQgaG9vayBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGEgPSB2bm9kZS5jb21wb25lbnQuZGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGEgJiYgcXVldWVQb3N0UmVuZGVyRWZmZWN0KGRhLCBzdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjYWNoZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBwZW5kaW5nQ2FjaGVLZXkgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIXNsb3RzLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc2xvdHMuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBjb25zdCByYXdWTm9kZSA9IGNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZOb2RlKHJhd1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCEocmF3Vk5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShyYXdWTm9kZS5zaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3Vk5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHZub2RlID0gZ2V0SW5uZXJDaGlsZChyYXdWTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXAgPSB2bm9kZS50eXBlO1xyXG4gICAgICAgICAgICAvLyBmb3IgYXN5bmMgY29tcG9uZW50cywgbmFtZSBjaGVjayBzaG91bGQgYmUgYmFzZWQgaW4gaXRzIGxvYWRlZFxyXG4gICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGlzQXN5bmNXcmFwcGVyKHZub2RlKVxyXG4gICAgICAgICAgICAgICAgPyB2bm9kZS50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fVxyXG4gICAgICAgICAgICAgICAgOiBjb21wKTtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlLCBtYXggfSA9IHByb3BzO1xyXG4gICAgICAgICAgICBpZiAoKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcclxuICAgICAgICAgICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXdWTm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbCA/IGNvbXAgOiB2bm9kZS5rZXk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZOb2RlID0gY2FjaGUuZ2V0KGtleSk7XHJcbiAgICAgICAgICAgIC8vIGNsb25lIHZub2RlIGlmIGl0J3MgcmV1c2VkIGJlY2F1c2Ugd2UgYXJlIGdvaW5nIHRvIG11dGF0ZSBpdFxyXG4gICAgICAgICAgICBpZiAodm5vZGUuZWwpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3Vk5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Vk5vZGUuc3NDb250ZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gIzE1MTMgaXQncyBwb3NzaWJsZSBmb3IgdGhlIHJldHVybmVkIHZub2RlIHRvIGJlIGNsb25lZCBkdWUgdG8gYXR0clxyXG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaCBvciBzY29wZUlkLCBzbyB0aGUgdm5vZGUgaGVyZSBtYXkgbm90IGJlIHRoZSBmaW5hbCB2bm9kZVxyXG4gICAgICAgICAgICAvLyB0aGF0IGlzIG1vdW50ZWQuIEluc3RlYWQgb2YgY2FjaGluZyBpdCBkaXJlY3RseSwgd2Ugc3RvcmUgdGhlIHBlbmRpbmdcclxuICAgICAgICAgICAgLy8ga2V5IGFuZCBjYWNoZSBgaW5zdGFuY2Uuc3ViVHJlZWAgKHRoZSBub3JtYWxpemVkIHZub2RlKSBpblxyXG4gICAgICAgICAgICAvLyBiZWZvcmVNb3VudC9iZWZvcmVVcGRhdGUgaG9va3MuXHJcbiAgICAgICAgICAgIHBlbmRpbmdDYWNoZUtleSA9IGtleTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZFZOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb3B5IG92ZXIgbW91bnRlZCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgdm5vZGUuZWwgPSBjYWNoZWRWTm9kZS5lbDtcclxuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudCA9IGNhY2hlZFZOb2RlLmNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGlmICh2bm9kZS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIHRyYW5zaXRpb24gaG9va3Mgb24gc3ViVHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25Ib29rcyh2bm9kZSwgdm5vZGUudHJhbnNpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhdm9pZCB2bm9kZSBiZWluZyBtb3VudGVkIGFzIGZyZXNoXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gNTEyIC8qIENPTVBPTkVOVF9LRVBUX0FMSVZFICovO1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIGtleSB0aGUgZnJlc2hlc3RcclxuICAgICAgICAgICAgICAgIGtleXMuZGVsZXRlKGtleSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLmFkZChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5cy5hZGQoa2V5KTtcclxuICAgICAgICAgICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgICAgICAgICAgaWYgKG1heCAmJiBrZXlzLnNpemUgPiBwYXJzZUludChtYXgsIDEwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShrZXlzLnZhbHVlcygpLm5leHQoKS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXZvaWQgdm5vZGUgYmVpbmcgdW5tb3VudGVkXHJcbiAgICAgICAgICAgIHZub2RlLnNoYXBlRmxhZyB8PSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gdm5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1N1c3BlbnNlKHJhd1ZOb2RlLnR5cGUpID8gcmF3Vk5vZGUgOiB2bm9kZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG57XHJcbiAgICBLZWVwQWxpdmVJbXBsLl9faXNCdWlsZEluID0gdHJ1ZTtcclxufVxyXG4vLyBleHBvcnQgdGhlIHB1YmxpYyB0eXBlIGZvciBoL3RzeCBpbmZlcmVuY2VcclxuLy8gYWxzbyB0byBhdm9pZCBpbmxpbmUgaW1wb3J0KCkgaW4gZ2VuZXJhdGVkIGQudHMgZmlsZXNcclxuY29uc3QgS2VlcEFsaXZlID0gS2VlcEFsaXZlSW1wbDtcclxuZnVuY3Rpb24gbWF0Y2hlcyhwYXR0ZXJuLCBuYW1lKSB7XHJcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnNvbWUoKHApID0+IG1hdGNoZXMocCwgbmFtZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcclxuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluY2x1ZGVzKG5hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0dGVybi50ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gb25BY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJhXCIgLyogQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIG9uRGVhY3RpdmF0ZWQoaG9vaywgdGFyZ2V0KSB7XHJcbiAgICByZWdpc3RlcktlZXBBbGl2ZUhvb2soaG9vaywgXCJkYVwiIC8qIERFQUNUSVZBVEVEICovLCB0YXJnZXQpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZ2lzdGVyS2VlcEFsaXZlSG9vayhob29rLCB0eXBlLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgIC8vIGNhY2hlIHRoZSBkZWFjdGl2YXRlIGJyYW5jaCBjaGVjayB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZVxyXG4gICAgLy8gaG9vayBjYW4gYmUgcHJvcGVybHkgZGVkdXBlZCBieSB0aGUgc2NoZWR1bGVyLiBcIl9fd2RjXCIgc3RhbmRzIGZvciBcIndpdGhcclxuICAgIC8vIGRlYWN0aXZhdGlvbiBjaGVja1wiLlxyXG4gICAgY29uc3Qgd3JhcHBlZEhvb2sgPSBob29rLl9fd2RjIHx8XHJcbiAgICAgICAgKGhvb2suX193ZGMgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZmlyZSB0aGUgaG9vayBpZiB0aGUgdGFyZ2V0IGluc3RhbmNlIGlzIE5PVCBpbiBhIGRlYWN0aXZhdGVkIGJyYW5jaC5cclxuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5pc0RlYWN0aXZhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBob29rKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICBpbmplY3RIb29rKHR5cGUsIHdyYXBwZWRIb29rLCB0YXJnZXQpO1xyXG4gICAgLy8gSW4gYWRkaXRpb24gdG8gcmVnaXN0ZXJpbmcgaXQgb24gdGhlIHRhcmdldCBpbnN0YW5jZSwgd2Ugd2FsayB1cCB0aGUgcGFyZW50XHJcbiAgICAvLyBjaGFpbiBhbmQgcmVnaXN0ZXIgaXQgb24gYWxsIGFuY2VzdG9yIGluc3RhbmNlcyB0aGF0IGFyZSBrZWVwLWFsaXZlIHJvb3RzLlxyXG4gICAgLy8gVGhpcyBhdm9pZHMgdGhlIG5lZWQgdG8gd2FsayB0aGUgZW50aXJlIGNvbXBvbmVudCB0cmVlIHdoZW4gaW52b2tpbmcgdGhlc2VcclxuICAgIC8vIGhvb2tzLCBhbmQgbW9yZSBpbXBvcnRhbnRseSwgYXZvaWRzIHRoZSBuZWVkIHRvIHRyYWNrIGNoaWxkIGNvbXBvbmVudHMgaW5cclxuICAgIC8vIGFycmF5cy5cclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGlzS2VlcEFsaXZlKGN1cnJlbnQucGFyZW50LnZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0VG9LZWVwQWxpdmVSb290KHdyYXBwZWRIb29rLCB0eXBlLCB0YXJnZXQsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0VG9LZWVwQWxpdmVSb290KGhvb2ssIHR5cGUsIHRhcmdldCwga2VlcEFsaXZlUm9vdCkge1xyXG4gICAgLy8gaW5qZWN0SG9vayB3cmFwcyB0aGUgb3JpZ2luYWwgZm9yIGVycm9yIGhhbmRsaW5nLCBzbyBtYWtlIHN1cmUgdG8gcmVtb3ZlXHJcbiAgICAvLyB0aGUgd3JhcHBlZCB2ZXJzaW9uLlxyXG4gICAgY29uc3QgaW5qZWN0ZWQgPSBpbmplY3RIb29rKHR5cGUsIGhvb2ssIGtlZXBBbGl2ZVJvb3QsIHRydWUgLyogcHJlcGVuZCAqLyk7XHJcbiAgICBvblVubW91bnRlZCgoKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlKGtlZXBBbGl2ZVJvb3RbdHlwZV0sIGluamVjdGVkKTtcclxuICAgIH0sIHRhcmdldCk7XHJcbn1cclxuZnVuY3Rpb24gcmVzZXRTaGFwZUZsYWcodm5vZGUpIHtcclxuICAgIGxldCBzaGFwZUZsYWcgPSB2bm9kZS5zaGFwZUZsYWc7XHJcbiAgICBpZiAoc2hhcGVGbGFnICYgMjU2IC8qIENPTVBPTkVOVF9TSE9VTERfS0VFUF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovO1xyXG4gICAgfVxyXG4gICAgaWYgKHNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgIHNoYXBlRmxhZyAtPSA1MTIgLyogQ09NUE9ORU5UX0tFUFRfQUxJVkUgKi87XHJcbiAgICB9XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgPSBzaGFwZUZsYWc7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SW5uZXJDaGlsZCh2bm9kZSkge1xyXG4gICAgcmV0dXJuIHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLyA/IHZub2RlLnNzQ29udGVudCA6IHZub2RlO1xyXG59XG5cbmZ1bmN0aW9uIGluamVjdEhvb2sodHlwZSwgaG9vaywgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlLCBwcmVwZW5kID0gZmFsc2UpIHtcclxuICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBob29rcyA9IHRhcmdldFt0eXBlXSB8fCAodGFyZ2V0W3R5cGVdID0gW10pO1xyXG4gICAgICAgIC8vIGNhY2hlIHRoZSBlcnJvciBoYW5kbGluZyB3cmFwcGVyIGZvciBpbmplY3RlZCBob29rcyBzbyB0aGUgc2FtZSBob29rXHJcbiAgICAgICAgLy8gY2FuIGJlIHByb3Blcmx5IGRlZHVwZWQgYnkgdGhlIHNjaGVkdWxlci4gXCJfX3dlaFwiIHN0YW5kcyBmb3IgXCJ3aXRoIGVycm9yXHJcbiAgICAgICAgLy8gaGFuZGxpbmdcIi5cclxuICAgICAgICBjb25zdCB3cmFwcGVkSG9vayA9IGhvb2suX193ZWggfHxcclxuICAgICAgICAgICAgKGhvb2suX193ZWggPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1VubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgY2FuIHBvdGVudGlhbGx5IGJlIGNhbGxlZCBpbnNpZGUgZWZmZWN0cy5cclxuICAgICAgICAgICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBjdXJyZW50SW5zdGFuY2UgZHVyaW5nIGhvb2sgaW52b2NhdGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgaG9vayBkb2VzIG5vdCBzeW5jaHJvbm91c2x5IHRyaWdnZXIgb3RoZXIgaG9va3MsIHdoaWNoXHJcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSBmYWxzZSB3aGVuIHRoZSB1c2VyIGRvZXMgc29tZXRoaW5nIHJlYWxseSBmdW5reS5cclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaG9vaywgdGFyZ2V0LCB0eXBlLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAocHJlcGVuZCkge1xyXG4gICAgICAgICAgICBob29rcy51bnNoaWZ0KHdyYXBwZWRIb29rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhvb2tzLnB1c2god3JhcHBlZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd3JhcHBlZEhvb2s7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBjb25zdCBhcGlOYW1lID0gdG9IYW5kbGVyS2V5KEVycm9yVHlwZVN0cmluZ3NbdHlwZV0ucmVwbGFjZSgvIGhvb2skLywgJycpKTtcclxuICAgICAgICB3YXJuJDEoYCR7YXBpTmFtZX0gaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBgICtcclxuICAgICAgICAgICAgYGFzc29jaWF0ZWQgd2l0aC4gYCArXHJcbiAgICAgICAgICAgIGBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuYCArXHJcbiAgICAgICAgICAgIChgIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgaG9va3MgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdCBzdGF0ZW1lbnQuYFxyXG4gICAgICAgICAgICAgICAgKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY3JlYXRlSG9vayA9IChsaWZlY3ljbGUpID0+IChob29rLCB0YXJnZXQgPSBjdXJyZW50SW5zdGFuY2UpID0+IFxyXG4vLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcclxuKCFpc0luU1NSQ29tcG9uZW50U2V0dXAgfHwgbGlmZWN5Y2xlID09PSBcInNwXCIgLyogU0VSVkVSX1BSRUZFVENIICovKSAmJlxyXG4gICAgaW5qZWN0SG9vayhsaWZlY3ljbGUsIGhvb2ssIHRhcmdldCk7XHJcbmNvbnN0IG9uQmVmb3JlTW91bnQgPSBjcmVhdGVIb29rKFwiYm1cIiAvKiBCRUZPUkVfTU9VTlQgKi8pO1xyXG5jb25zdCBvbk1vdW50ZWQgPSBjcmVhdGVIb29rKFwibVwiIC8qIE1PVU5URUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVwZGF0ZSA9IGNyZWF0ZUhvb2soXCJidVwiIC8qIEJFRk9SRV9VUERBVEUgKi8pO1xyXG5jb25zdCBvblVwZGF0ZWQgPSBjcmVhdGVIb29rKFwidVwiIC8qIFVQREFURUQgKi8pO1xyXG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVIb29rKFwiYnVtXCIgLyogQkVGT1JFX1VOTU9VTlQgKi8pO1xyXG5jb25zdCBvblVubW91bnRlZCA9IGNyZWF0ZUhvb2soXCJ1bVwiIC8qIFVOTU9VTlRFRCAqLyk7XHJcbmNvbnN0IG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVIb29rKFwic3BcIiAvKiBTRVJWRVJfUFJFRkVUQ0ggKi8pO1xyXG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUhvb2soXCJydGdcIiAvKiBSRU5ERVJfVFJJR0dFUkVEICovKTtcclxuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlSG9vayhcInJ0Y1wiIC8qIFJFTkRFUl9UUkFDS0VEICovKTtcclxuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgaW5qZWN0SG9vayhcImVjXCIgLyogRVJST1JfQ0FQVFVSRUQgKi8sIGhvb2ssIHRhcmdldCk7XHJcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcGF0Q2hpbGRyZW4oaW5zdGFuY2UpIHtcclxuICAgIGFzc2VydENvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9DSElMRFJFTlwiIC8qIElOU1RBTkNFX0NISUxEUkVOICovLCBpbnN0YW5jZSk7XHJcbiAgICBjb25zdCByb290ID0gaW5zdGFuY2Uuc3ViVHJlZTtcclxuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XHJcbiAgICBpZiAocm9vdCkge1xyXG4gICAgICAgIHdhbGsocm9vdCwgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xyXG59XHJcbmZ1bmN0aW9uIHdhbGsodm5vZGUsIGNoaWxkcmVuKSB7XHJcbiAgICBpZiAodm5vZGUuY29tcG9uZW50KSB7XHJcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2bm9kZS5jb21wb25lbnQucHJveHkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICBjb25zdCB2bm9kZXMgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB3YWxrKHZub2Rlc1tpXSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRDb21wYXRMaXN0ZW5lcnMoaW5zdGFuY2UpIHtcclxuICAgIGFzc2VydENvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9MSVNURU5FUlNcIiAvKiBJTlNUQU5DRV9MSVNURU5FUlMgKi8sIGluc3RhbmNlKTtcclxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHt9O1xyXG4gICAgY29uc3QgcmF3UHJvcHMgPSBpbnN0YW5jZS52bm9kZS5wcm9wcztcclxuICAgIGlmICghcmF3UHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gbGlzdGVuZXJzO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1trZXlbMl0udG9Mb3dlckNhc2UoKSArIGtleS5zbGljZSgzKV0gPSByYXdQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsaXN0ZW5lcnM7XHJcbn1cblxuY29uc3QgbGVnYWN5RGlyZWN0aXZlSG9va01hcCA9IHtcclxuICAgIGJlZm9yZU1vdW50OiAnYmluZCcsXHJcbiAgICBtb3VudGVkOiAnaW5zZXJ0ZWQnLFxyXG4gICAgdXBkYXRlZDogWyd1cGRhdGUnLCAnY29tcG9uZW50VXBkYXRlZCddLFxyXG4gICAgdW5tb3VudGVkOiAndW5iaW5kJ1xyXG59O1xyXG5mdW5jdGlvbiBtYXBDb21wYXREaXJlY3RpdmVIb29rKG5hbWUsIGRpciwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IG1hcHBlZE5hbWUgPSBsZWdhY3lEaXJlY3RpdmVIb29rTWFwW25hbWVdO1xyXG4gICAgaWYgKG1hcHBlZE5hbWUpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShtYXBwZWROYW1lKSkge1xyXG4gICAgICAgICAgICBjb25zdCBob29rID0gW107XHJcbiAgICAgICAgICAgIG1hcHBlZE5hbWUuZm9yRWFjaChtYXBwZWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkSG9vayA9IGRpclttYXBwZWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZEhvb2spIHtcclxuICAgICAgICAgICAgICAgICAgICBzb2Z0QXNzZXJ0Q29tcGF0RW5hYmxlZChcIkNVU1RPTV9ESVJcIiAvKiBDVVNUT01fRElSICovLCBpbnN0YW5jZSwgbWFwcGVkLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBob29rLnB1c2gobWFwcGVkSG9vayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gaG9vay5sZW5ndGggPyBob29rIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGRpclttYXBwZWROYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgc29mdEFzc2VydENvbXBhdEVuYWJsZWQoXCJDVVNUT01fRElSXCIgLyogQ1VTVE9NX0RJUiAqLywgaW5zdGFuY2UsIG1hcHBlZE5hbWUsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkaXJbbWFwcGVkTmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG5SdW50aW1lIGhlbHBlciBmb3IgYXBwbHlpbmcgZGlyZWN0aXZlcyB0byBhIHZub2RlLiBFeGFtcGxlIHVzYWdlOlxyXG5cbmNvbnN0IGNvbXAgPSByZXNvbHZlQ29tcG9uZW50KCdjb21wJylcclxuY29uc3QgZm9vID0gcmVzb2x2ZURpcmVjdGl2ZSgnZm9vJylcclxuY29uc3QgYmFyID0gcmVzb2x2ZURpcmVjdGl2ZSgnYmFyJylcclxuXG5yZXR1cm4gd2l0aERpcmVjdGl2ZXMoaChjb21wKSwgW1xyXG4gIFtmb28sIHRoaXMueF0sXHJcbiAgW2JhciwgdGhpcy55XVxyXG5dKVxyXG4qL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSkge1xyXG4gICAgaWYgKGlzQnVpbHRJbkRpcmVjdGl2ZShuYW1lKSkge1xyXG4gICAgICAgIHdhcm4kMSgnRG8gbm90IHVzZSBidWlsdC1pbiBkaXJlY3RpdmUgaWRzIGFzIGN1c3RvbSBkaXJlY3RpdmUgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBkaXJlY3RpdmVzIHRvIGEgVk5vZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoRGlyZWN0aXZlcyh2bm9kZSwgZGlyZWN0aXZlcykge1xyXG4gICAgY29uc3QgaW50ZXJuYWxJbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4kMShgd2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5gKTtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEV4cG9zZVByb3h5KGludGVybmFsSW5zdGFuY2UpIHx8XHJcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5wcm94eTtcclxuICAgIGNvbnN0IGJpbmRpbmdzID0gdm5vZGUuZGlycyB8fCAodm5vZGUuZGlycyA9IFtdKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGxldCBbZGlyLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgPSBFTVBUWV9PQkpdID0gZGlyZWN0aXZlc1tpXTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihkaXIpKSB7XHJcbiAgICAgICAgICAgIGRpciA9IHtcclxuICAgICAgICAgICAgICAgIG1vdW50ZWQ6IGRpcixcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWQ6IGRpclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlyLmRlZXApIHtcclxuICAgICAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiaW5kaW5ncy5wdXNoKHtcclxuICAgICAgICAgICAgZGlyLFxyXG4gICAgICAgICAgICBpbnN0YW5jZSxcclxuICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIG9sZFZhbHVlOiB2b2lkIDAsXHJcbiAgICAgICAgICAgIGFyZyxcclxuICAgICAgICAgICAgbW9kaWZpZXJzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgcHJldlZOb2RlLCBpbnN0YW5jZSwgbmFtZSkge1xyXG4gICAgY29uc3QgYmluZGluZ3MgPSB2bm9kZS5kaXJzO1xyXG4gICAgY29uc3Qgb2xkQmluZGluZ3MgPSBwcmV2Vk5vZGUgJiYgcHJldlZOb2RlLmRpcnM7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYmluZGluZyA9IGJpbmRpbmdzW2ldO1xyXG4gICAgICAgIGlmIChvbGRCaW5kaW5ncykge1xyXG4gICAgICAgICAgICBiaW5kaW5nLm9sZFZhbHVlID0gb2xkQmluZGluZ3NbaV0udmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBob29rID0gYmluZGluZy5kaXJbbmFtZV07XHJcbiAgICAgICAgaWYgKCFob29rKSB7XHJcbiAgICAgICAgICAgIGhvb2sgPSBtYXBDb21wYXREaXJlY3RpdmVIb29rKG5hbWUsIGJpbmRpbmcuZGlyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgICAgIC8vIGRpc2FibGUgdHJhY2tpbmcgaW5zaWRlIGFsbCBsaWZlY3ljbGUgaG9va3NcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBjYW4gcG90ZW50aWFsbHkgYmUgY2FsbGVkIGluc2lkZSBlZmZlY3RzLlxyXG4gICAgICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA4IC8qIERJUkVDVElWRV9IT09LICovLCBbXHJcbiAgICAgICAgICAgICAgICB2bm9kZS5lbCxcclxuICAgICAgICAgICAgICAgIGJpbmRpbmcsXHJcbiAgICAgICAgICAgICAgICB2bm9kZSxcclxuICAgICAgICAgICAgICAgIHByZXZWTm9kZVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCBDT01QT05FTlRTID0gJ2NvbXBvbmVudHMnO1xyXG5jb25zdCBESVJFQ1RJVkVTID0gJ2RpcmVjdGl2ZXMnO1xyXG5jb25zdCBGSUxURVJTID0gJ2ZpbHRlcnMnO1xyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQobmFtZSwgbWF5YmVTZWxmUmVmZXJlbmNlKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KENPTVBPTkVOVFMsIG5hbWUsIHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSkgfHwgbmFtZTtcclxufVxyXG5jb25zdCBOVUxMX0RZTkFNSUNfQ09NUE9ORU5UID0gU3ltYm9sKCk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICBpZiAoaXNTdHJpbmcoY29tcG9uZW50KSkge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlQXNzZXQoQ09NUE9ORU5UUywgY29tcG9uZW50LCBmYWxzZSkgfHwgY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gaW52YWxpZCB0eXBlcyB3aWxsIGZhbGx0aHJvdWdoIHRvIGNyZWF0ZVZOb2RlIGFuZCByYWlzZSB3YXJuaW5nXHJcbiAgICAgICAgcmV0dXJuIChjb21wb25lbnQgfHwgTlVMTF9EWU5BTUlDX0NPTVBPTkVOVCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRGlyZWN0aXZlKG5hbWUpIHtcclxuICAgIHJldHVybiByZXNvbHZlQXNzZXQoRElSRUNUSVZFUywgbmFtZSk7XHJcbn1cclxuLyoqXHJcbiAqIHYyIGNvbXBhdCBvbmx5XHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihuYW1lKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KEZJTFRFUlMsIG5hbWUpO1xyXG59XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIHJlc29sdmVBc3NldCh0eXBlLCBuYW1lLCB3YXJuTWlzc2luZyA9IHRydWUsIG1heWJlU2VsZlJlZmVyZW5jZSA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB8fCBjdXJyZW50SW5zdGFuY2U7XHJcbiAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBDb21wb25lbnQgPSBpbnN0YW5jZS50eXBlO1xyXG4gICAgICAgIC8vIGV4cGxpY2l0IHNlbGYgbmFtZSBoYXMgaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIGlmICh0eXBlID09PSBDT01QT05FTlRTKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQsIGZhbHNlIC8qIGRvIG5vdCBpbmNsdWRlIGluZmVycmVkIG5hbWUgdG8gYXZvaWQgYnJlYWtpbmcgZXhpc3RpbmcgY29kZSAqLyk7XHJcbiAgICAgICAgICAgIGlmIChzZWxmTmFtZSAmJlxyXG4gICAgICAgICAgICAgICAgKHNlbGZOYW1lID09PSBuYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhbWVsaXplKG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZk5hbWUgPT09IGNhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBcclxuICAgICAgICAvLyBsb2NhbCByZWdpc3RyYXRpb25cclxuICAgICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcclxuICAgICAgICByZXNvbHZlKGluc3RhbmNlW3R5cGVdIHx8IENvbXBvbmVudFt0eXBlXSwgbmFtZSkgfHxcclxuICAgICAgICAgICAgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxyXG4gICAgICAgICAgICByZXNvbHZlKGluc3RhbmNlLmFwcENvbnRleHRbdHlwZV0sIG5hbWUpO1xyXG4gICAgICAgIGlmICghcmVzICYmIG1heWJlU2VsZlJlZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBpbXBsaWNpdCBzZWxmLXJlZmVyZW5jZVxyXG4gICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZXh0cmEgPSB0eXBlID09PSBDT01QT05FTlRTXHJcbiAgICAgICAgICAgICAgICA/IGBcXG5JZiB0aGlzIGlzIGEgbmF0aXZlIGN1c3RvbSBlbGVtZW50LCBtYWtlIHN1cmUgdG8gZXhjbHVkZSBpdCBmcm9tIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBjb21wb25lbnQgcmVzb2x1dGlvbiB2aWEgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudC5gXHJcbiAgICAgICAgICAgICAgICA6IGBgO1xyXG4gICAgICAgICAgICB3YXJuJDEoYEZhaWxlZCB0byByZXNvbHZlICR7dHlwZS5zbGljZSgwLCAtMSl9OiAke25hbWV9JHtleHRyYX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4kMShgcmVzb2x2ZSR7Y2FwaXRhbGl6ZSh0eXBlLnNsaWNlKDAsIC0xKSl9IGAgK1xyXG4gICAgICAgICAgICBgY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmUocmVnaXN0cnksIG5hbWUpIHtcclxuICAgIHJldHVybiAocmVnaXN0cnkgJiZcclxuICAgICAgICAocmVnaXN0cnlbbmFtZV0gfHxcclxuICAgICAgICAgICAgcmVnaXN0cnlbY2FtZWxpemUobmFtZSldIHx8XHJcbiAgICAgICAgICAgIHJlZ2lzdHJ5W2NhcGl0YWxpemUoY2FtZWxpemUobmFtZSkpXSkpO1xyXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRMZWdhY3lSZW5kZXJGbihpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGNvbnN0IHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XHJcbiAgICAvLyB2MyBydW50aW1lIGNvbXBpbGVkLCBvciBhbHJlYWR5IGNoZWNrZWQgLyB3cmFwcGVkXHJcbiAgICBpZiAoIXJlbmRlciB8fCByZW5kZXIuX3JjIHx8IHJlbmRlci5fY29tcGF0Q2hlY2tlZCB8fCByZW5kZXIuX2NvbXBhdFdyYXBwZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAocmVuZGVyLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgLy8gdjMgcHJlLWNvbXBpbGVkIGZ1bmN0aW9uLCBzaW5jZSB2MiByZW5kZXIgZnVuY3Rpb25zIG5ldmVyIG5lZWQgbW9yZSB0aGFuXHJcbiAgICAgICAgLy8gMiBhcmd1bWVudHMsIGFuZCB2MiBmdW5jdGlvbmFsIHJlbmRlciBmdW5jdGlvbnMgd291bGQgaGF2ZSBhbHJlYWR5IGJlZW5cclxuICAgICAgICAvLyBub3JtYWxpemVkIGludG8gdjMgZnVuY3Rpb25hbCBjb21wb25lbnRzXHJcbiAgICAgICAgcmVuZGVyLl9jb21wYXRDaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB2MiByZW5kZXIgZnVuY3Rpb24sIHRyeSB0byBwcm92aWRlIGNvbXBhdFxyXG4gICAgaWYgKGNoZWNrQ29tcGF0RW5hYmxlZChcIlJFTkRFUl9GVU5DVElPTlwiIC8qIFJFTkRFUl9GVU5DVElPTiAqLywgaW5zdGFuY2UpKSB7XHJcbiAgICAgICAgY29uc3Qgd3JhcHBlZCA9IChDb21wb25lbnQucmVuZGVyID0gZnVuY3Rpb24gY29tcGF0UmVuZGVyKCkge1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBjb21wYXRIKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgd3JhcHBlZC5fY29tcGF0V3JhcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcGF0SCh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKSB7XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICB0eXBlID0gQ29tbWVudDtcclxuICAgIH1cclxuICAgIC8vIHRvIHN1cHBvcnQgdjIgc3RyaW5nIGNvbXBvbmVudCBuYW1lIGxvb2shdXBcclxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBjb25zdCB0ID0gaHlwaGVuYXRlKHR5cGUpO1xyXG4gICAgICAgIGlmICh0ID09PSAndHJhbnNpdGlvbicgfHwgdCA9PT0gJ3RyYW5zaXRpb24tZ3JvdXAnIHx8IHQgPT09ICdrZWVwLWFsaXZlJykge1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0cmFuc2l0aW9uIGFuZCB0cmFuc2l0aW9uLWdyb3VwIGFyZSBydW50aW1lLWRvbS1zcGVjaWZpYyxcclxuICAgICAgICAgICAgLy8gd2UgY2Fubm90IGltcG9ydCB0aGVtIGRpcmVjdGx5IGhlcmUuIEluc3RlYWQgdGhleSBhcmUgcmVnaXN0ZXJlZCB1c2luZ1xyXG4gICAgICAgICAgICAvLyBzcGVjaWFsIGtleXMgaW4gQHZ1ZS9jb21wYXQgZW50cnkuXHJcbiAgICAgICAgICAgIHR5cGUgPSBgX19jb21wYXRfXyR7dH1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0eXBlID0gcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQodHlwZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIGNvbnN0IGlzMm5kQXJnQXJyYXlDaGlsZHJlbiA9IGlzQXJyYXkocHJvcHNPckNoaWxkcmVuKTtcclxuICAgIGlmIChsID09PSAyIHx8IGlzMm5kQXJnQXJyYXlDaGlsZHJlbikge1xyXG4gICAgICAgIGlmIChpc09iamVjdChwcm9wc09yQ2hpbGRyZW4pICYmICFpczJuZEFyZ0FycmF5Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgLy8gc2luZ2xlIHZub2RlIHdpdGhvdXQgcHJvcHNcclxuICAgICAgICAgICAgaWYgKGlzVk5vZGUocHJvcHNPckNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRMZWdhY3lTbG90cyhjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHByb3BzIHdpdGhvdXQgY2hpbGRyZW5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRMZWdhY3lTbG90cyhjb252ZXJ0TGVnYWN5RGlyZWN0aXZlcyhjcmVhdGVWTm9kZSh0eXBlLCBjb252ZXJ0TGVnYWN5UHJvcHMocHJvcHNPckNoaWxkcmVuLCB0eXBlKSksIHByb3BzT3JDaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gb21pdCBwcm9wc1xyXG4gICAgICAgICAgICByZXR1cm4gY29udmVydExlZ2FjeVNsb3RzKGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChpc1ZOb2RlKGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb252ZXJ0TGVnYWN5U2xvdHMoY29udmVydExlZ2FjeURpcmVjdGl2ZXMoY3JlYXRlVk5vZGUodHlwZSwgY29udmVydExlZ2FjeVByb3BzKHByb3BzT3JDaGlsZHJlbiwgdHlwZSksIGNoaWxkcmVuKSwgcHJvcHNPckNoaWxkcmVuKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgc2tpcExlZ2FjeVJvb3RMZXZlbFByb3BzID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzdGF0aWNTdHlsZSxzdGF0aWNDbGFzcyxkaXJlY3RpdmVzLG1vZGVsLGhvb2snKTtcclxuZnVuY3Rpb24gY29udmVydExlZ2FjeVByb3BzKGxlZ2FjeVByb3BzLCB0eXBlKSB7XHJcbiAgICBpZiAoIWxlZ2FjeVByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGxlZ2FjeVByb3BzKSB7XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2F0dHJzJyB8fCBrZXkgPT09ICdkb21Qcm9wcycgfHwga2V5ID09PSAncHJvcHMnKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChjb252ZXJ0ZWQsIGxlZ2FjeVByb3BzW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdvbicgfHwga2V5ID09PSAnbmF0aXZlT24nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGxlZ2FjeVByb3BzW2tleV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlcktleSA9IGNvbnZlcnRMZWdhY3lFdmVudEtleShldmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnbmF0aXZlT24nKVxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJLZXkgKz0gYE5hdGl2ZWA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGNvbnZlcnRlZFtoYW5kbGVyS2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluY29taW5nID0gbGlzdGVuZXJzW2V2ZW50XTtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZyAhPT0gaW5jb21pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydGVkW2hhbmRsZXJLZXldID0gW10uY29uY2F0KGV4aXN0aW5nLCBpbmNvbWluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZWRbaGFuZGxlcktleV0gPSBpbmNvbWluZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXNraXBMZWdhY3lSb290TGV2ZWxQcm9wcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnZlcnRlZFtrZXldID0gbGVnYWN5UHJvcHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVnYWN5UHJvcHMuc3RhdGljQ2xhc3MpIHtcclxuICAgICAgICBjb252ZXJ0ZWQuY2xhc3MgPSBub3JtYWxpemVDbGFzcyhbbGVnYWN5UHJvcHMuc3RhdGljQ2xhc3MsIGNvbnZlcnRlZC5jbGFzc10pO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZ2FjeVByb3BzLnN0YXRpY1N0eWxlKSB7XHJcbiAgICAgICAgY29udmVydGVkLnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW2xlZ2FjeVByb3BzLnN0YXRpY1N0eWxlLCBjb252ZXJ0ZWQuc3R5bGVdKTtcclxuICAgIH1cclxuICAgIGlmIChsZWdhY3lQcm9wcy5tb2RlbCAmJiBpc09iamVjdCh0eXBlKSkge1xyXG4gICAgICAgIC8vIHYyIGNvbXBpbGVkIGNvbXBvbmVudCB2LW1vZGVsXHJcbiAgICAgICAgY29uc3QgeyBwcm9wID0gJ3ZhbHVlJywgZXZlbnQgPSAnaW5wdXQnIH0gPSB0eXBlLm1vZGVsIHx8IHt9O1xyXG4gICAgICAgIGNvbnZlcnRlZFtwcm9wXSA9IGxlZ2FjeVByb3BzLm1vZGVsLnZhbHVlO1xyXG4gICAgICAgIGNvbnZlcnRlZFtjb21wYXRNb2RlbEV2ZW50UHJlZml4ICsgZXZlbnRdID0gbGVnYWN5UHJvcHMubW9kZWwuY2FsbGJhY2s7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udmVydGVkO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRMZWdhY3lFdmVudEtleShldmVudCkge1xyXG4gICAgLy8gbm9ybWFsaXplIHYyIGV2ZW50IHByZWZpeGVzXHJcbiAgICBpZiAoZXZlbnRbMF0gPT09ICcmJykge1xyXG4gICAgICAgIGV2ZW50ID0gZXZlbnQuc2xpY2UoMSkgKyAnUGFzc2l2ZSc7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnRbMF0gPT09ICd+Jykge1xyXG4gICAgICAgIGV2ZW50ID0gZXZlbnQuc2xpY2UoMSkgKyAnT25jZSc7XHJcbiAgICB9XHJcbiAgICBpZiAoZXZlbnRbMF0gPT09ICchJykge1xyXG4gICAgICAgIGV2ZW50ID0gZXZlbnQuc2xpY2UoMSkgKyAnQ2FwdHVyZSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9IYW5kbGVyS2V5KGV2ZW50KTtcclxufVxyXG5mdW5jdGlvbiBjb252ZXJ0TGVnYWN5RGlyZWN0aXZlcyh2bm9kZSwgcHJvcHMpIHtcclxuICAgIGlmIChwcm9wcyAmJiBwcm9wcy5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHdpdGhEaXJlY3RpdmVzKHZub2RlLCBwcm9wcy5kaXJlY3RpdmVzLm1hcCgoeyBuYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMgfSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZURpcmVjdGl2ZShuYW1lKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnZlcnRMZWdhY3lTbG90cyh2bm9kZSkge1xyXG4gICAgY29uc3QgeyBwcm9wcywgY2hpbGRyZW4gfSA9IHZub2RlO1xyXG4gICAgbGV0IHNsb3RzO1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmIGlzQXJyYXkoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgc2xvdHMgPSB7fTtcclxuICAgICAgICAvLyBjaGVjayBcInNsb3RcIiBwcm9wZXJ0eSBvbiB2bm9kZXMgYW5kIHR1cm4gdGhlbSBpbnRvIHYzIGZ1bmN0aW9uIHNsb3RzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBzbG90TmFtZSA9IChpc1ZOb2RlKGNoaWxkKSAmJiBjaGlsZC5wcm9wcyAmJiBjaGlsZC5wcm9wcy5zbG90KSB8fCAnZGVmYXVsdCc7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSBzbG90c1tzbG90TmFtZV0gfHwgKHNsb3RzW3Nsb3ROYW1lXSA9IFtdKTtcclxuICAgICAgICAgICAgaWYgKGlzVk5vZGUoY2hpbGQpICYmIGNoaWxkLnR5cGUgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIHNsb3QucHVzaChjaGlsZC5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzbG90cykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzbG90cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvdENoaWxkcmVuID0gc2xvdHNba2V5XTtcclxuICAgICAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBzbG90Q2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBzbG90c1trZXldLl9ucyA9IHRydWU7IC8qIG5vbi1zY29wZWQgc2xvdCAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2NvcGVkU2xvdHMgPSBwcm9wcyAmJiBwcm9wcy5zY29wZWRTbG90cztcclxuICAgIGlmIChzY29wZWRTbG90cykge1xyXG4gICAgICAgIGRlbGV0ZSBwcm9wcy5zY29wZWRTbG90cztcclxuICAgICAgICBpZiAoc2xvdHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKHNsb3RzLCBzY29wZWRTbG90cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzbG90cyA9IHNjb3BlZFNsb3RzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzbG90cykge1xyXG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBzbG90cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lTGVnYWN5Vk5vZGVQcm9wZXJ0aWVzKHZub2RlKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJSRU5ERVJfRlVOQ1RJT05cIiAvKiBSRU5ERVJfRlVOQ1RJT04gKi8sIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgdHJ1ZSAvKiBlbmFibGUgZm9yIGJ1aWx0LWlucyAqLykgJiZcclxuICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJQUklWQVRFX0FQSVNcIiAvKiBQUklWQVRFX0FQSVMgKi8sIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSwgdHJ1ZSAvKiBlbmFibGUgZm9yIGJ1aWx0LWlucyAqLykpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG4gICAgICAgIGNvbnN0IGdldEluc3RhbmNlID0gKCkgPT4gdm5vZGUuY29tcG9uZW50ICYmIHZub2RlLmNvbXBvbmVudC5wcm94eTtcclxuICAgICAgICBsZXQgY29tcG9uZW50T3B0aW9ucztcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh2bm9kZSwge1xyXG4gICAgICAgICAgICB0YWc6IHsgZ2V0OiAoKSA9PiB2bm9kZS50eXBlIH0sXHJcbiAgICAgICAgICAgIGRhdGE6IHsgZ2V0OiAoKSA9PiB2bm9kZS5wcm9wcyB8fCB7fSwgc2V0OiBwID0+ICh2bm9kZS5wcm9wcyA9IHApIH0sXHJcbiAgICAgICAgICAgIGVsbTogeyBnZXQ6ICgpID0+IHZub2RlLmVsIH0sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlOiB7IGdldDogZ2V0SW5zdGFuY2UgfSxcclxuICAgICAgICAgICAgY2hpbGQ6IHsgZ2V0OiBnZXRJbnN0YW5jZSB9LFxyXG4gICAgICAgICAgICB0ZXh0OiB7IGdldDogKCkgPT4gKGlzU3RyaW5nKHZub2RlLmNoaWxkcmVuKSA/IHZub2RlLmNoaWxkcmVuIDogbnVsbCkgfSxcclxuICAgICAgICAgICAgY29udGV4dDogeyBnZXQ6ICgpID0+IGNvbnRleHQgJiYgY29udGV4dC5wcm94eSB9LFxyXG4gICAgICAgICAgICBjb21wb25lbnRPcHRpb25zOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoY29tcG9uZW50T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN0b3I6IHZub2RlLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wc0RhdGE6IHZub2RlLnByb3BzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHZub2RlLmNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5vcm1hbGl6ZWRGdW5jdGlvbmFsQ29tcG9uZW50TWFwID0gbmV3IE1hcCgpO1xyXG5jb25zdCBsZWdhY3lTbG90UHJveHlIYW5kbGVycyA9IHtcclxuICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGNvbnN0IHNsb3QgPSB0YXJnZXRba2V5XTtcclxuICAgICAgICByZXR1cm4gc2xvdCAmJiBzbG90KCk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGNvbnZlcnRMZWdhY3lGdW5jdGlvbmFsQ29tcG9uZW50KGNvbXApIHtcclxuICAgIGlmIChub3JtYWxpemVkRnVuY3Rpb25hbENvbXBvbmVudE1hcC5oYXMoY29tcCkpIHtcclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEZ1bmN0aW9uYWxDb21wb25lbnRNYXAuZ2V0KGNvbXApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVnYWN5Rm4gPSBjb21wLnJlbmRlcjtcclxuICAgIGNvbnN0IEZ1bmMgPSAocHJvcHMsIGN0eCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3QgbGVnYWN5Q3R4ID0ge1xyXG4gICAgICAgICAgICBwcm9wcyxcclxuICAgICAgICAgICAgY2hpbGRyZW46IGluc3RhbmNlLnZub2RlLmNoaWxkcmVuIHx8IFtdLFxyXG4gICAgICAgICAgICBkYXRhOiBpbnN0YW5jZS52bm9kZS5wcm9wcyB8fCB7fSxcclxuICAgICAgICAgICAgc2NvcGVkU2xvdHM6IGN0eC5zbG90cyxcclxuICAgICAgICAgICAgcGFyZW50OiBpbnN0YW5jZS5wYXJlbnQgJiYgaW5zdGFuY2UucGFyZW50LnByb3h5LFxyXG4gICAgICAgICAgICBzbG90cygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkoY3R4LnNsb3RzLCBsZWdhY3lTbG90UHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBsaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcGF0TGlzdGVuZXJzKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IGluamVjdGlvbnMoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcC5pbmplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmplY3Rpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoY29tcC5pbmplY3QsIGluamVjdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmplY3Rpb25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbGVnYWN5Rm4oY29tcGF0SCwgbGVnYWN5Q3R4KTtcclxuICAgIH07XHJcbiAgICBGdW5jLnByb3BzID0gY29tcC5wcm9wcztcclxuICAgIEZ1bmMuZGlzcGxheU5hbWUgPSBjb21wLm5hbWU7XHJcbiAgICBGdW5jLmNvbXBhdENvbmZpZyA9IGNvbXAuY29tcGF0Q29uZmlnO1xyXG4gICAgLy8gdjIgZnVuY3Rpb25hbCBjb21wb25lbnRzIGRvIG5vdCBpbmhlcml0IGF0dHJzXHJcbiAgICBGdW5jLmluaGVyaXRBdHRycyA9IGZhbHNlO1xyXG4gICAgbm9ybWFsaXplZEZ1bmN0aW9uYWxDb21wb25lbnRNYXAuc2V0KGNvbXAsIEZ1bmMpO1xyXG4gICAgcmV0dXJuIEZ1bmM7XHJcbn1cblxuLyoqXHJcbiAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyTGlzdChzb3VyY2UsIHJlbmRlckl0ZW0sIGNhY2hlLCBpbmRleCkge1xyXG4gICAgbGV0IHJldDtcclxuICAgIGNvbnN0IGNhY2hlZCA9IChjYWNoZSAmJiBjYWNoZVtpbmRleF0pO1xyXG4gICAgaWYgKGlzQXJyYXkoc291cmNlKSB8fCBpc1N0cmluZyhzb3VyY2UpKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc291cmNlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtpXSwgaSwgdW5kZWZpbmVkLCBjYWNoZWQgJiYgY2FjaGVkW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIU51bWJlci5pc0ludGVnZXIoc291cmNlKSkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYFRoZSB2LWZvciByYW5nZSBleHBlY3QgYW4gaW50ZWdlciB2YWx1ZSBidXQgZ290ICR7c291cmNlfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHNvdXJjZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2U7IGkrKykge1xyXG4gICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKGkgKyAxLCBpLCB1bmRlZmluZWQsIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcclxuICAgICAgICBpZiAoc291cmNlW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gQXJyYXkuZnJvbShzb3VyY2UsIChpdGVtLCBpKSA9PiByZW5kZXJJdGVtKGl0ZW0sIGksIHVuZGVmaW5lZCwgY2FjaGVkICYmIGNhY2hlZFtpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXJJdGVtKHNvdXJjZVtrZXldLCBrZXksIGksIGNhY2hlZCAmJiBjYWNoZWRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0ID0gW107XHJcbiAgICB9XHJcbiAgICBpZiAoY2FjaGUpIHtcclxuICAgICAgICBjYWNoZVtpbmRleF0gPSByZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgY3JlYXRpbmcgZHluYW1pYyBzbG90cyBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVNsb3RzKHNsb3RzLCBkeW5hbWljU2xvdHMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc2xvdCA9IGR5bmFtaWNTbG90c1tpXTtcclxuICAgICAgICAvLyBhcnJheSBvZiBkeW5hbWljIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWZvcj1cIi4uLlwiICNbLi4uXT5cclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsb3QubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzW3Nsb3Rbal0ubmFtZV0gPSBzbG90W2pdLmZuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWwgc2luZ2xlIHNsb3QgZ2VuZXJhdGVkIGJ5IDx0ZW1wbGF0ZSB2LWlmPVwiLi4uXCIgI2Zvbz5cclxuICAgICAgICAgICAgc2xvdHNbc2xvdC5uYW1lXSA9IHNsb3QuZm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XG5cbi8qKlxyXG4gKiBDb21waWxlciBydW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIGA8c2xvdC8+YFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU2xvdChzbG90cywgbmFtZSwgcHJvcHMgPSB7fSwgXHJcbi8vIHRoaXMgaXMgbm90IGEgdXNlci1mYWNpbmcgZnVuY3Rpb24sIHNvIHRoZSBmYWxsYmFjayBpcyBhbHdheXMgZ2VuZXJhdGVkIGJ5XHJcbi8vIHRoZSBjb21waWxlciBhbmQgZ3VhcmFudGVlZCB0byBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheVxyXG5mYWxsYmFjaywgbm9TbG90dGVkKSB7XHJcbiAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLmlzQ0UgfHxcclxuICAgICAgICAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnBhcmVudCAmJlxyXG4gICAgICAgICAgICBpc0FzeW5jV3JhcHBlcihjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50KSAmJlxyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UucGFyZW50LmlzQ0UpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKCdzbG90JywgbmFtZSA9PT0gJ2RlZmF1bHQnID8gbnVsbCA6IHsgbmFtZSB9LCBmYWxsYmFjayAmJiBmYWxsYmFjaygpKTtcclxuICAgIH1cclxuICAgIGxldCBzbG90ID0gc2xvdHNbbmFtZV07XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNsb3QgJiYgc2xvdC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgd2FybiQxKGBTU1Itb3B0aW1pemVkIHNsb3QgZnVuY3Rpb24gZGV0ZWN0ZWQgaW4gYSBub24tU1NSLW9wdGltaXplZCByZW5kZXIgYCArXHJcbiAgICAgICAgICAgIGBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYHBhcmVudCB0ZW1wbGF0ZS5gKTtcclxuICAgICAgICBzbG90ID0gKCkgPT4gW107XHJcbiAgICB9XHJcbiAgICAvLyBhIGNvbXBpbGVkIHNsb3QgZGlzYWJsZXMgYmxvY2sgdHJhY2tpbmcgYnkgZGVmYXVsdCB0byBhdm9pZCBtYW51YWxcclxuICAgIC8vIGludm9jYXRpb24gaW50ZXJmZXJpbmcgd2l0aCB0ZW1wbGF0ZS1iYXNlZCBibG9jayB0cmFja2luZywgYnV0IGluXHJcbiAgICAvLyBgcmVuZGVyU2xvdGAgd2UgY2FuIGJlIHN1cmUgdGhhdCBpdCdzIHRlbXBsYXRlLWJhc2VkIHNvIHdlIGNhbiBmb3JjZVxyXG4gICAgLy8gZW5hYmxlIGl0LlxyXG4gICAgaWYgKHNsb3QgJiYgc2xvdC5fYykge1xyXG4gICAgICAgIHNsb3QuX2QgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIG9wZW5CbG9jaygpO1xyXG4gICAgY29uc3QgdmFsaWRTbG90Q29udGVudCA9IHNsb3QgJiYgZW5zdXJlVmFsaWRWTm9kZShzbG90KHByb3BzKSk7XHJcbiAgICBjb25zdCByZW5kZXJlZCA9IGNyZWF0ZUJsb2NrKEZyYWdtZW50LCB7IGtleTogcHJvcHMua2V5IHx8IGBfJHtuYW1lfWAgfSwgdmFsaWRTbG90Q29udGVudCB8fCAoZmFsbGJhY2sgPyBmYWxsYmFjaygpIDogW10pLCB2YWxpZFNsb3RDb250ZW50ICYmIHNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovXHJcbiAgICAgICAgPyA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi9cclxuICAgICAgICA6IC0yIC8qIEJBSUwgKi8pO1xyXG4gICAgaWYgKCFub1Nsb3R0ZWQgJiYgcmVuZGVyZWQuc2NvcGVJZCkge1xyXG4gICAgICAgIHJlbmRlcmVkLnNsb3RTY29wZUlkcyA9IFtyZW5kZXJlZC5zY29wZUlkICsgJy1zJ107XHJcbiAgICB9XHJcbiAgICBpZiAoc2xvdCAmJiBzbG90Ll9jKSB7XHJcbiAgICAgICAgc2xvdC5fZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVuZGVyZWQ7XHJcbn1cclxuZnVuY3Rpb24gZW5zdXJlVmFsaWRWTm9kZSh2bm9kZXMpIHtcclxuICAgIHJldHVybiB2bm9kZXMuc29tZShjaGlsZCA9PiB7XHJcbiAgICAgICAgaWYgKCFpc1ZOb2RlKGNoaWxkKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IENvbW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gRnJhZ21lbnQgJiZcclxuICAgICAgICAgICAgIWVuc3VyZVZhbGlkVk5vZGUoY2hpbGQuY2hpbGRyZW4pKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KVxyXG4gICAgICAgID8gdm5vZGVzXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBGb3IgcHJlZml4aW5nIGtleXMgaW4gdi1vbj1cIm9ialwiIHdpdGggXCJvblwiXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0hhbmRsZXJzKG9iaikge1xyXG4gICAgY29uc3QgcmV0ID0ge307XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc09iamVjdChvYmopKSB7XHJcbiAgICAgICAgd2FybiQxKGB2LW9uIHdpdGggbm8gYXJndW1lbnQgZXhwZWN0cyBhbiBvYmplY3QgdmFsdWUuYCk7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIHJldFt0b0hhbmRsZXJLZXkoa2V5KV0gPSBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuZnVuY3Rpb24gdG9PYmplY3QoYXJyKSB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFycltpXSkge1xyXG4gICAgICAgICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gbGVnYWN5QmluZE9iamVjdFByb3BzKGRhdGEsIF90YWcsIHZhbHVlLCBfYXNQcm9wLCBpc1N5bmMpIHtcclxuICAgIGlmICh2YWx1ZSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJvcChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5jbGFzcyA9IG5vcm1hbGl6ZUNsYXNzKFtkYXRhLmNsYXNzLCB2YWx1ZS5jbGFzc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5zdHlsZSA9IG5vcm1hbGl6ZUNsYXNzKFtkYXRhLnN0eWxlLCB2YWx1ZS5zdHlsZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBhdHRycykgJiYgIShoeXBoZW5hdGVkS2V5IGluIGF0dHJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbltgdXBkYXRlOiR7a2V5fWBdID0gZnVuY3Rpb24gKCRldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5mdW5jdGlvbiBsZWdhY3lCaW5kT2JqZWN0TGlzdGVuZXJzKHByb3BzLCBsaXN0ZW5lcnMpIHtcclxuICAgIHJldHVybiBtZXJnZVByb3BzKHByb3BzLCB0b0hhbmRsZXJzKGxpc3RlbmVycykpO1xyXG59XHJcbmZ1bmN0aW9uIGxlZ2FjeVJlbmRlclNsb3QoaW5zdGFuY2UsIG5hbWUsIGZhbGxiYWNrLCBwcm9wcywgYmluZE9iamVjdCkge1xyXG4gICAgaWYgKGJpbmRPYmplY3QpIHtcclxuICAgICAgICBwcm9wcyA9IG1lcmdlUHJvcHMocHJvcHMsIGJpbmRPYmplY3QpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbmRlclNsb3QoaW5zdGFuY2Uuc2xvdHMsIG5hbWUsIHByb3BzLCBmYWxsYmFjayAmJiAoKCkgPT4gZmFsbGJhY2spKTtcclxufVxyXG5mdW5jdGlvbiBsZWdhY3lyZXNvbHZlU2NvcGVkU2xvdHMoZm5zLCByYXcsIFxyXG4vLyB0aGUgZm9sbG93aW5nIGFyZSBhZGRlZCBpbiAyLjZcclxuaGFzRHluYW1pY0tleXMpIHtcclxuICAgIC8vIHYyIGRlZmF1bHQgc2xvdCBkb2Vzbid0IGhhdmUgbmFtZVxyXG4gICAgcmV0dXJuIGNyZWF0ZVNsb3RzKHJhdyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9LCBtYXBLZXlUb05hbWUoZm5zKSk7XHJcbn1cclxuZnVuY3Rpb24gbWFwS2V5VG9OYW1lKHNsb3RzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZm4gPSBzbG90c1tpXTtcclxuICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoZm4pKSB7XHJcbiAgICAgICAgICAgICAgICBtYXBLZXlUb05hbWUoZm4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm4ubmFtZSA9IGZuLmtleSB8fCAnZGVmYXVsdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2xvdHM7XHJcbn1cclxuY29uc3Qgc3RhdGljQ2FjaGVNYXAgPSAvKiNfX1BVUkVfXyovIG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIGxlZ2FjeVJlbmRlclN0YXRpYyhpbnN0YW5jZSwgaW5kZXgpIHtcclxuICAgIGxldCBjYWNoZSA9IHN0YXRpY0NhY2hlTWFwLmdldChpbnN0YW5jZSk7XHJcbiAgICBpZiAoIWNhY2hlKSB7XHJcbiAgICAgICAgc3RhdGljQ2FjaGVNYXAuc2V0KGluc3RhbmNlLCAoY2FjaGUgPSBbXSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNhY2hlW2luZGV4XSkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZVtpbmRleF07XHJcbiAgICB9XHJcbiAgICBjb25zdCBmbiA9IGluc3RhbmNlLnR5cGUuc3RhdGljUmVuZGVyRm5zW2luZGV4XTtcclxuICAgIGNvbnN0IGN0eCA9IGluc3RhbmNlLnByb3h5O1xyXG4gICAgcmV0dXJuIChjYWNoZVtpbmRleF0gPSBmbi5jYWxsKGN0eCwgbnVsbCwgY3R4KSk7XHJcbn1cclxuZnVuY3Rpb24gbGVnYWN5Q2hlY2tLZXlDb2RlcyhpbnN0YW5jZSwgZXZlbnRLZXlDb2RlLCBrZXksIGJ1aWx0SW5LZXlDb2RlLCBldmVudEtleU5hbWUsIGJ1aWx0SW5LZXlOYW1lKSB7XHJcbiAgICBjb25zdCBjb25maWcgPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcclxuICAgIGNvbnN0IGNvbmZpZ0tleUNvZGVzID0gY29uZmlnLmtleUNvZGVzIHx8IHt9O1xyXG4gICAgY29uc3QgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZ0tleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XHJcbiAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWdLZXlDb2Rlc1trZXldKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xyXG4gICAgICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2goZXhwZWN0LCBhY3R1YWwpIHtcclxuICAgIGlmIChpc0FycmF5KGV4cGVjdCkpIHtcclxuICAgICAgICByZXR1cm4gIWV4cGVjdC5pbmNsdWRlcyhhY3R1YWwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdCAhPT0gYWN0dWFsO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGxlZ2FjeU1hcmtPbmNlKHRyZWUpIHtcclxuICAgIHJldHVybiB0cmVlO1xyXG59XHJcbmZ1bmN0aW9uIGxlZ2FjeUJpbmREeW5hbWljS2V5cyhwcm9wcywgdmFsdWVzKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHZhbHVlc1tpXTtcclxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XHJcbiAgICAgICAgICAgIHByb3BzW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG5mdW5jdGlvbiBsZWdhY3lQcmVwZW5kTW9kaWZpZXIodmFsdWUsIHN5bWJvbCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBzeW1ib2wgKyB2YWx1ZSA6IHZhbHVlO1xyXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wYXRJbnN0YW5jZVByb3BlcnRpZXMobWFwKSB7XHJcbiAgICBjb25zdCBzZXQgPSAodGFyZ2V0LCBrZXksIHZhbCkgPT4ge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGRlbCA9ICh0YXJnZXQsIGtleSkgPT4ge1xyXG4gICAgICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcclxuICAgIH07XHJcbiAgICBleHRlbmQobWFwLCB7XHJcbiAgICAgICAgJHNldDogaSA9PiB7XHJcbiAgICAgICAgICAgIGFzc2VydENvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9TRVRcIiAvKiBJTlNUQU5DRV9TRVQgKi8sIGkpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJGRlbGV0ZTogaSA9PiB7XHJcbiAgICAgICAgICAgIGFzc2VydENvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9ERUxFVEVcIiAvKiBJTlNUQU5DRV9ERUxFVEUgKi8sIGkpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGVsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJG1vdW50OiBpID0+IHtcclxuICAgICAgICAgICAgYXNzZXJ0Q29tcGF0RW5hYmxlZChcIkdMT0JBTF9NT1VOVFwiIC8qIEdMT0JBTF9NT1VOVCAqLywgbnVsbCAvKiB0aGlzIHdhcm5pbmcgaXMgZ2xvYmFsICovKTtcclxuICAgICAgICAgICAgLy8gcm9vdCBtb3VudCBvdmVycmlkZSBmcm9tIC4vZ2xvYmFsLnRzIGluIGluc3RhbGxDb21wYXRNb3VudFxyXG4gICAgICAgICAgICByZXR1cm4gaS5jdHguX2NvbXBhdF9tb3VudCB8fCBOT09QO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJGRlc3Ryb3k6IGkgPT4ge1xyXG4gICAgICAgICAgICBhc3NlcnRDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfREVTVFJPWVwiIC8qIElOU1RBTkNFX0RFU1RST1kgKi8sIGkpO1xyXG4gICAgICAgICAgICAvLyByb290IGRlc3Ryb3kgb3ZlcnJpZGUgZnJvbSAuL2dsb2JhbC50cyBpbiBpbnN0YWxsQ29tcGF0TW91bnRcclxuICAgICAgICAgICAgcmV0dXJuIGkuY3R4Ll9jb21wYXRfZGVzdHJveSB8fCBOT09QO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gb3ZlcnJpZGVzIGV4aXN0aW5nIGFjY2Vzc29yXHJcbiAgICAgICAgJHNsb3RzOiBpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIlJFTkRFUl9GVU5DVElPTlwiIC8qIFJFTkRFUl9GVU5DVElPTiAqLywgaSkgJiZcclxuICAgICAgICAgICAgICAgIGkucmVuZGVyICYmXHJcbiAgICAgICAgICAgICAgICBpLnJlbmRlci5fY29tcGF0V3JhcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm94eShpLnNsb3RzLCBsZWdhY3lTbG90UHJveHlIYW5kbGVycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLnNsb3RzKSA6IGkuc2xvdHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAkc2NvcGVkU2xvdHM6IGkgPT4ge1xyXG4gICAgICAgICAgICBhc3NlcnRDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfU0NPUEVEX1NMT1RTXCIgLyogSU5TVEFOQ0VfU0NPUEVEX1NMT1RTICovLCBpKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzID0ge307XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGkuc2xvdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gaS5zbG90c1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmbi5fbnMgLyogbm9uLXNjb3BlZCBzbG90ICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBmbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJG9uOiBpID0+IG9uLmJpbmQobnVsbCwgaSksXHJcbiAgICAgICAgJG9uY2U6IGkgPT4gb25jZS5iaW5kKG51bGwsIGkpLFxyXG4gICAgICAgICRvZmY6IGkgPT4gb2ZmLmJpbmQobnVsbCwgaSksXHJcbiAgICAgICAgJGNoaWxkcmVuOiBnZXRDb21wYXRDaGlsZHJlbixcclxuICAgICAgICAkbGlzdGVuZXJzOiBnZXRDb21wYXRMaXN0ZW5lcnNcclxuICAgIH0pO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNDb21wYXRFbmFibGVkKFwiUFJJVkFURV9BUElTXCIgLyogUFJJVkFURV9BUElTICovLCBudWxsKSkge1xyXG4gICAgICAgIGV4dGVuZChtYXAsIHtcclxuICAgICAgICAgICAgLy8gbmVlZGVkIGJ5IG1hbnkgbGlicyAvIHJlbmRlciBmbnNcclxuICAgICAgICAgICAgJHZub2RlOiBpID0+IGkudm5vZGUsXHJcbiAgICAgICAgICAgIC8vIGluamVjdCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW50byAkb3B0aW9ucyBmb3IgY29tcGF0XHJcbiAgICAgICAgICAgIC8vIGUuZy4gdnVleCBuZWVkcyB0aGlzLiRvcHRpb25zLnBhcmVudFxyXG4gICAgICAgICAgICAkb3B0aW9uczogaSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBleHRlbmQoe30sIHJlc29sdmVNZXJnZWRPcHRpb25zKGkpKTtcclxuICAgICAgICAgICAgICAgIHJlcy5wYXJlbnQgPSBpLnByb3h5LiRwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICByZXMucHJvcHNEYXRhID0gaS52bm9kZS5wcm9wcztcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIHNvbWUgcHJpdmF0ZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGxpa2VseSBhY2Nlc3NlZC4uLlxyXG4gICAgICAgICAgICBfc2VsZjogaSA9PiBpLnByb3h5LFxyXG4gICAgICAgICAgICBfdWlkOiBpID0+IGkudWlkLFxyXG4gICAgICAgICAgICBfZGF0YTogaSA9PiBpLmRhdGEsXHJcbiAgICAgICAgICAgIF9pc01vdW50ZWQ6IGkgPT4gaS5pc01vdW50ZWQsXHJcbiAgICAgICAgICAgIF9pc0Rlc3Ryb3llZDogaSA9PiBpLmlzVW5tb3VudGVkLFxyXG4gICAgICAgICAgICAvLyB2MiByZW5kZXIgaGVscGVyc1xyXG4gICAgICAgICAgICAkY3JlYXRlRWxlbWVudDogKCkgPT4gY29tcGF0SCxcclxuICAgICAgICAgICAgX2M6ICgpID0+IGNvbXBhdEgsXHJcbiAgICAgICAgICAgIF9vOiAoKSA9PiBsZWdhY3lNYXJrT25jZSxcclxuICAgICAgICAgICAgX246ICgpID0+IHRvTnVtYmVyLFxyXG4gICAgICAgICAgICBfczogKCkgPT4gdG9EaXNwbGF5U3RyaW5nLFxyXG4gICAgICAgICAgICBfbDogKCkgPT4gcmVuZGVyTGlzdCxcclxuICAgICAgICAgICAgX3Q6IGkgPT4gbGVnYWN5UmVuZGVyU2xvdC5iaW5kKG51bGwsIGkpLFxyXG4gICAgICAgICAgICBfcTogKCkgPT4gbG9vc2VFcXVhbCxcclxuICAgICAgICAgICAgX2k6ICgpID0+IGxvb3NlSW5kZXhPZixcclxuICAgICAgICAgICAgX206IGkgPT4gbGVnYWN5UmVuZGVyU3RhdGljLmJpbmQobnVsbCwgaSksXHJcbiAgICAgICAgICAgIF9mOiAoKSA9PiByZXNvbHZlRmlsdGVyLFxyXG4gICAgICAgICAgICBfazogaSA9PiBsZWdhY3lDaGVja0tleUNvZGVzLmJpbmQobnVsbCwgaSksXHJcbiAgICAgICAgICAgIF9iOiAoKSA9PiBsZWdhY3lCaW5kT2JqZWN0UHJvcHMsXHJcbiAgICAgICAgICAgIF92OiAoKSA9PiBjcmVhdGVUZXh0Vk5vZGUsXHJcbiAgICAgICAgICAgIF9lOiAoKSA9PiBjcmVhdGVDb21tZW50Vk5vZGUsXHJcbiAgICAgICAgICAgIF91OiAoKSA9PiBsZWdhY3lyZXNvbHZlU2NvcGVkU2xvdHMsXHJcbiAgICAgICAgICAgIF9nOiAoKSA9PiBsZWdhY3lCaW5kT2JqZWN0TGlzdGVuZXJzLFxyXG4gICAgICAgICAgICBfZDogKCkgPT4gbGVnYWN5QmluZER5bmFtaWNLZXlzLFxyXG4gICAgICAgICAgICBfcDogKCkgPT4gbGVnYWN5UHJlcGVuZE1vZGlmaWVyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqICMyNDM3IEluIFZ1ZSAzLCBmdW5jdGlvbmFsIGNvbXBvbmVudHMgZG8gbm90IGhhdmUgYSBwdWJsaWMgaW5zdGFuY2UgcHJveHkgYnV0XHJcbiAqIHRoZXkgZXhpc3QgaW4gdGhlIGludGVybmFsIHBhcmVudCBjaGFpbi4gRm9yIGNvZGUgdGhhdCByZWxpZXMgb24gdHJhdmVyc2luZ1xyXG4gKiBwdWJsaWMgJHBhcmVudCBjaGFpbnMsIHNraXAgZnVuY3Rpb25hbCBvbmVzIGFuZCBnbyB0byB0aGUgcGFyZW50IGluc3RlYWQuXHJcbiAqL1xyXG5jb25zdCBnZXRQdWJsaWNJbnN0YW5jZSA9IChpKSA9PiB7XHJcbiAgICBpZiAoIWkpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bENvbXBvbmVudChpKSlcclxuICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkoaSkgfHwgaS5wcm94eTtcclxuICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShpLnBhcmVudCk7XHJcbn07XHJcbmNvbnN0IHB1YmxpY1Byb3BlcnRpZXNNYXAgPSBcclxuLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcclxuLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxyXG4vKiNfX1BVUkVfXyovIGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB7XHJcbiAgICAkOiBpID0+IGksXHJcbiAgICAkZWw6IGkgPT4gaS52bm9kZS5lbCxcclxuICAgICRkYXRhOiBpID0+IGkuZGF0YSxcclxuICAgICRwcm9wczogaSA9PiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGkucHJvcHMpIDogaS5wcm9wcyksXHJcbiAgICAkYXR0cnM6IGkgPT4gKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IHNoYWxsb3dSZWFkb25seShpLmF0dHJzKSA6IGkuYXR0cnMpLFxyXG4gICAgJHNsb3RzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5zbG90cykgOiBpLnNsb3RzKSxcclxuICAgICRyZWZzOiBpID0+ICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyBzaGFsbG93UmVhZG9ubHkoaS5yZWZzKSA6IGkucmVmcyksXHJcbiAgICAkcGFyZW50OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucGFyZW50KSxcclxuICAgICRyb290OiBpID0+IGdldFB1YmxpY0luc3RhbmNlKGkucm9vdCksXHJcbiAgICAkZW1pdDogaSA9PiBpLmVtaXQsXHJcbiAgICAkb3B0aW9uczogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IHJlc29sdmVNZXJnZWRPcHRpb25zKGkpIDogaS50eXBlKSxcclxuICAgICRmb3JjZVVwZGF0ZTogaSA9PiBpLmYgfHwgKGkuZiA9ICgpID0+IHF1ZXVlSm9iKGkudXBkYXRlKSksXHJcbiAgICAkbmV4dFRpY2s6IGkgPT4gaS5uIHx8IChpLm4gPSBuZXh0VGljay5iaW5kKGkucHJveHkpKSxcclxuICAgICR3YXRjaDogaSA9PiAoX19WVUVfT1BUSU9OU19BUElfXyA/IGluc3RhbmNlV2F0Y2guYmluZChpKSA6IE5PT1ApXHJcbn0pO1xyXG57XHJcbiAgICBpbnN0YWxsQ29tcGF0SW5zdGFuY2VQcm9wZXJ0aWVzKHB1YmxpY1Byb3BlcnRpZXNNYXApO1xyXG59XHJcbmNvbnN0IGlzUmVzZXJ2ZWRQcmVmaXggPSAoa2V5KSA9PiBrZXkgPT09ICdfJyB8fCBrZXkgPT09ICckJztcclxuY29uc3QgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzID0ge1xyXG4gICAgZ2V0KHsgXzogaW5zdGFuY2UgfSwga2V5KSB7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUsIGRhdGEsIHByb3BzLCBhY2Nlc3NDYWNoZSwgdHlwZSwgYXBwQ29udGV4dCB9ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgLy8gZm9yIGludGVybmFsIGZvcm1hdHRlcnMgdG8ga25vdyB0aGF0IHRoaXMgaXMgYSBWdWUgaW5zdGFuY2VcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGtleSA9PT0gJ19faXNWdWUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwcmlvcml0aXplIDxzY3JpcHQgc2V0dXA+IGJpbmRpbmdzIGR1cmluZyBkZXYuXHJcbiAgICAgICAgLy8gdGhpcyBhbGxvd3MgZXZlbiBwcm9wZXJ0aWVzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQgdG8gYmUgdXNlZCAtIHNvIHRoYXRcclxuICAgICAgICAvLyBpdCBhbGlnbnMgd2l0aCB0aGUgcHJvZHVjdGlvbiBiZWhhdmlvciB3aGVyZSB0aGUgcmVuZGVyIGZuIGlzIGlubGluZWQgYW5kXHJcbiAgICAgICAgLy8gaW5kZWVkIGhhcyBhY2Nlc3MgdG8gYWxsIGRlY2xhcmVkIHZhcmlhYmxlcy5cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJlxyXG4gICAgICAgICAgICBzZXR1cFN0YXRlLl9faXNTY3JpcHRTZXR1cCAmJlxyXG4gICAgICAgICAgICBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkYXRhIC8gcHJvcHMgLyBjdHhcclxuICAgICAgICAvLyBUaGlzIGdldHRlciBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgcHJvcGVydHkgYWNjZXNzIG9uIHRoZSByZW5kZXIgY29udGV4dFxyXG4gICAgICAgIC8vIGR1cmluZyByZW5kZXIgYW5kIGlzIGEgbWFqb3IgaG90c3BvdC4gVGhlIG1vc3QgZXhwZW5zaXZlIHBhcnQgb2YgdGhpc1xyXG4gICAgICAgIC8vIGlzIHRoZSBtdWx0aXBsZSBoYXNPd24oKSBjYWxscy4gSXQncyBtdWNoIGZhc3RlciB0byBkbyBhIHNpbXBsZSBwcm9wZXJ0eVxyXG4gICAgICAgIC8vIGFjY2VzcyBvbiBhIHBsYWluIG9iamVjdCwgc28gd2UgdXNlIGFuIGFjY2Vzc0NhY2hlIG9iamVjdCAod2l0aCBudWxsXHJcbiAgICAgICAgLy8gcHJvdG90eXBlKSB0byBtZW1vaXplIHdoYXQgYWNjZXNzIHR5cGUgYSBrZXkgY29ycmVzcG9uZHMgdG8uXHJcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wcztcclxuICAgICAgICBpZiAoa2V5WzBdICE9PSAnJCcpIHtcclxuICAgICAgICAgICAgY29uc3QgbiA9IGFjY2Vzc0NhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBTRVRVUCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwU3RhdGVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogREFUQSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQgLyogQ09OVEVYVCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBQUk9QUyAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdDoganVzdCBmYWxsdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDEgLyogU0VUVVAgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dXBTdGF0ZVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDIgLyogREFUQSAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXHJcbiAgICAgICAgICAgIC8vIHByb3BzXHJcbiAgICAgICAgICAgIChub3JtYWxpemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pICYmXHJcbiAgICAgICAgICAgICAgICBoYXNPd24obm9ybWFsaXplZFByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBhY2Nlc3NDYWNoZVtrZXldID0gMyAvKiBQUk9QUyAqLztcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGN0eCAhPT0gRU1QVFlfT0JKICYmIGhhc093bihjdHgsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSA0IC8qIENPTlRFWFQgKi87XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgc2hvdWxkQ2FjaGVBY2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0NhY2hlW2tleV0gPSAwIC8qIE9USEVSICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1YmxpY0dldHRlciA9IHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XTtcclxuICAgICAgICBsZXQgY3NzTW9kdWxlLCBnbG9iYWxQcm9wZXJ0aWVzO1xyXG4gICAgICAgIC8vIHB1YmxpYyAkeHh4IHByb3BlcnRpZXNcclxuICAgICAgICBpZiAocHVibGljR2V0dGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICckYXR0cnMnKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbWFya0F0dHJzQWNjZXNzZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHVibGljR2V0dGVyKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgLy8gY3NzIG1vZHVsZSAoaW5qZWN0ZWQgYnkgdnVlLWxvYWRlcilcclxuICAgICAgICAoY3NzTW9kdWxlID0gdHlwZS5fX2Nzc01vZHVsZXMpICYmXHJcbiAgICAgICAgICAgIChjc3NNb2R1bGUgPSBjc3NNb2R1bGVba2V5XSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNzc01vZHVsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3R4ICE9PSBFTVBUWV9PQkogJiYgaGFzT3duKGN0eCwga2V5KSkge1xyXG4gICAgICAgICAgICAvLyB1c2VyIG1heSBzZXQgY3VzdG9tIHByb3BlcnRpZXMgdG8gYHRoaXNgIHRoYXQgc3RhcnQgd2l0aCBgJGBcclxuICAgICAgICAgICAgYWNjZXNzQ2FjaGVba2V5XSA9IDQgLyogQ09OVEVYVCAqLztcclxuICAgICAgICAgICAgcmV0dXJuIGN0eFtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xyXG4gICAgICAgICgoZ2xvYmFsUHJvcGVydGllcyA9IGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMpLFxyXG4gICAgICAgICAgICBoYXNPd24oZ2xvYmFsUHJvcGVydGllcywga2V5KSkpIHtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsUHJvcGVydGllcywga2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChkZXNjLmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGluc3RhbmNlLnByb3h5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdsb2JhbFByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih2YWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih2YWwuYmluZChpbnN0YW5jZS5wcm94eSksIHZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSAmJlxyXG4gICAgICAgICAgICAoIWlzU3RyaW5nKGtleSkgfHxcclxuICAgICAgICAgICAgICAgIC8vICMxMDkxIGF2b2lkIGludGVybmFsIGlzUmVmL2lzVk5vZGUgY2hlY2tzIG9uIGNvbXBvbmVudCBpbnN0YW5jZSBsZWFkaW5nXHJcbiAgICAgICAgICAgICAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcclxuICAgICAgICAgICAgICAgIGtleS5pbmRleE9mKCdfX3YnKSAhPT0gMCkpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBpc1Jlc2VydmVkUHJlZml4KGtleVswXSkgJiYgaGFzT3duKGRhdGEsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBtdXN0IGJlIGFjY2Vzc2VkIHZpYSAkZGF0YSBiZWNhdXNlIGl0IHN0YXJ0cyB3aXRoIGEgcmVzZXJ2ZWQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaW5zdGFuY2UgPT09IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBQcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KGtleSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBidXQgaXMgbm90IGRlZmluZWQgb24gaW5zdGFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2V0KHsgXzogaW5zdGFuY2UgfSwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgc2V0dXBTdGF0ZSwgY3R4IH0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpZiAoc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihzZXR1cFN0YXRlLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHNldHVwU3RhdGVba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0YSAhPT0gRU1QVFlfT0JKICYmIGhhc093bihkYXRhLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGluc3RhbmNlLnByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBBdHRlbXB0aW5nIHRvIG11dGF0ZSBwcm9wIFwiJHtrZXl9XCIuIFByb3BzIGFyZSByZWFkb25seS5gLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnICYmIGtleS5zbGljZSgxKSBpbiBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgQXR0ZW1wdGluZyB0byBtdXRhdGUgcHVibGljIHByb3BlcnR5IFwiJHtrZXl9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggJCBhcmUgcmVzZXJ2ZWQgYW5kIHJlYWRvbmx5LmAsIGluc3RhbmNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3R4W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBoYXMoeyBfOiB7IGRhdGEsIHNldHVwU3RhdGUsIGFjY2Vzc0NhY2hlLCBjdHgsIGFwcENvbnRleHQsIHByb3BzT3B0aW9ucyB9IH0sIGtleSkge1xyXG4gICAgICAgIGxldCBub3JtYWxpemVkUHJvcHM7XHJcbiAgICAgICAgcmV0dXJuICghIWFjY2Vzc0NhY2hlW2tleV0gfHxcclxuICAgICAgICAgICAgKGRhdGEgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oZGF0YSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKHNldHVwU3RhdGUgIT09IEVNUFRZX09CSiAmJiBoYXNPd24oc2V0dXBTdGF0ZSwga2V5KSkgfHxcclxuICAgICAgICAgICAgKChub3JtYWxpemVkUHJvcHMgPSBwcm9wc09wdGlvbnNbMF0pICYmIGhhc093bihub3JtYWxpemVkUHJvcHMsIGtleSkpIHx8XHJcbiAgICAgICAgICAgIGhhc093bihjdHgsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKHB1YmxpY1Byb3BlcnRpZXNNYXAsIGtleSkgfHxcclxuICAgICAgICAgICAgaGFzT3duKGFwcENvbnRleHQuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSkpO1xyXG4gICAgfSxcclxuICAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IuZ2V0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gaW52YWxpZGF0ZSBrZXkgY2FjaGUgb2YgYSBnZXR0ZXIgYmFzZWQgcHJvcGVydHkgIzU0MTdcclxuICAgICAgICAgICAgdGFyZ2V0Ll8uYWNjZXNzQ2FjaGVba2V5XSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc093bihkZXNjcmlwdG9yLCAndmFsdWUnKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldCh0YXJnZXQsIGtleSwgZGVzY3JpcHRvci52YWx1ZSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcclxuICAgIH1cclxufTtcclxuaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhZmFsc2UpIHtcclxuICAgIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5vd25LZXlzID0gKHRhcmdldCkgPT4ge1xyXG4gICAgICAgIHdhcm4kMShgQXZvaWQgYXBwIGxvZ2ljIHRoYXQgcmVsaWVzIG9uIGVudW1lcmF0aW5nIGtleXMgb24gYSBjb21wb25lbnQgaW5zdGFuY2UuIGAgK1xyXG4gICAgICAgICAgICBgVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuYCk7XHJcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xyXG4gICAgfTtcclxufVxyXG5jb25zdCBSdW50aW1lQ29tcGlsZWRQdWJsaWNJbnN0YW5jZVByb3h5SGFuZGxlcnMgPSAvKiNfX1BVUkVfXyovIGV4dGVuZCh7fSwgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLCB7XHJcbiAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAvLyBmYXN0IHBhdGggZm9yIHVuc2NvcGFibGVzIHdoZW4gdXNpbmcgYHdpdGhgIGJsb2NrXHJcbiAgICAgICAgaWYgKGtleSA9PT0gU3ltYm9sLnVuc2NvcGFibGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycy5nZXQodGFyZ2V0LCBrZXksIHRhcmdldCk7XHJcbiAgICB9LFxyXG4gICAgaGFzKF8sIGtleSkge1xyXG4gICAgICAgIGNvbnN0IGhhcyA9IGtleVswXSAhPT0gJ18nICYmICFpc0dsb2JhbGx5V2hpdGVsaXN0ZWQoa2V5KTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXMgJiYgUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzLmhhcyhfLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXyB3aGljaCBpcyBhIHJlc2VydmVkIHByZWZpeCBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhcztcclxuICAgIH1cclxufSk7XHJcbi8vIGRldiBvbmx5XHJcbi8vIEluIGRldiBtb2RlLCB0aGUgcHJveHkgdGFyZ2V0IGV4cG9zZXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyBzZWVuIG9uIGB0aGlzYFxyXG4vLyBmb3IgZWFzaWVyIGNvbnNvbGUgaW5zcGVjdGlvbi4gSW4gcHJvZCBtb2RlIGl0IHdpbGwgYmUgYW4gZW1wdHkgb2JqZWN0IHNvXHJcbi8vIHRoZXNlIHByb3BlcnRpZXMgZGVmaW5pdGlvbnMgY2FuIGJlIHNraXBwZWQuXHJcbmZ1bmN0aW9uIGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xyXG4gICAgLy8gZXhwb3NlIGludGVybmFsIGluc3RhbmNlIGZvciBwcm94eSBoYW5kbGVyc1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgYF9gLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGdldDogKCkgPT4gaW5zdGFuY2VcclxuICAgIH0pO1xyXG4gICAgLy8gZXhwb3NlIHB1YmxpYyBwcm9wZXJ0aWVzXHJcbiAgICBPYmplY3Qua2V5cyhwdWJsaWNQcm9wZXJ0aWVzTWFwKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljUHJvcGVydGllc01hcFtrZXldKGluc3RhbmNlKSxcclxuICAgICAgICAgICAgLy8gaW50ZXJjZXB0ZWQgYnkgdGhlIHByb3h5IHNvIG5vIG5lZWQgZm9yIGltcGxlbWVudGF0aW9uLFxyXG4gICAgICAgICAgICAvLyBidXQgbmVlZGVkIHRvIHByZXZlbnQgc2V0IGVycm9yc1xyXG4gICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG4vLyBkZXYgb25seVxyXG5mdW5jdGlvbiBleHBvc2VQcm9wc09uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHByb3BzT3B0aW9uczogW3Byb3BzT3B0aW9uc10gfSA9IGluc3RhbmNlO1xyXG4gICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGluc3RhbmNlLnByb3BzW2tleV0sXHJcbiAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgeyBjdHgsIHNldHVwU3RhdGUgfSA9IGluc3RhbmNlO1xyXG4gICAgT2JqZWN0LmtleXModG9SYXcoc2V0dXBTdGF0ZSkpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBpZiAoIXNldHVwU3RhdGUuX19pc1NjcmlwdFNldHVwKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgc2V0dXAoKSByZXR1cm4gcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShrZXkpfSBzaG91bGQgbm90IHN0YXJ0IHdpdGggXCIkXCIgb3IgXCJfXCIgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBrZXksIHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHNldHVwU3RhdGVba2V5XSxcclxuICAgICAgICAgICAgICAgIHNldDogTk9PUFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBkZWVwTWVyZ2VEYXRhKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgY29uc3QgdG9WYWwgPSB0b1trZXldO1xyXG4gICAgICAgIGNvbnN0IGZyb21WYWwgPSBmcm9tW2tleV07XHJcbiAgICAgICAgaWYgKGtleSBpbiB0byAmJiBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuRGVwcmVjYXRpb24oXCJPUFRJT05TX0RBVEFfTUVSR0VcIiAvKiBPUFRJT05TX0RBVEFfTUVSR0UgKi8sIG51bGwsIGtleSk7XHJcbiAgICAgICAgICAgIGRlZXBNZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21WYWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSB7XHJcbiAgICBjb25zdCBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gKHR5cGUsIGtleSkgPT4ge1xyXG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgJHt0eXBlfSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiAke2NhY2hlW2tleV19LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5sZXQgc2hvdWxkQ2FjaGVBY2Nlc3MgPSB0cnVlO1xyXG5mdW5jdGlvbiBhcHBseU9wdGlvbnMoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICBjb25zdCBwdWJsaWNUaGlzID0gaW5zdGFuY2UucHJveHk7XHJcbiAgICBjb25zdCBjdHggPSBpbnN0YW5jZS5jdHg7XHJcbiAgICAvLyBkbyBub3QgY2FjaGUgcHJvcGVydHkgYWNjZXNzIG9uIHB1YmxpYyBwcm94eSBkdXJpbmcgc3RhdGUgaW5pdGlhbGl6YXRpb25cclxuICAgIHNob3VsZENhY2hlQWNjZXNzID0gZmFsc2U7XHJcbiAgICAvLyBjYWxsIGJlZm9yZUNyZWF0ZSBmaXJzdCBiZWZvcmUgYWNjZXNzaW5nIG90aGVyIG9wdGlvbnMgc2luY2VcclxuICAgIC8vIHRoZSBob29rIG1heSBtdXRhdGUgcmVzb2x2ZWQgb3B0aW9ucyAoIzI3OTEpXHJcbiAgICBpZiAob3B0aW9ucy5iZWZvcmVDcmVhdGUpIHtcclxuICAgICAgICBjYWxsSG9vayhvcHRpb25zLmJlZm9yZUNyZWF0ZSwgaW5zdGFuY2UsIFwiYmNcIiAvKiBCRUZPUkVfQ1JFQVRFICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgXHJcbiAgICAvLyBzdGF0ZVxyXG4gICAgZGF0YTogZGF0YU9wdGlvbnMsIGNvbXB1dGVkOiBjb21wdXRlZE9wdGlvbnMsIG1ldGhvZHMsIHdhdGNoOiB3YXRjaE9wdGlvbnMsIHByb3ZpZGU6IHByb3ZpZGVPcHRpb25zLCBpbmplY3Q6IGluamVjdE9wdGlvbnMsIFxyXG4gICAgLy8gbGlmZWN5Y2xlXHJcbiAgICBjcmVhdGVkLCBiZWZvcmVNb3VudCwgbW91bnRlZCwgYmVmb3JlVXBkYXRlLCB1cGRhdGVkLCBhY3RpdmF0ZWQsIGRlYWN0aXZhdGVkLCBiZWZvcmVEZXN0cm95LCBiZWZvcmVVbm1vdW50LCBkZXN0cm95ZWQsIHVubW91bnRlZCwgcmVuZGVyLCByZW5kZXJUcmFja2VkLCByZW5kZXJUcmlnZ2VyZWQsIGVycm9yQ2FwdHVyZWQsIHNlcnZlclByZWZldGNoLCBcclxuICAgIC8vIHB1YmxpYyBBUElcclxuICAgIGV4cG9zZSwgaW5oZXJpdEF0dHJzLCBcclxuICAgIC8vIGFzc2V0c1xyXG4gICAgY29tcG9uZW50cywgZGlyZWN0aXZlcywgZmlsdGVycyB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGNyZWF0ZUR1cGxpY2F0ZUNoZWNrZXIoKSA6IG51bGw7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgY29uc3QgW3Byb3BzT3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICAgICAgaWYgKHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wc09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIlByb3BzXCIgLyogUFJPUFMgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIGluaXRpYWxpemF0aW9uIG9yZGVyICh0byBiZSBjb25zaXN0ZW50IHdpdGggVnVlIDIpOlxyXG4gICAgLy8gLSBwcm9wcyAoYWxyZWFkeSBkb25lIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbilcclxuICAgIC8vIC0gaW5qZWN0XHJcbiAgICAvLyAtIG1ldGhvZHNcclxuICAgIC8vIC0gZGF0YSAoZGVmZXJyZWQgc2luY2UgaXQgcmVsaWVzIG9uIGB0aGlzYCBhY2Nlc3MpXHJcbiAgICAvLyAtIGNvbXB1dGVkXHJcbiAgICAvLyAtIHdhdGNoIChkZWZlcnJlZCBzaW5jZSBpdCByZWxpZXMgb24gYHRoaXNgIGFjY2VzcylcclxuICAgIGlmIChpbmplY3RPcHRpb25zKSB7XHJcbiAgICAgICAgcmVzb2x2ZUluamVjdGlvbnMoaW5qZWN0T3B0aW9ucywgY3R4LCBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMsIGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLnVud3JhcEluamVjdGVkUmVmKTtcclxuICAgIH1cclxuICAgIGlmIChtZXRob2RzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRob2RIYW5kbGVyID0gbWV0aG9kc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihtZXRob2RIYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gZGV2IG1vZGUsIHdlIHVzZSB0aGUgYGNyZWF0ZVJlbmRlckNvbnRleHRgIGZ1bmN0aW9uIHRvIGRlZmluZVxyXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyB0byB0aGUgcHJveHkgdGFyZ2V0LCBhbmQgdGhvc2UgYXJlIHJlYWQtb25seSBidXRcclxuICAgICAgICAgICAgICAgIC8vIHJlY29uZmlndXJhYmxlLCBzbyBpdCBuZWVkcyB0byBiZSByZWRlZmluZWQgaGVyZVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWV0aG9kSGFuZGxlci5iaW5kKHB1YmxpY1RoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHhba2V5XSA9IG1ldGhvZEhhbmRsZXIuYmluZChwdWJsaWNUaGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZVByb3BlcnRpZXMoXCJNZXRob2RzXCIgLyogTUVUSE9EUyAqLywga2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIHR5cGUgXCIke3R5cGVvZiBtZXRob2RIYW5kbGVyfVwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgYERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZGF0YU9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc0Z1bmN0aW9uKGRhdGFPcHRpb25zKSkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYFRoZSBkYXRhIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uIGAgK1xyXG4gICAgICAgICAgICAgICAgYFBsYWluIG9iamVjdCB1c2FnZSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhID0gZGF0YU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzLCBwdWJsaWNUaGlzKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGlzUHJvbWlzZShkYXRhKSkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYGRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBgICtcclxuICAgICAgICAgICAgICAgIGBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGAgK1xyXG4gICAgICAgICAgICAgICAgYGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuJDEoYGRhdGEoKSBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmRhdGEgPSByZWFjdGl2ZShkYXRhKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkRhdGFcIiAvKiBEQVRBICovLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9zZSBkYXRhIG9uIGN0eCBkdXJpbmcgZGV2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJlZml4KGtleVswXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBkYXRhW2tleV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IE5PT1BcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc3RhdGUgaW5pdGlhbGl6YXRpb24gY29tcGxldGUgYXQgdGhpcyBwb2ludCAtIHN0YXJ0IGNhY2hpbmcgYWNjZXNzXHJcbiAgICBzaG91bGRDYWNoZUFjY2VzcyA9IHRydWU7XHJcbiAgICBpZiAoY29tcHV0ZWRPcHRpb25zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29tcHV0ZWRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IGNvbXB1dGVkT3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICBjb25zdCBnZXQgPSBpc0Z1bmN0aW9uKG9wdClcclxuICAgICAgICAgICAgICAgID8gb3B0LmJpbmQocHVibGljVGhpcywgcHVibGljVGhpcylcclxuICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbihvcHQuZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgID8gb3B0LmdldC5iaW5kKHB1YmxpY1RoaXMsIHB1YmxpY1RoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBOT09QO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGdldCA9PT0gTk9PUCkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGhhcyBubyBnZXR0ZXIuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2V0ID0gIWlzRnVuY3Rpb24ob3B0KSAmJiBpc0Z1bmN0aW9uKG9wdC5zZXQpXHJcbiAgICAgICAgICAgICAgICA/IG9wdC5zZXQuYmluZChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJylcclxuICAgICAgICAgICAgICAgICAgICA/ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQxKGBXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIHJlYWRvbmx5LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICA6IE5PT1A7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb21wdXRlZCQxKHtcclxuICAgICAgICAgICAgICAgIGdldCxcclxuICAgICAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBjLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgc2V0OiB2ID0+IChjLnZhbHVlID0gdilcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlUHJvcGVydGllcyhcIkNvbXB1dGVkXCIgLyogQ09NUFVURUQgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod2F0Y2hPcHRpb25zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIod2F0Y2hPcHRpb25zW2tleV0sIGN0eCwgcHVibGljVGhpcywga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlcyA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbnMpXHJcbiAgICAgICAgICAgID8gcHJvdmlkZU9wdGlvbnMuY2FsbChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICA6IHByb3ZpZGVPcHRpb25zO1xyXG4gICAgICAgIFJlZmxlY3Qub3duS2V5cyhwcm92aWRlcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICBwcm92aWRlKGtleSwgcHJvdmlkZXNba2V5XSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY3JlYXRlZCkge1xyXG4gICAgICAgIGNhbGxIb29rKGNyZWF0ZWQsIGluc3RhbmNlLCBcImNcIiAvKiBDUkVBVEVEICovKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhyZWdpc3RlciwgaG9vaykge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGhvb2spKSB7XHJcbiAgICAgICAgICAgIGhvb2suZm9yRWFjaChfaG9vayA9PiByZWdpc3RlcihfaG9vay5iaW5kKHB1YmxpY1RoaXMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvb2spIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXIoaG9vay5iaW5kKHB1YmxpY1RoaXMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVNb3VudCwgYmVmb3JlTW91bnQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uTW91bnRlZCwgbW91bnRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVcGRhdGUsIGJlZm9yZVVwZGF0ZSk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25VcGRhdGVkLCB1cGRhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkFjdGl2YXRlZCwgYWN0aXZhdGVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvbkRlYWN0aXZhdGVkLCBkZWFjdGl2YXRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25FcnJvckNhcHR1cmVkLCBlcnJvckNhcHR1cmVkKTtcclxuICAgIHJlZ2lzdGVyTGlmZWN5Y2xlSG9vayhvblJlbmRlclRyYWNrZWQsIHJlbmRlclRyYWNrZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uUmVuZGVyVHJpZ2dlcmVkLCByZW5kZXJUcmlnZ2VyZWQpO1xyXG4gICAgcmVnaXN0ZXJMaWZlY3ljbGVIb29rKG9uQmVmb3JlVW5tb3VudCwgYmVmb3JlVW5tb3VudCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIHVubW91bnRlZCk7XHJcbiAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25TZXJ2ZXJQcmVmZXRjaCwgc2VydmVyUHJlZmV0Y2gpO1xyXG4gICAge1xyXG4gICAgICAgIGlmIChiZWZvcmVEZXN0cm95ICYmXHJcbiAgICAgICAgICAgIHNvZnRBc3NlcnRDb21wYXRFbmFibGVkKFwiT1BUSU9OU19CRUZPUkVfREVTVFJPWVwiIC8qIE9QVElPTlNfQkVGT1JFX0RFU1RST1kgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25CZWZvcmVVbm1vdW50LCBiZWZvcmVEZXN0cm95KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc3Ryb3llZCAmJlxyXG4gICAgICAgICAgICBzb2Z0QXNzZXJ0Q29tcGF0RW5hYmxlZChcIk9QVElPTlNfREVTVFJPWUVEXCIgLyogT1BUSU9OU19ERVNUUk9ZRUQgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICByZWdpc3RlckxpZmVjeWNsZUhvb2sob25Vbm1vdW50ZWQsIGRlc3Ryb3llZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzQXJyYXkoZXhwb3NlKSkge1xyXG4gICAgICAgIGlmIChleHBvc2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cG9zZWQgPSBpbnN0YW5jZS5leHBvc2VkIHx8IChpbnN0YW5jZS5leHBvc2VkID0ge30pO1xyXG4gICAgICAgICAgICBleHBvc2UuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9zZWQsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcHVibGljVGhpc1trZXldLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldDogdmFsID0+IChwdWJsaWNUaGlzW2tleV0gPSB2YWwpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFpbnN0YW5jZS5leHBvc2VkKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLmV4cG9zZWQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgd2hlbiBjcmVhdGluZyB0aGUgaW5zdGFuY2UgYnV0IGFsc28gbmVlZCB0byBiZVxyXG4gICAgLy8gYXBwbGllZCBmcm9tIG1peGluc1xyXG4gICAgaWYgKHJlbmRlciAmJiBpbnN0YW5jZS5yZW5kZXIgPT09IE5PT1ApIHtcclxuICAgICAgICBpbnN0YW5jZS5yZW5kZXIgPSByZW5kZXI7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5oZXJpdEF0dHJzICE9IG51bGwpIHtcclxuICAgICAgICBpbnN0YW5jZS5pbmhlcml0QXR0cnMgPSBpbmhlcml0QXR0cnM7XHJcbiAgICB9XHJcbiAgICAvLyBhc3NldCBvcHRpb25zLlxyXG4gICAgaWYgKGNvbXBvbmVudHMpXHJcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XHJcbiAgICBpZiAoZGlyZWN0aXZlcylcclxuICAgICAgICBpbnN0YW5jZS5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcclxuICAgIGlmIChmaWx0ZXJzICYmXHJcbiAgICAgICAgaXNDb21wYXRFbmFibGVkKFwiRklMVEVSU1wiIC8qIEZJTFRFUlMgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgIGluc3RhbmNlLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVJbmplY3Rpb25zKGluamVjdE9wdGlvbnMsIGN0eCwgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzID0gTk9PUCwgdW53cmFwUmVmID0gZmFsc2UpIHtcclxuICAgIGlmIChpc0FycmF5KGluamVjdE9wdGlvbnMpKSB7XHJcbiAgICAgICAgaW5qZWN0T3B0aW9ucyA9IG5vcm1hbGl6ZUluamVjdChpbmplY3RPcHRpb25zKTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IGluIGluamVjdE9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvcHQgPSBpbmplY3RPcHRpb25zW2tleV07XHJcbiAgICAgICAgbGV0IGluamVjdGVkO1xyXG4gICAgICAgIGlmIChpc09iamVjdChvcHQpKSB7XHJcbiAgICAgICAgICAgIGlmICgnZGVmYXVsdCcgaW4gb3B0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXksIG9wdC5kZWZhdWx0LCB0cnVlIC8qIHRyZWF0IGRlZmF1bHQgZnVuY3Rpb24gYXMgZmFjdG9yeSAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQuZnJvbSB8fCBrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpbmplY3RlZCA9IGluamVjdChvcHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWYoaW5qZWN0ZWQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoZSBjaGVjayBpbiAzLjNcclxuICAgICAgICAgICAgaWYgKHVud3JhcFJlZikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwga2V5LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiBpbmplY3RlZC52YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHYgPT4gKGluamVjdGVkLnZhbHVlID0gdilcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgaW5qZWN0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhIHJlZiBhbmQgd2lsbCBiZSBhdXRvLXVud3JhcHBlZCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGFuZCBubyBsb25nZXIgbmVlZHMgXFxgLnZhbHVlXFxgIGluIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgVG8gb3B0LWluIHRvIHRoZSBuZXcgYmVoYXZpb3Igbm93LCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHNldCBcXGBhcHAuY29uZmlnLnVud3JhcEluamVjdGVkUmVmID0gdHJ1ZVxcYCAodGhpcyBjb25maWcgaXMgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0ZW1wb3JhcnkgYW5kIHdpbGwgbm90IGJlIG5lZWRlZCBpbiB0aGUgZnV0dXJlLilgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN0eFtrZXldID0gaW5qZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVQcm9wZXJ0aWVzKFwiSW5qZWN0XCIgLyogSU5KRUNUICovLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSG9vayhob29rLCBpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcoaXNBcnJheShob29rKVxyXG4gICAgICAgID8gaG9vay5tYXAoaCA9PiBoLmJpbmQoaW5zdGFuY2UucHJveHkpKVxyXG4gICAgICAgIDogaG9vay5iaW5kKGluc3RhbmNlLnByb3h5KSwgaW5zdGFuY2UsIHR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIocmF3LCBjdHgsIHB1YmxpY1RoaXMsIGtleSkge1xyXG4gICAgY29uc3QgZ2V0dGVyID0ga2V5LmluY2x1ZGVzKCcuJylcclxuICAgICAgICA/IGNyZWF0ZVBhdGhHZXR0ZXIocHVibGljVGhpcywga2V5KVxyXG4gICAgICAgIDogKCkgPT4gcHVibGljVGhpc1trZXldO1xyXG4gICAgaWYgKGlzU3RyaW5nKHJhdykpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGVyID0gY3R4W3Jhd107XHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3Jhd31cImAsIGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xyXG4gICAgICAgIHdhdGNoKGdldHRlciwgcmF3LmJpbmQocHVibGljVGhpcykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QocmF3KSkge1xyXG4gICAgICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICAgICAgcmF3LmZvckVhY2gociA9PiBjcmVhdGVXYXRjaGVyKHIsIGN0eCwgcHVibGljVGhpcywga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaXNGdW5jdGlvbihyYXcuaGFuZGxlcilcclxuICAgICAgICAgICAgICAgID8gcmF3LmhhbmRsZXIuYmluZChwdWJsaWNUaGlzKVxyXG4gICAgICAgICAgICAgICAgOiBjdHhbcmF3LmhhbmRsZXJdO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2goZ2V0dGVyLCBoYW5kbGVyLCByYXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBJbnZhbGlkIHdhdGNoIGhhbmRsZXIgc3BlY2lmaWVkIGJ5IGtleSBcIiR7cmF3LmhhbmRsZXJ9XCJgLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm4kMShgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtrZXl9XCJgLCByYXcpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXNvbHZlIG1lcmdlZCBvcHRpb25zIGFuZCBjYWNoZSBpdCBvbiB0aGUgY29tcG9uZW50LlxyXG4gKiBUaGlzIGlzIGRvbmUgb25seSBvbmNlIHBlci1jb21wb25lbnQgc2luY2UgdGhlIG1lcmdpbmcgZG9lcyBub3QgaW52b2x2ZVxyXG4gKiBpbnN0YW5jZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlTWVyZ2VkT3B0aW9ucyhpbnN0YW5jZSkge1xyXG4gICAgY29uc3QgYmFzZSA9IGluc3RhbmNlLnR5cGU7XHJcbiAgICBjb25zdCB7IG1peGlucywgZXh0ZW5kczogZXh0ZW5kc09wdGlvbnMgfSA9IGJhc2U7XHJcbiAgICBjb25zdCB7IG1peGluczogZ2xvYmFsTWl4aW5zLCBvcHRpb25zQ2FjaGU6IGNhY2hlLCBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzIH0gfSA9IGluc3RhbmNlLmFwcENvbnRleHQ7XHJcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoYmFzZSk7XHJcbiAgICBsZXQgcmVzb2x2ZWQ7XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmVzb2x2ZWQgPSBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZ2xvYmFsTWl4aW5zLmxlbmd0aCAmJiAhbWl4aW5zICYmICFleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJQUklWQVRFX0FQSVNcIiAvKiBQUklWQVRFX0FQSVMgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICByZXNvbHZlZCA9IGV4dGVuZCh7fSwgYmFzZSk7XHJcbiAgICAgICAgICAgIHJlc29sdmVkLnBhcmVudCA9IGluc3RhbmNlLnBhcmVudCAmJiBpbnN0YW5jZS5wYXJlbnQucHJveHk7XHJcbiAgICAgICAgICAgIHJlc29sdmVkLnByb3BzRGF0YSA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmVkID0ge307XHJcbiAgICAgICAgaWYgKGdsb2JhbE1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZ2xvYmFsTWl4aW5zLmZvckVhY2gobSA9PiBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIG0sIG9wdGlvbk1lcmdlU3RyYXRlZ2llcywgdHJ1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXJnZU9wdGlvbnMocmVzb2x2ZWQsIGJhc2UsIG9wdGlvbk1lcmdlU3RyYXRlZ2llcyk7XHJcbiAgICB9XHJcbiAgICBjYWNoZS5zZXQoYmFzZSwgcmVzb2x2ZWQpO1xyXG4gICAgcmV0dXJuIHJlc29sdmVkO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyh0bywgZnJvbSwgc3RyYXRzLCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKGZyb20pKSB7XHJcbiAgICAgICAgZnJvbSA9IGZyb20ub3B0aW9ucztcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbWl4aW5zLCBleHRlbmRzOiBleHRlbmRzT3B0aW9ucyB9ID0gZnJvbTtcclxuICAgIGlmIChleHRlbmRzT3B0aW9ucykge1xyXG4gICAgICAgIG1lcmdlT3B0aW9ucyh0bywgZXh0ZW5kc09wdGlvbnMsIHN0cmF0cywgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAobWl4aW5zKSB7XHJcbiAgICAgICAgbWl4aW5zLmZvckVhY2goKG0pID0+IG1lcmdlT3B0aW9ucyh0bywgbSwgc3RyYXRzLCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKGFzTWl4aW4gJiYga2V5ID09PSAnZXhwb3NlJykge1xyXG4gICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgSXQgc2hvdWxkIG9ubHkgYmUgZGVjbGFyZWQgaW4gdGhlIGJhc2UgY29tcG9uZW50IGl0c2VsZi5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ID0gaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0c1trZXldIHx8IChzdHJhdHMgJiYgc3RyYXRzW2tleV0pO1xyXG4gICAgICAgICAgICB0b1trZXldID0gc3RyYXQgPyBzdHJhdCh0b1trZXldLCBmcm9tW2tleV0pIDogZnJvbVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0bztcclxufVxyXG5jb25zdCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzID0ge1xyXG4gICAgZGF0YTogbWVyZ2VEYXRhRm4sXHJcbiAgICBwcm9wczogbWVyZ2VPYmplY3RPcHRpb25zLFxyXG4gICAgZW1pdHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIC8vIG9iamVjdHNcclxuICAgIG1ldGhvZHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGNvbXB1dGVkOiBtZXJnZU9iamVjdE9wdGlvbnMsXHJcbiAgICAvLyBsaWZlY3ljbGVcclxuICAgIGJlZm9yZUNyZWF0ZTogbWVyZ2VBc0FycmF5LFxyXG4gICAgY3JlYXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYmVmb3JlTW91bnQ6IG1lcmdlQXNBcnJheSxcclxuICAgIG1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGJlZm9yZVVwZGF0ZTogbWVyZ2VBc0FycmF5LFxyXG4gICAgdXBkYXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgYmVmb3JlRGVzdHJveTogbWVyZ2VBc0FycmF5LFxyXG4gICAgYmVmb3JlVW5tb3VudDogbWVyZ2VBc0FycmF5LFxyXG4gICAgZGVzdHJveWVkOiBtZXJnZUFzQXJyYXksXHJcbiAgICB1bm1vdW50ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGFjdGl2YXRlZDogbWVyZ2VBc0FycmF5LFxyXG4gICAgZGVhY3RpdmF0ZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIGVycm9yQ2FwdHVyZWQ6IG1lcmdlQXNBcnJheSxcclxuICAgIHNlcnZlclByZWZldGNoOiBtZXJnZUFzQXJyYXksXHJcbiAgICAvLyBhc3NldHNcclxuICAgIGNvbXBvbmVudHM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIGRpcmVjdGl2ZXM6IG1lcmdlT2JqZWN0T3B0aW9ucyxcclxuICAgIC8vIHdhdGNoXHJcbiAgICB3YXRjaDogbWVyZ2VXYXRjaE9wdGlvbnMsXHJcbiAgICAvLyBwcm92aWRlIC8gaW5qZWN0XHJcbiAgICBwcm92aWRlOiBtZXJnZURhdGFGbixcclxuICAgIGluamVjdDogbWVyZ2VJbmplY3RcclxufTtcclxue1xyXG4gICAgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cy5maWx0ZXJzID0gbWVyZ2VPYmplY3RPcHRpb25zO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlRGF0YUZuKHRvLCBmcm9tKSB7XHJcbiAgICBpZiAoIWZyb20pIHtcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9XHJcbiAgICBpZiAoIXRvKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xyXG4gICAgICAgIHJldHVybiAoaXNDb21wYXRFbmFibGVkKFwiT1BUSU9OU19EQVRBX01FUkdFXCIgLyogT1BUSU9OU19EQVRBX01FUkdFICovLCBudWxsKVxyXG4gICAgICAgICAgICA/IGRlZXBNZXJnZURhdGFcclxuICAgICAgICAgICAgOiBleHRlbmQpKGlzRnVuY3Rpb24odG8pID8gdG8uY2FsbCh0aGlzLCB0aGlzKSA6IHRvLCBpc0Z1bmN0aW9uKGZyb20pID8gZnJvbS5jYWxsKHRoaXMsIHRoaXMpIDogZnJvbSk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSW5qZWN0KHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RPcHRpb25zKG5vcm1hbGl6ZUluamVjdCh0byksIG5vcm1hbGl6ZUluamVjdChmcm9tKSk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0KHJhdykge1xyXG4gICAgaWYgKGlzQXJyYXkocmF3KSkge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc1tyYXdbaV1dID0gcmF3W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhdztcclxufVxyXG5mdW5jdGlvbiBtZXJnZUFzQXJyYXkodG8sIGZyb20pIHtcclxuICAgIHJldHVybiB0byA/IFsuLi5uZXcgU2V0KFtdLmNvbmNhdCh0bywgZnJvbSkpXSA6IGZyb207XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VPYmplY3RPcHRpb25zKHRvLCBmcm9tKSB7XHJcbiAgICByZXR1cm4gdG8gPyBleHRlbmQoZXh0ZW5kKE9iamVjdC5jcmVhdGUobnVsbCksIHRvKSwgZnJvbSkgOiBmcm9tO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlV2F0Y2hPcHRpb25zKHRvLCBmcm9tKSB7XHJcbiAgICBpZiAoIXRvKVxyXG4gICAgICAgIHJldHVybiBmcm9tO1xyXG4gICAgaWYgKCFmcm9tKVxyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIGNvbnN0IG1lcmdlZCA9IGV4dGVuZChPYmplY3QuY3JlYXRlKG51bGwpLCB0byk7XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgbWVyZ2VkW2tleV0gPSBtZXJnZUFzQXJyYXkodG9ba2V5XSwgZnJvbVtrZXldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXJnZWQ7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJvcHNEZWZhdWx0VGhpcyhpbnN0YW5jZSwgcmF3UHJvcHMsIHByb3BLZXkpIHtcclxuICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcclxuICAgICAgICBnZXQoXywga2V5KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKFwiUFJPUFNfREVGQVVMVF9USElTXCIgLyogUFJPUFNfREVGQVVMVF9USElTICovLCBudWxsLCBwcm9wS2V5KTtcclxuICAgICAgICAgICAgLy8gJG9wdGlvbnNcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRvcHRpb25zJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVNZXJnZWRPcHRpb25zKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpbmplY3Rpb25zXHJcbiAgICAgICAgICAgIGNvbnN0IGluamVjdGlvbnMgPSBpbnN0YW5jZS50eXBlLmluamVjdDtcclxuICAgICAgICAgICAgaWYgKGluamVjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGluamVjdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluamVjdGlvbnMuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0KGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIGluamVjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0KGtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBzaG91bGRTa2lwQXR0cihrZXksIGluc3RhbmNlKSB7XHJcbiAgICBpZiAoa2V5ID09PSAnaXMnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpICYmXHJcbiAgICAgICAgaXNDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfQVRUUlNfQ0xBU1NfU1RZTEVcIiAvKiBJTlNUQU5DRV9BVFRSU19DTEFTU19TVFlMRSAqLywgaW5zdGFuY2UpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPbihrZXkpICYmXHJcbiAgICAgICAgaXNDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfTElTVEVORVJTXCIgLyogSU5TVEFOQ0VfTElTVEVORVJTICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIHZ1ZS1yb3V0ZXJcclxuICAgIGlmIChrZXkuc3RhcnRzV2l0aCgncm91dGVyVmlldycpIHx8IGtleSA9PT0gJ3JlZ2lzdGVyUm91dGVJbnN0YW5jZScpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBpc1N0YXRlZnVsLCAvLyByZXN1bHQgb2YgYml0d2lzZSBmbGFnIGNvbXBhcmlzb25cclxuaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcHJvcHMgPSB7fTtcclxuICAgIGNvbnN0IGF0dHJzID0ge307XHJcbiAgICBkZWYoYXR0cnMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxuICAgIGluc3RhbmNlLnByb3BzRGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKTtcclxuICAgIC8vIGVuc3VyZSBhbGwgZGVjbGFyZWQgcHJvcCBrZXlzIGFyZSBwcmVzZW50XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnN0YW5jZS5wcm9wc09wdGlvbnNbMF0pIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gdmFsaWRhdGlvblxyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHZhbGlkYXRlUHJvcHMocmF3UHJvcHMgfHwge30sIHByb3BzLCBpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTdGF0ZWZ1bCkge1xyXG4gICAgICAgIC8vIHN0YXRlZnVsXHJcbiAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBpc1NTUiA/IHByb3BzIDogc2hhbGxvd1JlYWN0aXZlKHByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UudHlwZS5wcm9wcykge1xyXG4gICAgICAgICAgICAvLyBmdW5jdGlvbmFsIHcvIG9wdGlvbmFsIHByb3BzLCBwcm9wcyA9PT0gYXR0cnNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBhdHRycztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uYWwgdy8gZGVjbGFyZWQgcHJvcHNcclxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnN0YW5jZS5hdHRycyA9IGF0dHJzO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZVByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcmF3UHJldlByb3BzLCBvcHRpbWl6ZWQpIHtcclxuICAgIGNvbnN0IHsgcHJvcHMsIGF0dHJzLCB2bm9kZTogeyBwYXRjaEZsYWcgfSB9ID0gaW5zdGFuY2U7XHJcbiAgICBjb25zdCByYXdDdXJyZW50UHJvcHMgPSB0b1Jhdyhwcm9wcyk7XHJcbiAgICBjb25zdCBbb3B0aW9uc10gPSBpbnN0YW5jZS5wcm9wc09wdGlvbnM7XHJcbiAgICBsZXQgaGFzQXR0cnNDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICBpZiAoXHJcbiAgICAvLyBhbHdheXMgZm9yY2UgZnVsbCBkaWZmIGluIGRldlxyXG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcclxuICAgIC8vIC0gdml0ZSM4NzIgbm9uLXNmYyBjb21wb25lbnQgdXNlZCBieSBzZmMgY29tcG9uZW50XHJcbiAgICAhKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIChpbnN0YW5jZS50eXBlLl9faG1ySWQgfHxcclxuICAgICAgICAgICAgKGluc3RhbmNlLnBhcmVudCAmJiBpbnN0YW5jZS5wYXJlbnQudHlwZS5fX2htcklkKSkpICYmXHJcbiAgICAgICAgKG9wdGltaXplZCB8fCBwYXRjaEZsYWcgPiAwKSAmJlxyXG4gICAgICAgICEocGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLykpIHtcclxuICAgICAgICBpZiAocGF0Y2hGbGFnICYgOCAvKiBQUk9QUyAqLykge1xyXG4gICAgICAgICAgICAvLyBDb21waWxlci1nZW5lcmF0ZWQgcHJvcHMgJiBubyBrZXlzIGNoYW5nZSwganVzdCBzZXQgdGhlIHVwZGF0ZWRcclxuICAgICAgICAgICAgLy8gdGhlIHByb3BzLlxyXG4gICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gaW5zdGFuY2Uudm5vZGUuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiB0aGUgcHJvcCBrZXkgaXMgYSBkZWNsYXJlZCBlbWl0IGV2ZW50IGxpc3RlbmVyXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbWl0TGlzdGVuZXIoaW5zdGFuY2UuZW1pdHNPcHRpb25zLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBQUk9QUyBmbGFnIGd1YXJhbnRlZXMgcmF3UHJvcHMgdG8gYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXR0ciAvIHByb3BzIHNlcGFyYXRpb24gd2FzIGRvbmUgb24gaW5pdCBhbmQgd2lsbCBiZSBjb25zaXN0ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhpcyBjb2RlIHBhdGgsIHNvIGp1c3QgY2hlY2sgaWYgYXR0cnMgaGF2ZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKGF0dHJzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gYXR0cnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxpemVkS2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBjYW1lbGl6ZWRLZXksIHZhbHVlLCBpbnN0YW5jZSwgZmFsc2UgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT24oa2V5KSAmJiBrZXkuZW5kc1dpdGgoJ05hdGl2ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkuc2xpY2UoMCwgLTYpOyAvLyByZW1vdmUgTmF0aXZlIHBvc3RmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRTa2lwQXR0cihrZXksIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBmdWxsIHByb3BzIHVwZGF0ZS5cclxuICAgICAgICBpZiAoc2V0RnVsbFByb3BzKGluc3RhbmNlLCByYXdQcm9wcywgcHJvcHMsIGF0dHJzKSkge1xyXG4gICAgICAgICAgICBoYXNBdHRyc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbiBjYXNlIG9mIGR5bmFtaWMgcHJvcHMsIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIGtleXMgZnJvbVxyXG4gICAgICAgIC8vIHRoZSBwcm9wcyBvYmplY3RcclxuICAgICAgICBsZXQga2ViYWJLZXk7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghcmF3UHJvcHMgfHxcclxuICAgICAgICAgICAgICAgIC8vIGZvciBjYW1lbENhc2VcclxuICAgICAgICAgICAgICAgICghaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGUgb3JpZ2luYWwgcHJvcHMgd2FzIHBhc3NlZCBpbiBhcyBrZWJhYi1jYXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXHJcbiAgICAgICAgICAgICAgICAgICAgKChrZWJhYktleSA9IGh5cGhlbmF0ZShrZXkpKSA9PT0ga2V5IHx8ICFoYXNPd24ocmF3UHJvcHMsIGtlYmFiS2V5KSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdQcmV2UHJvcHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGNhbWVsQ2FzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocmF3UHJldlByb3BzW2tleV0gIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGtlYmFiLWNhc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ByZXZQcm9wc1trZWJhYktleV0gIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHJlc29sdmVQcm9wVmFsdWUob3B0aW9ucywgcmF3Q3VycmVudFByb3BzLCBrZXksIHVuZGVmaW5lZCwgaW5zdGFuY2UsIHRydWUgLyogaXNBYnNlbnQgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bmN0aW9uYWwgY29tcG9uZW50IHcvbyBwcm9wcyBkZWNsYXJhdGlvbiwgcHJvcHMgYW5kXHJcbiAgICAgICAgLy8gYXR0cnMgcG9pbnQgdG8gdGhlIHNhbWUgb2JqZWN0IHNvIGl0IHNob3VsZCBhbHJlYWR5IGhhdmUgYmVlbiB1cGRhdGVkLlxyXG4gICAgICAgIGlmIChhdHRycyAhPT0gcmF3Q3VycmVudFByb3BzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1Byb3BzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFoYXNPd24ocmF3UHJvcHMsIGtleSArICdOYXRpdmUnKSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQXR0cnNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHRyaWdnZXIgdXBkYXRlcyBmb3IgJGF0dHJzIGluIGNhc2UgaXQncyB1c2VkIGluIGNvbXBvbmVudCBzbG90c1xyXG4gICAgaWYgKGhhc0F0dHJzQ2hhbmdlZCkge1xyXG4gICAgICAgIHRyaWdnZXIoaW5zdGFuY2UsIFwic2V0XCIgLyogU0VUICovLCAnJGF0dHJzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wcyhyYXdQcm9wcyB8fCB7fSwgcHJvcHMsIGluc3RhbmNlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRGdWxsUHJvcHMoaW5zdGFuY2UsIHJhd1Byb3BzLCBwcm9wcywgYXR0cnMpIHtcclxuICAgIGNvbnN0IFtvcHRpb25zLCBuZWVkQ2FzdEtleXNdID0gaW5zdGFuY2UucHJvcHNPcHRpb25zO1xyXG4gICAgbGV0IGhhc0F0dHJzQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgbGV0IHJhd0Nhc3RWYWx1ZXM7XHJcbiAgICBpZiAocmF3UHJvcHMpIHtcclxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgLy8ga2V5LCByZWYgYXJlIHJlc2VydmVkIGFuZCBuZXZlciBwYXNzZWQgZG93blxyXG4gICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKCdvbkhvb2s6JykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzb2Z0QXNzZXJ0Q29tcGF0RW5hYmxlZChcIklOU1RBTkNFX0VWRU5UX0hPT0tTXCIgLyogSU5TVEFOQ0VfRVZFTlRfSE9PS1MgKi8sIGluc3RhbmNlLCBrZXkuc2xpY2UoMikudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnaW5saW5lLXRlbXBsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmF3UHJvcHNba2V5XTtcclxuICAgICAgICAgICAgLy8gcHJvcCBvcHRpb24gbmFtZXMgYXJlIGNhbWVsaXplZCBkdXJpbmcgbm9ybWFsaXphdGlvbiwgc28gdG8gc3VwcG9ydFxyXG4gICAgICAgICAgICAvLyBrZWJhYiAtPiBjYW1lbCBjb252ZXJzaW9uIGhlcmUgd2UgbmVlZCB0byBjYW1lbGl6ZSB0aGUga2V5LlxyXG4gICAgICAgICAgICBsZXQgY2FtZWxLZXk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAoY2FtZWxLZXkgPSBjYW1lbGl6ZShrZXkpKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghbmVlZENhc3RLZXlzIHx8ICFuZWVkQ2FzdEtleXMuaW5jbHVkZXMoY2FtZWxLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbY2FtZWxLZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAocmF3Q2FzdFZhbHVlcyB8fCAocmF3Q2FzdFZhbHVlcyA9IHt9KSlbY2FtZWxLZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW1pdExpc3RlbmVyKGluc3RhbmNlLmVtaXRzT3B0aW9ucywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQW55IG5vbi1kZWNsYXJlZCAoZWl0aGVyIGFzIGEgcHJvcCBvciBhbiBlbWl0dGVkIGV2ZW50KSBwcm9wcyBhcmUgcHV0XHJcbiAgICAgICAgICAgICAgICAvLyBpbnRvIGEgc2VwYXJhdGUgYGF0dHJzYCBvYmplY3QgZm9yIHNwcmVhZGluZy4gTWFrZSBzdXJlIHRvIHByZXNlcnZlXHJcbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBrZXkgY2FzaW5nXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT24oa2V5KSAmJiBrZXkuZW5kc1dpdGgoJ05hdGl2ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zbGljZSgwLCAtNik7IC8vIHJlbW92ZSBOYXRpdmUgcG9zdGZpeFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaG91bGRTa2lwQXR0cihrZXksIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gYXR0cnMpIHx8IHZhbHVlICE9PSBhdHRyc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dHJzQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmVlZENhc3RLZXlzKSB7XHJcbiAgICAgICAgY29uc3QgcmF3Q3VycmVudFByb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IGNhc3RWYWx1ZXMgPSByYXdDYXN0VmFsdWVzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRDYXN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZWVkQ2FzdEtleXNbaV07XHJcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSByZXNvbHZlUHJvcFZhbHVlKG9wdGlvbnMsIHJhd0N1cnJlbnRQcm9wcywga2V5LCBjYXN0VmFsdWVzW2tleV0sIGluc3RhbmNlLCAhaGFzT3duKGNhc3RWYWx1ZXMsIGtleSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYXNBdHRyc0NoYW5nZWQ7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVByb3BWYWx1ZShvcHRpb25zLCBwcm9wcywga2V5LCB2YWx1ZSwgaW5zdGFuY2UsIGlzQWJzZW50KSB7XHJcbiAgICBjb25zdCBvcHQgPSBvcHRpb25zW2tleV07XHJcbiAgICBpZiAob3B0ICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzT3duKG9wdCwgJ2RlZmF1bHQnKTtcclxuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlc1xyXG4gICAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gb3B0LmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChvcHQudHlwZSAhPT0gRnVuY3Rpb24gJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzRGVmYXVsdHMgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBwcm9wc0RlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcm9wc0RlZmF1bHRzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvcHNEZWZhdWx0c1trZXldID0gZGVmYXVsdFZhbHVlLmNhbGwoaXNDb21wYXRFbmFibGVkKFwiUFJPUFNfREVGQVVMVF9USElTXCIgLyogUFJPUFNfREVGQVVMVF9USElTICovLCBpbnN0YW5jZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjcmVhdGVQcm9wc0RlZmF1bHRUaGlzKGluc3RhbmNlLCBwcm9wcywga2V5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsIHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICB1bnNldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm9vbGVhbiBjYXN0aW5nXHJcbiAgICAgICAgaWYgKG9wdFswIC8qIHNob3VsZENhc3QgKi9dKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0Fic2VudCAmJiAhaGFzRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRbMSAvKiBzaG91bGRDYXN0VHJ1ZSAqL10gJiZcclxuICAgICAgICAgICAgICAgICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzT3B0aW9ucyhjb21wLCBhcHBDb250ZXh0LCBhc01peGluID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNhY2hlID0gYXBwQ29udGV4dC5wcm9wc0NhY2hlO1xyXG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGNvbXApO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYXcgPSBjb21wLnByb3BzO1xyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xyXG4gICAgY29uc3QgbmVlZENhc3RLZXlzID0gW107XHJcbiAgICAvLyBhcHBseSBtaXhpbi9leHRlbmRzIHByb3BzXHJcbiAgICBsZXQgaGFzRXh0ZW5kcyA9IGZhbHNlO1xyXG4gICAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18gJiYgIWlzRnVuY3Rpb24oY29tcCkpIHtcclxuICAgICAgICBjb25zdCBleHRlbmRQcm9wcyA9IChyYXcpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocmF3KSkge1xyXG4gICAgICAgICAgICAgICAgcmF3ID0gcmF3Lm9wdGlvbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGFzRXh0ZW5kcyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wcywga2V5c10gPSBub3JtYWxpemVQcm9wc09wdGlvbnMocmF3LCBhcHBDb250ZXh0LCB0cnVlKTtcclxuICAgICAgICAgICAgZXh0ZW5kKG5vcm1hbGl6ZWQsIHByb3BzKTtcclxuICAgICAgICAgICAgaWYgKGtleXMpXHJcbiAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaCguLi5rZXlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghYXNNaXhpbiAmJiBhcHBDb250ZXh0Lm1peGlucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgYXBwQ29udGV4dC5taXhpbnMuZm9yRWFjaChleHRlbmRQcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb21wLmV4dGVuZHMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kUHJvcHMoY29tcC5leHRlbmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXAubWl4aW5zKSB7XHJcbiAgICAgICAgICAgIGNvbXAubWl4aW5zLmZvckVhY2goZXh0ZW5kUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghcmF3ICYmICFoYXNFeHRlbmRzKSB7XHJcbiAgICAgICAgY2FjaGUuc2V0KGNvbXAsIEVNUFRZX0FSUik7XHJcbiAgICAgICAgcmV0dXJuIEVNUFRZX0FSUjtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHJhdykpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFpc1N0cmluZyhyYXdbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDEoYHByb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC5gLCByYXdbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBjYW1lbGl6ZShyYXdbaV0pO1xyXG4gICAgICAgICAgICBpZiAodmFsaWRhdGVQcm9wTmFtZShub3JtYWxpemVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9IEVNUFRZX09CSjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJhdykge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWlzT2JqZWN0KHJhdykpIHtcclxuICAgICAgICAgICAgd2FybiQxKGBpbnZhbGlkIHByb3BzIG9wdGlvbnNgLCByYXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByYXcpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZVByb3BOYW1lKG5vcm1hbGl6ZWRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSByYXdba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSAobm9ybWFsaXplZFtub3JtYWxpemVkS2V5XSA9XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBcnJheShvcHQpIHx8IGlzRnVuY3Rpb24ob3B0KSA/IHsgdHlwZTogb3B0IH0gOiBvcHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFswIC8qIHNob3VsZENhc3QgKi9dID0gYm9vbGVhbkluZGV4ID4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcFsxIC8qIHNob3VsZENhc3RUcnVlICovXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcHJvcCBuZWVkcyBib29sZWFuIGNhc3Rpbmcgb3IgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib29sZWFuSW5kZXggPiAtMSB8fCBoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkQ2FzdEtleXMucHVzaChub3JtYWxpemVkS2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXMgPSBbbm9ybWFsaXplZCwgbmVlZENhc3RLZXlzXTtcclxuICAgIGNhY2hlLnNldChjb21wLCByZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BOYW1lKGtleSkge1xyXG4gICAgaWYgKGtleVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuJDEoYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7a2V5fVwiIGlzIGEgcmVzZXJ2ZWQgcHJvcGVydHkuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gdXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIHR5cGUgY29uc3RydWN0b3JzXHJcbi8vIHNvIHRoYXQgaXQgd29ya3MgYWNyb3NzIHZtcyAvIGlmcmFtZXMuXHJcbmZ1bmN0aW9uIGdldFR5cGUoY3Rvcikge1xyXG4gICAgY29uc3QgbWF0Y2ggPSBjdG9yICYmIGN0b3IudG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogY3RvciA9PT0gbnVsbCA/ICdudWxsJyA6ICcnO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xyXG4gICAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGlmIChpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkVHlwZXMuZmluZEluZGV4KHQgPT4gaXNTYW1lVHlwZSh0LCB0eXBlKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKHJhd1Byb3BzLCBwcm9wcywgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IHJlc29sdmVkVmFsdWVzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IGluc3RhbmNlLnByb3BzT3B0aW9uc1swXTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgb3B0ID0gb3B0aW9uc1trZXldO1xyXG4gICAgICAgIGlmIChvcHQgPT0gbnVsbClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgdmFsaWRhdGVQcm9wKGtleSwgcmVzb2x2ZWRWYWx1ZXNba2V5XSwgb3B0LCAhaGFzT3duKHJhd1Byb3BzLCBrZXkpICYmICFoYXNPd24ocmF3UHJvcHMsIGh5cGhlbmF0ZShrZXkpKSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AobmFtZSwgdmFsdWUsIHByb3AsIGlzQWJzZW50KSB7XHJcbiAgICBjb25zdCB7IHR5cGUsIHJlcXVpcmVkLCB2YWxpZGF0b3IgfSA9IHByb3A7XHJcbiAgICAvLyByZXF1aXJlZCFcclxuICAgIGlmIChyZXF1aXJlZCAmJiBpc0Fic2VudCkge1xyXG4gICAgICAgIHdhcm4kMSgnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gbWlzc2luZyBidXQgb3B0aW9uYWxcclxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gdHlwZSBjaGVja1xyXG4gICAgaWYgKHR5cGUgIT0gbnVsbCAmJiB0eXBlICE9PSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlcyA9IGlzQXJyYXkodHlwZSkgPyB0eXBlIDogW3R5cGVdO1xyXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICAgICAgICAvLyB2YWx1ZSBpcyB2YWxpZCBhcyBsb25nIGFzIG9uZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGVzIG1hdGNoXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGggJiYgIWlzVmFsaWQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IHZhbGlkLCBleHBlY3RlZFR5cGUgfSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVzW2ldKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGV4cGVjdGVkVHlwZSB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlzVmFsaWQgPSB2YWxpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGN1c3RvbSB2YWxpZGF0b3JcclxuICAgIGlmICh2YWxpZGF0b3IgJiYgIXZhbGlkYXRvcih2YWx1ZSkpIHtcclxuICAgICAgICB3YXJuJDEoJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBpc1NpbXBsZVR5cGUgPSAvKiNfX1BVUkVfXyovIG1ha2VNYXAoJ1N0cmluZyxOdW1iZXIsQm9vbGVhbixGdW5jdGlvbixTeW1ib2wsQmlnSW50Jyk7XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgbGV0IHZhbGlkO1xyXG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcclxuICAgIGlmIChpc1NpbXBsZVR5cGUoZXhwZWN0ZWRUeXBlKSkge1xyXG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XHJcbiAgICAgICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xyXG4gICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xyXG4gICAgICAgIHZhbGlkID0gaXNPYmplY3QodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ251bGwnKSB7XHJcbiAgICAgICAgdmFsaWQgPSB2YWx1ZSA9PT0gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZCxcclxuICAgICAgICBleHBlY3RlZFR5cGVcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIGxldCBtZXNzYWdlID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke25hbWV9XCIuYCArXHJcbiAgICAgICAgYCBFeHBlY3RlZCAke2V4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJyB8ICcpfWA7XHJcbiAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xyXG4gICAgY29uc3QgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcclxuICAgIGlmIChleHBlY3RlZFR5cGVzLmxlbmd0aCA9PT0gMSAmJlxyXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXHJcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGAgd2l0aCB2YWx1ZSAke2V4cGVjdGVkVmFsdWV9YDtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xyXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IHJlY2VpdmVkIHZhbHVlXHJcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcclxuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7cmVjZWl2ZWRWYWx1ZX0uYDtcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59XHJcbi8qKlxyXG4gKiBkZXYgb25seVxyXG4gKi9cclxuZnVuY3Rpb24gc3R5bGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gYCR7TnVtYmVyKHZhbHVlKX1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIGRldiBvbmx5XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodHlwZSkge1xyXG4gICAgY29uc3QgZXhwbGljaXRUeXBlcyA9IFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ107XHJcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGVsZW0gPT4gdHlwZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtKTtcclxufVxyXG4vKipcclxuICogZGV2IG9ubHlcclxuICovXHJcbmZ1bmN0aW9uIGlzQm9vbGVhbiguLi5hcmdzKSB7XHJcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xyXG59XG5cbmNvbnN0IGlzSW50ZXJuYWxLZXkgPSAoa2V5KSA9PiBrZXlbMF0gPT09ICdfJyB8fCBrZXkgPT09ICckc3RhYmxlJztcclxuY29uc3Qgbm9ybWFsaXplU2xvdFZhbHVlID0gKHZhbHVlKSA9PiBpc0FycmF5KHZhbHVlKVxyXG4gICAgPyB2YWx1ZS5tYXAobm9ybWFsaXplVk5vZGUpXHJcbiAgICA6IFtub3JtYWxpemVWTm9kZSh2YWx1ZSldO1xyXG5jb25zdCBub3JtYWxpemVTbG90ID0gKGtleSwgcmF3U2xvdCwgY3R4KSA9PiB7XHJcbiAgICBpZiAocmF3U2xvdC5fbikge1xyXG4gICAgICAgIC8vIGFscmVhZHkgbm9ybWFsaXplZCAtICM1MzUzXHJcbiAgICAgICAgcmV0dXJuIHJhd1Nsb3Q7XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gd2l0aEN0eCgoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgY3VycmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgU2xvdCBcIiR7a2V5fVwiIGludm9rZWQgb3V0c2lkZSBvZiB0aGUgcmVuZGVyIGZ1bmN0aW9uOiBgICtcclxuICAgICAgICAgICAgICAgIGB0aGlzIHdpbGwgbm90IHRyYWNrIGRlcGVuZGVuY2llcyB1c2VkIGluIHRoZSBzbG90LiBgICtcclxuICAgICAgICAgICAgICAgIGBJbnZva2UgdGhlIHNsb3QgZnVuY3Rpb24gaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNsb3RWYWx1ZShyYXdTbG90KC4uLmFyZ3MpKTtcclxuICAgIH0sIGN0eCk7XHJcbiAgICBub3JtYWxpemVkLl9jID0gZmFsc2U7XHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3Qgbm9ybWFsaXplT2JqZWN0U2xvdHMgPSAocmF3U2xvdHMsIHNsb3RzLCBpbnN0YW5jZSkgPT4ge1xyXG4gICAgY29uc3QgY3R4ID0gcmF3U2xvdHMuX2N0eDtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd1Nsb3RzKSB7XHJcbiAgICAgICAgaWYgKGlzSW50ZXJuYWxLZXkoa2V5KSlcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSByYXdTbG90c1trZXldO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBzbG90c1trZXldID0gbm9ybWFsaXplU2xvdChrZXksIHZhbHVlLCBjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICEoaXNDb21wYXRFbmFibGVkKFwiUkVOREVSX0ZVTkNUSU9OXCIgLyogUkVOREVSX0ZVTkNUSU9OICovLCBpbnN0YW5jZSkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDEoYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7a2V5fVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHNsb3RzW2tleV0gPSAoKSA9PiBub3JtYWxpemVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgbm9ybWFsaXplVk5vZGVTbG90cyA9IChpbnN0YW5jZSwgY2hpbGRyZW4pID0+IHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAhaXNLZWVwQWxpdmUoaW5zdGFuY2Uudm5vZGUpICYmXHJcbiAgICAgICAgIShpc0NvbXBhdEVuYWJsZWQoXCJSRU5ERVJfRlVOQ1RJT05cIiAvKiBSRU5ERVJfRlVOQ1RJT04gKi8sIGluc3RhbmNlKSkpIHtcclxuICAgICAgICB3YXJuJDEoYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgZGVmYXVsdCBzbG90LiBgICtcclxuICAgICAgICAgICAgYFByZWZlciBmdW5jdGlvbiBzbG90cyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLmApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVNsb3RWYWx1ZShjaGlsZHJlbik7XHJcbiAgICBpbnN0YW5jZS5zbG90cy5kZWZhdWx0ID0gKCkgPT4gbm9ybWFsaXplZDtcclxufTtcclxuY29uc3QgaW5pdFNsb3RzID0gKGluc3RhbmNlLCBjaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGluc3RhbmNlLnZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gdXNlcnMgY2FuIGdldCB0aGUgc2hhbGxvdyByZWFkb25seSB2ZXJzaW9uIG9mIHRoZSBzbG90cyBvYmplY3QgdGhyb3VnaCBgdGhpcy4kc2xvdHNgLFxyXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGQgYXZvaWQgdGhlIHByb3h5IG9iamVjdCBwb2xsdXRpbmcgdGhlIHNsb3RzIG9mIHRoZSBpbnRlcm5hbCBpbnN0YW5jZVxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zbG90cyA9IHRvUmF3KGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgLy8gbWFrZSBjb21waWxlciBtYXJrZXIgbm9uLWVudW1lcmFibGVcclxuICAgICAgICAgICAgZGVmKGNoaWxkcmVuLCAnXycsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplT2JqZWN0U2xvdHMoY2hpbGRyZW4sIChpbnN0YW5jZS5zbG90cyA9IHt9KSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGluc3RhbmNlLnNsb3RzID0ge307XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWYoaW5zdGFuY2Uuc2xvdHMsIEludGVybmFsT2JqZWN0S2V5LCAxKTtcclxufTtcclxuY29uc3QgdXBkYXRlU2xvdHMgPSAoaW5zdGFuY2UsIGNoaWxkcmVuLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgIGNvbnN0IHsgdm5vZGUsIHNsb3RzIH0gPSBpbnN0YW5jZTtcclxuICAgIGxldCBuZWVkRGVsZXRpb25DaGVjayA9IHRydWU7XHJcbiAgICBsZXQgZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0ID0gRU1QVFlfT0JKO1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDMyIC8qIFNMT1RTX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGNoaWxkcmVuLl87XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgLy8gY29tcGlsZWQgc2xvdHMuXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IHdhcyBITVIgdXBkYXRlZCBzbyBzbG90IGNvbnRlbnQgbWF5IGhhdmUgY2hhbmdlZC5cclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHVwZGF0ZSBzbG90cyBhbmQgbWFyayBpbnN0YW5jZSBmb3IgaG1yIGFzIHdlbGxcclxuICAgICAgICAgICAgICAgIGV4dGVuZChzbG90cywgY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGltaXplZCAmJiB0eXBlID09PSAxIC8qIFNUQUJMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gY29tcGlsZWQgQU5EIHN0YWJsZS5cclxuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gdXBkYXRlLCBhbmQgc2tpcCBzdGFsZSBzbG90cyByZW1vdmFsLlxyXG4gICAgICAgICAgICAgICAgbmVlZERlbGV0aW9uQ2hlY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBpbGVkIGJ1dCBkeW5hbWljICh2LWlmL3YtZm9yIG9uIHNsb3RzKSAtIHVwZGF0ZSBzbG90cywgYnV0IHNraXBcclxuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICBleHRlbmQoc2xvdHMsIGNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIC8vICMyODkzXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHJlbmRlcmluZyB0aGUgb3B0aW1pemVkIHNsb3RzIGJ5IG1hbnVhbGx5IHdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxldGUgdGhlIGBzbG90cy5fYCBmbGFnIGlmIG5lY2Vzc2FyeSB0byBtYWtlIHN1YnNlcXVlbnQgdXBkYXRlcyByZWxpYWJsZSxcclxuICAgICAgICAgICAgICAgIC8vIGkuZS4gbGV0IHRoZSBgcmVuZGVyU2xvdGAgY3JlYXRlIHRoZSBiYWlsZWQgRnJhZ21lbnRcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW1pemVkICYmIHR5cGUgPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzLl87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5lZWREZWxldGlvbkNoZWNrID0gIWNoaWxkcmVuLiRzdGFibGU7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZU9iamVjdFNsb3RzKGNoaWxkcmVuLCBzbG90cywgaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgLy8gbm9uIHNsb3Qgb2JqZWN0IGNoaWxkcmVuIChkaXJlY3QgdmFsdWUpIHBhc3NlZCB0byBhIGNvbXBvbmVudFxyXG4gICAgICAgIG5vcm1hbGl6ZVZOb2RlU2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgICAgICBkZWxldGlvbkNvbXBhcmlzb25UYXJnZXQgPSB7IGRlZmF1bHQ6IDEgfTtcclxuICAgIH1cclxuICAgIC8vIGRlbGV0ZSBzdGFsZSBzbG90c1xyXG4gICAgaWYgKG5lZWREZWxldGlvbkNoZWNrKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcclxuICAgICAgICAgICAgaWYgKCFpc0ludGVybmFsS2V5KGtleSkgJiYgIShrZXkgaW4gZGVsZXRpb25Db21wYXJpc29uVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHNsb3RzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5cbi8vIGRldiBvbmx5XHJcbmZ1bmN0aW9uIGluc3RhbGxMZWdhY3lDb25maWdXYXJuaW5ncyhjb25maWcpIHtcclxuICAgIGNvbnN0IGxlZ2FjeUNvbmZpZ09wdGlvbnMgPSB7XHJcbiAgICAgICAgc2lsZW50OiBcIkNPTkZJR19TSUxFTlRcIiAvKiBDT05GSUdfU0lMRU5UICovLFxyXG4gICAgICAgIGRldnRvb2xzOiBcIkNPTkZJR19ERVZUT09MU1wiIC8qIENPTkZJR19ERVZUT09MUyAqLyxcclxuICAgICAgICBpZ25vcmVkRWxlbWVudHM6IFwiQ09ORklHX0lHTk9SRURfRUxFTUVOVFNcIiAvKiBDT05GSUdfSUdOT1JFRF9FTEVNRU5UUyAqLyxcclxuICAgICAgICBrZXlDb2RlczogXCJDT05GSUdfS0VZX0NPREVTXCIgLyogQ09ORklHX0tFWV9DT0RFUyAqLyxcclxuICAgICAgICBwcm9kdWN0aW9uVGlwOiBcIkNPTkZJR19QUk9EVUNUSU9OX1RJUFwiIC8qIENPTkZJR19QUk9EVUNUSU9OX1RJUCAqL1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5rZXlzKGxlZ2FjeUNvbmZpZ09wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBsZXQgdmFsID0gY29uZmlnW2tleV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbmZpZywga2V5LCB7XHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldChuZXdWYWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDb3B5aW5nQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybkRlcHJlY2F0aW9uKGxlZ2FjeUNvbmZpZ09wdGlvbnNba2V5XSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXdWYWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluc3RhbGxMZWdhY3lPcHRpb25NZXJnZVN0cmF0cyhjb25maWcpIHtcclxuICAgIGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXMgPSBuZXcgUHJveHkoe30sIHtcclxuICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoa2V5IGluIGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMgJiZcclxuICAgICAgICAgICAgICAgIHNvZnRBc3NlcnRDb21wYXRFbmFibGVkKFwiQ09ORklHX09QVElPTl9NRVJHRV9TVFJBVFNcIiAvKiBDT05GSUdfT1BUSU9OX01FUkdFX1NUUkFUUyAqLywgbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG5sZXQgaXNDb3B5aW5nQ29uZmlnID0gZmFsc2U7XHJcbi8vIGV4cG9ydGVkIG9ubHkgZm9yIHRlc3RcclxubGV0IHNpbmdsZXRvbkFwcDtcclxubGV0IHNpbmdsZXRvbkN0b3I7XHJcbi8vIExlZ2FjeSBnbG9iYWwgVnVlIGNvbnN0cnVjdG9yXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBhdFZ1ZShjcmVhdGVBcHAsIGNyZWF0ZVNpbmdsZXRvbkFwcCkge1xyXG4gICAgc2luZ2xldG9uQXBwID0gY3JlYXRlU2luZ2xldG9uQXBwKHt9KTtcclxuICAgIGNvbnN0IFZ1ZSA9IChzaW5nbGV0b25DdG9yID0gZnVuY3Rpb24gVnVlKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVDb21wYXRBcHAob3B0aW9ucywgVnVlKTtcclxuICAgIH0pO1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ29tcGF0QXBwKG9wdGlvbnMgPSB7fSwgQ3Rvcikge1xyXG4gICAgICAgIGFzc2VydENvbXBhdEVuYWJsZWQoXCJHTE9CQUxfTU9VTlRcIiAvKiBHTE9CQUxfTU9VTlQgKi8sIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gb3B0aW9ucztcclxuICAgICAgICBpZiAoZGF0YSAmJlxyXG4gICAgICAgICAgICAhaXNGdW5jdGlvbihkYXRhKSAmJlxyXG4gICAgICAgICAgICBzb2Z0QXNzZXJ0Q29tcGF0RW5hYmxlZChcIk9QVElPTlNfREFUQV9GTlwiIC8qIE9QVElPTlNfREFUQV9GTiAqLywgbnVsbCkpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gKCkgPT4gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXBwID0gY3JlYXRlQXBwKG9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChDdG9yICE9PSBWdWUpIHtcclxuICAgICAgICAgICAgYXBwbHlTaW5nbGV0b25Qcm90b3R5cGUoYXBwLCBDdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgdm0gPSBhcHAuX2NyZWF0ZVJvb3Qob3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZtLiRtb3VudChvcHRpb25zLmVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBWdWUudmVyc2lvbiA9IGAyLjYuMTQtY29tcGF0OiR7XCIzLjIuMzdcIn1gO1xyXG4gICAgVnVlLmNvbmZpZyA9IHNpbmdsZXRvbkFwcC5jb25maWc7XHJcbiAgICBWdWUudXNlID0gKHAsIC4uLm9wdGlvbnMpID0+IHtcclxuICAgICAgICBpZiAocCAmJiBpc0Z1bmN0aW9uKHAuaW5zdGFsbCkpIHtcclxuICAgICAgICAgICAgcC5pbnN0YWxsKFZ1ZSwgLi4ub3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocCkpIHtcclxuICAgICAgICAgICAgcChWdWUsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVnVlO1xyXG4gICAgfTtcclxuICAgIFZ1ZS5taXhpbiA9IG0gPT4ge1xyXG4gICAgICAgIHNpbmdsZXRvbkFwcC5taXhpbihtKTtcclxuICAgICAgICByZXR1cm4gVnVlO1xyXG4gICAgfTtcclxuICAgIFZ1ZS5jb21wb25lbnQgPSAoKG5hbWUsIGNvbXApID0+IHtcclxuICAgICAgICBpZiAoY29tcCkge1xyXG4gICAgICAgICAgICBzaW5nbGV0b25BcHAuY29tcG9uZW50KG5hbWUsIGNvbXApO1xyXG4gICAgICAgICAgICByZXR1cm4gVnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZXRvbkFwcC5jb21wb25lbnQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBWdWUuZGlyZWN0aXZlID0gKChuYW1lLCBkaXIpID0+IHtcclxuICAgICAgICBpZiAoZGlyKSB7XHJcbiAgICAgICAgICAgIHNpbmdsZXRvbkFwcC5kaXJlY3RpdmUobmFtZSwgZGlyKTtcclxuICAgICAgICAgICAgcmV0dXJuIFZ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGV0b25BcHAuZGlyZWN0aXZlKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgVnVlLm9wdGlvbnMgPSB7IF9iYXNlOiBWdWUgfTtcclxuICAgIGxldCBjaWQgPSAxO1xyXG4gICAgVnVlLmNpZCA9IGNpZDtcclxuICAgIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xyXG4gICAgY29uc3QgZXh0ZW5kQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgZnVuY3Rpb24gZXh0ZW5kQ3RvcihleHRlbmRPcHRpb25zID0ge30pIHtcclxuICAgICAgICBhc3NlcnRDb21wYXRFbmFibGVkKFwiR0xPQkFMX0VYVEVORFwiIC8qIEdMT0JBTF9FWFRFTkQgKi8sIG51bGwpO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGV4dGVuZE9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zLm9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHRlbmRDYWNoZS5oYXMoZXh0ZW5kT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZENhY2hlLmdldChleHRlbmRPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgU3VwZXIgPSB0aGlzO1xyXG4gICAgICAgIGZ1bmN0aW9uIFN1YlZ1ZShpbmxpbmVPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghaW5saW5lT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBhdEFwcChTdWJWdWUub3B0aW9ucywgU3ViVnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wYXRBcHAobWVyZ2VPcHRpb25zKGV4dGVuZCh7fSwgU3ViVnVlLm9wdGlvbnMpLCBpbmxpbmVPcHRpb25zLCBpbnRlcm5hbE9wdGlvbk1lcmdlU3RyYXRzKSwgU3ViVnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBTdWJWdWUuc3VwZXIgPSBTdXBlcjtcclxuICAgICAgICBTdWJWdWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShWdWUucHJvdG90eXBlKTtcclxuICAgICAgICBTdWJWdWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViVnVlO1xyXG4gICAgICAgIC8vIGNsb25lIG5vbi1wcmltaXRpdmUgYmFzZSBvcHRpb24gdmFsdWVzIGZvciBlZGdlIGNhc2Ugb2YgbXV0YXRpbmdcclxuICAgICAgICAvLyBleHRlbmRlZCBvcHRpb25zXHJcbiAgICAgICAgY29uc3QgbWVyZ2VCYXNlID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gU3VwZXIub3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBzdXBlclZhbHVlID0gU3VwZXIub3B0aW9uc1trZXldO1xyXG4gICAgICAgICAgICBtZXJnZUJhc2Vba2V5XSA9IGlzQXJyYXkoc3VwZXJWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gc3VwZXJWYWx1ZS5zbGljZSgpXHJcbiAgICAgICAgICAgICAgICA6IGlzT2JqZWN0KHN1cGVyVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBleHRlbmQoT2JqZWN0LmNyZWF0ZShudWxsKSwgc3VwZXJWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICA6IHN1cGVyVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFN1YlZ1ZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKG1lcmdlQmFzZSwgZXh0ZW5kT3B0aW9ucywgaW50ZXJuYWxPcHRpb25NZXJnZVN0cmF0cyk7XHJcbiAgICAgICAgU3ViVnVlLm9wdGlvbnMuX2Jhc2UgPSBTdWJWdWU7XHJcbiAgICAgICAgU3ViVnVlLmV4dGVuZCA9IGV4dGVuZEN0b3IuYmluZChTdWJWdWUpO1xyXG4gICAgICAgIFN1YlZ1ZS5taXhpbiA9IFN1cGVyLm1peGluO1xyXG4gICAgICAgIFN1YlZ1ZS51c2UgPSBTdXBlci51c2U7XHJcbiAgICAgICAgU3ViVnVlLmNpZCA9ICsrY2lkO1xyXG4gICAgICAgIGV4dGVuZENhY2hlLnNldChleHRlbmRPcHRpb25zLCBTdWJWdWUpO1xyXG4gICAgICAgIHJldHVybiBTdWJWdWU7XHJcbiAgICB9XHJcbiAgICBWdWUuZXh0ZW5kID0gZXh0ZW5kQ3Rvci5iaW5kKFZ1ZSk7XHJcbiAgICBWdWUuc2V0ID0gKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGFzc2VydENvbXBhdEVuYWJsZWQoXCJHTE9CQUxfU0VUXCIgLyogR0xPQkFMX1NFVCAqLywgbnVsbCk7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBWdWUuZGVsZXRlID0gKHRhcmdldCwga2V5KSA9PiB7XHJcbiAgICAgICAgYXNzZXJ0Q29tcGF0RW5hYmxlZChcIkdMT0JBTF9ERUxFVEVcIiAvKiBHTE9CQUxfREVMRVRFICovLCBudWxsKTtcclxuICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XHJcbiAgICB9O1xyXG4gICAgVnVlLm9ic2VydmFibGUgPSAodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgYXNzZXJ0Q29tcGF0RW5hYmxlZChcIkdMT0JBTF9PQlNFUlZBQkxFXCIgLyogR0xPQkFMX09CU0VSVkFCTEUgKi8sIG51bGwpO1xyXG4gICAgICAgIHJldHVybiByZWFjdGl2ZSh0YXJnZXQpO1xyXG4gICAgfTtcclxuICAgIFZ1ZS5maWx0ZXIgPSAoKG5hbWUsIGZpbHRlcikgPT4ge1xyXG4gICAgICAgIGlmIChmaWx0ZXIpIHtcclxuICAgICAgICAgICAgc2luZ2xldG9uQXBwLmZpbHRlcihuYW1lLCBmaWx0ZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gVnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZXRvbkFwcC5maWx0ZXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBpbnRlcm5hbCB1dGlscyAtIHRoZXNlIGFyZSB0ZWNobmljYWxseSBpbnRlcm5hbCBidXQgc29tZSBwbHVnaW5zIHVzZSBpdC5cclxuICAgIGNvbnN0IHV0aWwgPSB7XHJcbiAgICAgICAgd2FybjogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gd2FybiQxIDogTk9PUCxcclxuICAgICAgICBleHRlbmQsXHJcbiAgICAgICAgbWVyZ2VPcHRpb25zOiAocGFyZW50LCBjaGlsZCwgdm0pID0+IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSA/IHVuZGVmaW5lZCA6IGludGVybmFsT3B0aW9uTWVyZ2VTdHJhdHMpLFxyXG4gICAgICAgIGRlZmluZVJlYWN0aXZlXHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ3V0aWwnLCB7XHJcbiAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICBhc3NlcnRDb21wYXRFbmFibGVkKFwiR0xPQkFMX1BSSVZBVEVfVVRJTFwiIC8qIEdMT0JBTF9QUklWQVRFX1VUSUwgKi8sIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIFZ1ZS5jb25maWd1cmVDb21wYXQgPSBjb25maWd1cmVDb21wYXQ7XHJcbiAgICByZXR1cm4gVnVlO1xyXG59XHJcbmZ1bmN0aW9uIGluc3RhbGxBcHBDb21wYXRQcm9wZXJ0aWVzKGFwcCwgY29udGV4dCwgcmVuZGVyKSB7XHJcbiAgICBpbnN0YWxsRmlsdGVyTWV0aG9kKGFwcCwgY29udGV4dCk7XHJcbiAgICBpbnN0YWxsTGVnYWN5T3B0aW9uTWVyZ2VTdHJhdHMoYXBwLmNvbmZpZyk7XHJcbiAgICBpZiAoIXNpbmdsZXRvbkFwcCkge1xyXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGNhbGwgb2YgY3JlYXRpbmcgdGhlIHNpbmdsZXRvbiBpdHNlbGYgc28gdGhlIHJlc3QgaXNcclxuICAgICAgICAvLyB1bm5lY2Vzc2FyeVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGluc3RhbGxDb21wYXRNb3VudChhcHAsIGNvbnRleHQsIHJlbmRlcik7XHJcbiAgICBpbnN0YWxsTGVnYWN5QVBJcyhhcHApO1xyXG4gICAgYXBwbHlTaW5nbGV0b25BcHBNdXRhdGlvbnMoYXBwKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXHJcbiAgICAgICAgaW5zdGFsbExlZ2FjeUNvbmZpZ1dhcm5pbmdzKGFwcC5jb25maWcpO1xyXG59XHJcbmZ1bmN0aW9uIGluc3RhbGxGaWx0ZXJNZXRob2QoYXBwLCBjb250ZXh0KSB7XHJcbiAgICBjb250ZXh0LmZpbHRlcnMgPSB7fTtcclxuICAgIGFwcC5maWx0ZXIgPSAobmFtZSwgZmlsdGVyKSA9PiB7XHJcbiAgICAgICAgYXNzZXJ0Q29tcGF0RW5hYmxlZChcIkZJTFRFUlNcIiAvKiBGSUxURVJTICovLCBudWxsKTtcclxuICAgICAgICBpZiAoIWZpbHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5maWx0ZXJzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuZmlsdGVyc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYEZpbHRlciBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuZmlsdGVyc1tuYW1lXSA9IGZpbHRlcjtcclxuICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBpbnN0YWxsTGVnYWN5QVBJcyhhcHApIHtcclxuICAgIC8vIGV4cG9zZSBnbG9iYWwgQVBJIG9uIGFwcCBpbnN0YW5jZSBmb3IgbGVnYWN5IHBsdWdpbnNcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwcCwge1xyXG4gICAgICAgIC8vIHNvIHRoYXQgYXBwLnVzZSgpIGNhbiB3b3JrIHdpdGggbGVnYWN5IHBsdWdpbnMgdGhhdCBleHRlbmQgcHJvdG90eXBlc1xyXG4gICAgICAgIHByb3RvdHlwZToge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybkRlcHJlY2F0aW9uKFwiR0xPQkFMX1BST1RPVFlQRVwiIC8qIEdMT0JBTF9QUk9UT1RZUEUgKi8sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcC5jb25maWcuZ2xvYmFsUHJvcGVydGllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dFRpY2s6IHsgdmFsdWU6IG5leHRUaWNrIH0sXHJcbiAgICAgICAgZXh0ZW5kOiB7IHZhbHVlOiBzaW5nbGV0b25DdG9yLmV4dGVuZCB9LFxyXG4gICAgICAgIHNldDogeyB2YWx1ZTogc2luZ2xldG9uQ3Rvci5zZXQgfSxcclxuICAgICAgICBkZWxldGU6IHsgdmFsdWU6IHNpbmdsZXRvbkN0b3IuZGVsZXRlIH0sXHJcbiAgICAgICAgb2JzZXJ2YWJsZTogeyB2YWx1ZTogc2luZ2xldG9uQ3Rvci5vYnNlcnZhYmxlIH0sXHJcbiAgICAgICAgdXRpbDoge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luZ2xldG9uQ3Rvci51dGlsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlTaW5nbGV0b25BcHBNdXRhdGlvbnMoYXBwKSB7XHJcbiAgICAvLyBjb3B5IG92ZXIgYXNzZXQgcmVnaXN0cmllcyBhbmQgZGVvcHQgZmxhZ1xyXG4gICAgYXBwLl9jb250ZXh0Lm1peGlucyA9IFsuLi5zaW5nbGV0b25BcHAuX2NvbnRleHQubWl4aW5zXTtcclxuICAgIFsnY29tcG9uZW50cycsICdkaXJlY3RpdmVzJywgJ2ZpbHRlcnMnXS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGFwcC5fY29udGV4dFtrZXldID0gT2JqZWN0LmNyZWF0ZShzaW5nbGV0b25BcHAuX2NvbnRleHRba2V5XSk7XHJcbiAgICB9KTtcclxuICAgIC8vIGNvcHkgb3ZlciBnbG9iYWwgY29uZmlnIG11dGF0aW9uc1xyXG4gICAgaXNDb3B5aW5nQ29uZmlnID0gdHJ1ZTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIHNpbmdsZXRvbkFwcC5jb25maWcpIHtcclxuICAgICAgICBpZiAoa2V5ID09PSAnaXNOYXRpdmVUYWcnKVxyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBpZiAoaXNSdW50aW1lT25seSgpICYmXHJcbiAgICAgICAgICAgIChrZXkgPT09ICdpc0N1c3RvbUVsZW1lbnQnIHx8IGtleSA9PT0gJ2NvbXBpbGVyT3B0aW9ucycpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2YWwgPSBzaW5nbGV0b25BcHAuY29uZmlnW2tleV07XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGFwcC5jb25maWdba2V5XSA9IGlzT2JqZWN0KHZhbCkgPyBPYmplY3QuY3JlYXRlKHZhbCkgOiB2YWw7XHJcbiAgICAgICAgLy8gY29tcGF0IGZvciBydW50aW1lIGlnbm9yZWRFbGVtZW50cyAtPiBpc0N1c3RvbUVsZW1lbnRcclxuICAgICAgICBpZiAoa2V5ID09PSAnaWdub3JlZEVsZW1lbnRzJyAmJlxyXG4gICAgICAgICAgICBpc0NvbXBhdEVuYWJsZWQoXCJDT05GSUdfSUdOT1JFRF9FTEVNRU5UU1wiIC8qIENPTkZJR19JR05PUkVEX0VMRU1FTlRTICovLCBudWxsKSAmJlxyXG4gICAgICAgICAgICAhaXNSdW50aW1lT25seSgpICYmXHJcbiAgICAgICAgICAgIGlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICBhcHAuY29uZmlnLmNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQgPSB0YWcgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5zb21lKHYgPT4gKGlzU3RyaW5nKHYpID8gdiA9PT0gdGFnIDogdi50ZXN0KHRhZykpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvcHlpbmdDb25maWcgPSBmYWxzZTtcclxuICAgIGFwcGx5U2luZ2xldG9uUHJvdG90eXBlKGFwcCwgc2luZ2xldG9uQ3Rvcik7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlTaW5nbGV0b25Qcm90b3R5cGUoYXBwLCBDdG9yKSB7XHJcbiAgICAvLyBjb3B5IHByb3RvdHlwZSBhdWdtZW50YXRpb25zIGFzIGNvbmZpZy5nbG9iYWxQcm9wZXJ0aWVzXHJcbiAgICBjb25zdCBlbmFibGVkID0gaXNDb21wYXRFbmFibGVkKFwiR0xPQkFMX1BST1RPVFlQRVwiIC8qIEdMT0JBTF9QUk9UT1RZUEUgKi8sIG51bGwpO1xyXG4gICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICBhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKEN0b3IucHJvdG90eXBlKTtcclxuICAgIH1cclxuICAgIGxldCBoYXNQcm90b3R5cGVBdWdtZW50YXRpb25zID0gZmFsc2U7XHJcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKEN0b3IucHJvdG90eXBlKTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2NyaXB0b3JzKSB7XHJcbiAgICAgICAgaWYgKGtleSAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgICBoYXNQcm90b3R5cGVBdWdtZW50YXRpb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIGtleSwgZGVzY3JpcHRvcnNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGhhc1Byb3RvdHlwZUF1Z21lbnRhdGlvbnMpIHtcclxuICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJHTE9CQUxfUFJPVE9UWVBFXCIgLyogR0xPQkFMX1BST1RPVFlQRSAqLywgbnVsbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaW5zdGFsbENvbXBhdE1vdW50KGFwcCwgY29udGV4dCwgcmVuZGVyKSB7XHJcbiAgICBsZXQgaXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICAvKipcclxuICAgICAqIFZ1ZSAyIHN1cHBvcnRzIHRoZSBiZWhhdmlvciBvZiBjcmVhdGluZyBhIGNvbXBvbmVudCBpbnN0YW5jZSBidXQgbm90XHJcbiAgICAgKiBtb3VudGluZyBpdCwgd2hpY2ggaXMgbm8gbG9uZ2VyIHBvc3NpYmxlIGluIFZ1ZSAzIC0gdGhpcyBpbnRlcm5hbFxyXG4gICAgICogZnVuY3Rpb24gc2ltdWxhdGVzIHRoYXQgYmVoYXZpb3IuXHJcbiAgICAgKi9cclxuICAgIGFwcC5fY3JlYXRlUm9vdCA9IG9wdGlvbnMgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFwcC5fY29tcG9uZW50O1xyXG4gICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoY29tcG9uZW50LCBvcHRpb25zLnByb3BzRGF0YSB8fCBudWxsKTtcclxuICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICBjb25zdCBoYXNOb1JlbmRlciA9ICFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZTtcclxuICAgICAgICBjb25zdCBlbXB0eVJlbmRlciA9ICgpID0+IHsgfTtcclxuICAgICAgICAvLyBjcmVhdGUgcm9vdCBpbnN0YW5jZVxyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIC8vIHN1cHByZXNzIFwibWlzc2luZyByZW5kZXIgZm5cIiB3YXJuaW5nIHNpbmNlIGl0IGNhbid0IGJlIGRldGVybWluZWRcclxuICAgICAgICAvLyB1bnRpbCAkbW91bnQgaXMgY2FsbGVkXHJcbiAgICAgICAgaWYgKGhhc05vUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IGVtcHR5UmVuZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR1cENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICAgICAgdm5vZGUuY29tcG9uZW50ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgdm5vZGUuaXNDb21wYXRSb290ID0gdHJ1ZTtcclxuICAgICAgICAvLyAkbW91bnQgJiAkZGVzdHJveVxyXG4gICAgICAgIC8vIHRoZXNlIGFyZSBkZWZpbmVkIG9uIGN0eCBhbmQgcGlja2VkIHVwIGJ5IHRoZSAkbW91bnQvJGRlc3Ryb3lcclxuICAgICAgICAvLyBwdWJsaWMgcHJvcGVydHkgZ2V0dGVycyBvbiB0aGUgaW5zdGFuY2UgcHJveHkuXHJcbiAgICAgICAgLy8gTm90ZTogdGhlIGZvbGxvd2luZyBhc3N1bWVzIERPTSBlbnZpcm9ubWVudCBzaW5jZSB0aGUgY29tcGF0IGJ1aWxkXHJcbiAgICAgICAgLy8gb25seSB0YXJnZXRzIHdlYi4gSXQgZXNzZW50aWFsbHkgaW5jbHVkZXMgbG9naWMgZm9yIGFwcC5tb3VudCBmcm9tXHJcbiAgICAgICAgLy8gYm90aCBydW50aW1lLWNvcmUgQU5EIHJ1bnRpbWUtZG9tLlxyXG4gICAgICAgIGluc3RhbmNlLmN0eC5fY29tcGF0X21vdW50ID0gKHNlbGVjdG9yT3JFbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgd2FybiQxKGBSb290IGluc3RhbmNlIGlzIGFscmVhZHkgbW91bnRlZC5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY29udGFpbmVyO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yT3JFbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvck9yRWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQxKGBGYWlsZWQgdG8gbW91bnQgcm9vdCBpbnN0YW5jZTogc2VsZWN0b3IgXCIke3NlbGVjdG9yT3JFbH1cIiByZXR1cm5lZCBudWxsLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gc2VsZWN0b3JPckVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGlzU1ZHID0gY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuICAgICAgICAgICAgLy8gSE1SIHJvb3QgcmVsb2FkXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lZCA9IGNsb25lVk5vZGUodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBhdCBtb2RlIHdpbGwgdXNlIGluc3RhbmNlIGlmIG5vdCByZXNldCB0byBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmNvbXBvbmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lZCwgY29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlc29sdmUgaW4tRE9NIHRlbXBsYXRlIGlmIGNvbXBvbmVudCBkaWQgbm90IHByb3ZpZGUgcmVuZGVyXHJcbiAgICAgICAgICAgIC8vIGFuZCBubyBzZXR1cC9taXhpbiByZW5kZXIgZnVuY3Rpb25zIGFyZSBwcm92aWRlZCAoYnkgY2hlY2tpbmdcclxuICAgICAgICAgICAgLy8gdGhhdCB0aGUgaW5zdGFuY2UgaXMgc3RpbGwgdXNpbmcgdGhlIHBsYWNlaG9sZGVyIHJlbmRlciBmbilcclxuICAgICAgICAgICAgaWYgKGhhc05vUmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gZW1wdHlSZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJvb3QgZGlyZWN0aXZlcyBjaGVja1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVyLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGNvbnRhaW5lci5hdHRyaWJ1dGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lICE9PSAndi1jbG9haycgJiYgL14odi18OnxAKS8udGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuRGVwcmVjYXRpb24oXCJHTE9CQUxfTU9VTlRfQ09OVEFJTkVSXCIgLyogR0xPQkFMX01PVU5UX0NPTlRBSU5FUiAqLywgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudGVtcGxhdGUgPSBjb250YWluZXIuaW5uZXJIVE1MO1xyXG4gICAgICAgICAgICAgICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGZhbHNlLCB0cnVlIC8qIHNraXAgb3B0aW9ucyAqLyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2xlYXIgY29udGVudCBiZWZvcmUgbW91bnRpbmdcclxuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgICAgICAvLyBUT0RPIGh5ZHJhdGlvblxyXG4gICAgICAgICAgICByZW5kZXIodm5vZGUsIGNvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbmVyIGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS12LWFwcCcsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBhcHAuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAgICAgY29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgZGV2dG9vbHNJbml0QXBwKGFwcCwgdmVyc2lvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3h5O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4Ll9jb21wYXRfZGVzdHJveSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgYXBwLl9jb250YWluZXIuX192dWVfYXBwX187XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJ1bSwgc2NvcGUsIHVtIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIC8vIGJlZm9yZURlc3Ryb3kgaG9va3NcclxuICAgICAgICAgICAgICAgIGlmIChidW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhidW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIklOU1RBTkNFX0VWRU5UX0hPT0tTXCIgLyogSU5TVEFOQ0VfRVZFTlRfSE9PS1MgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmVtaXQoJ2hvb2s6YmVmb3JlRGVzdHJveScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3RvcCBlZmZlY3RzXHJcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB1bm1vdW50ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnModW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIklOU1RBTkNFX0VWRU5UX0hPT0tTXCIgLyogSU5TVEFOQ0VfRVZFTlRfSE9PS1MgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmVtaXQoJ2hvb2s6ZGVzdHJveWVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5wcm94eTtcclxuICAgIH07XHJcbn1cclxuY29uc3QgbWV0aG9kc1RvUGF0Y2ggPSBbXHJcbiAgICAncHVzaCcsXHJcbiAgICAncG9wJyxcclxuICAgICdzaGlmdCcsXHJcbiAgICAndW5zaGlmdCcsXHJcbiAgICAnc3BsaWNlJyxcclxuICAgICdzb3J0JyxcclxuICAgICdyZXZlcnNlJ1xyXG5dO1xyXG5jb25zdCBwYXRjaGVkID0gbmV3IFdlYWtTZXQoKTtcclxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUob2JqLCBrZXksIHZhbCkge1xyXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIG9yaWdpbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIGFmdGVyIGJlaW5nIGRlZmluZWRcclxuICAgIC8vIGFuZCBleHBlY3RpbmcgcmVhY3Rpdml0eS4uLiB3ZSBhcmUgY292ZXJpbmcgaXQgaGVyZSBiZWNhdXNlIHRoaXMgc2VlbXMgdG9cclxuICAgIC8vIGJlIGEgYml0IG1vcmUgY29tbW9uLlxyXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkgJiYgIWlzUmVhY3RpdmUodmFsKSAmJiAhcGF0Y2hlZC5oYXModmFsKSkge1xyXG4gICAgICAgIGNvbnN0IHJlYWN0aXZlVmFsID0gcmVhY3RpdmUodmFsKTtcclxuICAgICAgICBpZiAoaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZHNUb1BhdGNoLmZvckVhY2gobSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICB2YWxbbV0gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGVbbV0uY2FsbChyZWFjdGl2ZVZhbCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbCkuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZVNpbXBsZSh2YWwsIGtleSwgdmFsW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBpID0gb2JqLiQ7XHJcbiAgICBpZiAoaSAmJiBvYmogPT09IGkucHJveHkpIHtcclxuICAgICAgICAvLyB0YXJnZXQgaXMgYSBWdWUgaW5zdGFuY2UgLSBkZWZpbmUgb24gaW5zdGFuY2UuY3R4XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmVTaW1wbGUoaS5jdHgsIGtleSwgdmFsKTtcclxuICAgICAgICBpLmFjY2Vzc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xyXG4gICAgICAgIG9ialtrZXldID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVmaW5lUmVhY3RpdmVTaW1wbGUob2JqLCBrZXksIHZhbCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmVTaW1wbGUob2JqLCBrZXksIHZhbCkge1xyXG4gICAgdmFsID0gaXNPYmplY3QodmFsKSA/IHJlYWN0aXZlKHZhbCkgOiB2YWw7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgIHRyYWNrKG9iaiwgXCJnZXRcIiAvKiBHRVQgKi8sIGtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQobmV3VmFsKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IGlzT2JqZWN0KG5ld1ZhbCkgPyByZWFjdGl2ZShuZXdWYWwpIDogbmV3VmFsO1xyXG4gICAgICAgICAgICB0cmlnZ2VyKG9iaiwgXCJzZXRcIiAvKiBTRVQgKi8sIGtleSwgbmV3VmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcHBDb250ZXh0KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhcHA6IG51bGwsXHJcbiAgICAgICAgY29uZmlnOiB7XHJcbiAgICAgICAgICAgIGlzTmF0aXZlVGFnOiBOTyxcclxuICAgICAgICAgICAgcGVyZm9ybWFuY2U6IGZhbHNlLFxyXG4gICAgICAgICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcclxuICAgICAgICAgICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiB7fSxcclxuICAgICAgICAgICAgZXJyb3JIYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHdhcm5IYW5kbGVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGNvbXBpbGVyT3B0aW9uczoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIG1peGluczogW10sXHJcbiAgICAgICAgY29tcG9uZW50czoge30sXHJcbiAgICAgICAgZGlyZWN0aXZlczoge30sXHJcbiAgICAgICAgcHJvdmlkZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAgICAgb3B0aW9uc0NhY2hlOiBuZXcgV2Vha01hcCgpLFxyXG4gICAgICAgIHByb3BzQ2FjaGU6IG5ldyBXZWFrTWFwKCksXHJcbiAgICAgICAgZW1pdHNDYWNoZTogbmV3IFdlYWtNYXAoKVxyXG4gICAgfTtcclxufVxyXG5sZXQgdWlkID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQXBwQVBJKHJlbmRlciwgaHlkcmF0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUFwcChyb290Q29tcG9uZW50LCByb290UHJvcHMgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJvb3RDb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIHJvb3RDb21wb25lbnQgPSBPYmplY3QuYXNzaWduKHt9LCByb290Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvb3RQcm9wcyAhPSBudWxsICYmICFpc09iamVjdChyb290UHJvcHMpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB3YXJuJDEoYHJvb3QgcHJvcHMgcGFzc2VkIHRvIGFwcC5tb3VudCgpIG11c3QgYmUgYW4gb2JqZWN0LmApO1xyXG4gICAgICAgICAgICByb290UHJvcHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQXBwQ29udGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGluc3RhbGxlZFBsdWdpbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgbGV0IGlzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGFwcCA9IChjb250ZXh0LmFwcCA9IHtcclxuICAgICAgICAgICAgX3VpZDogdWlkKyssXHJcbiAgICAgICAgICAgIF9jb21wb25lbnQ6IHJvb3RDb21wb25lbnQsXHJcbiAgICAgICAgICAgIF9wcm9wczogcm9vdFByb3BzLFxyXG4gICAgICAgICAgICBfY29udGFpbmVyOiBudWxsLFxyXG4gICAgICAgICAgICBfY29udGV4dDogY29udGV4dCxcclxuICAgICAgICAgICAgX2luc3RhbmNlOiBudWxsLFxyXG4gICAgICAgICAgICB2ZXJzaW9uLFxyXG4gICAgICAgICAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uZmlnO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQgY29uZmlnKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYGFwcC5jb25maWcgY2Fubm90IGJlIHJlcGxhY2VkLiBNb2RpZnkgaW5kaXZpZHVhbCBvcHRpb25zIGluc3RlYWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVzZShwbHVnaW4sIC4uLm9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmhhcyhwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4kMShgUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGx1Z2luICYmIGlzRnVuY3Rpb24ocGx1Z2luLmluc3RhbGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uaW5zdGFsbChhcHAsIC4uLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5hZGQocGx1Z2luKTtcclxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4oYXBwLCAuLi5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgQSBwbHVnaW4gbXVzdCBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgd2l0aCBhbiBcImluc3RhbGxcIiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGZ1bmN0aW9uLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWl4aW4obWl4aW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0Lm1peGlucy5pbmNsdWRlcyhtaXhpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5taXhpbnMucHVzaChtaXhpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDEoJ01peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWl4aW4ubmFtZSA/IGA6ICR7bWl4aW4ubmFtZX1gIDogJycpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDEoJ01peGlucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYnVpbGRzIHN1cHBvcnRpbmcgT3B0aW9ucyBBUEknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbXBvbmVudChuYW1lLCBjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29udGV4dC5jb25maWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wb25lbnRzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBjb250ZXh0LmNvbXBvbmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYENvbXBvbmVudCBcIiR7bmFtZX1cIiBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgaW4gdGFyZ2V0IGFwcC5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuY29tcG9uZW50c1tuYW1lXSA9IGNvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcHA7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRpcmVjdGl2ZShuYW1lLCBkaXJlY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpcmVjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpcmVjdGl2ZXNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGNvbnRleHQuZGlyZWN0aXZlc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgRGlyZWN0aXZlIFwiJHtuYW1lfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXJlY3RpdmVzW25hbWVdID0gZGlyZWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbW91bnQocm9vdENvbnRhaW5lciwgaXNIeWRyYXRlLCBpc1NWRykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjNTU3MVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgcm9vdENvbnRhaW5lci5fX3Z1ZV9hcHBfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYFRoZXJlIGlzIGFscmVhZHkgYW4gYXBwIGluc3RhbmNlIG1vdW50ZWQgb24gdGhlIGhvc3QgY29udGFpbmVyLlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCBJZiB5b3Ugd2FudCB0byBtb3VudCBhbm90aGVyIGFwcCBvbiB0aGUgc2FtZSBob3N0IGNvbnRhaW5lcixgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAgeW91IG5lZWQgdG8gdW5tb3VudCB0aGUgcHJldmlvdXMgYXBwIGJ5IGNhbGxpbmcgXFxgYXBwLnVubW91bnQoKVxcYCBmaXJzdC5gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVWTm9kZShyb290Q29tcG9uZW50LCByb290UHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIGFwcCBjb250ZXh0IG9uIHRoZSByb290IFZOb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBzZXQgb24gdGhlIHJvb3QgaW5zdGFuY2Ugb24gaW5pdGlhbCBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5hcHBDb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBITVIgcm9vdCByZWxvYWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVsb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNsb25lVk5vZGUodm5vZGUpLCByb290Q29udGFpbmVyLCBpc1NWRyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0h5ZHJhdGUgJiYgaHlkcmF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoeWRyYXRlKHZub2RlLCByb290Q29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcih2bm9kZSwgcm9vdENvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcC5fY29udGFpbmVyID0gcm9vdENvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICByb290Q29udGFpbmVyLl9fdnVlX2FwcF9fID0gYXBwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5faW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldnRvb2xzSW5pdEFwcChhcHAsIHZlcnNpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYEFwcCBoYXMgYWxyZWFkeSBiZWVuIG1vdW50ZWQuXFxuYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3Ugd2FudCB0byByZW1vdW50IHRoZSBzYW1lIGFwcCwgbW92ZSB5b3VyIGFwcCBjcmVhdGlvbiBsb2dpYyBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYG1vdW50IC0gZS5nLiBcXGBjb25zdCBjcmVhdGVNeUFwcCA9ICgpID0+IGNyZWF0ZUFwcChBcHApXFxgYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVubW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIGFwcC5fY29udGFpbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHAuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2dG9vbHNVbm1vdW50QXBwKGFwcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcHAuX2NvbnRhaW5lci5fX3Z1ZV9hcHBfXztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgQ2Fubm90IHVubW91bnQgYW4gYXBwIHRoYXQgaXMgbm90IG1vdW50ZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByb3ZpZGUoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXkgaW4gY29udGV4dC5wcm92aWRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgQXBwIGFscmVhZHkgcHJvdmlkZXMgcHJvcGVydHkgd2l0aCBrZXkgXCIke1N0cmluZyhrZXkpfVwiLiBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5wcm92aWRlc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnN0YWxsQXBwQ29tcGF0UHJvcGVydGllcyhhcHAsIGNvbnRleHQsIHJlbmRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcHA7XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBGdW5jdGlvbiBmb3IgaGFuZGxpbmcgYSB0ZW1wbGF0ZSByZWZcclxuICovXHJcbmZ1bmN0aW9uIHNldFJlZihyYXdSZWYsIG9sZFJhd1JlZiwgcGFyZW50U3VzcGVuc2UsIHZub2RlLCBpc1VubW91bnQgPSBmYWxzZSkge1xyXG4gICAgaWYgKGlzQXJyYXkocmF3UmVmKSkge1xyXG4gICAgICAgIHJhd1JlZi5mb3JFYWNoKChyLCBpKSA9PiBzZXRSZWYociwgb2xkUmF3UmVmICYmIChpc0FycmF5KG9sZFJhd1JlZikgPyBvbGRSYXdSZWZbaV0gOiBvbGRSYXdSZWYpLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUsIGlzVW5tb3VudCkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc0FzeW5jV3JhcHBlcih2bm9kZSkgJiYgIWlzVW5tb3VudCkge1xyXG4gICAgICAgIC8vIHdoZW4gbW91bnRpbmcgYXN5bmMgY29tcG9uZW50cywgbm90aGluZyBuZWVkcyB0byBiZSBkb25lLFxyXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIHRlbXBsYXRlIHJlZiBpcyBmb3J3YXJkZWQgdG8gaW5uZXIgY29tcG9uZW50XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVmVmFsdWUgPSB2bm9kZS5zaGFwZUZsYWcgJiA0IC8qIFNUQVRFRlVMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgID8gZ2V0RXhwb3NlUHJveHkodm5vZGUuY29tcG9uZW50KSB8fCB2bm9kZS5jb21wb25lbnQucHJveHlcclxuICAgICAgICA6IHZub2RlLmVsO1xyXG4gICAgY29uc3QgdmFsdWUgPSBpc1VubW91bnQgPyBudWxsIDogcmVmVmFsdWU7XHJcbiAgICBjb25zdCB7IGk6IG93bmVyLCByOiByZWYgfSA9IHJhd1JlZjtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIW93bmVyKSB7XHJcbiAgICAgICAgd2FybiQxKGBNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIGAgK1xyXG4gICAgICAgICAgICBgQSB2bm9kZSB3aXRoIHJlZiBtdXN0IGJlIGNyZWF0ZWQgaW5zaWRlIHRoZSByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb2xkUmVmID0gb2xkUmF3UmVmICYmIG9sZFJhd1JlZi5yO1xyXG4gICAgY29uc3QgcmVmcyA9IG93bmVyLnJlZnMgPT09IEVNUFRZX09CSiA/IChvd25lci5yZWZzID0ge30pIDogb3duZXIucmVmcztcclxuICAgIGNvbnN0IHNldHVwU3RhdGUgPSBvd25lci5zZXR1cFN0YXRlO1xyXG4gICAgLy8gZHluYW1pYyByZWYgY2hhbmdlZC4gdW5zZXQgb2xkIHJlZlxyXG4gICAgaWYgKG9sZFJlZiAhPSBudWxsICYmIG9sZFJlZiAhPT0gcmVmKSB7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgcmVmc1tvbGRSZWZdID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCBvbGRSZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR1cFN0YXRlW29sZFJlZl0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVmKG9sZFJlZikpIHtcclxuICAgICAgICAgICAgb2xkUmVmLnZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNGdW5jdGlvbihyZWYpKSB7XHJcbiAgICAgICAgY2FsbFdpdGhFcnJvckhhbmRsaW5nKHJlZiwgb3duZXIsIDEyIC8qIEZVTkNUSU9OX1JFRiAqLywgW3ZhbHVlLCByZWZzXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBfaXNTdHJpbmcgPSBpc1N0cmluZyhyZWYpO1xyXG4gICAgICAgIGNvbnN0IF9pc1JlZiA9IGlzUmVmKHJlZik7XHJcbiAgICAgICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9TZXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmF3UmVmLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IF9pc1N0cmluZyA/IHJlZnNbcmVmXSA6IHJlZi52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbm1vdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZShleGlzdGluZywgcmVmVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1N0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihzZXR1cFN0YXRlLCByZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU3RhdGVbcmVmXSA9IHJlZnNbcmVmXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYudmFsdWUgPSBbcmVmVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYXdSZWYuaylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyYXdSZWYua10gPSByZWYudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucHVzaChyZWZWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWZzW3JlZl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHNldHVwU3RhdGUsIHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTdGF0ZVtyZWZdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2lzUmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd1JlZi5rKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzW3Jhd1JlZi5rXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQxKCdJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOicsIHJlZiwgYCgke3R5cGVvZiByZWZ9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRvU2V0LmlkID0gLTE7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoZG9TZXQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvU2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMSgnSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTonLCByZWYsIGAoJHt0eXBlb2YgcmVmfSlgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxubGV0IGhhc01pc21hdGNoID0gZmFsc2U7XHJcbmNvbnN0IGlzU1ZHQ29udGFpbmVyID0gKGNvbnRhaW5lcikgPT4gL3N2Zy8udGVzdChjb250YWluZXIubmFtZXNwYWNlVVJJKSAmJiBjb250YWluZXIudGFnTmFtZSAhPT0gJ2ZvcmVpZ25PYmplY3QnO1xyXG5jb25zdCBpc0NvbW1lbnQgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBDT01NRU5UICovO1xyXG4vLyBOb3RlOiBoeWRyYXRpb24gaXMgRE9NLXNwZWNpZmljXHJcbi8vIEJ1dCB3ZSBoYXZlIHRvIHBsYWNlIGl0IGluIGNvcmUgZHVlIHRvIHRpZ2h0IGNvdXBsaW5nIHdpdGggY29yZSAtIHNwbGl0dGluZ1xyXG4vLyBpdCBvdXQgY3JlYXRlcyBhIHRvbiBvZiB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxyXG4vLyBIeWRyYXRpb24gYWxzbyBkZXBlbmRzIG9uIHNvbWUgcmVuZGVyZXIgaW50ZXJuYWwgbG9naWMgd2hpY2ggbmVlZHMgdG8gYmVcclxuLy8gcGFzc2VkIGluIHZpYSBhcmd1bWVudHMuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkZ1bmN0aW9ucyhyZW5kZXJlckludGVybmFscykge1xyXG4gICAgY29uc3QgeyBtdDogbW91bnRDb21wb25lbnQsIHA6IHBhdGNoLCBvOiB7IHBhdGNoUHJvcCwgY3JlYXRlVGV4dCwgbmV4dFNpYmxpbmcsIHBhcmVudE5vZGUsIHJlbW92ZSwgaW5zZXJ0LCBjcmVhdGVDb21tZW50IH0gfSA9IHJlbmRlcmVySW50ZXJuYWxzO1xyXG4gICAgY29uc3QgaHlkcmF0ZSA9ICh2bm9kZSwgY29udGFpbmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBBdHRlbXB0aW5nIHRvIGh5ZHJhdGUgZXhpc3RpbmcgbWFya3VwIGJ1dCBjb250YWluZXIgaXMgZW1wdHkuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5gKTtcclxuICAgICAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGZsdXNoUG9zdEZsdXNoQ2JzKCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5fdm5vZGUgPSB2bm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoYXNNaXNtYXRjaCA9IGZhbHNlO1xyXG4gICAgICAgIGh5ZHJhdGVOb2RlKGNvbnRhaW5lci5maXJzdENoaWxkLCB2bm9kZSwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKGhhc01pc21hdGNoICYmICFmYWxzZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGVycm9yIHNob3VsZCBzaG93IHVwIGluIHByb2R1Y3Rpb25cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSHlkcmF0aW9uIGNvbXBsZXRlZCBidXQgY29udGFpbnMgbWlzbWF0Y2hlcy5gKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZU5vZGUgPSAobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCBpc0ZyYWdtZW50U3RhcnQgPSBpc0NvbW1lbnQobm9kZSkgJiYgbm9kZS5kYXRhID09PSAnWyc7XHJcbiAgICAgICAgY29uc3Qgb25NaXNtYXRjaCA9ICgpID0+IGhhbmRsZU1pc21hdGNoKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnRTdGFydCk7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCByZWYsIHNoYXBlRmxhZywgcGF0Y2hGbGFnIH0gPSB2bm9kZTtcclxuICAgICAgICBjb25zdCBkb21UeXBlID0gbm9kZS5ub2RlVHlwZTtcclxuICAgICAgICB2bm9kZS5lbCA9IG5vZGU7XHJcbiAgICAgICAgaWYgKHBhdGNoRmxhZyA9PT0gLTIgLyogQkFJTCAqLykge1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdm5vZGUuZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5leHROb2RlID0gbnVsbDtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBUZXh0OlxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbVR5cGUgIT09IDMgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICM1NzI4IGVtcHR5IHRleHQgbm9kZSBpbnNpZGUgYSBzbG90IGNhbiBjYXVzZSBoeWRyYXRpb24gZmFpbHVyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIHdvbid0IGNvbnRhaW4gYSB0ZXh0IG5vZGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodm5vZGUuY2hpbGRyZW4gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCgodm5vZGUuZWwgPSBjcmVhdGVUZXh0KCcnKSksIHBhcmVudE5vZGUobm9kZSksIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhICE9PSB2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQxKGBIeWRyYXRpb24gdGV4dCBtaXNtYXRjaDpgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBDbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkobm9kZS5kYXRhKX1gICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFxuLSBTZXJ2ZXI6ICR7SlNPTi5zdHJpbmdpZnkodm5vZGUuY2hpbGRyZW4pfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovIHx8IGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFN0YXRpYzpcclxuICAgICAgICAgICAgICAgIGlmIChkb21UeXBlICE9PSAxIC8qIEVMRU1FTlQgKi8gJiYgZG9tVHlwZSAhPT0gMyAvKiBURVhUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBvbk1pc21hdGNoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgYW5jaG9yLCBhZG9wdCBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0aWMgdm5vZGUgaGFzIGl0cyBjb250ZW50IHN0cmlwcGVkIGR1cmluZyBidWlsZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZG9wdCBpdCBmcm9tIHRoZSBzZXJ2ZXItcmVuZGVyZWQgSFRNTC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWVkVG9BZG9wdENvbnRlbnQgPSAhdm5vZGUuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuc3RhdGljQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZFRvQWRvcHRDb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW4gKz1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBFTEVNRU5UICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV4dE5vZGUub3V0ZXJIVE1MXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV4dE5vZGUuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZub2RlLnN0YXRpY0NvdW50IC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEZyYWdtZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0ZyYWdtZW50U3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IG9uTWlzbWF0Y2goKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gaHlkcmF0ZUZyYWdtZW50KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxIC8qIEVMRU1FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gMSAvKiBFTEVNRU5UICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnR5cGUudG9Mb3dlckNhc2UoKSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBoeWRyYXRlRWxlbWVudChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBzZXR0aW5nIHVwIHRoZSByZW5kZXIgZWZmZWN0LCBpZiB0aGUgaW5pdGlhbCB2bm9kZSBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIC5lbCBzZXQsIHRoZSBjb21wb25lbnQgd2lsbCBwZXJmb3JtIGh5ZHJhdGlvbiBpbnN0ZWFkIG9mIG1vdW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gaXRzIHN1Yi10cmVlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnNsb3RTY29wZUlkcyA9IHNsb3RTY29wZUlkcztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q29tcG9uZW50KHZub2RlLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHQ29udGFpbmVyKGNvbnRhaW5lciksIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IG1heSBiZSBhc3luYywgc28gaW4gdGhlIGNhc2Ugb2YgZnJhZ21lbnRzIHdlIGNhbm5vdCByZWx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gY29tcG9uZW50J3MgcmVuZGVyZWQgb3V0cHV0IHRvIGRldGVybWluZSB0aGUgZW5kIG9mIHRoZSBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RlYWQsIHdlIGRvIGEgbG9va2FoZWFkIHRvIGZpbmQgdGhlIGVuZCBhbmNob3Igbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGlzRnJhZ21lbnRTdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGxvY2F0ZUNsb3NpbmdBc3luY0FuY2hvcihub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICM0MjkzIHRlbGVwb3J0IGFzIGNvbXBvbmVudCByb290XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROb2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tbWVudChuZXh0Tm9kZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUuZGF0YSA9PT0gJ3RlbGVwb3J0IGVuZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBuZXh0U2libGluZyhuZXh0Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICMzNzg3XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29tcG9uZW50IGlzIGFzeW5jLCBpdCBtYXkgZ2V0IG1vdmVkIC8gdW5tb3VudGVkIGJlZm9yZSBpdHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lciBjb21wb25lbnQgaXMgbG9hZGVkLCBzbyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZub2RlIHRoYXQgbWF0Y2hlcyBpdHMgYWRvcHRlZCBET00uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN5bmNXcmFwcGVyKHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3ViVHJlZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnJhZ21lbnRTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKEZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuYW5jaG9yID0gbmV4dE5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5leHROb2RlLnByZXZpb3VzU2libGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29udGFpbmVyLmxhc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IDMgPyBjcmVhdGVUZXh0Vk5vZGUoJycpIDogY3JlYXRlVk5vZGUoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlRyZWUuZWwgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnQuc3ViVHJlZSA9IHN1YlRyZWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgNjQgLyogVEVMRVBPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVHlwZSAhPT0gOCAvKiBDT01NRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gb25NaXNtYXRjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUgPSB2bm9kZS50eXBlLmh5ZHJhdGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZUNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHZub2RlLnR5cGUuaHlkcmF0ZShub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIocGFyZW50Tm9kZShub2RlKSksIHNsb3RTY29wZUlkcywgb3B0aW1pemVkLCByZW5kZXJlckludGVybmFscywgaHlkcmF0ZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQxKCdJbnZhbGlkIEhvc3RWTm9kZSB0eXBlOicsIHR5cGUsIGAoJHt0eXBlb2YgdHlwZX0pYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBudWxsLCBwYXJlbnRTdXNwZW5zZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV4dE5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaHlkcmF0ZUVsZW1lbnQgPSAoZWwsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXZub2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBwYXRjaEZsYWcsIHNoYXBlRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gIzQwMDYgZm9yIGZvcm0gZWxlbWVudHMgd2l0aCBub24tc3RyaW5nIHYtbW9kZWwgdmFsdWUgYmluZGluZ3NcclxuICAgICAgICAvLyBlLmcuIDxvcHRpb24gOnZhbHVlPVwib2JqXCI+LCA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgOnRydWUtdmFsdWU9XCIxXCI+XHJcbiAgICAgICAgY29uc3QgZm9yY2VQYXRjaFZhbHVlID0gKHR5cGUgPT09ICdpbnB1dCcgJiYgZGlycykgfHwgdHlwZSA9PT0gJ29wdGlvbic7XHJcbiAgICAgICAgLy8gc2tpcCBwcm9wcyAmIGNoaWxkcmVuIGlmIHRoaXMgaXMgaG9pc3RlZCBzdGF0aWMgbm9kZXNcclxuICAgICAgICAvLyAjNTQwNSBpbiBkZXYsIGFsd2F5cyBoeWRyYXRlIGNoaWxkcmVuIGZvciBITVJcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IGZvcmNlUGF0Y2hWYWx1ZSB8fCBwYXRjaEZsYWcgIT09IC0xIC8qIEhPSVNURUQgKi8pIHtcclxuICAgICAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZURpcmVjdGl2ZUhvb2sodm5vZGUsIG51bGwsIHBhcmVudENvbXBvbmVudCwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwcm9wc1xyXG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmb3JjZVBhdGNoVmFsdWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAhb3B0aW1pemVkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hGbGFnICYgKDE2IC8qIEZVTExfUFJPUFMgKi8gfCAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGZvcmNlUGF0Y2hWYWx1ZSAmJiBrZXkuZW5kc1dpdGgoJ3ZhbHVlJykpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNPbihrZXkpICYmICFpc1Jlc2VydmVkUHJvcChrZXkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCBrZXksIG51bGwsIHByb3BzW2tleV0sIGZhbHNlLCB1bmRlZmluZWQsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wcy5vbkNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGljayBsaXN0ZW5lcnMgKHdoaWNoIGlzIG1vc3Qgb2Z0ZW4pIHRvIGF2b2lkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW5nIHRocm91Z2ggcHJvcHMuXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hQcm9wKGVsLCAnb25DbGljaycsIG51bGwsIHByb3BzLm9uQ2xpY2ssIGZhbHNlLCB1bmRlZmluZWQsIHBhcmVudENvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdm5vZGUgLyBkaXJlY3RpdmUgaG9va3NcclxuICAgICAgICAgICAgbGV0IHZub2RlSG9va3M7XHJcbiAgICAgICAgICAgIGlmICgodm5vZGVIb29rcyA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVCZWZvcmVNb3VudCkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2tzLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHZub2RlSG9va3MgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlTW91bnRlZCkgfHwgZGlycykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVFZmZlY3RXaXRoU3VzcGVuc2UoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlSG9va3MgJiYgaW52b2tlVk5vZGVIb29rKHZub2RlSG9va3MsIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpcnMgJiYgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnbW91bnRlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLyAmJlxyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBlbGVtZW50IGhhcyBpbm5lckhUTUwgLyB0ZXh0Q29udGVudFxyXG4gICAgICAgICAgICAgICAgIShwcm9wcyAmJiAocHJvcHMuaW5uZXJIVE1MIHx8IHByb3BzLnRleHRDb250ZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaHlkcmF0ZUNoaWxkcmVuKGVsLmZpcnN0Q2hpbGQsIHZub2RlLCBlbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhaGFzV2FybmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMShgSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIGluIDwke3Zub2RlLnR5cGV9PjogYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgbW9yZSBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgU1NSZWQgRE9NIGNvbnRhaW5zIG1vcmUgbm9kZXMgdGhhbiBpdCBzaG91bGQuIFJlbW92ZSB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ciA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQgIT09IHZub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYEh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggaW4gPCR7dm5vZGUudHlwZX0+OlxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gQ2xpZW50OiAke2VsLnRleHRDb250ZW50fVxcbmAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC0gU2VydmVyOiAke3Zub2RlLmNoaWxkcmVufWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLm5leHRTaWJsaW5nO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVDaGlsZHJlbiA9IChub2RlLCBwYXJlbnRWTm9kZSwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIG9wdGltaXplZCA9IG9wdGltaXplZCB8fCAhIXBhcmVudFZOb2RlLmR5bmFtaWNDaGlsZHJlbjtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudFZOb2RlLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IGwgPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGhhc1dhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZub2RlID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNoaWxkcmVuW2ldXHJcbiAgICAgICAgICAgICAgICA6IChjaGlsZHJlbltpXSA9IG5vcm1hbGl6ZVZOb2RlKGNoaWxkcmVuW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gaHlkcmF0ZU5vZGUobm9kZSwgdm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2bm9kZS50eXBlID09PSBUZXh0ICYmICF2bm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFoYXNXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYEh5ZHJhdGlvbiBjaGlsZHJlbiBtaXNtYXRjaCBpbiA8JHtjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpfT46IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgc2VydmVyIHJlbmRlcmVkIGVsZW1lbnQgY29udGFpbnMgZmV3ZXIgY2hpbGQgbm9kZXMgdGhhbiBjbGllbnQgdmRvbS5gKTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIFNTUmVkIERPTSBkaWRuJ3QgY29udGFpbiBlbm91Z2ggbm9kZXMuIE1vdW50IHRoZSBtaXNzaW5nIG9uZXMuXHJcbiAgICAgICAgICAgICAgICBwYXRjaChudWxsLCB2bm9kZSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWR0NvbnRhaW5lcihjb250YWluZXIpLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGh5ZHJhdGVGcmFnbWVudCA9IChub2RlLCB2bm9kZSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChmcmFnbWVudFNsb3RTY29wZUlkcykge1xyXG4gICAgICAgICAgICBzbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHNcclxuICAgICAgICAgICAgICAgID8gc2xvdFNjb3BlSWRzLmNvbmNhdChmcmFnbWVudFNsb3RTY29wZUlkcylcclxuICAgICAgICAgICAgICAgIDogZnJhZ21lbnRTbG90U2NvcGVJZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudE5vZGUobm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV4dCA9IGh5ZHJhdGVDaGlsZHJlbihuZXh0U2libGluZyhub2RlKSwgdm5vZGUsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIGlmIChuZXh0ICYmIGlzQ29tbWVudChuZXh0KSAmJiBuZXh0LmRhdGEgPT09ICddJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciA9IG5leHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGZyYWdtZW50IGRpZG4ndCBoeWRyYXRlIHN1Y2Nlc3NmdWxseSwgc2luY2Ugd2UgZGlkbid0IGdldCBhIGVuZCBhbmNob3JcclxuICAgICAgICAgICAgLy8gYmFjay4gVGhpcyBzaG91bGQgaGF2ZSBsZWQgdG8gbm9kZS9jaGlsZHJlbiBtaXNtYXRjaCB3YXJuaW5ncy5cclxuICAgICAgICAgICAgaGFzTWlzbWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgYW5jaG9yIGlzIG1pc3NpbmcsIHdlIG5lZWQgdG8gY3JlYXRlIG9uZSBhbmQgaW5zZXJ0IGl0XHJcbiAgICAgICAgICAgIGluc2VydCgodm5vZGUuYW5jaG9yID0gY3JlYXRlQ29tbWVudChgXWApKSwgY29udGFpbmVyLCBuZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IGhhbmRsZU1pc21hdGNoID0gKG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIGlzRnJhZ21lbnQpID0+IHtcclxuICAgICAgICBoYXNNaXNtYXRjaCA9IHRydWU7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmXHJcbiAgICAgICAgICAgIHdhcm4kMShgSHlkcmF0aW9uIG5vZGUgbWlzbWF0Y2g6XFxuLSBDbGllbnQgdm5vZGU6YCwgdm5vZGUudHlwZSwgYFxcbi0gU2VydmVyIHJlbmRlcmVkIERPTTpgLCBub2RlLCBub2RlLm5vZGVUeXBlID09PSAzIC8qIFRFWFQgKi9cclxuICAgICAgICAgICAgICAgID8gYCh0ZXh0KWBcclxuICAgICAgICAgICAgICAgIDogaXNDb21tZW50KG5vZGUpICYmIG5vZGUuZGF0YSA9PT0gJ1snXHJcbiAgICAgICAgICAgICAgICAgICAgPyBgKHN0YXJ0IG9mIGZyYWdtZW50KWBcclxuICAgICAgICAgICAgICAgICAgICA6IGBgKTtcclxuICAgICAgICB2bm9kZS5lbCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGlzRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4Y2Vzc2l2ZSBmcmFnbWVudCBub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3Iobm9kZSk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXh0ID0gbmV4dFNpYmxpbmcobm9kZSk7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcGFyZW50Tm9kZShub2RlKTtcclxuICAgICAgICByZW1vdmUobm9kZSk7XHJcbiAgICAgICAgcGF0Y2gobnVsbCwgdm5vZGUsIGNvbnRhaW5lciwgbmV4dCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkdDb250YWluZXIoY29udGFpbmVyKSwgc2xvdFNjb3BlSWRzKTtcclxuICAgICAgICByZXR1cm4gbmV4dDtcclxuICAgIH07XHJcbiAgICBjb25zdCBsb2NhdGVDbG9zaW5nQXN5bmNBbmNob3IgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgIGxldCBtYXRjaCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBpc0NvbW1lbnQobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmRhdGEgPT09ICdbJylcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaCsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZGF0YSA9PT0gJ10nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0U2libGluZyhub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBbaHlkcmF0ZSwgaHlkcmF0ZU5vZGVdO1xyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAqL1xyXG5sZXQgc3VwcG9ydGVkO1xyXG5sZXQgcGVyZjtcclxuZnVuY3Rpb24gc3RhcnRNZWFzdXJlKGluc3RhbmNlLCB0eXBlKSB7XHJcbiAgICBpZiAoaW5zdGFuY2UuYXBwQ29udGV4dC5jb25maWcucGVyZm9ybWFuY2UgJiYgaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIHBlcmYubWFyayhgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzUGVyZlN0YXJ0KGluc3RhbmNlLCB0eXBlLCBpc1N1cHBvcnRlZCgpID8gcGVyZi5ub3coKSA6IERhdGUubm93KCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVuZE1lYXN1cmUoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIGlmIChpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBpc1N1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUYWcgPSBgdnVlLSR7dHlwZX0tJHtpbnN0YW5jZS51aWR9YDtcclxuICAgICAgICBjb25zdCBlbmRUYWcgPSBzdGFydFRhZyArIGA6ZW5kYDtcclxuICAgICAgICBwZXJmLm1hcmsoZW5kVGFnKTtcclxuICAgICAgICBwZXJmLm1lYXN1cmUoYDwke2Zvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIGluc3RhbmNlLnR5cGUpfT4gJHt0eXBlfWAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XHJcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XHJcbiAgICB9XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykge1xyXG4gICAgICAgIGRldnRvb2xzUGVyZkVuZChpbnN0YW5jZSwgdHlwZSwgaXNTdXBwb3J0ZWQoKSA/IHBlcmYubm93KCkgOiBEYXRlLm5vdygpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcclxuICAgIGlmIChzdXBwb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICBwZXJmID0gd2luZG93LnBlcmZvcm1hbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG59XG5cbi8qKlxyXG4gKiBUaGlzIGlzIG9ubHkgY2FsbGVkIGluIGVzbS1idW5kbGVyIGJ1aWxkcy5cclxuICogSXQgaXMgY2FsbGVkIHdoZW4gYSByZW5kZXJlciBpcyBjcmVhdGVkLCBpbiBgYmFzZUNyZWF0ZVJlbmRlcmVyYCBzbyB0aGF0XHJcbiAqIGltcG9ydGluZyBydW50aW1lLWNvcmUgaXMgc2lkZS1lZmZlY3RzIGZyZWUuXHJcbiAqXHJcbiAqIGlzdGFuYnVsLWlnbm9yZS1uZXh0XHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0RmVhdHVyZUZsYWdzKCkge1xyXG4gICAgY29uc3QgbmVlZFdhcm4gPSBbXTtcclxuICAgIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX09QVElPTlNfQVBJX19gKTtcclxuICAgICAgICBnZXRHbG9iYWxUaGlzKCkuX19WVUVfT1BUSU9OU19BUElfXyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIG5lZWRXYXJuLnB1c2goYF9fVlVFX1BST0RfREVWVE9PTFNfX2ApO1xyXG4gICAgICAgIGdldEdsb2JhbFRoaXMoKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbmVlZFdhcm4ubGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgbXVsdGkgPSBuZWVkV2Fybi5sZW5ndGggPiAxO1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgRmVhdHVyZSBmbGFnJHttdWx0aSA/IGBzYCA6IGBgfSAke25lZWRXYXJuLmpvaW4oJywgJyl9ICR7bXVsdGkgPyBgYXJlYCA6IGBpc2B9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCBgICtcclxuICAgICAgICAgICAgYHdoaWNoIGV4cGVjdHMgdGhlc2UgY29tcGlsZS10aW1lIGZlYXR1cmUgZmxhZ3MgdG8gYmUgZ2xvYmFsbHkgaW5qZWN0ZWQgYCArXHJcbiAgICAgICAgICAgIGB2aWEgdGhlIGJ1bmRsZXIgY29uZmlnIGluIG9yZGVyIHRvIGdldCBiZXR0ZXIgdHJlZS1zaGFraW5nIGluIHRoZSBgICtcclxuICAgICAgICAgICAgYHByb2R1Y3Rpb24gYnVuZGxlLlxcblxcbmAgK1xyXG4gICAgICAgICAgICBgRm9yIG1vcmUgZGV0YWlscywgc2VlIGh0dHBzOi8vbGluay52dWVqcy5vcmcvZmVhdHVyZS1mbGFncy5gKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QgPSBxdWV1ZUVmZmVjdFdpdGhTdXNwZW5zZVxyXG4gICAgO1xyXG4vKipcclxuICogVGhlIGNyZWF0ZVJlbmRlcmVyIGZ1bmN0aW9uIGFjY2VwdHMgdHdvIGdlbmVyaWMgYXJndW1lbnRzOlxyXG4gKiBIb3N0Tm9kZSBhbmQgSG9zdEVsZW1lbnQsIGNvcnJlc3BvbmRpbmcgdG8gTm9kZSBhbmQgRWxlbWVudCB0eXBlcyBpbiB0aGVcclxuICogaG9zdCBlbnZpcm9ubWVudC4gRm9yIGV4YW1wbGUsIGZvciBydW50aW1lLWRvbSwgSG9zdE5vZGUgd291bGQgYmUgdGhlIERPTVxyXG4gKiBgTm9kZWAgaW50ZXJmYWNlIGFuZCBIb3N0RWxlbWVudCB3b3VsZCBiZSB0aGUgRE9NIGBFbGVtZW50YCBpbnRlcmZhY2UuXHJcbiAqXHJcbiAqIEN1c3RvbSByZW5kZXJlcnMgY2FuIHBhc3MgaW4gdGhlIHBsYXRmb3JtIHNwZWNpZmljIHR5cGVzIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgIGpzXHJcbiAqIGNvbnN0IHsgcmVuZGVyLCBjcmVhdGVBcHAgfSA9IGNyZWF0ZVJlbmRlcmVyPE5vZGUsIEVsZW1lbnQ+KHtcclxuICogICBwYXRjaFByb3AsXHJcbiAqICAgLi4ubm9kZU9wc1xyXG4gKiB9KVxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucyk7XHJcbn1cclxuLy8gU2VwYXJhdGUgQVBJIGZvciBjcmVhdGluZyBoeWRyYXRpb24tZW5hYmxlZCByZW5kZXJlci5cclxuLy8gSHlkcmF0aW9uIGxvZ2ljIGlzIG9ubHkgdXNlZCB3aGVuIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgbWFraW5nIGl0XHJcbi8vIHRyZWUtc2hha2FibGUuXHJcbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRnVuY3Rpb25zKTtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBiYXNlQ3JlYXRlUmVuZGVyZXIob3B0aW9ucywgY3JlYXRlSHlkcmF0aW9uRm5zKSB7XHJcbiAgICAvLyBjb21waWxlLXRpbWUgZmVhdHVyZSBmbGFncyBjaGVja1xyXG4gICAge1xyXG4gICAgICAgIGluaXRGZWF0dXJlRmxhZ3MoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhcmdldCA9IGdldEdsb2JhbFRoaXMoKTtcclxuICAgIHRhcmdldC5fX1ZVRV9fID0gdHJ1ZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgc2V0RGV2dG9vbHNIb29rKHRhcmdldC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fLCB0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBpbnNlcnQ6IGhvc3RJbnNlcnQsIHJlbW92ZTogaG9zdFJlbW92ZSwgcGF0Y2hQcm9wOiBob3N0UGF0Y2hQcm9wLCBjcmVhdGVFbGVtZW50OiBob3N0Q3JlYXRlRWxlbWVudCwgY3JlYXRlVGV4dDogaG9zdENyZWF0ZVRleHQsIGNyZWF0ZUNvbW1lbnQ6IGhvc3RDcmVhdGVDb21tZW50LCBzZXRUZXh0OiBob3N0U2V0VGV4dCwgc2V0RWxlbWVudFRleHQ6IGhvc3RTZXRFbGVtZW50VGV4dCwgcGFyZW50Tm9kZTogaG9zdFBhcmVudE5vZGUsIG5leHRTaWJsaW5nOiBob3N0TmV4dFNpYmxpbmcsIHNldFNjb3BlSWQ6IGhvc3RTZXRTY29wZUlkID0gTk9PUCwgY2xvbmVOb2RlOiBob3N0Q2xvbmVOb2RlLCBpbnNlcnRTdGF0aWNDb250ZW50OiBob3N0SW5zZXJ0U3RhdGljQ29udGVudCB9ID0gb3B0aW9ucztcclxuICAgIC8vIE5vdGU6IGZ1bmN0aW9ucyBpbnNpZGUgdGhpcyBjbG9zdXJlIHNob3VsZCB1c2UgYGNvbnN0IHh4eCA9ICgpID0+IHt9YFxyXG4gICAgLy8gc3R5bGUgaW4gb3JkZXIgdG8gcHJldmVudCBiZWluZyBpbmxpbmVkIGJ5IG1pbmlmaWVycy5cclxuICAgIGNvbnN0IHBhdGNoID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IgPSBudWxsLCBwYXJlbnRDb21wb25lbnQgPSBudWxsLCBwYXJlbnRTdXNwZW5zZSA9IG51bGwsIGlzU1ZHID0gZmFsc2UsIHNsb3RTY29wZUlkcyA9IG51bGwsIG9wdGltaXplZCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nID8gZmFsc2UgOiAhIW4yLmR5bmFtaWNDaGlsZHJlbikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PT0gbjIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXRjaGluZyAmIG5vdCBzYW1lIHR5cGUsIHVubW91bnQgb2xkIHRyZWVcclxuICAgICAgICBpZiAobjEgJiYgIWlzU2FtZVZOb2RlVHlwZShuMSwgbjIpKSB7XHJcbiAgICAgICAgICAgIGFuY2hvciA9IGdldE5leHRIb3N0Tm9kZShuMSk7XHJcbiAgICAgICAgICAgIHVubW91bnQobjEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICBuMSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuMi5wYXRjaEZsYWcgPT09IC0yIC8qIEJBSUwgKi8pIHtcclxuICAgICAgICAgICAgb3B0aW1pemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIG4yLmR5bmFtaWNDaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcmVmLCBzaGFwZUZsYWcgfSA9IG4yO1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFRleHQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzVGV4dChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIENvbW1lbnQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzQ29tbWVudE5vZGUobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTdGF0aWM6XHJcbiAgICAgICAgICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50U3RhdGljTm9kZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoU3RhdGljTm9kZShuMSwgbjIsIGNvbnRhaW5lciwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzRnJhZ21lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NDb21wb25lbnQobjEsIG4yLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvY2VzcyhuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGludGVybmFscyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDEoJ0ludmFsaWQgVk5vZGUgdHlwZTonLCB0eXBlLCBgKCR7dHlwZW9mIHR5cGV9KWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBzZXRSZWYocmVmLCBuMSAmJiBuMS5yZWYsIHBhcmVudFN1c3BlbnNlLCBuMiB8fCBuMSwgIW4yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc1RleHQgPSAobjEsIG4yLCBjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoKG4yLmVsID0gaG9zdENyZWF0ZVRleHQobjIuY2hpbGRyZW4pKSwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSAobjIuZWwgPSBuMS5lbCk7XHJcbiAgICAgICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRUZXh0KGVsLCBuMi5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbW1lbnROb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IpID0+IHtcclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KChuMi5lbCA9IGhvc3RDcmVhdGVDb21tZW50KG4yLmNoaWxkcmVuIHx8ICcnKSksIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gc3VwcG9ydCBmb3IgZHluYW1pYyBjb21tZW50c1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudFN0YXRpY05vZGUgPSAobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIFtuMi5lbCwgbjIuYW5jaG9yXSA9IGhvc3RJbnNlcnRTdGF0aWNDb250ZW50KG4yLmNoaWxkcmVuLCBjb250YWluZXIsIGFuY2hvciwgaXNTVkcsIG4yLmVsLCBuMi5hbmNob3IpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV2IC8gSE1SIG9ubHlcclxuICAgICAqL1xyXG4gICAgY29uc3QgcGF0Y2hTdGF0aWNOb2RlID0gKG4xLCBuMiwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIC8vIHN0YXRpYyBub2RlcyBhcmUgb25seSBwYXRjaGVkIGR1cmluZyBkZXYgZm9yIEhNUlxyXG4gICAgICAgIGlmIChuMi5jaGlsZHJlbiAhPT0gbjEuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gaG9zdE5leHRTaWJsaW5nKG4xLmFuY2hvcik7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleGlzdGluZ1xyXG4gICAgICAgICAgICByZW1vdmVTdGF0aWNOb2RlKG4xKTtcclxuICAgICAgICAgICAgW24yLmVsLCBuMi5hbmNob3JdID0gaG9zdEluc2VydFN0YXRpY0NvbnRlbnQobjIuY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuMi5lbCA9IG4xLmVsO1xyXG4gICAgICAgICAgICBuMi5hbmNob3IgPSBuMS5hbmNob3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9LCBjb250YWluZXIsIG5leHRTaWJsaW5nKSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RJbnNlcnQoZWwsIGNvbnRhaW5lciwgbmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RJbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIG5leHRTaWJsaW5nKTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVTdGF0aWNOb2RlID0gKHsgZWwsIGFuY2hvciB9KSA9PiB7XHJcbiAgICAgICAgbGV0IG5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGVsICYmIGVsICE9PSBhbmNob3IpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhlbCk7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUoZWwpO1xyXG4gICAgICAgICAgICBlbCA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoYW5jaG9yKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcm9jZXNzRWxlbWVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IG4yLnR5cGUgPT09ICdzdmcnO1xyXG4gICAgICAgIGlmIChuMSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vdW50RWxlbWVudChuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaEVsZW1lbnQobjEsIG4yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3VudEVsZW1lbnQgPSAodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBsZXQgZWw7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHByb3BzLCBzaGFwZUZsYWcsIHRyYW5zaXRpb24sIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgaWYgKCEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgdm5vZGUuZWwgJiZcclxuICAgICAgICAgICAgaG9zdENsb25lTm9kZSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9PT0gLTEgLyogSE9JU1RFRCAqLykge1xyXG4gICAgICAgICAgICAvLyBJZiBhIHZub2RlIGhhcyBub24tbnVsbCBlbCwgaXQgbWVhbnMgaXQncyBiZWluZyByZXVzZWQuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgc3RhdGljIHZub2RlcyBjYW4gYmUgcmV1c2VkLCBzbyBpdHMgbW91bnRlZCBET00gbm9kZXMgc2hvdWxkIGJlXHJcbiAgICAgICAgICAgIC8vIGV4YWN0bHkgdGhlIHNhbWUsIGFuZCB3ZSBjYW4gc2ltcGx5IGRvIGEgY2xvbmUgaGVyZS5cclxuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIGluIHByb2R1Y3Rpb24gc2luY2UgY2xvbmVkIHRyZWVzIGNhbm5vdCBiZSBITVIgdXBkYXRlZC5cclxuICAgICAgICAgICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDbG9uZU5vZGUodm5vZGUuZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwgPSB2bm9kZS5lbCA9IGhvc3RDcmVhdGVFbGVtZW50KHZub2RlLnR5cGUsIGlzU1ZHLCBwcm9wcyAmJiBwcm9wcy5pcywgcHJvcHMpO1xyXG4gICAgICAgICAgICAvLyBtb3VudCBjaGlsZHJlbiBmaXJzdCwgc2luY2Ugc29tZSBwcm9wcyBtYXkgcmVseSBvbiBjaGlsZCBjb250ZW50XHJcbiAgICAgICAgICAgIC8vIGJlaW5nIGFscmVhZHkgcmVuZGVyZWQsIGUuZy4gYDxzZWxlY3QgdmFsdWU+YFxyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0RWxlbWVudFRleHQoZWwsIHZub2RlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDaGlsZHJlbih2bm9kZS5jaGlsZHJlbiwgZWwsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHICYmIHR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd2YWx1ZScgJiYgIWlzUmVzZXJ2ZWRQcm9wKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBudWxsLCBwcm9wc1trZXldLCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UgZm9yIHNldHRpbmcgdmFsdWUgb24gRE9NIGVsZW1lbnRzOlxyXG4gICAgICAgICAgICAgICAgICogLSBpdCBjYW4gYmUgb3JkZXItc2Vuc2l0aXZlIChlLmcuIHNob3VsZCBiZSBzZXQgKmFmdGVyKiBtaW4vbWF4LCAjMjMyNSwgIzQwMjQpXHJcbiAgICAgICAgICAgICAgICAgKiAtIGl0IG5lZWRzIHRvIGJlIGZvcmNlZCAoIzE0NzEpXHJcbiAgICAgICAgICAgICAgICAgKiAjMjM1MyBwcm9wb3NlcyBhZGRpbmcgYW5vdGhlciByZW5kZXJlciBvcHRpb24gdG8gY29uZmlndXJlIHRoaXMsIGJ1dFxyXG4gICAgICAgICAgICAgICAgICogdGhlIHByb3BlcnRpZXMgYWZmZWN0cyBhcmUgc28gZmluaXRlIGl0IGlzIHdvcnRoIHNwZWNpYWwgY2FzaW5nIGl0XHJcbiAgICAgICAgICAgICAgICAgKiBoZXJlIHRvIHJlZHVjZSB0aGUgY29tcGxleGl0eS4gKFNwZWNpYWwgY2FzaW5nIGl0IGFsc28gc2hvdWxkIG5vdFxyXG4gICAgICAgICAgICAgICAgICogYWZmZWN0IG5vbi1ET00gcmVuZGVyZXJzKVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICd2YWx1ZScsIG51bGwsIHByb3BzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMub25Wbm9kZUJlZm9yZU1vdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNjb3BlSWRcclxuICAgICAgICAgICAgc2V0U2NvcGVJZChlbCwgdm5vZGUsIHZub2RlLnNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCAnX192bm9kZScsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2bm9kZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsICdfX3Z1ZVBhcmVudENvbXBvbmVudCcsIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJlbnRDb21wb25lbnQsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlTW91bnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzE1ODMgRm9yIGluc2lkZSBzdXNwZW5zZSArIHN1c3BlbnNlIG5vdCByZXNvbHZlZCBjYXNlLCBlbnRlciBob29rIHNob3VsZCBjYWxsIHdoZW4gc3VzcGVuc2UgcmVzb2x2ZWRcclxuICAgICAgICAvLyAjMTY4OSBGb3IgaW5zaWRlIHN1c3BlbnNlICsgc3VzcGVuc2UgcmVzb2x2ZWQgY2FzZSwganVzdCBjYWxsIGl0XHJcbiAgICAgICAgY29uc3QgbmVlZENhbGxUcmFuc2l0aW9uSG9va3MgPSAoIXBhcmVudFN1c3BlbnNlIHx8IChwYXJlbnRTdXNwZW5zZSAmJiAhcGFyZW50U3VzcGVuc2UucGVuZGluZ0JyYW5jaCkpICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkO1xyXG4gICAgICAgIGlmIChuZWVkQ2FsbFRyYW5zaXRpb25Ib29rcykge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZU1vdW50ZWQpIHx8XHJcbiAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzIHx8XHJcbiAgICAgICAgICAgIGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIG5lZWRDYWxsVHJhbnNpdGlvbkhvb2tzICYmIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgZGlycyAmJiBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICdtb3VudGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc2V0U2NvcGVJZCA9IChlbCwgdm5vZGUsIHNjb3BlSWQsIHNsb3RTY29wZUlkcywgcGFyZW50Q29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHNjb3BlSWQpIHtcclxuICAgICAgICAgICAgaG9zdFNldFNjb3BlSWQoZWwsIHNjb3BlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2xvdFNjb3BlSWRzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdFNjb3BlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0U2V0U2NvcGVJZChlbCwgc2xvdFNjb3BlSWRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyZW50Q29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJUcmVlID0gcGFyZW50Q29tcG9uZW50LnN1YlRyZWU7XHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgIHN1YlRyZWUucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgc3ViVHJlZS5wYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJUcmVlID1cclxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJTaW5nbGVSb290KHN1YlRyZWUuY2hpbGRyZW4pIHx8IHN1YlRyZWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZub2RlID09PSBzdWJUcmVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRWTm9kZSA9IHBhcmVudENvbXBvbmVudC52bm9kZTtcclxuICAgICAgICAgICAgICAgIHNldFNjb3BlSWQoZWwsIHBhcmVudFZOb2RlLCBwYXJlbnRWTm9kZS5zY29wZUlkLCBwYXJlbnRWTm9kZS5zbG90U2NvcGVJZHMsIHBhcmVudENvbXBvbmVudC5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdW50Q2hpbGRyZW4gPSAoY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gKGNoaWxkcmVuW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGNoaWxkcmVuW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjaGlsZHJlbltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChudWxsLCBjaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoRWxlbWVudCA9IChuMSwgbjIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gKG4yLmVsID0gbjEuZWwpO1xyXG4gICAgICAgIGxldCB7IHBhdGNoRmxhZywgZHluYW1pY0NoaWxkcmVuLCBkaXJzIH0gPSBuMjtcclxuICAgICAgICAvLyAjMTQyNiB0YWtlIHRoZSBvbGQgdm5vZGUncyBwYXRjaCBmbGFnIGludG8gYWNjb3VudCBzaW5jZSB1c2VyIG1heSBjbG9uZSBhXHJcbiAgICAgICAgLy8gY29tcGlsZXItZ2VuZXJhdGVkIHZub2RlLCB3aGljaCBkZS1vcHRzIHRvIEZVTExfUFJPUFNcclxuICAgICAgICBwYXRjaEZsYWcgfD0gbjEucGF0Y2hGbGFnICYgMTYgLyogRlVMTF9QUk9QUyAqLztcclxuICAgICAgICBjb25zdCBvbGRQcm9wcyA9IG4xLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IG4yLnByb3BzIHx8IEVNUFRZX09CSjtcclxuICAgICAgICBsZXQgdm5vZGVIb29rO1xyXG4gICAgICAgIC8vIGRpc2FibGUgcmVjdXJzZSBpbiBiZWZvcmVVcGRhdGUgaG9va3NcclxuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIGZhbHNlKTtcclxuICAgICAgICBpZiAoKHZub2RlSG9vayA9IG5ld1Byb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpKSB7XHJcbiAgICAgICAgICAgIGludm9rZVZOb2RlSG9vayh2bm9kZUhvb2ssIHBhcmVudENvbXBvbmVudCwgbjIsIG4xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnMpIHtcclxuICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayhuMiwgbjEsIHBhcmVudENvbXBvbmVudCwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnRDb21wb25lbnQgJiYgdG9nZ2xlUmVjdXJzZShwYXJlbnRDb21wb25lbnQsIHRydWUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNIbXJVcGRhdGluZykge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgICAgIHBhdGNoRmxhZyA9IDA7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhcmVDaGlsZHJlblNWRyA9IGlzU1ZHICYmIG4yLnR5cGUgIT09ICdmb3JlaWduT2JqZWN0JztcclxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgZWwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGFyZUNoaWxkcmVuU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHBhcmVudENvbXBvbmVudCAmJiBwYXJlbnRDb21wb25lbnQudHlwZS5fX2htcklkKSB7XHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xyXG4gICAgICAgICAgICAvLyBmdWxsIGRpZmZcclxuICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGVsLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBhcmVDaGlsZHJlblNWRywgc2xvdFNjb3BlSWRzLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBwcmVzZW5jZSBvZiBhIHBhdGNoRmxhZyBtZWFucyB0aGlzIGVsZW1lbnQncyByZW5kZXIgY29kZSB3YXNcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIGJ5IHRoZSBjb21waWxlciBhbmQgY2FuIHRha2UgdGhlIGZhc3QgcGF0aC5cclxuICAgICAgICAgICAgLy8gaW4gdGhpcyBwYXRoIG9sZCBub2RlIGFuZCBuZXcgbm9kZSBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXHJcbiAgICAgICAgICAgIC8vIChpLmUuIGF0IHRoZSBleGFjdCBzYW1lIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UgdGVtcGxhdGUpXHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxNiAvKiBGVUxMX1BST1BTICovKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHByb3BzIGNvbnRhaW4gZHluYW1pYyBrZXlzLCBmdWxsIGRpZmYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbGFzc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBmbGFnIGlzIG1hdGNoZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHluYW1pYyBjbGFzcyBiaW5kaW5ncy5cclxuICAgICAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAyIC8qIENMQVNTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFByb3BzLmNsYXNzICE9PSBuZXdQcm9wcy5jbGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCAnY2xhc3MnLCBudWxsLCBuZXdQcm9wcy5jbGFzcywgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHN0eWxlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkeW5hbWljIHN0eWxlIGJpbmRpbmdzXHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hGbGFnICYgNCAvKiBTVFlMRSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICdzdHlsZScsIG9sZFByb3BzLnN0eWxlLCBuZXdQcm9wcy5zdHlsZSwgaXNTVkcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHJvcHNcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmxhZyBpcyBtYXRjaGVkIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGR5bmFtaWMgcHJvcC9hdHRyIGJpbmRpbmdzXHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlciB0aGFuIGNsYXNzIGFuZCBzdHlsZS4gVGhlIGtleXMgb2YgZHluYW1pYyBwcm9wL2F0dHJzIGFyZSBzYXZlZCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGZhc3RlciBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIGR5bmFtaWMga2V5cyBsaWtlIDpbZm9vXT1cImJhclwiIHdpbGwgY2F1c2UgdGhpcyBvcHRpbWl6YXRpb24gdG9cclxuICAgICAgICAgICAgICAgIC8vIGJhaWwgb3V0IGFuZCBnbyB0aHJvdWdoIGEgZnVsbCBkaWZmIGJlY2F1c2Ugd2UgbmVlZCB0byB1bnNldCB0aGUgb2xkIGtleVxyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDggLyogUFJPUFMgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZmxhZyBpcyBwcmVzZW50IHRoZW4gZHluYW1pY1Byb3BzIG11c3QgYmUgbm9uLW51bGxcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1RvVXBkYXRlID0gbjIuZHluYW1pY1Byb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHNUb1VwZGF0ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wc1RvVXBkYXRlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gb2xkUHJvcHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5ld1Byb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICMxNDcxIGZvcmNlIHBhdGNoIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2IHx8IGtleSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgbjEuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGV4dFxyXG4gICAgICAgICAgICAvLyBUaGlzIGZsYWcgaXMgbWF0Y2hlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBvbmx5IGR5bmFtaWMgdGV4dCBjaGlsZHJlbi5cclxuICAgICAgICAgICAgaWYgKHBhdGNoRmxhZyAmIDEgLyogVEVYVCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4xLmNoaWxkcmVuICE9PSBuMi5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChlbCwgbjIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpbWl6ZWQgJiYgZHluYW1pY0NoaWxkcmVuID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gdW5vcHRpbWl6ZWQsIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaFByb3BzKGVsLCBuMiwgb2xkUHJvcHMsIG5ld1Byb3BzLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodm5vZGVIb29rID0gbmV3UHJvcHMub25Wbm9kZVVwZGF0ZWQpIHx8IGRpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIG4yLCBuMSk7XHJcbiAgICAgICAgICAgICAgICBkaXJzICYmIGludm9rZURpcmVjdGl2ZUhvb2sobjIsIG4xLCBwYXJlbnRDb21wb25lbnQsICd1cGRhdGVkJyk7XHJcbiAgICAgICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhlIGZhc3QgcGF0aCBmb3IgYmxvY2tzLlxyXG4gICAgY29uc3QgcGF0Y2hCbG9ja0NoaWxkcmVuID0gKG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgZmFsbGJhY2tDb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZOb2RlID0gbmV3Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY29udGFpbmVyIChwYXJlbnQgZWxlbWVudCkgZm9yIHRoZSBwYXRjaC5cclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gXHJcbiAgICAgICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxyXG4gICAgICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XHJcbiAgICAgICAgICAgIG9sZFZOb2RlLmVsICYmXHJcbiAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGEgRnJhZ21lbnQsIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgYWN0dWFsIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICAob2xkVk5vZGUudHlwZSA9PT0gRnJhZ21lbnQgfHxcclxuICAgICAgICAgICAgICAgICAgICAvLyAtIEluIHRoZSBjYXNlIG9mIGRpZmZlcmVudCBub2RlcywgdGhlcmUgaXMgZ29pbmcgdG8gYmUgYSByZXBsYWNlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICAgICAgICFpc1NhbWVWTm9kZVR5cGUob2xkVk5vZGUsIG5ld1ZOb2RlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gSW4gdGhlIGNhc2Ugb2YgYSBjb21wb25lbnQsIGl0IGNvdWxkIGNvbnRhaW4gYW55dGhpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVk5vZGUuc2hhcGVGbGFnICYgKDYgLyogQ09NUE9ORU5UICovIHwgNjQgLyogVEVMRVBPUlQgKi8pKVxyXG4gICAgICAgICAgICAgICAgPyBob3N0UGFyZW50Tm9kZShvbGRWTm9kZS5lbClcclxuICAgICAgICAgICAgICAgIDogLy8gSW4gb3RoZXIgY2FzZXMsIHRoZSBwYXJlbnQgY29udGFpbmVyIGlzIG5vdCBhY3R1YWxseSB1c2VkIHNvIHdlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBwYXNzIHRoZSBibG9jayBlbGVtZW50IGhlcmUgdG8gYXZvaWQgYSBET00gcGFyZW50Tm9kZSBjYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQ29udGFpbmVyO1xyXG4gICAgICAgICAgICBwYXRjaChvbGRWTm9kZSwgbmV3Vk5vZGUsIGNvbnRhaW5lciwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHBhdGNoUHJvcHMgPSAoZWwsIHZub2RlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKSA9PiB7XHJcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIGlzIG5vdCB2YWxpZCBwcm9wXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuZXdQcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZlciBwYXRjaGluZyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT09IHByZXYgJiYga2V5ICE9PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhdGNoUHJvcChlbCwga2V5LCBwcmV2LCBuZXh0LCBpc1NWRywgdm5vZGUuY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBFTVBUWV9PQkopIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Jlc2VydmVkUHJvcChrZXkpICYmICEoa2V5IGluIG5ld1Byb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UGF0Y2hQcm9wKGVsLCBrZXksIG9sZFByb3BzW2tleV0sIG51bGwsIGlzU1ZHLCB2bm9kZS5jaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdW5tb3VudENoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RQYXRjaFByb3AoZWwsICd2YWx1ZScsIG9sZFByb3BzLnZhbHVlLCBuZXdQcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0ZyYWdtZW50ID0gKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U3RhcnRBbmNob3IgPSAobjIuZWwgPSBuMSA/IG4xLmVsIDogaG9zdENyZWF0ZVRleHQoJycpKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudEVuZEFuY2hvciA9IChuMi5hbmNob3IgPSBuMSA/IG4xLmFuY2hvciA6IGhvc3RDcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgbGV0IHsgcGF0Y2hGbGFnLCBkeW5hbWljQ2hpbGRyZW4sIHNsb3RTY29wZUlkczogZnJhZ21lbnRTbG90U2NvcGVJZHMgfSA9IG4yO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgLy8gIzU1MjMgZGV2IHJvb3QgZnJhZ21lbnQgbWF5IGluaGVyaXQgZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICAoaXNIbXJVcGRhdGluZyB8fCBwYXRjaEZsYWcgJiAyMDQ4IC8qIERFVl9ST09UX0ZSQUdNRU5UICovKSkge1xyXG4gICAgICAgICAgICAvLyBITVIgdXBkYXRlZCAvIERldiByb290IGZyYWdtZW50ICh3LyBjb21tZW50cyksIGZvcmNlIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICBwYXRjaEZsYWcgPSAwO1xyXG4gICAgICAgICAgICBvcHRpbWl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHluYW1pY0NoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIHNsb3QgZnJhZ21lbnQgd2l0aCA6c2xvdHRlZCBzY29wZSBpZHNcclxuICAgICAgICBpZiAoZnJhZ21lbnRTbG90U2NvcGVJZHMpIHtcclxuICAgICAgICAgICAgc2xvdFNjb3BlSWRzID0gc2xvdFNjb3BlSWRzXHJcbiAgICAgICAgICAgICAgICA/IHNsb3RTY29wZUlkcy5jb25jYXQoZnJhZ21lbnRTbG90U2NvcGVJZHMpXHJcbiAgICAgICAgICAgICAgICA6IGZyYWdtZW50U2xvdFNjb3BlSWRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGZyYWdtZW50U3RhcnRBbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgaG9zdEluc2VydChmcmFnbWVudEVuZEFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAvLyBhIGZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYXJyYXkgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gc2luY2UgdGhleSBhcmUgZWl0aGVyIGdlbmVyYXRlZCBieSB0aGUgY29tcGlsZXIsIG9yIGltcGxpY2l0bHkgY3JlYXRlZFxyXG4gICAgICAgICAgICAvLyBmcm9tIGFycmF5cy5cclxuICAgICAgICAgICAgbW91bnRDaGlsZHJlbihuMi5jaGlsZHJlbiwgY29udGFpbmVyLCBmcmFnbWVudEVuZEFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBwYXRjaEZsYWcgJiA2NCAvKiBTVEFCTEVfRlJBR01FTlQgKi8gJiZcclxuICAgICAgICAgICAgICAgIGR5bmFtaWNDaGlsZHJlbiAmJlxyXG4gICAgICAgICAgICAgICAgLy8gIzI3MTUgdGhlIHByZXZpb3VzIGZyYWdtZW50IGNvdWxkJ3ZlIGJlZW4gYSBCQUlMZWQgb25lIGFzIGEgcmVzdWx0XHJcbiAgICAgICAgICAgICAgICAvLyBvZiByZW5kZXJTbG90KCkgd2l0aCBubyB2YWxpZCBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgbjEuZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIHN0YWJsZSBmcmFnbWVudCAodGVtcGxhdGUgcm9vdCBvciA8dGVtcGxhdGUgdi1mb3I+KSBkb2Vzbid0IG5lZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIHBhdGNoIGNoaWxkcmVuIG9yZGVyLCBidXQgaXQgbWF5IGNvbnRhaW4gZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hCbG9ja0NoaWxkcmVuKG4xLmR5bmFtaWNDaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXJlbnRDb21wb25lbnQgJiYgcGFyZW50Q29tcG9uZW50LnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgLy8gIzIwODAgaWYgdGhlIHN0YWJsZSBmcmFnbWVudCBoYXMgYSBrZXksIGl0J3MgYSA8dGVtcGxhdGUgdi1mb3I+IHRoYXQgbWF5XHJcbiAgICAgICAgICAgICAgICAvLyAgZ2V0IG1vdmVkIGFyb3VuZC4gTWFrZSBzdXJlIGFsbCByb290IGxldmVsIHZub2RlcyBpbmhlcml0IGVsLlxyXG4gICAgICAgICAgICAgICAgLy8gIzIxMzQgb3IgaWYgaXQncyBhIGNvbXBvbmVudCByb290LCBpdCBtYXkgYWxzbyBnZXQgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGlzIGJlaW5nIG1vdmVkLlxyXG4gICAgICAgICAgICAgICAgbjIua2V5ICE9IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAocGFyZW50Q29tcG9uZW50ICYmIG4yID09PSBwYXJlbnRDb21wb25lbnQuc3ViVHJlZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSAvKiBzaGFsbG93ICovKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGtleWVkIC8gdW5rZXllZCwgb3IgbWFudWFsIGZyYWdtZW50cy5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBrZXllZCAmIHVua2V5ZWQsIHNpbmNlIHRoZXkgYXJlIGNvbXBpbGVyIGdlbmVyYXRlZCBmcm9tIHYtZm9yLFxyXG4gICAgICAgICAgICAgICAgLy8gZWFjaCBjaGlsZCBpcyBndWFyYW50ZWVkIHRvIGJlIGEgYmxvY2sgc28gdGhlIGZyYWdtZW50IHdpbGwgbmV2ZXJcclxuICAgICAgICAgICAgICAgIC8vIGhhdmUgZHluYW1pY0NoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGNvbnRhaW5lciwgZnJhZ21lbnRFbmRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvY2Vzc0NvbXBvbmVudCA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBuMi5zbG90U2NvcGVJZHMgPSBzbG90U2NvcGVJZHM7XHJcbiAgICAgICAgaWYgKG4xID09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG4yLnNoYXBlRmxhZyAmIDUxMiAvKiBDT01QT05FTlRfS0VQVF9BTElWRSAqLykge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Q29tcG9uZW50LmN0eC5hY3RpdmF0ZShuMiwgY29udGFpbmVyLCBhbmNob3IsIGlzU1ZHLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW91bnRDb21wb25lbnQobjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50KG4xLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgbW91bnRDb21wb25lbnQgPSAoaW5pdGlhbFZOb2RlLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIC8vIDIueCBjb21wYXQgbWF5IHByZS1jcmVhdGUgdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBiZWZvcmUgYWN0dWFsbHlcclxuICAgICAgICAvLyBtb3VudGluZ1xyXG4gICAgICAgIGNvbnN0IGNvbXBhdE1vdW50SW5zdGFuY2UgPSBpbml0aWFsVk5vZGUuaXNDb21wYXRSb290ICYmIGluaXRpYWxWTm9kZS5jb21wb25lbnQ7XHJcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb21wYXRNb3VudEluc3RhbmNlIHx8XHJcbiAgICAgICAgICAgIChpbml0aWFsVk5vZGUuY29tcG9uZW50ID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2UoaW5pdGlhbFZOb2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKSk7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpbnN0YW5jZS50eXBlLl9faG1ySWQpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJITVIoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHB1c2hXYXJuaW5nQ29udGV4dChpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmplY3QgcmVuZGVyZXIgaW50ZXJuYWxzIGZvciBrZWVwQWxpdmVcclxuICAgICAgICBpZiAoaXNLZWVwQWxpdmUoaW5pdGlhbFZOb2RlKSkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZS5jdHgucmVuZGVyZXIgPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc29sdmUgcHJvcHMgYW5kIHNsb3RzIGZvciBzZXR1cCBjb250ZXh0XHJcbiAgICAgICAgaWYgKCEoY29tcGF0TW91bnRJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaW5pdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldHVwQ29tcG9uZW50KGluc3RhbmNlKTtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYGluaXRgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCgpIGlzIGFzeW5jLiBUaGlzIGNvbXBvbmVudCByZWxpZXMgb24gYXN5bmMgbG9naWMgdG8gYmUgcmVzb2x2ZWRcclxuICAgICAgICAvLyBiZWZvcmUgcHJvY2VlZGluZ1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCkge1xyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZSAmJiBwYXJlbnRTdXNwZW5zZS5yZWdpc3RlckRlcChpbnN0YW5jZSwgc2V0dXBSZW5kZXJFZmZlY3QpO1xyXG4gICAgICAgICAgICAvLyBHaXZlIGl0IGEgcGxhY2Vob2xkZXIgaWYgdGhpcyBpcyBub3QgaHlkcmF0aW9uXHJcbiAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIHNlbGYtZGVmaW5lZCBmYWxsYmFja1xyXG4gICAgICAgICAgICBpZiAoIWluaXRpYWxWTm9kZS5lbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSAoaW5zdGFuY2Uuc3ViVHJlZSA9IGNyZWF0ZVZOb2RlKENvbW1lbnQpKTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NDb21tZW50Tm9kZShudWxsLCBwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0dXBSZW5kZXJFZmZlY3QoaW5zdGFuY2UsIGluaXRpYWxWTm9kZSwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgb3B0aW1pemVkKTtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBtb3VudGApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnQgPSAobjEsIG4yLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IChuMi5jb21wb25lbnQgPSBuMS5jb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVDb21wb25lbnQobjEsIG4yLCBvcHRpbWl6ZWQpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAgICAgIWluc3RhbmNlLmFzeW5jUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jICYgc3RpbGwgcGVuZGluZyAtIGp1c3QgdXBkYXRlIHByb3BzIGFuZCBzbG90c1xyXG4gICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNvbXBvbmVudCdzIHJlYWN0aXZlIGVmZmVjdCBmb3IgcmVuZGVyIGlzbid0IHNldC11cCB5ZXRcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoV2FybmluZ0NvbnRleHQobjIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdXBkYXRlQ29tcG9uZW50UHJlUmVuZGVyKGluc3RhbmNlLCBuMiwgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3BXYXJuaW5nQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UubmV4dCA9IG4yO1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgY2hpbGQgY29tcG9uZW50IGlzIGFsc28gcXVldWVkLCByZW1vdmUgaXQgdG8gYXZvaWRcclxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZSB1cGRhdGluZyB0aGUgc2FtZSBjaGlsZCBjb21wb25lbnQgaW4gdGhlIHNhbWUgZmx1c2guXHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlSm9iKGluc3RhbmNlLnVwZGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZS51cGRhdGUgaXMgdGhlIHJlYWN0aXZlIGVmZmVjdC5cclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyB1cGRhdGUgbmVlZGVkLiBqdXN0IGNvcHkgb3ZlciBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnZub2RlID0gbjI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNldHVwUmVuZGVyRWZmZWN0ID0gKGluc3RhbmNlLCBpbml0aWFsVk5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIG9wdGltaXplZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFVwZGF0ZUZuID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlLmlzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWwsIHByb3BzIH0gPSBpbml0aWFsVk5vZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJtLCBtLCBwYXJlbnQgfSA9IGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNBc3luY1dyYXBwZXJWTm9kZSA9IGlzQXN5bmNXcmFwcGVyKGluaXRpYWxWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVNb3VudCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAoYm0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VBcnJheUZucyhibSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlQmVmb3JlTW91bnRcclxuICAgICAgICAgICAgICAgIGlmICghaXNBc3luY1dyYXBwZXJWTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlTW91bnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBpbml0aWFsVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIklOU1RBTkNFX0VWRU5UX0hPT0tTXCIgLyogSU5TVEFOQ0VfRVZFTlRfSE9PS1MgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmVtaXQoJ2hvb2s6YmVmb3JlTW91bnQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsICYmIGh5ZHJhdGVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm5vZGUgaGFzIGFkb3B0ZWQgaG9zdCBub2RlIC0gcGVyZm9ybSBoeWRyYXRpb24gaW5zdGVhZCBvZiBtb3VudC5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlU3ViVHJlZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IHJlbmRlckNvbXBvbmVudFJvb3QoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcmVuZGVyYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVOb2RlKGVsLCBpbnN0YW5jZS5zdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgaHlkcmF0ZWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1dyYXBwZXJWTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUudHlwZS5fX2FzeW5jTG9hZGVyKCkudGhlbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogd2UgYXJlIG1vdmluZyB0aGUgcmVuZGVyIGNhbGwgaW50byBhbiBhc3luYyBjYWxsYmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgd29uJ3QgdHJhY2sgZGVwZW5kZW5jaWVzIC0gYnV0IGl0J3Mgb2sgYmVjYXVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHNlcnZlci1yZW5kZXJlZCBhc3luYyB3cmFwcGVyIGlzIGFscmVhZHkgaW4gcmVzb2x2ZWQgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IHdpbGwgbmV2ZXIgbmVlZCB0byBjaGFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICFpbnN0YW5jZS5pc1VubW91bnRlZCAmJiBoeWRyYXRlU3ViVHJlZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGVTdWJUcmVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IChpbnN0YW5jZS5zdWJUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIHN1YlRyZWUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE1lYXN1cmUoaW5zdGFuY2UsIGBwYXRjaGApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUuZWwgPSBzdWJUcmVlLmVsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnRlZCBob29rXHJcbiAgICAgICAgICAgICAgICBpZiAobSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdChtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvblZub2RlTW91bnRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FzeW5jV3JhcHBlclZOb2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHZub2RlSG9vayA9IHByb3BzICYmIHByb3BzLm9uVm5vZGVNb3VudGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjb3BlZEluaXRpYWxWTm9kZSA9IGluaXRpYWxWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoKCkgPT4gaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50LCBzY29wZWRJbml0aWFsVk5vZGUpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRFbmFibGVkKFwiSU5TVEFOQ0VfRVZFTlRfSE9PS1NcIiAvKiBJTlNUQU5DRV9FVkVOVF9IT09LUyAqLywgaW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGluc3RhbmNlLmVtaXQoJ2hvb2s6bW91bnRlZCcpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBhY3RpdmF0ZWQgaG9vayBmb3Iga2VlcC1hbGl2ZSByb290cy5cclxuICAgICAgICAgICAgICAgIC8vICMxNzQyIGFjdGl2YXRlZCBob29rIG11c3QgYmUgYWNjZXNzZWQgYWZ0ZXIgZmlyc3QgcmVuZGVyXHJcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB0aGUgaG9vayBtYXkgYmUgaW5qZWN0ZWQgYnkgYSBjaGlsZCBrZWVwLWFsaXZlXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbFZOb2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAocGFyZW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXN5bmNXcmFwcGVyKHBhcmVudC52bm9kZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnZub2RlLnNoYXBlRmxhZyAmIDI1NiAvKiBDT01QT05FTlRfU0hPVUxEX0tFRVBfQUxJVkUgKi8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuYSAmJiBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QoaW5zdGFuY2UuYSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9FVkVOVF9IT09LU1wiIC8qIElOU1RBTkNFX0VWRU5UX0hPT0tTICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGluc3RhbmNlLmVtaXQoJ2hvb2s6YWN0aXZhdGVkJyksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc01vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudEFkZGVkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICMyNDU4OiBkZWZlcmVuY2UgbW91bnQtb25seSBvYmplY3QgcGFyYW1ldGVycyB0byBwcmV2ZW50IG1lbWxlYWtzXHJcbiAgICAgICAgICAgICAgICBpbml0aWFsVk5vZGUgPSBjb250YWluZXIgPSBhbmNob3IgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRyaWdnZXJlZCBieSBtdXRhdGlvbiBvZiBjb21wb25lbnQncyBvd24gc3RhdGUgKG5leHQ6IG51bGwpXHJcbiAgICAgICAgICAgICAgICAvLyBPUiBwYXJlbnQgY2FsbGluZyBwcm9jZXNzQ29tcG9uZW50IChuZXh0OiBWTm9kZSlcclxuICAgICAgICAgICAgICAgIGxldCB7IG5leHQsIGJ1LCB1LCBwYXJlbnQsIHZub2RlIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5OZXh0ID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGxldCB2bm9kZUhvb2s7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaFdhcm5pbmdDb250ZXh0KG5leHQgfHwgaW5zdGFuY2Uudm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWxsb3cgY29tcG9uZW50IGVmZmVjdCByZWN1cnNpb24gZHVyaW5nIHByZS1saWZlY3ljbGUgaG9va3MuXHJcbiAgICAgICAgICAgICAgICB0b2dnbGVSZWN1cnNlKGluc3RhbmNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHQuZWwgPSB2bm9kZS5lbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIoaW5zdGFuY2UsIG5leHQsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gdm5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmVVcGRhdGUgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJyYXlGbnMoYnUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZUJlZm9yZVVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgaWYgKCh2bm9kZUhvb2sgPSBuZXh0LnByb3BzICYmIG5leHQucHJvcHMub25Wbm9kZUJlZm9yZVVwZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9FVkVOVF9IT09LU1wiIC8qIElOU1RBTkNFX0VWRU5UX0hPT0tTICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5lbWl0KCdob29rOmJlZm9yZVVwZGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUmVjdXJzZShpbnN0YW5jZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGByZW5kZXJgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUcmVlID0gcmVuZGVyQ29tcG9uZW50Um9vdChpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTWVhc3VyZShpbnN0YW5jZSwgYHJlbmRlcmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldlRyZWUgPSBpbnN0YW5jZS5zdWJUcmVlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc3ViVHJlZSA9IG5leHRUcmVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TWVhc3VyZShpbnN0YW5jZSwgYHBhdGNoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRjaChwcmV2VHJlZSwgbmV4dFRyZWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIHRlbGVwb3J0XHJcbiAgICAgICAgICAgICAgICBob3N0UGFyZW50Tm9kZShwcmV2VHJlZS5lbCksIFxyXG4gICAgICAgICAgICAgICAgLy8gYW5jaG9yIG1heSBoYXZlIGNoYW5nZWQgaWYgaXQncyBpbiBhIGZyYWdtZW50XHJcbiAgICAgICAgICAgICAgICBnZXROZXh0SG9zdE5vZGUocHJldlRyZWUpLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgcGF0Y2hgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQuZWwgPSBuZXh0VHJlZS5lbDtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5OZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VsZi10cmlnZ2VyZWQgdXBkYXRlLiBJbiBjYXNlIG9mIEhPQywgdXBkYXRlIHBhcmVudCBjb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyB2bm9kZSBlbC4gSE9DIGlzIGluZGljYXRlZCBieSBwYXJlbnQgaW5zdGFuY2UncyBzdWJUcmVlIHBvaW50aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2hpbGQgY29tcG9uZW50J3Mgdm5vZGVcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIT0NIb3N0RWwoaW5zdGFuY2UsIG5leHRUcmVlLmVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZWQgaG9va1xyXG4gICAgICAgICAgICAgICAgaWYgKHUpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVBvc3RSZW5kZXJFZmZlY3QodSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb25Wbm9kZVVwZGF0ZWRcclxuICAgICAgICAgICAgICAgIGlmICgodm5vZGVIb29rID0gbmV4dC5wcm9wcyAmJiBuZXh0LnByb3BzLm9uVm5vZGVVcGRhdGVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnQsIG5leHQsIHZub2RlKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0RW5hYmxlZChcIklOU1RBTkNFX0VWRU5UX0hPT0tTXCIgLyogSU5TVEFOQ0VfRVZFTlRfSE9PS1MgKi8sIGluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlUG9zdFJlbmRlckVmZmVjdCgoKSA9PiBpbnN0YW5jZS5lbWl0KCdob29rOnVwZGF0ZWQnKSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXZ0b29sc0NvbXBvbmVudFVwZGF0ZWQoaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcFdhcm5pbmdDb250ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNyZWF0ZSByZWFjdGl2ZSBlZmZlY3QgZm9yIHJlbmRlcmluZ1xyXG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IChpbnN0YW5jZS5lZmZlY3QgPSBuZXcgUmVhY3RpdmVFZmZlY3QoY29tcG9uZW50VXBkYXRlRm4sICgpID0+IHF1ZXVlSm9iKHVwZGF0ZSksIGluc3RhbmNlLnNjb3BlIC8vIHRyYWNrIGl0IGluIGNvbXBvbmVudCdzIGVmZmVjdCBzY29wZVxyXG4gICAgICAgICkpO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IChpbnN0YW5jZS51cGRhdGUgPSAoKSA9PiBlZmZlY3QucnVuKCkpO1xyXG4gICAgICAgIHVwZGF0ZS5pZCA9IGluc3RhbmNlLnVpZDtcclxuICAgICAgICAvLyBhbGxvd1JlY3Vyc2VcclxuICAgICAgICAvLyAjMTgwMSwgIzIwNDMgY29tcG9uZW50IHJlbmRlciBlZmZlY3RzIHNob3VsZCBhbGxvdyByZWN1cnNpdmUgdXBkYXRlc1xyXG4gICAgICAgIHRvZ2dsZVJlY3Vyc2UoaW5zdGFuY2UsIHRydWUpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZWZmZWN0Lm9uVHJhY2sgPSBpbnN0YW5jZS5ydGNcclxuICAgICAgICAgICAgICAgID8gZSA9PiBpbnZva2VBcnJheUZucyhpbnN0YW5jZS5ydGMsIGUpXHJcbiAgICAgICAgICAgICAgICA6IHZvaWQgMDtcclxuICAgICAgICAgICAgZWZmZWN0Lm9uVHJpZ2dlciA9IGluc3RhbmNlLnJ0Z1xyXG4gICAgICAgICAgICAgICAgPyBlID0+IGludm9rZUFycmF5Rm5zKGluc3RhbmNlLnJ0ZywgZSlcclxuICAgICAgICAgICAgICAgIDogdm9pZCAwO1xyXG4gICAgICAgICAgICB1cGRhdGUub3duZXJJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGUoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1cGRhdGVDb21wb25lbnRQcmVSZW5kZXIgPSAoaW5zdGFuY2UsIG5leHRWTm9kZSwgb3B0aW1pemVkKSA9PiB7XHJcbiAgICAgICAgbmV4dFZOb2RlLmNvbXBvbmVudCA9IGluc3RhbmNlO1xyXG4gICAgICAgIGNvbnN0IHByZXZQcm9wcyA9IGluc3RhbmNlLnZub2RlLnByb3BzO1xyXG4gICAgICAgIGluc3RhbmNlLnZub2RlID0gbmV4dFZOb2RlO1xyXG4gICAgICAgIGluc3RhbmNlLm5leHQgPSBudWxsO1xyXG4gICAgICAgIHVwZGF0ZVByb3BzKGluc3RhbmNlLCBuZXh0Vk5vZGUucHJvcHMsIHByZXZQcm9wcywgb3B0aW1pemVkKTtcclxuICAgICAgICB1cGRhdGVTbG90cyhpbnN0YW5jZSwgbmV4dFZOb2RlLmNoaWxkcmVuLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIHBhdXNlVHJhY2tpbmcoKTtcclxuICAgICAgICAvLyBwcm9wcyB1cGRhdGUgbWF5IGhhdmUgdHJpZ2dlcmVkIHByZS1mbHVzaCB3YXRjaGVycy5cclxuICAgICAgICAvLyBmbHVzaCB0aGVtIGJlZm9yZSB0aGUgcmVuZGVyIHVwZGF0ZS5cclxuICAgICAgICBmbHVzaFByZUZsdXNoQ2JzKHVuZGVmaW5lZCwgaW5zdGFuY2UudXBkYXRlKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcGF0Y2hDaGlsZHJlbiA9IChuMSwgbjIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGMxID0gbjEgJiYgbjEuY2hpbGRyZW47XHJcbiAgICAgICAgY29uc3QgcHJldlNoYXBlRmxhZyA9IG4xID8gbjEuc2hhcGVGbGFnIDogMDtcclxuICAgICAgICBjb25zdCBjMiA9IG4yLmNoaWxkcmVuO1xyXG4gICAgICAgIGNvbnN0IHsgcGF0Y2hGbGFnLCBzaGFwZUZsYWcgfSA9IG4yO1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aFxyXG4gICAgICAgIGlmIChwYXRjaEZsYWcgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRjaEZsYWcgJiAxMjggLyogS0VZRURfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY291bGQgYmUgZWl0aGVyIGZ1bGx5LWtleWVkIG9yIG1peGVkIChzb21lIGtleWVkIHNvbWUgbm90KVxyXG4gICAgICAgICAgICAgICAgLy8gcHJlc2VuY2Ugb2YgcGF0Y2hGbGFnIG1lYW5zIGNoaWxkcmVuIGFyZSBndWFyYW50ZWVkIHRvIGJlIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hLZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0Y2hGbGFnICYgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pIHtcclxuICAgICAgICAgICAgICAgIC8vIHVua2V5ZWRcclxuICAgICAgICAgICAgICAgIHBhdGNoVW5rZXllZENoaWxkcmVuKGMxLCBjMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hpbGRyZW4gaGFzIDMgcG9zc2liaWxpdGllczogdGV4dCwgYXJyYXkgb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDggLyogVEVYVF9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAvLyB0ZXh0IGNoaWxkcmVuIGZhc3QgcGF0aFxyXG4gICAgICAgICAgICBpZiAocHJldlNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gYzEpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RTZXRFbGVtZW50VGV4dChjb250YWluZXIsIGMyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHByZXZTaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJldiBjaGlsZHJlbiB3YXMgYXJyYXlcclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR3byBhcnJheXMsIGNhbm5vdCBhc3N1bWUgYW55dGhpbmcsIGRvIGZ1bGwgZGlmZlxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoS2V5ZWRDaGlsZHJlbihjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmV3IGNoaWxkcmVuLCBqdXN0IHVubW91bnQgb2xkXHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGMxLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHByZXYgY2hpbGRyZW4gd2FzIHRleHQgT1IgbnVsbFxyXG4gICAgICAgICAgICAgICAgLy8gbmV3IGNoaWxkcmVuIGlzIGFycmF5IE9SIG51bGxcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2U2hhcGVGbGFnICYgOCAvKiBURVhUX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdFNldEVsZW1lbnRUZXh0KGNvbnRhaW5lciwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW91bnQgbmV3IGlmIGFycmF5XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VudENoaWxkcmVuKGMyLCBjb250YWluZXIsIGFuY2hvciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcywgb3B0aW1pemVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBwYXRjaFVua2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBjMSA9IGMxIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjMiA9IGMyIHx8IEVNUFRZX0FSUjtcclxuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBjMS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gYzIubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGNvbW1vbkxlbmd0aCA9IE1hdGgubWluKG9sZExlbmd0aCwgbmV3TGVuZ3RoKTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29tbW9uTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVWTm9kZShjMltpXSkpO1xyXG4gICAgICAgICAgICBwYXRjaChjMVtpXSwgbmV4dENoaWxkLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbGRMZW5ndGggPiBuZXdMZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZFxyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oYzEsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsIGZhbHNlLCBjb21tb25MZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbW91bnQgbmV3XHJcbiAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oYzIsIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQsIGNvbW1vbkxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBhbGwta2V5ZWQgb3IgbWl4ZWRcclxuICAgIGNvbnN0IHBhdGNoS2V5ZWRDaGlsZHJlbiA9IChjMSwgYzIsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpID0+IHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgbDIgPSBjMi5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGUxID0gYzEubGVuZ3RoIC0gMTsgLy8gcHJldiBlbmRpbmcgaW5kZXhcclxuICAgICAgICBsZXQgZTIgPSBsMiAtIDE7IC8vIG5leHQgZW5kaW5nIGluZGV4XHJcbiAgICAgICAgLy8gMS4gc3luYyBmcm9tIHN0YXJ0XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpIGQgZVxyXG4gICAgICAgIHdoaWxlIChpIDw9IGUxICYmIGkgPD0gZTIpIHtcclxuICAgICAgICAgICAgY29uc3QgbjEgPSBjMVtpXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbaV0gPSBvcHRpbWl6ZWRcclxuICAgICAgICAgICAgICAgID8gY2xvbmVJZk1vdW50ZWQoYzJbaV0pXHJcbiAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDIuIHN5bmMgZnJvbSBlbmRcclxuICAgICAgICAvLyBhIChiIGMpXHJcbiAgICAgICAgLy8gZCBlIChiIGMpXHJcbiAgICAgICAgd2hpbGUgKGkgPD0gZTEgJiYgaSA8PSBlMikge1xyXG4gICAgICAgICAgICBjb25zdCBuMSA9IGMxW2UxXTtcclxuICAgICAgICAgICAgY29uc3QgbjIgPSAoYzJbZTJdID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2UyXSlcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplVk5vZGUoYzJbZTJdKSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NhbWVWTm9kZVR5cGUobjEsIG4yKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2gobjEsIG4yLCBjb250YWluZXIsIG51bGwsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlMS0tO1xyXG4gICAgICAgICAgICBlMi0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLiBjb21tb24gc2VxdWVuY2UgKyBtb3VudFxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIGkgPSAyLCBlMSA9IDEsIGUyID0gMlxyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gYyAoYSBiKVxyXG4gICAgICAgIC8vIGkgPSAwLCBlMSA9IC0xLCBlMiA9IDBcclxuICAgICAgICBpZiAoaSA+IGUxKSB7XHJcbiAgICAgICAgICAgIGlmIChpIDw9IGUyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UG9zID0gZTIgKyAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbmV4dFBvcyA8IGwyID8gYzJbbmV4dFBvc10uZWwgOiBwYXJlbnRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8PSBlMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIChjMltpXSA9IG9wdGltaXplZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNsb25lSWZNb3VudGVkKGMyW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSksIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA0LiBjb21tb24gc2VxdWVuY2UgKyB1bm1vdW50XHJcbiAgICAgICAgLy8gKGEgYikgY1xyXG4gICAgICAgIC8vIChhIGIpXHJcbiAgICAgICAgLy8gaSA9IDIsIGUxID0gMiwgZTIgPSAxXHJcbiAgICAgICAgLy8gYSAoYiBjKVxyXG4gICAgICAgIC8vIChiIGMpXHJcbiAgICAgICAgLy8gaSA9IDAsIGUxID0gMCwgZTIgPSAtMVxyXG4gICAgICAgIGVsc2UgaWYgKGkgPiBlMikge1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8PSBlMSkge1xyXG4gICAgICAgICAgICAgICAgdW5tb3VudChjMVtpXSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNS4gdW5rbm93biBzZXF1ZW5jZVxyXG4gICAgICAgIC8vIFtpIC4uLiBlMSArIDFdOiBhIGIgW2MgZCBlXSBmIGdcclxuICAgICAgICAvLyBbaSAuLi4gZTIgKyAxXTogYSBiIFtlIGQgYyBoXSBmIGdcclxuICAgICAgICAvLyBpID0gMiwgZTEgPSA0LCBlMiA9IDVcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgczEgPSBpOyAvLyBwcmV2IHN0YXJ0aW5nIGluZGV4XHJcbiAgICAgICAgICAgIGNvbnN0IHMyID0gaTsgLy8gbmV4dCBzdGFydGluZyBpbmRleFxyXG4gICAgICAgICAgICAvLyA1LjEgYnVpbGQga2V5OmluZGV4IG1hcCBmb3IgbmV3Q2hpbGRyZW5cclxuICAgICAgICAgICAgY29uc3Qga2V5VG9OZXdJbmRleE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgZm9yIChpID0gczI7IGkgPD0gZTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gKGMyW2ldID0gb3B0aW1pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgPyBjbG9uZUlmTW91bnRlZChjMltpXSlcclxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZVZOb2RlKGMyW2ldKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBrZXlUb05ld0luZGV4TWFwLmhhcyhuZXh0Q2hpbGQua2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYER1cGxpY2F0ZSBrZXlzIGZvdW5kIGR1cmluZyB1cGRhdGU6YCwgSlNPTi5zdHJpbmdpZnkobmV4dENoaWxkLmtleSksIGBNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLmApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBrZXlUb05ld0luZGV4TWFwLnNldChuZXh0Q2hpbGQua2V5LCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjIgbG9vcCB0aHJvdWdoIG9sZCBjaGlsZHJlbiBsZWZ0IHRvIGJlIHBhdGNoZWQgYW5kIHRyeSB0byBwYXRjaFxyXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBub2RlcyAmIHJlbW92ZSBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudFxyXG4gICAgICAgICAgICBsZXQgajtcclxuICAgICAgICAgICAgbGV0IHBhdGNoZWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCB0b0JlUGF0Y2hlZCA9IGUyIC0gczIgKyAxO1xyXG4gICAgICAgICAgICBsZXQgbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLy8gdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBub2RlIGhhcyBtb3ZlZFxyXG4gICAgICAgICAgICBsZXQgbWF4TmV3SW5kZXhTb0ZhciA9IDA7XHJcbiAgICAgICAgICAgIC8vIHdvcmtzIGFzIE1hcDxuZXdJbmRleCwgb2xkSW5kZXg+XHJcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbGRJbmRleCBpcyBvZmZzZXQgYnkgKzFcclxuICAgICAgICAgICAgLy8gYW5kIG9sZEluZGV4ID0gMCBpcyBhIHNwZWNpYWwgdmFsdWUgaW5kaWNhdGluZyB0aGUgbmV3IG5vZGUgaGFzXHJcbiAgICAgICAgICAgIC8vIG5vIGNvcnJlc3BvbmRpbmcgb2xkIG5vZGUuXHJcbiAgICAgICAgICAgIC8vIHVzZWQgZm9yIGRldGVybWluaW5nIGxvbmdlc3Qgc3RhYmxlIHN1YnNlcXVlbmNlXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4VG9PbGRJbmRleE1hcCA9IG5ldyBBcnJheSh0b0JlUGF0Y2hlZCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b0JlUGF0Y2hlZDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW2ldID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gczE7IGkgPD0gZTE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoaWxkID0gYzFbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0Y2hlZCA+PSB0b0JlUGF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBuZXcgY2hpbGRyZW4gaGF2ZSBiZWVuIHBhdGNoZWQgc28gdGhpcyBjYW4gb25seSBiZSBhIHJlbW92YWxcclxuICAgICAgICAgICAgICAgICAgICB1bm1vdW50KHByZXZDaGlsZCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXggPSBrZXlUb05ld0luZGV4TWFwLmdldChwcmV2Q2hpbGQua2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleS1sZXNzIG5vZGUsIHRyeSB0byBsb2NhdGUgYSBrZXktbGVzcyBub2RlIG9mIHRoZSBzYW1lIHR5cGVcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBzMjsgaiA8PSBlMjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleFRvT2xkSW5kZXhNYXBbaiAtIHMyXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lVk5vZGVUeXBlKHByZXZDaGlsZCwgYzJbal0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudChwcmV2Q2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5kZXhUb09sZEluZGV4TWFwW25ld0luZGV4IC0gczJdID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4ID49IG1heE5ld0luZGV4U29GYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4TmV3SW5kZXhTb0ZhciA9IG5ld0luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXRjaChwcmV2Q2hpbGQsIGMyW25ld0luZGV4XSwgY29udGFpbmVyLCBudWxsLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoZWQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyA1LjMgbW92ZSBhbmQgbW91bnRcclxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgbG9uZ2VzdCBzdGFibGUgc3Vic2VxdWVuY2Ugb25seSB3aGVuIG5vZGVzIGhhdmUgbW92ZWRcclxuICAgICAgICAgICAgY29uc3QgaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2UgPSBtb3ZlZFxyXG4gICAgICAgICAgICAgICAgPyBnZXRTZXF1ZW5jZShuZXdJbmRleFRvT2xkSW5kZXhNYXApXHJcbiAgICAgICAgICAgICAgICA6IEVNUFRZX0FSUjtcclxuICAgICAgICAgICAgaiA9IGluY3JlYXNpbmdOZXdJbmRleFNlcXVlbmNlLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIC8vIGxvb3BpbmcgYmFja3dhcmRzIHNvIHRoYXQgd2UgY2FuIHVzZSBsYXN0IHBhdGNoZWQgbm9kZSBhcyBhbmNob3JcclxuICAgICAgICAgICAgZm9yIChpID0gdG9CZVBhdGNoZWQgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gczIgKyBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gYzJbbmV4dEluZGV4XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IG5leHRJbmRleCArIDEgPCBsMiA/IGMyW25leHRJbmRleCArIDFdLmVsIDogcGFyZW50QW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0luZGV4VG9PbGRJbmRleE1hcFtpXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50IG5ld1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGNoKG51bGwsIG5leHRDaGlsZCwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgaWY6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc3RhYmxlIHN1YnNlcXVlbmNlIChlLmcuIGEgcmV2ZXJzZSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBPUiBjdXJyZW50IG5vZGUgaXMgbm90IGFtb25nIHRoZSBzdGFibGUgc2VxdWVuY2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IDAgfHwgaSAhPT0gaW5jcmVhc2luZ05ld0luZGV4U2VxdWVuY2Vbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZShuZXh0Q2hpbGQsIGNvbnRhaW5lciwgYW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBtb3ZlID0gKHZub2RlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUsIHBhcmVudFN1c3BlbnNlID0gbnVsbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZWwsIHR5cGUsIHRyYW5zaXRpb24sIGNoaWxkcmVuLCBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICBtb3ZlKHZub2RlLmNvbXBvbmVudC5zdWJUcmVlLCBjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgdm5vZGUuc3VzcGVuc2UubW92ZShjb250YWluZXIsIGFuY2hvciwgbW92ZVR5cGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICB0eXBlLm1vdmUodm5vZGUsIGNvbnRhaW5lciwgYW5jaG9yLCBpbnRlcm5hbHMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBGcmFnbWVudCkge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgYW5jaG9yLCBtb3ZlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9zdEluc2VydCh2bm9kZS5hbmNob3IsIGNvbnRhaW5lciwgYW5jaG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgICAgICAgIG1vdmVTdGF0aWNOb2RlKHZub2RlLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2luZ2xlIG5vZGVzXHJcbiAgICAgICAgY29uc3QgbmVlZFRyYW5zaXRpb24gPSBtb3ZlVHlwZSAhPT0gMiAvKiBSRU9SREVSICovICYmXHJcbiAgICAgICAgICAgIHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uO1xyXG4gICAgICAgIGlmIChuZWVkVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogRU5URVIgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYmVmb3JlRW50ZXIoZWwpO1xyXG4gICAgICAgICAgICAgICAgaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHRyYW5zaXRpb24uZW50ZXIoZWwpLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYXZlLCBkZWxheUxlYXZlLCBhZnRlckxlYXZlIH0gPSB0cmFuc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlID0gKCkgPT4gaG9zdEluc2VydChlbCwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKGVsLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVsYXlMZWF2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUoZWwsIHJlbW92ZSwgcGVyZm9ybUxlYXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBob3N0SW5zZXJ0KGVsLCBjb250YWluZXIsIGFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnQgPSAodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlID0gZmFsc2UsIG9wdGltaXplZCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwcm9wcywgcmVmLCBjaGlsZHJlbiwgZHluYW1pY0NoaWxkcmVuLCBzaGFwZUZsYWcsIHBhdGNoRmxhZywgZGlycyB9ID0gdm5vZGU7XHJcbiAgICAgICAgLy8gdW5zZXQgcmVmXHJcbiAgICAgICAgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFJlZihyZWYsIG51bGwsIHBhcmVudFN1c3BlbnNlLCB2bm9kZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiAyNTYgLyogQ09NUE9ORU5UX1NIT1VMRF9LRUVQX0FMSVZFICovKSB7XHJcbiAgICAgICAgICAgIHBhcmVudENvbXBvbmVudC5jdHguZGVhY3RpdmF0ZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2hvdWxkSW52b2tlRGlycyA9IHNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiBkaXJzO1xyXG4gICAgICAgIGNvbnN0IHNob3VsZEludm9rZVZub2RlSG9vayA9ICFpc0FzeW5jV3JhcHBlcih2bm9kZSk7XHJcbiAgICAgICAgbGV0IHZub2RlSG9vaztcclxuICAgICAgICBpZiAoc2hvdWxkSW52b2tlVm5vZGVIb29rICYmXHJcbiAgICAgICAgICAgICh2bm9kZUhvb2sgPSBwcm9wcyAmJiBwcm9wcy5vblZub2RlQmVmb3JlVW5tb3VudCkpIHtcclxuICAgICAgICAgICAgaW52b2tlVk5vZGVIb29rKHZub2RlSG9vaywgcGFyZW50Q29tcG9uZW50LCB2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICB1bm1vdW50Q29tcG9uZW50KHZub2RlLmNvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxMjggLyogU1VTUEVOU0UgKi8pIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLnN1c3BlbnNlLnVubW91bnQocGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2hvdWxkSW52b2tlRGlycykge1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRGlyZWN0aXZlSG9vayh2bm9kZSwgbnVsbCwgcGFyZW50Q29tcG9uZW50LCAnYmVmb3JlVW5tb3VudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiA2NCAvKiBURUxFUE9SVCAqLykge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUudHlwZS5yZW1vdmUodm5vZGUsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIG9wdGltaXplZCwgaW50ZXJuYWxzLCBkb1JlbW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY0NoaWxkcmVuICYmXHJcbiAgICAgICAgICAgICAgICAvLyAjMTE1MzogZmFzdCBwYXRoIHNob3VsZCBub3QgYmUgdGFrZW4gZm9yIG5vbi1zdGFibGUgKHYtZm9yKSBmcmFnbWVudHNcclxuICAgICAgICAgICAgICAgICh0eXBlICE9PSBGcmFnbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChwYXRjaEZsYWcgPiAwICYmIHBhdGNoRmxhZyAmIDY0IC8qIFNUQUJMRV9GUkFHTUVOVCAqLykpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggZm9yIGJsb2NrIG5vZGVzOiBvbmx5IG5lZWQgdG8gdW5tb3VudCBkeW5hbWljIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgdW5tb3VudENoaWxkcmVuKGR5bmFtaWNDaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eXBlID09PSBGcmFnbWVudCAmJlxyXG4gICAgICAgICAgICAgICAgcGF0Y2hGbGFnICZcclxuICAgICAgICAgICAgICAgICAgICAoMTI4IC8qIEtFWUVEX0ZSQUdNRU5UICovIHwgMjU2IC8qIFVOS0VZRURfRlJBR01FTlQgKi8pKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFvcHRpbWl6ZWQgJiYgc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKHZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHNob3VsZEludm9rZVZub2RlSG9vayAmJlxyXG4gICAgICAgICAgICAodm5vZGVIb29rID0gcHJvcHMgJiYgcHJvcHMub25Wbm9kZVVubW91bnRlZCkpIHx8XHJcbiAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZub2RlSG9vayAmJiBpbnZva2VWTm9kZUhvb2sodm5vZGVIb29rLCBwYXJlbnRDb21wb25lbnQsIHZub2RlKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZEludm9rZURpcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VEaXJlY3RpdmVIb29rKHZub2RlLCBudWxsLCBwYXJlbnRDb21wb25lbnQsICd1bm1vdW50ZWQnKTtcclxuICAgICAgICAgICAgfSwgcGFyZW50U3VzcGVuc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBlbCwgYW5jaG9yLCB0cmFuc2l0aW9uIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgdm5vZGUucGF0Y2hGbGFnICYgMjA0OCAvKiBERVZfUk9PVF9GUkFHTUVOVCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gQ29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0UmVtb3ZlKGNoaWxkLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVGcmFnbWVudChlbCwgYW5jaG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlID09PSBTdGF0aWMpIHtcclxuICAgICAgICAgICAgcmVtb3ZlU3RhdGljTm9kZSh2bm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGVyZm9ybVJlbW92ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShlbCk7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uICYmICF0cmFuc2l0aW9uLnBlcnNpc3RlZCAmJiB0cmFuc2l0aW9uLmFmdGVyTGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uYWZ0ZXJMZWF2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmXHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24gJiZcclxuICAgICAgICAgICAgIXRyYW5zaXRpb24ucGVyc2lzdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbGVhdmUsIGRlbGF5TGVhdmUgfSA9IHRyYW5zaXRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHBlcmZvcm1MZWF2ZSA9ICgpID0+IGxlYXZlKGVsLCBwZXJmb3JtUmVtb3ZlKTtcclxuICAgICAgICAgICAgaWYgKGRlbGF5TGVhdmUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGF5TGVhdmUodm5vZGUuZWwsIHBlcmZvcm1SZW1vdmUsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwZXJmb3JtTGVhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGVyZm9ybVJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCByZW1vdmVGcmFnbWVudCA9IChjdXIsIGVuZCkgPT4ge1xyXG4gICAgICAgIC8vIEZvciBmcmFnbWVudHMsIGRpcmVjdGx5IHJlbW92ZSBhbGwgY29udGFpbmVkIERPTSBub2Rlcy5cclxuICAgICAgICAvLyAoZnJhZ21lbnQgY2hpbGQgbm9kZXMgY2Fubm90IGhhdmUgdHJhbnNpdGlvbilcclxuICAgICAgICBsZXQgbmV4dDtcclxuICAgICAgICB3aGlsZSAoY3VyICE9PSBlbmQpIHtcclxuICAgICAgICAgICAgbmV4dCA9IGhvc3ROZXh0U2libGluZyhjdXIpO1xyXG4gICAgICAgICAgICBob3N0UmVtb3ZlKGN1cik7XHJcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhvc3RSZW1vdmUoZW5kKTtcclxuICAgIH07XHJcbiAgICBjb25zdCB1bm1vdW50Q29tcG9uZW50ID0gKGluc3RhbmNlLCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUpID0+IHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIGluc3RhbmNlLnR5cGUuX19obXJJZCkge1xyXG4gICAgICAgICAgICB1bnJlZ2lzdGVySE1SKGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBidW0sIHNjb3BlLCB1cGRhdGUsIHN1YlRyZWUsIHVtIH0gPSBpbnN0YW5jZTtcclxuICAgICAgICAvLyBiZWZvcmVVbm1vdW50IGhvb2tcclxuICAgICAgICBpZiAoYnVtKSB7XHJcbiAgICAgICAgICAgIGludm9rZUFycmF5Rm5zKGJ1bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9FVkVOVF9IT09LU1wiIC8qIElOU1RBTkNFX0VWRU5UX0hPT0tTICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZW1pdCgnaG9vazpiZWZvcmVEZXN0cm95Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0b3AgZWZmZWN0cyBpbiBjb21wb25lbnQgc2NvcGVcclxuICAgICAgICBzY29wZS5zdG9wKCk7XHJcbiAgICAgICAgLy8gdXBkYXRlIG1heSBiZSBudWxsIGlmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgaXRzIGFzeW5jXHJcbiAgICAgICAgLy8gc2V0dXAgaGFzIHJlc29sdmVkLlxyXG4gICAgICAgIGlmICh1cGRhdGUpIHtcclxuICAgICAgICAgICAgLy8gc28gdGhhdCBzY2hlZHVsZXIgd2lsbCBubyBsb25nZXIgaW52b2tlIGl0XHJcbiAgICAgICAgICAgIHVwZGF0ZS5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdW5tb3VudChzdWJUcmVlLCBpbnN0YW5jZSwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdW5tb3VudGVkIGhvb2tcclxuICAgICAgICBpZiAodW0pIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KHVtLCBwYXJlbnRTdXNwZW5zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0NvbXBhdEVuYWJsZWQoXCJJTlNUQU5DRV9FVkVOVF9IT09LU1wiIC8qIElOU1RBTkNFX0VWRU5UX0hPT0tTICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IGluc3RhbmNlLmVtaXQoJ2hvb2s6ZGVzdHJveWVkJyksIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVQb3N0UmVuZGVyRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuaXNVbm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgICAgIH0sIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICAvLyBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIGRlcCBpbnNpZGUgYSBwZW5kaW5nIHN1c3BlbnNlIGlzIHVubW91bnRlZCBiZWZvcmVcclxuICAgICAgICAvLyBpdHMgYXN5bmMgZGVwIHJlc29sdmVzLiBUaGlzIHNob3VsZCByZW1vdmUgdGhlIGRlcCBmcm9tIHRoZSBzdXNwZW5zZSwgYW5kXHJcbiAgICAgICAgLy8gY2F1c2UgdGhlIHN1c3BlbnNlIHRvIHJlc29sdmUgaW1tZWRpYXRlbHkgaWYgdGhhdCB3YXMgdGhlIGxhc3QgZGVwLlxyXG4gICAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSAmJlxyXG4gICAgICAgICAgICBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nQnJhbmNoICYmXHJcbiAgICAgICAgICAgICFwYXJlbnRTdXNwZW5zZS5pc1VubW91bnRlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5hc3luY0RlcCAmJlxyXG4gICAgICAgICAgICAhaW5zdGFuY2UuYXN5bmNSZXNvbHZlZCAmJlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdXNwZW5zZUlkID09PSBwYXJlbnRTdXNwZW5zZS5wZW5kaW5nSWQpIHtcclxuICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UuZGVwcy0tO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50U3VzcGVuc2UuZGVwcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50U3VzcGVuc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSB7XHJcbiAgICAgICAgICAgIGRldnRvb2xzQ29tcG9uZW50UmVtb3ZlZChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHVubW91bnRDaGlsZHJlbiA9IChjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgZG9SZW1vdmUgPSBmYWxzZSwgb3B0aW1pemVkID0gZmFsc2UsIHN0YXJ0ID0gMCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHVubW91bnQoY2hpbGRyZW5baV0sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGRvUmVtb3ZlLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBnZXROZXh0SG9zdE5vZGUgPSB2bm9kZSA9PiB7XHJcbiAgICAgICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0SG9zdE5vZGUodm5vZGUuY29tcG9uZW50LnN1YlRyZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodm5vZGUuc2hhcGVGbGFnICYgMTI4IC8qIFNVU1BFTlNFICovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bm9kZS5zdXNwZW5zZS5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBob3N0TmV4dFNpYmxpbmcoKHZub2RlLmFuY2hvciB8fCB2bm9kZS5lbCkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbmRlciA9ICh2bm9kZSwgY29udGFpbmVyLCBpc1NWRykgPT4ge1xyXG4gICAgICAgIGlmICh2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB1bm1vdW50KGNvbnRhaW5lci5fdm5vZGUsIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYXRjaChjb250YWluZXIuX3Zub2RlIHx8IG51bGwsIHZub2RlLCBjb250YWluZXIsIG51bGwsIG51bGwsIG51bGwsIGlzU1ZHKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmx1c2hQb3N0Rmx1c2hDYnMoKTtcclxuICAgICAgICBjb250YWluZXIuX3Zub2RlID0gdm5vZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW50ZXJuYWxzID0ge1xyXG4gICAgICAgIHA6IHBhdGNoLFxyXG4gICAgICAgIHVtOiB1bm1vdW50LFxyXG4gICAgICAgIG06IG1vdmUsXHJcbiAgICAgICAgcjogcmVtb3ZlLFxyXG4gICAgICAgIG10OiBtb3VudENvbXBvbmVudCxcclxuICAgICAgICBtYzogbW91bnRDaGlsZHJlbixcclxuICAgICAgICBwYzogcGF0Y2hDaGlsZHJlbixcclxuICAgICAgICBwYmM6IHBhdGNoQmxvY2tDaGlsZHJlbixcclxuICAgICAgICBuOiBnZXROZXh0SG9zdE5vZGUsXHJcbiAgICAgICAgbzogb3B0aW9uc1xyXG4gICAgfTtcclxuICAgIGxldCBoeWRyYXRlO1xyXG4gICAgbGV0IGh5ZHJhdGVOb2RlO1xyXG4gICAgaWYgKGNyZWF0ZUh5ZHJhdGlvbkZucykge1xyXG4gICAgICAgIFtoeWRyYXRlLCBoeWRyYXRlTm9kZV0gPSBjcmVhdGVIeWRyYXRpb25GbnMoaW50ZXJuYWxzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVuZGVyLFxyXG4gICAgICAgIGh5ZHJhdGUsXHJcbiAgICAgICAgY3JlYXRlQXBwOiBjcmVhdGVBcHBBUEkocmVuZGVyLCBoeWRyYXRlKVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB0b2dnbGVSZWN1cnNlKHsgZWZmZWN0LCB1cGRhdGUgfSwgYWxsb3dlZCkge1xyXG4gICAgZWZmZWN0LmFsbG93UmVjdXJzZSA9IHVwZGF0ZS5hbGxvd1JlY3Vyc2UgPSBhbGxvd2VkO1xyXG59XHJcbi8qKlxyXG4gKiAjMTE1NlxyXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIEhNUi1lbmFibGVkLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBzdGF0aWMgbm9kZXNcclxuICogaW5zaWRlIGEgYmxvY2sgYWxzbyBpbmhlcml0IHRoZSBET00gZWxlbWVudCBmcm9tIHRoZSBwcmV2aW91cyB0cmVlIHNvIHRoYXRcclxuICogSE1SIHVwZGF0ZXMgKHdoaWNoIGFyZSBmdWxsIHVwZGF0ZXMpIGNhbiByZXRyaWV2ZSB0aGUgZWxlbWVudCBmb3IgcGF0Y2hpbmcuXHJcbiAqXHJcbiAqICMyMDgwXHJcbiAqIEluc2lkZSBrZXllZCBgdGVtcGxhdGVgIGZyYWdtZW50IHN0YXRpYyBjaGlsZHJlbiwgaWYgYSBmcmFnbWVudCBpcyBtb3ZlZCxcclxuICogdGhlIGNoaWxkcmVuIHdpbGwgYWx3YXlzIGJlIG1vdmVkLiBUaGVyZWZvcmUsIGluIG9yZGVyIHRvIGVuc3VyZSBjb3JyZWN0IG1vdmVcclxuICogcG9zaXRpb24sIGVsIHNob3VsZCBiZSBpbmhlcml0ZWQgZnJvbSBwcmV2aW91cyBub2Rlcy5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlU3RhdGljQ2hpbGRyZW4objEsIG4yLCBzaGFsbG93ID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGNoMSA9IG4xLmNoaWxkcmVuO1xyXG4gICAgY29uc3QgY2gyID0gbjIuY2hpbGRyZW47XHJcbiAgICBpZiAoaXNBcnJheShjaDEpICYmIGlzQXJyYXkoY2gyKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2gxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb25seSBjYWxsZWQgaW4gdGhlIG9wdGltaXplZCBwYXRoIHNvIGFycmF5IGNoaWxkcmVuIGFyZVxyXG4gICAgICAgICAgICAvLyBndWFyYW50ZWVkIHRvIGJlIHZub2Rlc1xyXG4gICAgICAgICAgICBjb25zdCBjMSA9IGNoMVtpXTtcclxuICAgICAgICAgICAgbGV0IGMyID0gY2gyW2ldO1xyXG4gICAgICAgICAgICBpZiAoYzIuc2hhcGVGbGFnICYgMSAvKiBFTEVNRU5UICovICYmICFjMi5keW5hbWljQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjMi5wYXRjaEZsYWcgPD0gMCB8fCBjMi5wYXRjaEZsYWcgPT09IDMyIC8qIEhZRFJBVEVfRVZFTlRTICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYzIgPSBjaDJbaV0gPSBjbG9uZUlmTW91bnRlZChjaDJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNoYWxsb3cpXHJcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2VTdGF0aWNDaGlsZHJlbihjMSwgYzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gaW5oZXJpdCBmb3IgY29tbWVudCBub2RlcywgYnV0IG5vdCBwbGFjZWhvbGRlcnMgKGUuZy4gdi1pZiB3aGljaFxyXG4gICAgICAgICAgICAvLyB3b3VsZCBoYXZlIHJlY2VpdmVkIC5lbCBkdXJpbmcgYmxvY2sgcGF0Y2gpXHJcbiAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgYzIudHlwZSA9PT0gQ29tbWVudCAmJiAhYzIuZWwpIHtcclxuICAgICAgICAgICAgICAgIGMyLmVsID0gYzEuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9uZ2VzdF9pbmNyZWFzaW5nX3N1YnNlcXVlbmNlXHJcbmZ1bmN0aW9uIGdldFNlcXVlbmNlKGFycikge1xyXG4gICAgY29uc3QgcCA9IGFyci5zbGljZSgpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gWzBdO1xyXG4gICAgbGV0IGksIGosIHUsIHYsIGM7XHJcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJySSA9IGFycltpXTtcclxuICAgICAgICBpZiAoYXJySSAhPT0gMCkge1xyXG4gICAgICAgICAgICBqID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKGFycltqXSA8IGFyckkpIHtcclxuICAgICAgICAgICAgICAgIHBbaV0gPSBqO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1ID0gMDtcclxuICAgICAgICAgICAgdiA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAodSA8IHYpIHtcclxuICAgICAgICAgICAgICAgIGMgPSAodSArIHYpID4+IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyW3Jlc3VsdFtjXV0gPCBhcnJJKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IGMgKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyckkgPCBhcnJbcmVzdWx0W3VdXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcFtpXSA9IHJlc3VsdFt1IC0gMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbdV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdSA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICB2ID0gcmVzdWx0W3UgLSAxXTtcclxuICAgIHdoaWxlICh1LS0gPiAwKSB7XHJcbiAgICAgICAgcmVzdWx0W3VdID0gdjtcclxuICAgICAgICB2ID0gcFt2XTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cblxuY29uc3QgaXNUZWxlcG9ydCA9ICh0eXBlKSA9PiB0eXBlLl9faXNUZWxlcG9ydDtcclxuY29uc3QgaXNUZWxlcG9ydERpc2FibGVkID0gKHByb3BzKSA9PiBwcm9wcyAmJiAocHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMuZGlzYWJsZWQgPT09ICcnKTtcclxuY29uc3QgaXNUYXJnZXRTVkcgPSAodGFyZ2V0KSA9PiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcclxuY29uc3QgcmVzb2x2ZVRhcmdldCA9IChwcm9wcywgc2VsZWN0KSA9PiB7XHJcbiAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IHByb3BzICYmIHByb3BzLnRvO1xyXG4gICAgaWYgKGlzU3RyaW5nKHRhcmdldFNlbGVjdG9yKSkge1xyXG4gICAgICAgIGlmICghc2VsZWN0KSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBDdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgc3RyaW5nIHRhcmdldCBmb3IgVGVsZXBvcnRzLiBgICtcclxuICAgICAgICAgICAgICAgICAgICBgKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gc2VsZWN0KHRhcmdldFNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMShgRmFpbGVkIHRvIGxvY2F0ZSBUZWxlcG9ydCB0YXJnZXQgd2l0aCBzZWxlY3RvciBcIiR7dGFyZ2V0U2VsZWN0b3J9XCIuIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGUgdGFyZ2V0IGVsZW1lbnQgbXVzdCBleGlzdCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpLmUuIHRoZSB0YXJnZXQgY2Fubm90IGJlIHJlbmRlcmVkIGJ5IHRoZSBjb21wb25lbnQgaXRzZWxmLCBhbmQgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhdGFyZ2V0U2VsZWN0b3IgJiYgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcclxuICAgICAgICAgICAgd2FybiQxKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHt0YXJnZXRTZWxlY3Rvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFNlbGVjdG9yO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBUZWxlcG9ydEltcGwgPSB7XHJcbiAgICBfX2lzVGVsZXBvcnQ6IHRydWUsXHJcbiAgICBwcm9jZXNzKG4xLCBuMiwgY29udGFpbmVyLCBhbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgaW50ZXJuYWxzKSB7XHJcbiAgICAgICAgY29uc3QgeyBtYzogbW91bnRDaGlsZHJlbiwgcGM6IHBhdGNoQ2hpbGRyZW4sIHBiYzogcGF0Y2hCbG9ja0NoaWxkcmVuLCBvOiB7IGluc2VydCwgcXVlcnlTZWxlY3RvciwgY3JlYXRlVGV4dCwgY3JlYXRlQ29tbWVudCB9IH0gPSBpbnRlcm5hbHM7XHJcbiAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBpc1RlbGVwb3J0RGlzYWJsZWQobjIucHJvcHMpO1xyXG4gICAgICAgIGxldCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiB9ID0gbjI7XHJcbiAgICAgICAgLy8gIzMzMDJcclxuICAgICAgICAvLyBITVIgdXBkYXRlZCwgZm9yY2UgZnVsbCBkaWZmXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBpc0htclVwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIG9wdGltaXplZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBkeW5hbWljQ2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobjEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5jaG9ycyBpbiB0aGUgbWFpbiB2aWV3XHJcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gKG4yLmVsID0gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpXHJcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbW1lbnQoJ3RlbGVwb3J0IHN0YXJ0JylcclxuICAgICAgICAgICAgICAgIDogY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBjb25zdCBtYWluQW5jaG9yID0gKG4yLmFuY2hvciA9IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21tZW50KCd0ZWxlcG9ydCBlbmQnKVxyXG4gICAgICAgICAgICAgICAgOiBjcmVhdGVUZXh0KCcnKSk7XHJcbiAgICAgICAgICAgIGluc2VydChwbGFjZWhvbGRlciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBpbnNlcnQobWFpbkFuY2hvciwgY29udGFpbmVyLCBhbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAobjIudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldChuMi5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBbmNob3IgPSAobjIudGFyZ2V0QW5jaG9yID0gY3JlYXRlVGV4dCgnJykpO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNlcnQodGFyZ2V0QW5jaG9yLCB0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgLy8gIzI2NTIgd2UgY291bGQgYmUgdGVsZXBvcnRpbmcgZnJvbSBhIG5vbi1TVkcgdHJlZSBpbnRvIGFuIFNWRyB0cmVlXHJcbiAgICAgICAgICAgICAgICBpc1NWRyA9IGlzU1ZHIHx8IGlzVGFyZ2V0U1ZHKHRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFkaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQxKCdJbnZhbGlkIFRlbGVwb3J0IHRhcmdldCBvbiBtb3VudDonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBtb3VudCA9IChjb250YWluZXIsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGVsZXBvcnQgKmFsd2F5cyogaGFzIEFycmF5IGNoaWxkcmVuLiBUaGlzIGlzIGVuZm9yY2VkIGluIGJvdGggdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBjb21waWxlciBhbmQgdm5vZGUgY2hpbGRyZW4gbm9ybWFsaXphdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmIChzaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRhaW5lciwgYW5jaG9yLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBpc1NWRywgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIG1vdW50KGNvbnRhaW5lciwgbWFpbkFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBtb3VudCh0YXJnZXQsIHRhcmdldEFuY2hvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBjb250ZW50XHJcbiAgICAgICAgICAgIG4yLmVsID0gbjEuZWw7XHJcbiAgICAgICAgICAgIGNvbnN0IG1haW5BbmNob3IgPSAobjIuYW5jaG9yID0gbjEuYW5jaG9yKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG4yLnRhcmdldCA9IG4xLnRhcmdldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFuY2hvciA9IChuMi50YXJnZXRBbmNob3IgPSBuMS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICBjb25zdCB3YXNEaXNhYmxlZCA9IGlzVGVsZXBvcnREaXNhYmxlZChuMS5wcm9wcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb250YWluZXIgPSB3YXNEaXNhYmxlZCA/IGNvbnRhaW5lciA6IHRhcmdldDtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEFuY2hvciA9IHdhc0Rpc2FibGVkID8gbWFpbkFuY2hvciA6IHRhcmdldEFuY2hvcjtcclxuICAgICAgICAgICAgaXNTVkcgPSBpc1NWRyB8fCBpc1RhcmdldFNWRyh0YXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY0NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYXN0IHBhdGggd2hlbiB0aGUgdGVsZXBvcnQgaGFwcGVucyB0byBiZSBhIGJsb2NrIHJvb3RcclxuICAgICAgICAgICAgICAgIHBhdGNoQmxvY2tDaGlsZHJlbihuMS5keW5hbWljQ2hpbGRyZW4sIGR5bmFtaWNDaGlsZHJlbiwgY3VycmVudENvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgaXNTVkcsIHNsb3RTY29wZUlkcyk7XHJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGluIGJsb2NrIHRyZWUgbW9kZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhbGwgcm9vdC1sZXZlbCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHRlbGVwb3J0IGluaGVyaXQgcHJldmlvdXMgRE9NIHJlZmVyZW5jZXMgc28gdGhhdCB0aGV5IGNhblxyXG4gICAgICAgICAgICAgICAgLy8gYmUgbW92ZWQgaW4gZnV0dXJlIHBhdGNoZXMuXHJcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZVN0YXRpY0NoaWxkcmVuKG4xLCBuMiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIW9wdGltaXplZCkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hDaGlsZHJlbihuMSwgbjIsIGN1cnJlbnRDb250YWluZXIsIGN1cnJlbnRBbmNob3IsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIGlzU1ZHLCBzbG90U2NvcGVJZHMsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghd2FzRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGVkIC0+IGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBpbnRvIG1haW4gY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCBjb250YWluZXIsIG1haW5BbmNob3IsIGludGVybmFscywgMSAvKiBUT0dHTEUgKi8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IGNoYW5nZWRcclxuICAgICAgICAgICAgICAgIGlmICgobjIucHJvcHMgJiYgbjIucHJvcHMudG8pICE9PSAobjEucHJvcHMgJiYgbjEucHJvcHMudG8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IChuMi50YXJnZXQgPSByZXNvbHZlVGFyZ2V0KG4yLnByb3BzLCBxdWVyeVNlbGVjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUYXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCBuZXh0VGFyZ2V0LCBudWxsLCBpbnRlcm5hbHMsIDAgLyogVEFSR0VUX0NIQU5HRSAqLyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDEoJ0ludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIHVwZGF0ZTonLCB0YXJnZXQsIGAoJHt0eXBlb2YgdGFyZ2V0fSlgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIC0+IGVuYWJsZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIGludG8gdGVsZXBvcnQgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZVRlbGVwb3J0KG4yLCB0YXJnZXQsIHRhcmdldEFuY2hvciwgaW50ZXJuYWxzLCAxIC8qIFRPR0dMRSAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlKHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBvcHRpbWl6ZWQsIHsgdW06IHVubW91bnQsIG86IHsgcmVtb3ZlOiBob3N0UmVtb3ZlIH0gfSwgZG9SZW1vdmUpIHtcclxuICAgICAgICBjb25zdCB7IHNoYXBlRmxhZywgY2hpbGRyZW4sIGFuY2hvciwgdGFyZ2V0QW5jaG9yLCB0YXJnZXQsIHByb3BzIH0gPSB2bm9kZTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGhvc3RSZW1vdmUodGFyZ2V0QW5jaG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gdW5tb3VudGVkIHRlbGVwb3J0IHNob3VsZCBhbHdheXMgcmVtb3ZlIGl0cyBjaGlsZHJlbiBpZiBub3QgZGlzYWJsZWRcclxuICAgICAgICBpZiAoZG9SZW1vdmUgfHwgIWlzVGVsZXBvcnREaXNhYmxlZChwcm9wcykpIHtcclxuICAgICAgICAgICAgaG9zdFJlbW92ZShhbmNob3IpO1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVGbGFnICYgMTYgLyogQVJSQVlfQ0hJTERSRU4gKi8pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHVubW91bnQoY2hpbGQsIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHRydWUsICEhY2hpbGQuZHluYW1pY0NoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3ZlOiBtb3ZlVGVsZXBvcnQsXHJcbiAgICBoeWRyYXRlOiBoeWRyYXRlVGVsZXBvcnRcclxufTtcclxuZnVuY3Rpb24gbW92ZVRlbGVwb3J0KHZub2RlLCBjb250YWluZXIsIHBhcmVudEFuY2hvciwgeyBvOiB7IGluc2VydCB9LCBtOiBtb3ZlIH0sIG1vdmVUeXBlID0gMiAvKiBSRU9SREVSICovKSB7XHJcbiAgICAvLyBtb3ZlIHRhcmdldCBhbmNob3IgaWYgdGhpcyBpcyBhIHRhcmdldCBjaGFuZ2UuXHJcbiAgICBpZiAobW92ZVR5cGUgPT09IDAgLyogVEFSR0VUX0NIQU5HRSAqLykge1xyXG4gICAgICAgIGluc2VydCh2bm9kZS50YXJnZXRBbmNob3IsIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgZWwsIGFuY2hvciwgc2hhcGVGbGFnLCBjaGlsZHJlbiwgcHJvcHMgfSA9IHZub2RlO1xyXG4gICAgY29uc3QgaXNSZW9yZGVyID0gbW92ZVR5cGUgPT09IDIgLyogUkVPUkRFUiAqLztcclxuICAgIC8vIG1vdmUgbWFpbiB2aWV3IGFuY2hvciBpZiB0aGlzIGlzIGEgcmUtb3JkZXIuXHJcbiAgICBpZiAoaXNSZW9yZGVyKSB7XHJcbiAgICAgICAgaW5zZXJ0KGVsLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbiAgICAvLyBpZiB0aGlzIGlzIGEgcmUtb3JkZXIgYW5kIHRlbGVwb3J0IGlzIGVuYWJsZWQgKGNvbnRlbnQgaXMgaW4gdGFyZ2V0KVxyXG4gICAgLy8gZG8gbm90IG1vdmUgY2hpbGRyZW4uIFNvIHRoZSBvcHBvc2l0ZSBpczogb25seSBtb3ZlIGNoaWxkcmVuIGlmIHRoaXNcclxuICAgIC8vIGlzIG5vdCBhIHJlb3JkZXIsIG9yIHRoZSB0ZWxlcG9ydCBpcyBkaXNhYmxlZFxyXG4gICAgaWYgKCFpc1Jlb3JkZXIgfHwgaXNUZWxlcG9ydERpc2FibGVkKHByb3BzKSkge1xyXG4gICAgICAgIC8vIFRlbGVwb3J0IGhhcyBlaXRoZXIgQXJyYXkgY2hpbGRyZW4gb3Igbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDE2IC8qIEFSUkFZX0NISUxEUkVOICovKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1vdmUoY2hpbGRyZW5baV0sIGNvbnRhaW5lciwgcGFyZW50QW5jaG9yLCAyIC8qIFJFT1JERVIgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbW92ZSBtYWluIHZpZXcgYW5jaG9yIGlmIHRoaXMgaXMgYSByZS1vcmRlci5cclxuICAgIGlmIChpc1Jlb3JkZXIpIHtcclxuICAgICAgICBpbnNlcnQoYW5jaG9yLCBjb250YWluZXIsIHBhcmVudEFuY2hvcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaHlkcmF0ZVRlbGVwb3J0KG5vZGUsIHZub2RlLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCBzbG90U2NvcGVJZHMsIG9wdGltaXplZCwgeyBvOiB7IG5leHRTaWJsaW5nLCBwYXJlbnROb2RlLCBxdWVyeVNlbGVjdG9yIH0gfSwgaHlkcmF0ZUNoaWxkcmVuKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSAodm5vZGUudGFyZ2V0ID0gcmVzb2x2ZVRhcmdldCh2bm9kZS5wcm9wcywgcXVlcnlTZWxlY3RvcikpO1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIHRlbGVwb3J0cyByZW5kZXJlZCB0byB0aGUgc2FtZSB0YXJnZXQgZWxlbWVudCwgd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vIHBpY2sgdXAgZnJvbSB3aGVyZSB0aGUgbGFzdCB0ZWxlcG9ydCBmaW5pc2hlZCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBub2RlXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRhcmdldC5fbHBhIHx8IHRhcmdldC5maXJzdENoaWxkO1xyXG4gICAgICAgIGlmICh2bm9kZS5zaGFwZUZsYWcgJiAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLykge1xyXG4gICAgICAgICAgICBpZiAoaXNUZWxlcG9ydERpc2FibGVkKHZub2RlLnByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuYW5jaG9yID0gaHlkcmF0ZUNoaWxkcmVuKG5leHRTaWJsaW5nKG5vZGUpLCB2bm9kZSwgcGFyZW50Tm9kZShub2RlKSwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICAgICAgdm5vZGUudGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmFuY2hvciA9IG5leHRTaWJsaW5nKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gbG9va2FoZWFkIHVudGlsIHdlIGZpbmQgdGhlIHRhcmdldCBhbmNob3JcclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCByZWx5IG9uIHJldHVybiB2YWx1ZSBvZiBoeWRyYXRlQ2hpbGRyZW4oKSBiZWNhdXNlIHRoZXJlXHJcbiAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBuZXN0ZWQgdGVsZXBvcnRzXHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0QW5jaG9yID0gdGFyZ2V0Tm9kZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXRBbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBbmNob3IgPSBuZXh0U2libGluZyh0YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBbmNob3IgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QW5jaG9yLm5vZGVUeXBlID09PSA4ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFuY2hvci5kYXRhID09PSAndGVsZXBvcnQgYW5jaG9yJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bm9kZS50YXJnZXRBbmNob3IgPSB0YXJnZXRBbmNob3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5fbHBhID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZub2RlLnRhcmdldEFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS50YXJnZXRBbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBoeWRyYXRlQ2hpbGRyZW4odGFyZ2V0Tm9kZSwgdm5vZGUsIHRhcmdldCwgcGFyZW50Q29tcG9uZW50LCBwYXJlbnRTdXNwZW5zZSwgc2xvdFNjb3BlSWRzLCBvcHRpbWl6ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZub2RlLmFuY2hvciAmJiBuZXh0U2libGluZyh2bm9kZS5hbmNob3IpO1xyXG59XHJcbi8vIEZvcmNlLWNhc3RlZCBwdWJsaWMgdHlwaW5nIGZvciBoIGFuZCBUU1ggcHJvcHMgaW5mZXJlbmNlXHJcbmNvbnN0IFRlbGVwb3J0ID0gVGVsZXBvcnRJbXBsO1xuXG5jb25zdCBub3JtYWxpemVkQXN5bmNDb21wb25lbnRNYXAgPSBuZXcgTWFwKCk7XHJcbmZ1bmN0aW9uIGNvbnZlcnRMZWdhY3lBc3luY0NvbXBvbmVudChjb21wKSB7XHJcbiAgICBpZiAobm9ybWFsaXplZEFzeW5jQ29tcG9uZW50TWFwLmhhcyhjb21wKSkge1xyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkQXN5bmNDb21wb25lbnRNYXAuZ2V0KGNvbXApO1xyXG4gICAgfVxyXG4gICAgLy8gd2UgaGF2ZSB0byBjYWxsIHRoZSBmdW5jdGlvbiBoZXJlIGR1ZSB0byBob3cgdjIncyBBUEkgd29uJ3QgZXhwb3NlIHRoZVxyXG4gICAgLy8gb3B0aW9ucyB1bnRpbCB3ZSBjYWxsIGl0XHJcbiAgICBsZXQgcmVzb2x2ZTtcclxuICAgIGxldCByZWplY3Q7XHJcbiAgICBjb25zdCBmYWxsYmFja1Byb21pc2UgPSBuZXcgUHJvbWlzZSgociwgcmopID0+IHtcclxuICAgICAgICAocmVzb2x2ZSA9IHIpLCAocmVqZWN0ID0gcmopO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCByZXMgPSBjb21wKHJlc29sdmUsIHJlamVjdCk7XHJcbiAgICBsZXQgY29udmVydGVkO1xyXG4gICAgaWYgKGlzUHJvbWlzZShyZXMpKSB7XHJcbiAgICAgICAgY29udmVydGVkID0gZGVmaW5lQXN5bmNDb21wb25lbnQoKCkgPT4gcmVzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHJlcykgJiYgIWlzVk5vZGUocmVzKSAmJiAhaXNBcnJheShyZXMpKSB7XHJcbiAgICAgICAgY29udmVydGVkID0gZGVmaW5lQXN5bmNDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBsb2FkZXI6ICgpID0+IHJlcy5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIGxvYWRpbmdDb21wb25lbnQ6IHJlcy5sb2FkaW5nLFxyXG4gICAgICAgICAgICBlcnJvckNvbXBvbmVudDogcmVzLmVycm9yLFxyXG4gICAgICAgICAgICBkZWxheTogcmVzLmRlbGF5LFxyXG4gICAgICAgICAgICB0aW1lb3V0OiByZXMudGltZW91dFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVzID09IG51bGwpIHtcclxuICAgICAgICBjb252ZXJ0ZWQgPSBkZWZpbmVBc3luY0NvbXBvbmVudCgoKSA9PiBmYWxsYmFja1Byb21pc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29udmVydGVkID0gY29tcDsgLy8gcHJvYmFibHkgYSB2MyBmdW5jdGlvbmFsIGNvbXBcclxuICAgIH1cclxuICAgIG5vcm1hbGl6ZWRBc3luY0NvbXBvbmVudE1hcC5zZXQoY29tcCwgY29udmVydGVkKTtcclxuICAgIHJldHVybiBjb252ZXJ0ZWQ7XHJcbn1cblxuZnVuY3Rpb24gY29udmVydExlZ2FjeUNvbXBvbmVudChjb21wLCBpbnN0YW5jZSkge1xyXG4gICAgaWYgKGNvbXAuX19pc0J1aWx0SW4pIHtcclxuICAgICAgICByZXR1cm4gY29tcDtcclxuICAgIH1cclxuICAgIC8vIDIueCBjb25zdHJ1Y3RvclxyXG4gICAgaWYgKGlzRnVuY3Rpb24oY29tcCkgJiYgY29tcC5jaWQpIHtcclxuICAgICAgICBjb21wID0gY29tcC5vcHRpb25zO1xyXG4gICAgfVxyXG4gICAgLy8gMi54IGFzeW5jIGNvbXBvbmVudFxyXG4gICAgaWYgKGlzRnVuY3Rpb24oY29tcCkgJiZcclxuICAgICAgICBjaGVja0NvbXBhdEVuYWJsZWQoXCJDT01QT05FTlRfQVNZTkNcIiAvKiBDT01QT05FTlRfQVNZTkMgKi8sIGluc3RhbmNlLCBjb21wKSkge1xyXG4gICAgICAgIC8vIHNpbmNlIGFmdGVyIGRpc2FibGluZyB0aGlzLCBwbGFpbiBmdW5jdGlvbnMgYXJlIHN0aWxsIHZhbGlkIHVzYWdlLCBkbyBub3RcclxuICAgICAgICAvLyB1c2Ugc29mdEFzc2VydCBoZXJlLlxyXG4gICAgICAgIHJldHVybiBjb252ZXJ0TGVnYWN5QXN5bmNDb21wb25lbnQoY29tcCk7XHJcbiAgICB9XHJcbiAgICAvLyAyLnggZnVuY3Rpb25hbCBjb21wb25lbnRcclxuICAgIGlmIChpc09iamVjdChjb21wKSAmJlxyXG4gICAgICAgIGNvbXAuZnVuY3Rpb25hbCAmJlxyXG4gICAgICAgIHNvZnRBc3NlcnRDb21wYXRFbmFibGVkKFwiQ09NUE9ORU5UX0ZVTkNUSU9OQUxcIiAvKiBDT01QT05FTlRfRlVOQ1RJT05BTCAqLywgaW5zdGFuY2UsIGNvbXApKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRMZWdhY3lGdW5jdGlvbmFsQ29tcG9uZW50KGNvbXApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXA7XHJcbn1cblxuY29uc3QgRnJhZ21lbnQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ0ZyYWdtZW50JyA6IHVuZGVmaW5lZCk7XHJcbmNvbnN0IFRleHQgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1RleHQnIDogdW5kZWZpbmVkKTtcclxuY29uc3QgQ29tbWVudCA9IFN5bWJvbCgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgPyAnQ29tbWVudCcgOiB1bmRlZmluZWQpO1xyXG5jb25zdCBTdGF0aWMgPSBTeW1ib2woKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gJ1N0YXRpYycgOiB1bmRlZmluZWQpO1xyXG4vLyBTaW5jZSB2LWlmIGFuZCB2LWZvciBhcmUgdGhlIHR3byBwb3NzaWJsZSB3YXlzIG5vZGUgc3RydWN0dXJlIGNhbiBkeW5hbWljYWxseVxyXG4vLyBjaGFuZ2UsIG9uY2Ugd2UgY29uc2lkZXIgdi1pZiBicmFuY2hlcyBhbmQgZWFjaCB2LWZvciBmcmFnbWVudCBhIGJsb2NrLCB3ZVxyXG4vLyBjYW4gZGl2aWRlIGEgdGVtcGxhdGUgaW50byBuZXN0ZWQgYmxvY2tzLCBhbmQgd2l0aGluIGVhY2ggYmxvY2sgdGhlIG5vZGVcclxuLy8gc3RydWN0dXJlIHdvdWxkIGJlIHN0YWJsZS4gVGhpcyBhbGxvd3MgdXMgdG8gc2tpcCBtb3N0IGNoaWxkcmVuIGRpZmZpbmdcclxuLy8gYW5kIG9ubHkgd29ycnkgYWJvdXQgdGhlIGR5bmFtaWMgbm9kZXMgKGluZGljYXRlZCBieSBwYXRjaCBmbGFncykuXHJcbmNvbnN0IGJsb2NrU3RhY2sgPSBbXTtcclxubGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XHJcbi8qKlxyXG4gKiBPcGVuIGEgYmxvY2suXHJcbiAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AuIEl0IGNhbm5vdCBiZSBwYXJ0IG9mIGBjcmVhdGVCbG9ja2BcclxuICogYmVjYXVzZSB0aGUgY2hpbGRyZW4gb2YgdGhlIGJsb2NrIGFyZSBldmFsdWF0ZWQgYmVmb3JlIGBjcmVhdGVCbG9ja2AgaXRzZWxmXHJcbiAqIGlzIGNhbGxlZC4gVGhlIGdlbmVyYXRlZCBjb2RlIHR5cGljYWxseSBsb29rcyBsaWtlIHRoaXM6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGZ1bmN0aW9uIHJlbmRlcigpIHtcclxuICogICByZXR1cm4gKG9wZW5CbG9jaygpLGNyZWF0ZUJsb2NrKCdkaXYnLCBudWxsLCBbLi4uXSkpXHJcbiAqIH1cclxuICogYGBgXHJcbiAqIGRpc2FibGVUcmFja2luZyBpcyB0cnVlIHdoZW4gY3JlYXRpbmcgYSB2LWZvciBmcmFnbWVudCBibG9jaywgc2luY2UgYSB2LWZvclxyXG4gKiBmcmFnbWVudCBhbHdheXMgZGlmZnMgaXRzIGNoaWxkcmVuLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gb3BlbkJsb2NrKGRpc2FibGVUcmFja2luZyA9IGZhbHNlKSB7XHJcbiAgICBibG9ja1N0YWNrLnB1c2goKGN1cnJlbnRCbG9jayA9IGRpc2FibGVUcmFja2luZyA/IG51bGwgOiBbXSkpO1xyXG59XHJcbmZ1bmN0aW9uIGNsb3NlQmxvY2soKSB7XHJcbiAgICBibG9ja1N0YWNrLnBvcCgpO1xyXG4gICAgY3VycmVudEJsb2NrID0gYmxvY2tTdGFja1tibG9ja1N0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGw7XHJcbn1cclxuLy8gV2hldGhlciB3ZSBzaG91bGQgYmUgdHJhY2tpbmcgZHluYW1pYyBjaGlsZCBub2RlcyBpbnNpZGUgYSBibG9jay5cclxuLy8gT25seSB0cmFja3Mgd2hlbiB0aGlzIHZhbHVlIGlzID4gMFxyXG4vLyBXZSBhcmUgbm90IHVzaW5nIGEgc2ltcGxlIGJvb2xlYW4gYmVjYXVzZSB0aGlzIHZhbHVlIG1heSBuZWVkIHRvIGJlXHJcbi8vIGluY3JlbWVudGVkL2RlY3JlbWVudGVkIGJ5IG5lc3RlZCB1c2FnZSBvZiB2LW9uY2UgKHNlZSBiZWxvdylcclxubGV0IGlzQmxvY2tUcmVlRW5hYmxlZCA9IDE7XHJcbi8qKlxyXG4gKiBCbG9jayB0cmFja2luZyBzb21ldGltZXMgbmVlZHMgdG8gYmUgZGlzYWJsZWQsIGZvciBleGFtcGxlIGR1cmluZyB0aGVcclxuICogY3JlYXRpb24gb2YgYSB0cmVlIHRoYXQgbmVlZHMgdG8gYmUgY2FjaGVkIGJ5IHYtb25jZS4gVGhlIGNvbXBpbGVyIGdlbmVyYXRlc1xyXG4gKiBjb2RlIGxpa2UgdGhpczpcclxuICpcclxuICogYGBgIGpzXHJcbiAqIF9jYWNoZVsxXSB8fCAoXHJcbiAqICAgc2V0QmxvY2tUcmFja2luZygtMSksXHJcbiAqICAgX2NhY2hlWzFdID0gY3JlYXRlVk5vZGUoLi4uKSxcclxuICogICBzZXRCbG9ja1RyYWNraW5nKDEpLFxyXG4gKiAgIF9jYWNoZVsxXVxyXG4gKiApXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0QmxvY2tUcmFja2luZyh2YWx1ZSkge1xyXG4gICAgaXNCbG9ja1RyZWVFbmFibGVkICs9IHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIHNldHVwQmxvY2sodm5vZGUpIHtcclxuICAgIC8vIHNhdmUgY3VycmVudCBibG9jayBjaGlsZHJlbiBvbiB0aGUgYmxvY2sgdm5vZGVcclxuICAgIHZub2RlLmR5bmFtaWNDaGlsZHJlbiA9XHJcbiAgICAgICAgaXNCbG9ja1RyZWVFbmFibGVkID4gMCA/IGN1cnJlbnRCbG9jayB8fCBFTVBUWV9BUlIgOiBudWxsO1xyXG4gICAgLy8gY2xvc2UgYmxvY2tcclxuICAgIGNsb3NlQmxvY2soKTtcclxuICAgIC8vIGEgYmxvY2sgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIHBhdGNoZWQsIHNvIHRyYWNrIGl0IGFzIGEgY2hpbGQgb2YgaXRzXHJcbiAgICAvLyBwYXJlbnQgYmxvY2tcclxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xyXG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcpIHtcclxuICAgIHJldHVybiBzZXR1cEJsb2NrKGNyZWF0ZUJhc2VWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCBzaGFwZUZsYWcsIHRydWUgLyogaXNCbG9jayAqLykpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBibG9jayByb290IHZub2RlLiBUYWtlcyB0aGUgc2FtZSBleGFjdCBhcmd1bWVudHMgYXMgYGNyZWF0ZVZOb2RlYC5cclxuICogQSBibG9jayByb290IGtlZXBzIHRyYWNrIG9mIGR5bmFtaWMgbm9kZXMgd2l0aGluIHRoZSBibG9jayBpbiB0aGVcclxuICogYGR5bmFtaWNDaGlsZHJlbmAgYXJyYXkuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVCbG9jayh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzKSB7XHJcbiAgICByZXR1cm4gc2V0dXBCbG9jayhjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywgY2hpbGRyZW4sIHBhdGNoRmxhZywgZHluYW1pY1Byb3BzLCB0cnVlIC8qIGlzQmxvY2s6IHByZXZlbnQgYSBibG9jayBmcm9tIHRyYWNraW5nIGl0c2VsZiAqLykpO1xyXG59XHJcbmZ1bmN0aW9uIGlzVk5vZGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlLl9fdl9pc1ZOb2RlID09PSB0cnVlIDogZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVk5vZGVUeXBlKG4xLCBuMikge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgIG4yLnNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovICYmXHJcbiAgICAgICAgaG1yRGlydHlDb21wb25lbnRzLmhhcyhuMi50eXBlKSkge1xyXG4gICAgICAgIC8vIEhNUiBvbmx5OiBpZiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGhvdC11cGRhdGVkLCBmb3JjZSBhIHJlbG9hZC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbjEudHlwZSA9PT0gbjIudHlwZSAmJiBuMS5rZXkgPT09IG4yLmtleTtcclxufVxyXG5sZXQgdm5vZGVBcmdzVHJhbnNmb3JtZXI7XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBBUEkgZm9yIHJlZ2lzdGVyaW5nIGFuIGFyZ3VtZW50cyB0cmFuc2Zvcm0gZm9yIGNyZWF0ZVZOb2RlXHJcbiAqIHVzZWQgZm9yIGNyZWF0aW5nIHN0dWJzIGluIHRoZSB0ZXN0LXV0aWxzXHJcbiAqIEl0IGlzICppbnRlcm5hbCogYnV0IG5lZWRzIHRvIGJlIGV4cG9zZWQgZm9yIHRlc3QtdXRpbHMgdG8gcGljayB1cCBwcm9wZXJcclxuICogdHlwaW5nc1xyXG4gKi9cclxuZnVuY3Rpb24gdHJhbnNmb3JtVk5vZGVBcmdzKHRyYW5zZm9ybWVyKSB7XHJcbiAgICB2bm9kZUFyZ3NUcmFuc2Zvcm1lciA9IHRyYW5zZm9ybWVyO1xyXG59XHJcbmNvbnN0IGNyZWF0ZVZOb2RlV2l0aEFyZ3NUcmFuc2Zvcm0gPSAoLi4uYXJncykgPT4ge1xyXG4gICAgcmV0dXJuIF9jcmVhdGVWTm9kZSguLi4odm5vZGVBcmdzVHJhbnNmb3JtZXJcclxuICAgICAgICA/IHZub2RlQXJnc1RyYW5zZm9ybWVyKGFyZ3MsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSlcclxuICAgICAgICA6IGFyZ3MpKTtcclxufTtcclxuY29uc3QgSW50ZXJuYWxPYmplY3RLZXkgPSBgX192SW50ZXJuYWxgO1xyXG5jb25zdCBub3JtYWxpemVLZXkgPSAoeyBrZXkgfSkgPT4ga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsO1xyXG5jb25zdCBub3JtYWxpemVSZWYgPSAoeyByZWYsIHJlZl9rZXksIHJlZl9mb3IgfSkgPT4ge1xyXG4gICAgcmV0dXJuIChyZWYgIT0gbnVsbFxyXG4gICAgICAgID8gaXNTdHJpbmcocmVmKSB8fCBpc1JlZihyZWYpIHx8IGlzRnVuY3Rpb24ocmVmKVxyXG4gICAgICAgICAgICA/IHsgaTogY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLCByOiByZWYsIGs6IHJlZl9rZXksIGY6ICEhcmVmX2ZvciB9XHJcbiAgICAgICAgICAgIDogcmVmXHJcbiAgICAgICAgOiBudWxsKTtcclxufTtcclxuZnVuY3Rpb24gY3JlYXRlQmFzZVZOb2RlKHR5cGUsIHByb3BzID0gbnVsbCwgY2hpbGRyZW4gPSBudWxsLCBwYXRjaEZsYWcgPSAwLCBkeW5hbWljUHJvcHMgPSBudWxsLCBzaGFwZUZsYWcgPSB0eXBlID09PSBGcmFnbWVudCA/IDAgOiAxIC8qIEVMRU1FTlQgKi8sIGlzQmxvY2tOb2RlID0gZmFsc2UsIG5lZWRGdWxsQ2hpbGRyZW5Ob3JtYWxpemF0aW9uID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHZub2RlID0ge1xyXG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxyXG4gICAgICAgIF9fdl9za2lwOiB0cnVlLFxyXG4gICAgICAgIHR5cGUsXHJcbiAgICAgICAgcHJvcHMsXHJcbiAgICAgICAga2V5OiBwcm9wcyAmJiBub3JtYWxpemVLZXkocHJvcHMpLFxyXG4gICAgICAgIHJlZjogcHJvcHMgJiYgbm9ybWFsaXplUmVmKHByb3BzKSxcclxuICAgICAgICBzY29wZUlkOiBjdXJyZW50U2NvcGVJZCxcclxuICAgICAgICBzbG90U2NvcGVJZHM6IG51bGwsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgY29tcG9uZW50OiBudWxsLFxyXG4gICAgICAgIHN1c3BlbnNlOiBudWxsLFxyXG4gICAgICAgIHNzQ29udGVudDogbnVsbCxcclxuICAgICAgICBzc0ZhbGxiYWNrOiBudWxsLFxyXG4gICAgICAgIGRpcnM6IG51bGwsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogbnVsbCxcclxuICAgICAgICBlbDogbnVsbCxcclxuICAgICAgICBhbmNob3I6IG51bGwsXHJcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxyXG4gICAgICAgIHRhcmdldEFuY2hvcjogbnVsbCxcclxuICAgICAgICBzdGF0aWNDb3VudDogMCxcclxuICAgICAgICBzaGFwZUZsYWcsXHJcbiAgICAgICAgcGF0Y2hGbGFnLFxyXG4gICAgICAgIGR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IG51bGwsXHJcbiAgICAgICAgYXBwQ29udGV4dDogbnVsbFxyXG4gICAgfTtcclxuICAgIGlmIChuZWVkRnVsbENoaWxkcmVuTm9ybWFsaXphdGlvbikge1xyXG4gICAgICAgIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbik7XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIHN1c3BlbnNlIGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgICAgICB0eXBlLm5vcm1hbGl6ZSh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAvLyBjb21waWxlZCBlbGVtZW50IHZub2RlIC0gaWYgY2hpbGRyZW4gaXMgcGFzc2VkLCBvbmx5IHBvc3NpYmxlIHR5cGVzIGFyZVxyXG4gICAgICAgIC8vIHN0cmluZyBvciBBcnJheS5cclxuICAgICAgICB2bm9kZS5zaGFwZUZsYWcgfD0gaXNTdHJpbmcoY2hpbGRyZW4pXHJcbiAgICAgICAgICAgID8gOCAvKiBURVhUX0NISUxEUkVOICovXHJcbiAgICAgICAgICAgIDogMTYgLyogQVJSQVlfQ0hJTERSRU4gKi87XHJcbiAgICB9XHJcbiAgICAvLyB2YWxpZGF0ZSBrZXlcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgdm5vZGUua2V5ICE9PSB2bm9kZS5rZXkpIHtcclxuICAgICAgICB3YXJuJDEoYFZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpgLCB2bm9kZS50eXBlKTtcclxuICAgIH1cclxuICAgIC8vIHRyYWNrIHZub2RlIGZvciBibG9jayB0cmVlXHJcbiAgICBpZiAoaXNCbG9ja1RyZWVFbmFibGVkID4gMCAmJlxyXG4gICAgICAgIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxyXG4gICAgICAgICFpc0Jsb2NrTm9kZSAmJlxyXG4gICAgICAgIC8vIGhhcyBjdXJyZW50IHBhcmVudCBibG9ja1xyXG4gICAgICAgIGN1cnJlbnRCbG9jayAmJlxyXG4gICAgICAgIC8vIHByZXNlbmNlIG9mIGEgcGF0Y2ggZmxhZyBpbmRpY2F0ZXMgdGhpcyBub2RlIG5lZWRzIHBhdGNoaW5nIG9uIHVwZGF0ZXMuXHJcbiAgICAgICAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXHJcbiAgICAgICAgLy8gY29tcG9uZW50IGRvZXNuJ3QgbmVlZCB0byB1cGRhdGUsIGl0IG5lZWRzIHRvIHBlcnNpc3QgdGhlIGluc3RhbmNlIG9uIHRvXHJcbiAgICAgICAgLy8gdGhlIG5leHQgdm5vZGUgc28gdGhhdCBpdCBjYW4gYmUgcHJvcGVybHkgdW5tb3VudGVkIGxhdGVyLlxyXG4gICAgICAgICh2bm9kZS5wYXRjaEZsYWcgPiAwIHx8IHNoYXBlRmxhZyAmIDYgLyogQ09NUE9ORU5UICovKSAmJlxyXG4gICAgICAgIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxyXG4gICAgICAgIC8vIHZub2RlIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBkeW5hbWljIGR1ZSB0byBoYW5kbGVyIGNhY2hpbmcuXHJcbiAgICAgICAgdm5vZGUucGF0Y2hGbGFnICE9PSAzMiAvKiBIWURSQVRFX0VWRU5UUyAqLykge1xyXG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKHZub2RlKTtcclxuICAgIH1cclxuICAgIHtcclxuICAgICAgICBjb252ZXJ0TGVnYWN5Vk1vZGVsUHJvcHModm5vZGUpO1xyXG4gICAgICAgIGRlZmluZUxlZ2FjeVZOb2RlUHJvcGVydGllcyh2bm9kZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm5vZGU7XHJcbn1cclxuY29uc3QgY3JlYXRlVk5vZGUgPSAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gY3JlYXRlVk5vZGVXaXRoQXJnc1RyYW5zZm9ybSA6IF9jcmVhdGVWTm9kZSk7XHJcbmZ1bmN0aW9uIF9jcmVhdGVWTm9kZSh0eXBlLCBwcm9wcyA9IG51bGwsIGNoaWxkcmVuID0gbnVsbCwgcGF0Y2hGbGFnID0gMCwgZHluYW1pY1Byb3BzID0gbnVsbCwgaXNCbG9ja05vZGUgPSBmYWxzZSkge1xyXG4gICAgaWYgKCF0eXBlIHx8IHR5cGUgPT09IE5VTExfRFlOQU1JQ19DT01QT05FTlQpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICF0eXBlKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgSW52YWxpZCB2bm9kZSB0eXBlIHdoZW4gY3JlYXRpbmcgdm5vZGU6ICR7dHlwZX0uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSBDb21tZW50O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVk5vZGUodHlwZSkpIHtcclxuICAgICAgICAvLyBjcmVhdGVWTm9kZSByZWNlaXZpbmcgYW4gZXhpc3Rpbmcgdm5vZGUuIFRoaXMgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgLy8gPGNvbXBvbmVudCA6aXM9XCJ2bm9kZVwiLz5cclxuICAgICAgICAvLyAjMjA3OCBtYWtlIHN1cmUgdG8gbWVyZ2UgcmVmcyBkdXJpbmcgdGhlIGNsb25lIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgaXRcclxuICAgICAgICBjb25zdCBjbG9uZWQgPSBjbG9uZVZOb2RlKHR5cGUsIHByb3BzLCB0cnVlIC8qIG1lcmdlUmVmOiB0cnVlICovKTtcclxuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplQ2hpbGRyZW4oY2xvbmVkLCBjaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmICFpc0Jsb2NrTm9kZSAmJiBjdXJyZW50QmxvY2spIHtcclxuICAgICAgICAgICAgaWYgKGNsb25lZC5zaGFwZUZsYWcgJiA2IC8qIENPTVBPTkVOVCAqLykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJsb2NrW2N1cnJlbnRCbG9jay5pbmRleE9mKHR5cGUpXSA9IGNsb25lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2xvbmVkLnBhdGNoRmxhZyB8PSAtMiAvKiBCQUlMICovO1xyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyBjb21wb25lbnQgbm9ybWFsaXphdGlvbi5cclxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KHR5cGUpKSB7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUuX192Y2NPcHRzO1xyXG4gICAgfVxyXG4gICAgLy8gMi54IGFzeW5jL2Z1bmN0aW9uYWwgY29tcG9uZW50IGNvbXBhdFxyXG4gICAge1xyXG4gICAgICAgIHR5cGUgPSBjb252ZXJ0TGVnYWN5Q29tcG9uZW50KHR5cGUsIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICAvLyBjbGFzcyAmIHN0eWxlIG5vcm1hbGl6YXRpb24uXHJcbiAgICBpZiAocHJvcHMpIHtcclxuICAgICAgICAvLyBmb3IgcmVhY3RpdmUgb3IgcHJveHkgb2JqZWN0cywgd2UgbmVlZCB0byBjbG9uZSBpdCB0byBlbmFibGUgbXV0YXRpb24uXHJcbiAgICAgICAgcHJvcHMgPSBndWFyZFJlYWN0aXZlUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIGxldCB7IGNsYXNzOiBrbGFzcywgc3R5bGUgfSA9IHByb3BzO1xyXG4gICAgICAgIGlmIChrbGFzcyAmJiAhaXNTdHJpbmcoa2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHByb3BzLmNsYXNzID0gbm9ybWFsaXplQ2xhc3Moa2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNPYmplY3Qoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgIC8vIHJlYWN0aXZlIHN0YXRlIG9iamVjdHMgbmVlZCB0byBiZSBjbG9uZWQgc2luY2UgdGhleSBhcmUgbGlrZWx5IHRvIGJlXHJcbiAgICAgICAgICAgIC8vIG11dGF0ZWRcclxuICAgICAgICAgICAgaWYgKGlzUHJveHkoc3R5bGUpICYmICFpc0FycmF5KHN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBleHRlbmQoe30sIHN0eWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcm9wcy5zdHlsZSA9IG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlbmNvZGUgdGhlIHZub2RlIHR5cGUgaW5mb3JtYXRpb24gaW50byBhIGJpdG1hcFxyXG4gICAgY29uc3Qgc2hhcGVGbGFnID0gaXNTdHJpbmcodHlwZSlcclxuICAgICAgICA/IDEgLyogRUxFTUVOVCAqL1xyXG4gICAgICAgIDogaXNTdXNwZW5zZSh0eXBlKVxyXG4gICAgICAgICAgICA/IDEyOCAvKiBTVVNQRU5TRSAqL1xyXG4gICAgICAgICAgICA6IGlzVGVsZXBvcnQodHlwZSlcclxuICAgICAgICAgICAgICAgID8gNjQgLyogVEVMRVBPUlQgKi9cclxuICAgICAgICAgICAgICAgIDogaXNPYmplY3QodHlwZSlcclxuICAgICAgICAgICAgICAgICAgICA/IDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovXHJcbiAgICAgICAgICAgICAgICAgICAgOiBpc0Z1bmN0aW9uKHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gMiAvKiBGVU5DVElPTkFMX0NPTVBPTkVOVCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNoYXBlRmxhZyAmIDQgLyogU1RBVEVGVUxfQ09NUE9ORU5UICovICYmIGlzUHJveHkodHlwZSkpIHtcclxuICAgICAgICB0eXBlID0gdG9SYXcodHlwZSk7XHJcbiAgICAgICAgd2FybiQxKGBWdWUgcmVjZWl2ZWQgYSBDb21wb25lbnQgd2hpY2ggd2FzIG1hZGUgYSByZWFjdGl2ZSBvYmplY3QuIFRoaXMgY2FuIGAgK1xyXG4gICAgICAgICAgICBgbGVhZCB0byB1bm5lY2Vzc2FyeSBwZXJmb3JtYW5jZSBvdmVyaGVhZCwgYW5kIHNob3VsZCBiZSBhdm9pZGVkIGJ5IGAgK1xyXG4gICAgICAgICAgICBgbWFya2luZyB0aGUgY29tcG9uZW50IHdpdGggXFxgbWFya1Jhd1xcYCBvciB1c2luZyBcXGBzaGFsbG93UmVmXFxgIGAgK1xyXG4gICAgICAgICAgICBgaW5zdGVhZCBvZiBcXGByZWZcXGAuYCwgYFxcbkNvbXBvbmVudCB0aGF0IHdhcyBtYWRlIHJlYWN0aXZlOiBgLCB0eXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVCYXNlVk5vZGUodHlwZSwgcHJvcHMsIGNoaWxkcmVuLCBwYXRjaEZsYWcsIGR5bmFtaWNQcm9wcywgc2hhcGVGbGFnLCBpc0Jsb2NrTm9kZSwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gZ3VhcmRSZWFjdGl2ZVByb3BzKHByb3BzKSB7XHJcbiAgICBpZiAoIXByb3BzKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIGlzUHJveHkocHJvcHMpIHx8IEludGVybmFsT2JqZWN0S2V5IGluIHByb3BzXHJcbiAgICAgICAgPyBleHRlbmQoe30sIHByb3BzKVxyXG4gICAgICAgIDogcHJvcHM7XHJcbn1cclxuZnVuY3Rpb24gY2xvbmVWTm9kZSh2bm9kZSwgZXh0cmFQcm9wcywgbWVyZ2VSZWYgPSBmYWxzZSkge1xyXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IE5PVCB1c2luZyBzcHJlYWQgb3IgZXh0ZW5kIHRvIGF2b2lkIHRoZSBydW50aW1lXHJcbiAgICAvLyBrZXkgZW51bWVyYXRpb24gY29zdC5cclxuICAgIGNvbnN0IHsgcHJvcHMsIHJlZiwgcGF0Y2hGbGFnLCBjaGlsZHJlbiB9ID0gdm5vZGU7XHJcbiAgICBjb25zdCBtZXJnZWRQcm9wcyA9IGV4dHJhUHJvcHMgPyBtZXJnZVByb3BzKHByb3BzIHx8IHt9LCBleHRyYVByb3BzKSA6IHByb3BzO1xyXG4gICAgY29uc3QgY2xvbmVkID0ge1xyXG4gICAgICAgIF9fdl9pc1ZOb2RlOiB0cnVlLFxyXG4gICAgICAgIF9fdl9za2lwOiB0cnVlLFxyXG4gICAgICAgIHR5cGU6IHZub2RlLnR5cGUsXHJcbiAgICAgICAgcHJvcHM6IG1lcmdlZFByb3BzLFxyXG4gICAgICAgIGtleTogbWVyZ2VkUHJvcHMgJiYgbm9ybWFsaXplS2V5KG1lcmdlZFByb3BzKSxcclxuICAgICAgICByZWY6IGV4dHJhUHJvcHMgJiYgZXh0cmFQcm9wcy5yZWZcclxuICAgICAgICAgICAgPyAvLyAjMjA3OCBpbiB0aGUgY2FzZSBvZiA8Y29tcG9uZW50IDppcz1cInZub2RlXCIgcmVmPVwiZXh0cmFcIi8+XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdm5vZGUgaXRzZWxmIGFscmVhZHkgaGFzIGEgcmVmLCBjbG9uZVZOb2RlIHdpbGwgbmVlZCB0byBtZXJnZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlZnMgc28gdGhlIHNpbmdsZSB2bm9kZSBjYW4gYmUgc2V0IG9uIG11bHRpcGxlIHJlZnNcclxuICAgICAgICAgICAgICAgIG1lcmdlUmVmICYmIHJlZlxyXG4gICAgICAgICAgICAgICAgICAgID8gaXNBcnJheShyZWYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLmNvbmNhdChub3JtYWxpemVSZWYoZXh0cmFQcm9wcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3JlZiwgbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXVxyXG4gICAgICAgICAgICAgICAgICAgIDogbm9ybWFsaXplUmVmKGV4dHJhUHJvcHMpXHJcbiAgICAgICAgICAgIDogcmVmLFxyXG4gICAgICAgIHNjb3BlSWQ6IHZub2RlLnNjb3BlSWQsXHJcbiAgICAgICAgc2xvdFNjb3BlSWRzOiB2bm9kZS5zbG90U2NvcGVJZHMsXHJcbiAgICAgICAgY2hpbGRyZW46IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiBwYXRjaEZsYWcgPT09IC0xIC8qIEhPSVNURUQgKi8gJiYgaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBjaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpXHJcbiAgICAgICAgICAgIDogY2hpbGRyZW4sXHJcbiAgICAgICAgdGFyZ2V0OiB2bm9kZS50YXJnZXQsXHJcbiAgICAgICAgdGFyZ2V0QW5jaG9yOiB2bm9kZS50YXJnZXRBbmNob3IsXHJcbiAgICAgICAgc3RhdGljQ291bnQ6IHZub2RlLnN0YXRpY0NvdW50LFxyXG4gICAgICAgIHNoYXBlRmxhZzogdm5vZGUuc2hhcGVGbGFnLFxyXG4gICAgICAgIC8vIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgd2l0aCBleHRyYSBwcm9wcywgd2UgY2FuIG5vIGxvbmdlciBhc3N1bWUgaXRzXHJcbiAgICAgICAgLy8gZXhpc3RpbmcgcGF0Y2ggZmxhZyB0byBiZSByZWxpYWJsZSBhbmQgbmVlZCB0byBhZGQgdGhlIEZVTExfUFJPUFMgZmxhZy5cclxuICAgICAgICAvLyBub3RlOiBwcmVzZXJ2ZSBmbGFnIGZvciBmcmFnbWVudHMgc2luY2UgdGhleSB1c2UgdGhlIGZsYWcgZm9yIGNoaWxkcmVuXHJcbiAgICAgICAgLy8gZmFzdCBwYXRocyBvbmx5LlxyXG4gICAgICAgIHBhdGNoRmxhZzogZXh0cmFQcm9wcyAmJiB2bm9kZS50eXBlICE9PSBGcmFnbWVudFxyXG4gICAgICAgICAgICA/IHBhdGNoRmxhZyA9PT0gLTEgLy8gaG9pc3RlZCBub2RlXHJcbiAgICAgICAgICAgICAgICA/IDE2IC8qIEZVTExfUFJPUFMgKi9cclxuICAgICAgICAgICAgICAgIDogcGF0Y2hGbGFnIHwgMTYgLyogRlVMTF9QUk9QUyAqL1xyXG4gICAgICAgICAgICA6IHBhdGNoRmxhZyxcclxuICAgICAgICBkeW5hbWljUHJvcHM6IHZub2RlLmR5bmFtaWNQcm9wcyxcclxuICAgICAgICBkeW5hbWljQ2hpbGRyZW46IHZub2RlLmR5bmFtaWNDaGlsZHJlbixcclxuICAgICAgICBhcHBDb250ZXh0OiB2bm9kZS5hcHBDb250ZXh0LFxyXG4gICAgICAgIGRpcnM6IHZub2RlLmRpcnMsXHJcbiAgICAgICAgdHJhbnNpdGlvbjogdm5vZGUudHJhbnNpdGlvbixcclxuICAgICAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcclxuICAgICAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcclxuICAgICAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXHJcbiAgICAgICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAgICBjb21wb25lbnQ6IHZub2RlLmNvbXBvbmVudCxcclxuICAgICAgICBzdXNwZW5zZTogdm5vZGUuc3VzcGVuc2UsXHJcbiAgICAgICAgc3NDb250ZW50OiB2bm9kZS5zc0NvbnRlbnQgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0NvbnRlbnQpLFxyXG4gICAgICAgIHNzRmFsbGJhY2s6IHZub2RlLnNzRmFsbGJhY2sgJiYgY2xvbmVWTm9kZSh2bm9kZS5zc0ZhbGxiYWNrKSxcclxuICAgICAgICBlbDogdm5vZGUuZWwsXHJcbiAgICAgICAgYW5jaG9yOiB2bm9kZS5hbmNob3JcclxuICAgIH07XHJcbiAgICB7XHJcbiAgICAgICAgZGVmaW5lTGVnYWN5Vk5vZGVQcm9wZXJ0aWVzKGNsb25lZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG59XHJcbi8qKlxyXG4gKiBEZXYgb25seSwgZm9yIEhNUiBvZiBob2lzdGVkIHZub2RlcyByZXVzZWQgaW4gdi1mb3JcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL2lzc3Vlcy8yMDIyXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwQ2xvbmVWTm9kZSh2bm9kZSkge1xyXG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmVWTm9kZSh2bm9kZSk7XHJcbiAgICBpZiAoaXNBcnJheSh2bm9kZS5jaGlsZHJlbikpIHtcclxuICAgICAgICBjbG9uZWQuY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbi5tYXAoZGVlcENsb25lVk5vZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsb25lZDtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh0ZXh0ID0gJyAnLCBmbGFnID0gMCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVZOb2RlKFRleHQsIG51bGwsIHRleHQsIGZsYWcpO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU3RhdGljVk5vZGUoY29udGVudCwgbnVtYmVyT2ZOb2Rlcykge1xyXG4gICAgLy8gQSBzdGF0aWMgdm5vZGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgc3RyaW5naWZpZWQgZWxlbWVudHMsIGFuZCB0aGUgbnVtYmVyXHJcbiAgICAvLyBvZiBlbGVtZW50cyBpcyBuZWNlc3NhcnkgZm9yIGh5ZHJhdGlvbi5cclxuICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUoU3RhdGljLCBudWxsLCBjb250ZW50KTtcclxuICAgIHZub2RlLnN0YXRpY0NvdW50ID0gbnVtYmVyT2ZOb2RlcztcclxuICAgIHJldHVybiB2bm9kZTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnRWTm9kZSh0ZXh0ID0gJycsIFxyXG4vLyB3aGVuIHVzZWQgYXMgdGhlIHYtZWxzZSBicmFuY2gsIHRoZSBjb21tZW50IG5vZGUgbXVzdCBiZSBjcmVhdGVkIGFzIGFcclxuLy8gYmxvY2sgdG8gZW5zdXJlIGNvcnJlY3QgdXBkYXRlcy5cclxuYXNCbG9jayA9IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gYXNCbG9ja1xyXG4gICAgICAgID8gKG9wZW5CbG9jaygpLCBjcmVhdGVCbG9jayhDb21tZW50LCBudWxsLCB0ZXh0KSlcclxuICAgICAgICA6IGNyZWF0ZVZOb2RlKENvbW1lbnQsIG51bGwsIHRleHQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVZOb2RlKGNoaWxkKSB7XHJcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIC8vIGVtcHR5IHBsYWNlaG9sZGVyXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKENvbW1lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBcnJheShjaGlsZCkpIHtcclxuICAgICAgICAvLyBmcmFnbWVudFxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShGcmFnbWVudCwgbnVsbCwgXHJcbiAgICAgICAgLy8gIzM2NjYsIGF2b2lkIHJlZmVyZW5jZSBwb2xsdXRpb24gd2hlbiByZXVzaW5nIHZub2RlXHJcbiAgICAgICAgY2hpbGQuc2xpY2UoKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSB2bm9kZSwgdGhpcyBzaG91bGQgYmUgdGhlIG1vc3QgY29tbW9uIHNpbmNlIGNvbXBpbGVkIHRlbXBsYXRlc1xyXG4gICAgICAgIC8vIGFsd2F5cyBwcm9kdWNlIGFsbC12bm9kZSBjaGlsZHJlbiBhcnJheXNcclxuICAgICAgICByZXR1cm4gY2xvbmVJZk1vdW50ZWQoY2hpbGQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3RyaW5ncyBhbmQgbnVtYmVyc1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZShUZXh0LCBudWxsLCBTdHJpbmcoY2hpbGQpKTtcclxuICAgIH1cclxufVxyXG4vLyBvcHRpbWl6ZWQgbm9ybWFsaXphdGlvbiBmb3IgdGVtcGxhdGUtY29tcGlsZWQgcmVuZGVyIGZuc1xyXG5mdW5jdGlvbiBjbG9uZUlmTW91bnRlZChjaGlsZCkge1xyXG4gICAgcmV0dXJuIGNoaWxkLmVsID09PSBudWxsIHx8IGNoaWxkLm1lbW8gPyBjaGlsZCA6IGNsb25lVk5vZGUoY2hpbGQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbikge1xyXG4gICAgbGV0IHR5cGUgPSAwO1xyXG4gICAgY29uc3QgeyBzaGFwZUZsYWcgfSA9IHZub2RlO1xyXG4gICAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xyXG4gICAgICAgIHR5cGUgPSAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAoc2hhcGVGbGFnICYgKDEgLyogRUxFTUVOVCAqLyB8IDY0IC8qIFRFTEVQT1JUICovKSkge1xyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgc2xvdCB0byBwbGFpbiBjaGlsZHJlbiBmb3IgcGxhaW4gZWxlbWVudCBhbmQgVGVsZXBvcnRcclxuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IGNoaWxkcmVuLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIGlmIChzbG90KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBfYyBtYXJrZXIgaXMgYWRkZWQgYnkgd2l0aEN0eCgpIGluZGljYXRpbmcgdGhpcyBpcyBhIGNvbXBpbGVkIHNsb3RcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVDaGlsZHJlbih2bm9kZSwgc2xvdCgpKTtcclxuICAgICAgICAgICAgICAgIHNsb3QuX2MgJiYgKHNsb3QuX2QgPSB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gMzIgLyogU0xPVFNfQ0hJTERSRU4gKi87XHJcbiAgICAgICAgICAgIGNvbnN0IHNsb3RGbGFnID0gY2hpbGRyZW4uXztcclxuICAgICAgICAgICAgaWYgKCFzbG90RmxhZyAmJiAhKEludGVybmFsT2JqZWN0S2V5IGluIGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4uX2N0eCA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbG90RmxhZyA9PT0gMyAvKiBGT1JXQVJERUQgKi8gJiYgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhIGNoaWxkIGNvbXBvbmVudCByZWNlaXZlcyBmb3J3YXJkZWQgc2xvdHMgZnJvbSB0aGUgcGFyZW50LlxyXG4gICAgICAgICAgICAgICAgLy8gaXRzIHNsb3QgdHlwZSBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBwYXJlbnQncyBzbG90IHR5cGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlbmRlcmluZ0luc3RhbmNlLnNsb3RzLl8gPT09IDEgLyogU1RBQkxFICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDEgLyogU1RBQkxFICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uXyA9IDIgLyogRFlOQU1JQyAqLztcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5wYXRjaEZsYWcgfD0gMTAyNCAvKiBEWU5BTUlDX1NMT1RTICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjaGlsZHJlbikpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IHsgZGVmYXVsdDogY2hpbGRyZW4sIF9jdHg6IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSB9O1xyXG4gICAgICAgIHR5cGUgPSAzMiAvKiBTTE9UU19DSElMRFJFTiAqLztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNoaWxkcmVuID0gU3RyaW5nKGNoaWxkcmVuKTtcclxuICAgICAgICAvLyBmb3JjZSB0ZWxlcG9ydCBjaGlsZHJlbiB0byBhcnJheSBzbyBpdCBjYW4gYmUgbW92ZWQgYXJvdW5kXHJcbiAgICAgICAgaWYgKHNoYXBlRmxhZyAmIDY0IC8qIFRFTEVQT1JUICovKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBBUlJBWV9DSElMRFJFTiAqLztcclxuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gOCAvKiBURVhUX0NISUxEUkVOICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB2bm9kZS5zaGFwZUZsYWcgfD0gdHlwZTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdG9NZXJnZSA9IGFyZ3NbaV07XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdG9NZXJnZSkge1xyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0LmNsYXNzICE9PSB0b01lcmdlLmNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LmNsYXNzID0gbm9ybWFsaXplQ2xhc3MoW3JldC5jbGFzcywgdG9NZXJnZS5jbGFzc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0LnN0eWxlID0gbm9ybWFsaXplU3R5bGUoW3JldC5zdHlsZSwgdG9NZXJnZS5zdHlsZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT24oa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXRba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluY29taW5nID0gdG9NZXJnZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluY29taW5nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcgIT09IGluY29taW5nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShpc0FycmF5KGV4aXN0aW5nKSAmJiBleGlzdGluZy5pbmNsdWRlcyhpbmNvbWluZykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaW5jb21pbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaW5jb21pbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0W2tleV0gPSB0b01lcmdlW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmZ1bmN0aW9uIGludm9rZVZOb2RlSG9vayhob29rLCBpbnN0YW5jZSwgdm5vZGUsIHByZXZWTm9kZSA9IG51bGwpIHtcclxuICAgIGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nKGhvb2ssIGluc3RhbmNlLCA3IC8qIFZOT0RFX0hPT0sgKi8sIFtcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICBwcmV2Vk5vZGVcclxuICAgIF0pO1xyXG59XG5cbmNvbnN0IGVtcHR5QXBwQ29udGV4dCA9IGNyZWF0ZUFwcENvbnRleHQoKTtcclxubGV0IHVpZCQxID0gMDtcclxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2Uodm5vZGUsIHBhcmVudCwgc3VzcGVuc2UpIHtcclxuICAgIGNvbnN0IHR5cGUgPSB2bm9kZS50eXBlO1xyXG4gICAgLy8gaW5oZXJpdCBwYXJlbnQgYXBwIGNvbnRleHQgLSBvciAtIGlmIHJvb3QsIGFkb3B0IGZyb20gcm9vdCB2bm9kZVxyXG4gICAgY29uc3QgYXBwQ29udGV4dCA9IChwYXJlbnQgPyBwYXJlbnQuYXBwQ29udGV4dCA6IHZub2RlLmFwcENvbnRleHQpIHx8IGVtcHR5QXBwQ29udGV4dDtcclxuICAgIGNvbnN0IGluc3RhbmNlID0ge1xyXG4gICAgICAgIHVpZDogdWlkJDErKyxcclxuICAgICAgICB2bm9kZSxcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHBhcmVudCxcclxuICAgICAgICBhcHBDb250ZXh0LFxyXG4gICAgICAgIHJvb3Q6IG51bGwsXHJcbiAgICAgICAgbmV4dDogbnVsbCxcclxuICAgICAgICBzdWJUcmVlOiBudWxsLFxyXG4gICAgICAgIGVmZmVjdDogbnVsbCxcclxuICAgICAgICB1cGRhdGU6IG51bGwsXHJcbiAgICAgICAgc2NvcGU6IG5ldyBFZmZlY3RTY29wZSh0cnVlIC8qIGRldGFjaGVkICovKSxcclxuICAgICAgICByZW5kZXI6IG51bGwsXHJcbiAgICAgICAgcHJveHk6IG51bGwsXHJcbiAgICAgICAgZXhwb3NlZDogbnVsbCxcclxuICAgICAgICBleHBvc2VQcm94eTogbnVsbCxcclxuICAgICAgICB3aXRoUHJveHk6IG51bGwsXHJcbiAgICAgICAgcHJvdmlkZXM6IHBhcmVudCA/IHBhcmVudC5wcm92aWRlcyA6IE9iamVjdC5jcmVhdGUoYXBwQ29udGV4dC5wcm92aWRlcyksXHJcbiAgICAgICAgYWNjZXNzQ2FjaGU6IG51bGwsXHJcbiAgICAgICAgcmVuZGVyQ2FjaGU6IFtdLFxyXG4gICAgICAgIC8vIGxvY2FsIHJlc29sdmVkIGFzc2V0c1xyXG4gICAgICAgIGNvbXBvbmVudHM6IG51bGwsXHJcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcclxuICAgICAgICAvLyByZXNvbHZlZCBwcm9wcyBhbmQgZW1pdHMgb3B0aW9uc1xyXG4gICAgICAgIHByb3BzT3B0aW9uczogbm9ybWFsaXplUHJvcHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIGVtaXRzT3B0aW9uczogbm9ybWFsaXplRW1pdHNPcHRpb25zKHR5cGUsIGFwcENvbnRleHQpLFxyXG4gICAgICAgIC8vIGVtaXRcclxuICAgICAgICBlbWl0OiBudWxsLFxyXG4gICAgICAgIGVtaXR0ZWQ6IG51bGwsXHJcbiAgICAgICAgLy8gcHJvcHMgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHByb3BzRGVmYXVsdHM6IEVNUFRZX09CSixcclxuICAgICAgICAvLyBpbmhlcml0QXR0cnNcclxuICAgICAgICBpbmhlcml0QXR0cnM6IHR5cGUuaW5oZXJpdEF0dHJzLFxyXG4gICAgICAgIC8vIHN0YXRlXHJcbiAgICAgICAgY3R4OiBFTVBUWV9PQkosXHJcbiAgICAgICAgZGF0YTogRU1QVFlfT0JKLFxyXG4gICAgICAgIHByb3BzOiBFTVBUWV9PQkosXHJcbiAgICAgICAgYXR0cnM6IEVNUFRZX09CSixcclxuICAgICAgICBzbG90czogRU1QVFlfT0JKLFxyXG4gICAgICAgIHJlZnM6IEVNUFRZX09CSixcclxuICAgICAgICBzZXR1cFN0YXRlOiBFTVBUWV9PQkosXHJcbiAgICAgICAgc2V0dXBDb250ZXh0OiBudWxsLFxyXG4gICAgICAgIC8vIHN1c3BlbnNlIHJlbGF0ZWRcclxuICAgICAgICBzdXNwZW5zZSxcclxuICAgICAgICBzdXNwZW5zZUlkOiBzdXNwZW5zZSA/IHN1c3BlbnNlLnBlbmRpbmdJZCA6IDAsXHJcbiAgICAgICAgYXN5bmNEZXA6IG51bGwsXHJcbiAgICAgICAgYXN5bmNSZXNvbHZlZDogZmFsc2UsXHJcbiAgICAgICAgLy8gbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICAgICAgLy8gbm90IHVzaW5nIGVudW1zIGhlcmUgYmVjYXVzZSBpdCByZXN1bHRzIGluIGNvbXB1dGVkIHByb3BlcnRpZXNcclxuICAgICAgICBpc01vdW50ZWQ6IGZhbHNlLFxyXG4gICAgICAgIGlzVW5tb3VudGVkOiBmYWxzZSxcclxuICAgICAgICBpc0RlYWN0aXZhdGVkOiBmYWxzZSxcclxuICAgICAgICBiYzogbnVsbCxcclxuICAgICAgICBjOiBudWxsLFxyXG4gICAgICAgIGJtOiBudWxsLFxyXG4gICAgICAgIG06IG51bGwsXHJcbiAgICAgICAgYnU6IG51bGwsXHJcbiAgICAgICAgdTogbnVsbCxcclxuICAgICAgICB1bTogbnVsbCxcclxuICAgICAgICBidW06IG51bGwsXHJcbiAgICAgICAgZGE6IG51bGwsXHJcbiAgICAgICAgYTogbnVsbCxcclxuICAgICAgICBydGc6IG51bGwsXHJcbiAgICAgICAgcnRjOiBudWxsLFxyXG4gICAgICAgIGVjOiBudWxsLFxyXG4gICAgICAgIHNwOiBudWxsXHJcbiAgICB9O1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluc3RhbmNlLmN0eCA9IGNyZWF0ZURldlJlbmRlckNvbnRleHQoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW5zdGFuY2UuY3R4ID0geyBfOiBpbnN0YW5jZSB9O1xyXG4gICAgfVxyXG4gICAgaW5zdGFuY2Uucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IDogaW5zdGFuY2U7XHJcbiAgICBpbnN0YW5jZS5lbWl0ID0gZW1pdCQyLmJpbmQobnVsbCwgaW5zdGFuY2UpO1xyXG4gICAgLy8gYXBwbHkgY3VzdG9tIGVsZW1lbnQgc3BlY2lhbCBoYW5kbGluZ1xyXG4gICAgaWYgKHZub2RlLmNlKSB7XHJcbiAgICAgICAgdm5vZGUuY2UoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluc3RhbmNlO1xyXG59XHJcbmxldCBjdXJyZW50SW5zdGFuY2UgPSBudWxsO1xyXG5jb25zdCBnZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiBjdXJyZW50SW5zdGFuY2UgfHwgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xyXG5jb25zdCBzZXRDdXJyZW50SW5zdGFuY2UgPSAoaW5zdGFuY2UpID0+IHtcclxuICAgIGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgaW5zdGFuY2Uuc2NvcGUub24oKTtcclxufTtcclxuY29uc3QgdW5zZXRDdXJyZW50SW5zdGFuY2UgPSAoKSA9PiB7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgJiYgY3VycmVudEluc3RhbmNlLnNjb3BlLm9mZigpO1xyXG4gICAgY3VycmVudEluc3RhbmNlID0gbnVsbDtcclxufTtcclxuY29uc3QgaXNCdWlsdEluVGFnID0gLyojX19QVVJFX18qLyBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcpO1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbXBvbmVudE5hbWUobmFtZSwgY29uZmlnKSB7XHJcbiAgICBjb25zdCBhcHBJc05hdGl2ZVRhZyA9IGNvbmZpZy5pc05hdGl2ZVRhZyB8fCBOTztcclxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgYXBwSXNOYXRpdmVUYWcobmFtZSkpIHtcclxuICAgICAgICB3YXJuJDEoJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgaWQ6ICcgKyBuYW1lKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gaW5zdGFuY2Uudm5vZGUuc2hhcGVGbGFnICYgNCAvKiBTVEFURUZVTF9DT01QT05FTlQgKi87XHJcbn1cclxubGV0IGlzSW5TU1JDb21wb25lbnRTZXR1cCA9IGZhbHNlO1xyXG5mdW5jdGlvbiBzZXR1cENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IgPSBmYWxzZSkge1xyXG4gICAgaXNJblNTUkNvbXBvbmVudFNldHVwID0gaXNTU1I7XHJcbiAgICBjb25zdCB7IHByb3BzLCBjaGlsZHJlbiB9ID0gaW5zdGFuY2Uudm5vZGU7XHJcbiAgICBjb25zdCBpc1N0YXRlZnVsID0gaXNTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSk7XHJcbiAgICBpbml0UHJvcHMoaW5zdGFuY2UsIHByb3BzLCBpc1N0YXRlZnVsLCBpc1NTUik7XHJcbiAgICBpbml0U2xvdHMoaW5zdGFuY2UsIGNoaWxkcmVuKTtcclxuICAgIGNvbnN0IHNldHVwUmVzdWx0ID0gaXNTdGF0ZWZ1bFxyXG4gICAgICAgID8gc2V0dXBTdGF0ZWZ1bENvbXBvbmVudChpbnN0YW5jZSwgaXNTU1IpXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbiAgICBpc0luU1NSQ29tcG9uZW50U2V0dXAgPSBmYWxzZTtcclxuICAgIHJldHVybiBzZXR1cFJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBzZXR1cFN0YXRlZnVsQ29tcG9uZW50KGluc3RhbmNlLCBpc1NTUikge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICBpZiAoQ29tcG9uZW50Lm5hbWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKENvbXBvbmVudC5uYW1lLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKENvbXBvbmVudC5jb21wb25lbnRzKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWVzW2ldLCBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXBvbmVudC5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoQ29tcG9uZW50LmRpcmVjdGl2ZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZURpcmVjdGl2ZU5hbWUobmFtZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wb25lbnQuY29tcGlsZXJPcHRpb25zICYmIGlzUnVudGltZU9ubHkoKSkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYFwiY29tcGlsZXJPcHRpb25zXCIgaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZSB0aGF0IGAgK1xyXG4gICAgICAgICAgICAgICAgYGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyLiBTaW5jZSB5b3UgYXJlIHVzaW5nIGEgcnVudGltZS1vbmx5IGAgK1xyXG4gICAgICAgICAgICAgICAgYGJ1aWxkLCB0aGUgb3B0aW9ucyBzaG91bGQgYmUgcGFzc2VkIHZpYSB5b3VyIGJ1aWxkIHRvb2wgY29uZmlnIGluc3RlYWQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMC4gY3JlYXRlIHJlbmRlciBwcm94eSBwcm9wZXJ0eSBhY2Nlc3MgY2FjaGVcclxuICAgIGluc3RhbmNlLmFjY2Vzc0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIC8vIDEuIGNyZWF0ZSBwdWJsaWMgaW5zdGFuY2UgLyByZW5kZXIgcHJveHlcclxuICAgIC8vIGFsc28gbWFyayBpdCByYXcgc28gaXQncyBuZXZlciBvYnNlcnZlZFxyXG4gICAgaW5zdGFuY2UucHJveHkgPSBtYXJrUmF3KG5ldyBQcm94eShpbnN0YW5jZS5jdHgsIFB1YmxpY0luc3RhbmNlUHJveHlIYW5kbGVycykpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGV4cG9zZVByb3BzT25SZW5kZXJDb250ZXh0KGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8vIDIuIGNhbGwgc2V0dXAoKVxyXG4gICAgY29uc3QgeyBzZXR1cCB9ID0gQ29tcG9uZW50O1xyXG4gICAgaWYgKHNldHVwKSB7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBDb250ZXh0ID0gKGluc3RhbmNlLnNldHVwQ29udGV4dCA9XHJcbiAgICAgICAgICAgIHNldHVwLmxlbmd0aCA+IDEgPyBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIDogbnVsbCk7XHJcbiAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGluc3RhbmNlKTtcclxuICAgICAgICBwYXVzZVRyYWNraW5nKCk7XHJcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBjYWxsV2l0aEVycm9ySGFuZGxpbmcoc2V0dXAsIGluc3RhbmNlLCAwIC8qIFNFVFVQX0ZVTkNUSU9OICovLCBbKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpID8gc2hhbGxvd1JlYWRvbmx5KGluc3RhbmNlLnByb3BzKSA6IGluc3RhbmNlLnByb3BzLCBzZXR1cENvbnRleHRdKTtcclxuICAgICAgICByZXNldFRyYWNraW5nKCk7XHJcbiAgICAgICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoaXNQcm9taXNlKHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgICAgICBzZXR1cFJlc3VsdC50aGVuKHVuc2V0Q3VycmVudEluc3RhbmNlLCB1bnNldEN1cnJlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGlmIChpc1NTUikge1xyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBwcm9taXNlIHNvIHNlcnZlci1yZW5kZXJlciBjYW4gd2FpdCBvbiBpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHVwUmVzdWx0XHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc29sdmVkUmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHJlc29sdmVkUmVzdWx0LCBpc1NTUik7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBpbnN0YW5jZSwgMCAvKiBTRVRVUF9GVU5DVElPTiAqLyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGFzeW5jIHNldHVwIHJldHVybmVkIFByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAvLyBiYWlsIGhlcmUgYW5kIHdhaXQgZm9yIHJlLWVudHJ5LlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuYXN5bmNEZXAgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWluc3RhbmNlLnN1c3BlbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IChfYSA9IENvbXBvbmVudC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnQW5vbnltb3VzJztcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDEoYENvbXBvbmVudCA8JHtuYW1lfT46IHNldHVwIGZ1bmN0aW9uIHJldHVybmVkIGEgcHJvbWlzZSwgYnV0IG5vIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBBIGNvbXBvbmVudCB3aXRoIGFzeW5jIHNldHVwKCkgbXVzdCBiZSBuZXN0ZWQgaW4gYSA8U3VzcGVuc2U+IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgaW4gb3JkZXIgdG8gYmUgcmVuZGVyZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNldHVwUmVzdWx0KGluc3RhbmNlLCBzZXR1cFJlc3VsdCwgaXNTU1IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZpbmlzaENvbXBvbmVudFNldHVwKGluc3RhbmNlLCBpc1NTUik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFuZGxlU2V0dXBSZXN1bHQoaW5zdGFuY2UsIHNldHVwUmVzdWx0LCBpc1NTUikge1xyXG4gICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgcmV0dXJuZWQgYW4gaW5saW5lIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICAgIGlmIChpbnN0YW5jZS50eXBlLl9fc3NySW5saW5lUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGZ1bmN0aW9uJ3MgbmFtZSBpcyBgc3NyUmVuZGVyYCAoY29tcGlsZWQgYnkgU0ZDIGlubGluZSBtb2RlKSxcclxuICAgICAgICAgICAgLy8gc2V0IGl0IGFzIHNzclJlbmRlciBpbnN0ZWFkLlxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zc3JSZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnJlbmRlciA9IHNldHVwUmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNldHVwUmVzdWx0KSkge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaXNWTm9kZShzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgd2FybiQxKGBzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIGAgK1xyXG4gICAgICAgICAgICAgICAgYHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXR1cCByZXR1cm5lZCBiaW5kaW5ncy5cclxuICAgICAgICAvLyBhc3N1bWluZyBhIHJlbmRlciBmdW5jdGlvbiBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGlzIHByZXNlbnQuXHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZGV2dG9vbHNSYXdTZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnNldHVwU3RhdGUgPSBwcm94eVJlZnMoc2V0dXBSZXN1bHQpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgZXhwb3NlU2V0dXBTdGF0ZU9uUmVuZGVyQ29udGV4dChpbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHNldHVwUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB3YXJuJDEoYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0fWApO1xyXG4gICAgfVxyXG4gICAgZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSKTtcclxufVxyXG5sZXQgY29tcGlsZTtcclxubGV0IGluc3RhbGxXaXRoUHJveHk7XHJcbi8qKlxyXG4gKiBGb3IgcnVudGltZS1kb20gdG8gcmVnaXN0ZXIgdGhlIGNvbXBpbGVyLlxyXG4gKiBOb3RlIHRoZSBleHBvcnRlZCBtZXRob2QgdXNlcyBhbnkgdG8gYXZvaWQgZC50cyByZWx5aW5nIG9uIHRoZSBjb21waWxlciB0eXBlcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyKF9jb21waWxlKSB7XHJcbiAgICBjb21waWxlID0gX2NvbXBpbGU7XHJcbiAgICBpbnN0YWxsV2l0aFByb3h5ID0gaSA9PiB7XHJcbiAgICAgICAgaWYgKGkucmVuZGVyLl9yYykge1xyXG4gICAgICAgICAgICBpLndpdGhQcm94eSA9IG5ldyBQcm94eShpLmN0eCwgUnVudGltZUNvbXBpbGVkUHVibGljSW5zdGFuY2VQcm94eUhhbmRsZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbi8vIGRldiBvbmx5XHJcbmNvbnN0IGlzUnVudGltZU9ubHkgPSAoKSA9PiAhY29tcGlsZTtcclxuZnVuY3Rpb24gZmluaXNoQ29tcG9uZW50U2V0dXAoaW5zdGFuY2UsIGlzU1NSLCBza2lwT3B0aW9ucykge1xyXG4gICAgY29uc3QgQ29tcG9uZW50ID0gaW5zdGFuY2UudHlwZTtcclxuICAgIHtcclxuICAgICAgICBjb252ZXJ0TGVnYWN5UmVuZGVyRm4oaW5zdGFuY2UpO1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgQ29tcG9uZW50LmNvbXBhdENvbmZpZykge1xyXG4gICAgICAgICAgICB2YWxpZGF0ZUNvbXBhdENvbmZpZyhDb21wb25lbnQuY29tcGF0Q29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB0ZW1wbGF0ZSAvIHJlbmRlciBmdW5jdGlvbiBub3JtYWxpemF0aW9uXHJcbiAgICAvLyBjb3VsZCBiZSBhbHJlYWR5IHNldCB3aGVuIHJldHVybmVkIGZyb20gc2V0dXAoKVxyXG4gICAgaWYgKCFpbnN0YW5jZS5yZW5kZXIpIHtcclxuICAgICAgICAvLyBvbmx5IGRvIG9uLXRoZS1mbHkgY29tcGlsZSBpZiBub3QgaW4gU1NSIC0gU1NSIG9uLXRoZS1mbHkgY29tcGlsYXRpb25cclxuICAgICAgICAvLyBpcyBkb25lIGJ5IHNlcnZlci1yZW5kZXJlclxyXG4gICAgICAgIGlmICghaXNTU1IgJiYgY29tcGlsZSAmJiAhQ29tcG9uZW50LnJlbmRlcikge1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IChpbnN0YW5jZS52bm9kZS5wcm9wcyAmJlxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uudm5vZGUucHJvcHNbJ2lubGluZS10ZW1wbGF0ZSddKSB8fFxyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnRlbXBsYXRlO1xyXG4gICAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydE1lYXN1cmUoaW5zdGFuY2UsIGBjb21waWxlYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzQ3VzdG9tRWxlbWVudCwgY29tcGlsZXJPcHRpb25zIH0gPSBpbnN0YW5jZS5hcHBDb250ZXh0LmNvbmZpZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVsaW1pdGVycywgY29tcGlsZXJPcHRpb25zOiBjb21wb25lbnRDb21waWxlck9wdGlvbnMgfSA9IENvbXBvbmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsQ29tcGlsZXJPcHRpb25zID0gZXh0ZW5kKGV4dGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDdXN0b21FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlcnNcclxuICAgICAgICAgICAgICAgIH0sIGNvbXBpbGVyT3B0aW9ucyksIGNvbXBvbmVudENvbXBpbGVyT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyBydW50aW1lIGNvbXBhdCBjb25maWcgaW50byB0aGUgY29tcGlsZXJcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbENvbXBpbGVyT3B0aW9ucy5jb21wYXRDb25maWcgPSBPYmplY3QuY3JlYXRlKGdsb2JhbENvbXBhdENvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbXBvbmVudC5jb21wYXRDb25maWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKGZpbmFsQ29tcGlsZXJPcHRpb25zLmNvbXBhdENvbmZpZywgQ29tcG9uZW50LmNvbXBhdENvbmZpZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LnJlbmRlciA9IGNvbXBpbGUodGVtcGxhdGUsIGZpbmFsQ29tcGlsZXJPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmRNZWFzdXJlKGluc3RhbmNlLCBgY29tcGlsZWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLnJlbmRlciA9IChDb21wb25lbnQucmVuZGVyIHx8IE5PT1ApO1xyXG4gICAgICAgIC8vIGZvciBydW50aW1lLWNvbXBpbGVkIHJlbmRlciBmdW5jdGlvbnMgdXNpbmcgYHdpdGhgIGJsb2NrcywgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIHByb3h5IHVzZWQgbmVlZHMgYSBkaWZmZXJlbnQgYGhhc2AgaGFuZGxlciB3aGljaCBpcyBtb3JlIHBlcmZvcm1hbnQgYW5kXHJcbiAgICAgICAgLy8gYWxzbyBvbmx5IGFsbG93cyBhIHdoaXRlbGlzdCBvZiBnbG9iYWxzIHRvIGZhbGx0aHJvdWdoLlxyXG4gICAgICAgIGlmIChpbnN0YWxsV2l0aFByb3h5KSB7XHJcbiAgICAgICAgICAgIGluc3RhbGxXaXRoUHJveHkoaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHN1cHBvcnQgZm9yIDIueCBvcHRpb25zXHJcbiAgICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhKHNraXBPcHRpb25zKSkge1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShpbnN0YW5jZSk7XHJcbiAgICAgICAgcGF1c2VUcmFja2luZygpO1xyXG4gICAgICAgIGFwcGx5T3B0aW9ucyhpbnN0YW5jZSk7XHJcbiAgICAgICAgcmVzZXRUcmFja2luZygpO1xyXG4gICAgICAgIHVuc2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICAvLyB3YXJuIG1pc3NpbmcgdGVtcGxhdGUvcmVuZGVyXHJcbiAgICAvLyB0aGUgcnVudGltZSBjb21waWxhdGlvbiBvZiB0ZW1wbGF0ZSBpbiBTU1IgaXMgZG9uZSBieSBzZXJ2ZXItcmVuZGVyXHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmICFDb21wb25lbnQucmVuZGVyICYmIGluc3RhbmNlLnJlbmRlciA9PT0gTk9PUCAmJiAhaXNTU1IpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIWNvbXBpbGUgJiYgQ29tcG9uZW50LnRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgYCArXHJcbiAgICAgICAgICAgICAgICBgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLmAgK1xyXG4gICAgICAgICAgICAgICAgKGAgQ29uZmlndXJlIHlvdXIgYnVuZGxlciB0byBhbGlhcyBcInZ1ZVwiIHRvIFwidnVlL2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYFxyXG4gICAgICAgICAgICAgICAgICAgICkgLyogc2hvdWxkIG5vdCBoYXBwZW4gKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybiQxKGBDb21wb25lbnQgaXMgbWlzc2luZyB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUF0dHJzUHJveHkoaW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBuZXcgUHJveHkoaW5zdGFuY2UuYXR0cnMsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKVxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIG1hcmtBdHRyc0FjY2Vzc2VkKCk7XHJcbiAgICAgICAgICAgICAgICB0cmFjayhpbnN0YW5jZSwgXCJnZXRcIiAvKiBHRVQgKi8sICckYXR0cnMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KCkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBzZXR1cENvbnRleHQuYXR0cnMgaXMgcmVhZG9ubHkuYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgOiB7XHJcbiAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2soaW5zdGFuY2UsIFwiZ2V0XCIgLyogR0VUICovLCAnJGF0dHJzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVTZXR1cENvbnRleHQoaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGV4cG9zZSA9IGV4cG9zZWQgPT4ge1xyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgaW5zdGFuY2UuZXhwb3NlZCkge1xyXG4gICAgICAgICAgICB3YXJuJDEoYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnN0YW5jZS5leHBvc2VkID0gZXhwb3NlZCB8fCB7fTtcclxuICAgIH07XHJcbiAgICBsZXQgYXR0cnM7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgLy8gV2UgdXNlIGdldHRlcnMgaW4gZGV2IGluIGNhc2UgbGlicyBsaWtlIHRlc3QtdXRpbHMgb3ZlcndyaXRlIGluc3RhbmNlXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyAob3ZlcndyaXRlcyBzaG91bGQgbm90IGJlIGRvbmUgaW4gcHJvZClcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBzbG90cygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGFsbG93UmVhZG9ubHkoaW5zdGFuY2Uuc2xvdHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgZW1pdCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZXZlbnQsIC4uLmFyZ3MpID0+IGluc3RhbmNlLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleHBvc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhdHRycyB8fCAoYXR0cnMgPSBjcmVhdGVBdHRyc1Byb3h5KGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNsb3RzOiBpbnN0YW5jZS5zbG90cyxcclxuICAgICAgICAgICAgZW1pdDogaW5zdGFuY2UuZW1pdCxcclxuICAgICAgICAgICAgZXhwb3NlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRFeHBvc2VQcm94eShpbnN0YW5jZSkge1xyXG4gICAgaWYgKGluc3RhbmNlLmV4cG9zZWQpIHtcclxuICAgICAgICByZXR1cm4gKGluc3RhbmNlLmV4cG9zZVByb3h5IHx8XHJcbiAgICAgICAgICAgIChpbnN0YW5jZS5leHBvc2VQcm94eSA9IG5ldyBQcm94eShwcm94eVJlZnMobWFya1JhdyhpbnN0YW5jZS5leHBvc2VkKSksIHtcclxuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHB1YmxpY1Byb3BlcnRpZXNNYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY1Byb3BlcnRpZXNNYXBba2V5XShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XHJcbmNvbnN0IGNsYXNzaWZ5ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCwgaW5jbHVkZUluZmVycmVkID0gdHJ1ZSkge1xyXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oQ29tcG9uZW50KVxyXG4gICAgICAgID8gQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lXHJcbiAgICAgICAgOiBDb21wb25lbnQubmFtZSB8fCAoaW5jbHVkZUluZmVycmVkICYmIENvbXBvbmVudC5fX25hbWUpO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGZvcm1hdENvbXBvbmVudE5hbWUoaW5zdGFuY2UsIENvbXBvbmVudCwgaXNSb290ID0gZmFsc2UpIHtcclxuICAgIGxldCBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpO1xyXG4gICAgaWYgKCFuYW1lICYmIENvbXBvbmVudC5fX2ZpbGUpIHtcclxuICAgICAgICBjb25zdCBtYXRjaCA9IENvbXBvbmVudC5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG1hdGNoWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghbmFtZSAmJiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnQpIHtcclxuICAgICAgICAvLyB0cnkgdG8gaW5mZXIgdGhlIG5hbWUgYmFzZWQgb24gcmV2ZXJzZSByZXNvbHV0aW9uXHJcbiAgICAgICAgY29uc3QgaW5mZXJGcm9tUmVnaXN0cnkgPSAocmVnaXN0cnkpID0+IHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeVtrZXldID09PSBDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBuYW1lID1cclxuICAgICAgICAgICAgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuY29tcG9uZW50cyB8fFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50LnR5cGUuY29tcG9uZW50cykgfHwgaW5mZXJGcm9tUmVnaXN0cnkoaW5zdGFuY2UuYXBwQ29udGV4dC5jb21wb25lbnRzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lID8gY2xhc3NpZnkobmFtZSkgOiBpc1Jvb3QgPyBgQXBwYCA6IGBBbm9ueW1vdXNgO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQodmFsdWUpIHtcclxuICAgIHJldHVybiBpc0Z1bmN0aW9uKHZhbHVlKSAmJiAnX192Y2NPcHRzJyBpbiB2YWx1ZTtcclxufVxuXG5jb25zdCBjb21wdXRlZCQxID0gKChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykgPT4ge1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcmV0dXJuIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zLCBpc0luU1NSQ29tcG9uZW50U2V0dXApO1xyXG59KTtcblxuLy8gZGV2IG9ubHlcclxuY29uc3Qgd2FyblJ1bnRpbWVVc2FnZSA9IChtZXRob2QpID0+IHdhcm4kMShgJHttZXRob2R9KCkgaXMgYSBjb21waWxlci1oaW50IGhlbHBlciB0aGF0IGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgICtcclxuICAgIGA8c2NyaXB0IHNldHVwPiBvZiBhIHNpbmdsZSBmaWxlIGNvbXBvbmVudC4gSXRzIGFyZ3VtZW50cyBzaG91bGQgYmUgYCArXHJcbiAgICBgY29tcGlsZWQgYXdheSBhbmQgcGFzc2luZyBpdCBhdCBydW50aW1lIGhhcyBubyBlZmZlY3QuYCk7XHJcbi8vIGltcGxlbWVudGF0aW9uXHJcbmZ1bmN0aW9uIGRlZmluZVByb3BzKCkge1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIHdhcm5SdW50aW1lVXNhZ2UoYGRlZmluZVByb3BzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBkZWZpbmVFbWl0cygpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFbWl0c2ApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFZ1ZSBgPHNjcmlwdCBzZXR1cD5gIGNvbXBpbGVyIG1hY3JvIGZvciBkZWNsYXJpbmcgYSBjb21wb25lbnQncyBleHBvc2VkXHJcbiAqIGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBpdCBpcyBhY2Nlc3NlZCBieSBhIHBhcmVudCBjb21wb25lbnQgdmlhIHRlbXBsYXRlXHJcbiAqIHJlZnMuXHJcbiAqXHJcbiAqIGA8c2NyaXB0IHNldHVwPmAgY29tcG9uZW50cyBhcmUgY2xvc2VkIGJ5IGRlZmF1bHQgLSBpLmUuIHZhcmlhYmxlcyBpbnNpZGVcclxuICogdGhlIGA8c2NyaXB0IHNldHVwPmAgc2NvcGUgaXMgbm90IGV4cG9zZWQgdG8gcGFyZW50IHVubGVzcyBleHBsaWNpdGx5IGV4cG9zZWRcclxuICogdmlhIGBkZWZpbmVFeHBvc2VgLlxyXG4gKlxyXG4gKiBUaGlzIGlzIG9ubHkgdXNhYmxlIGluc2lkZSBgPHNjcmlwdCBzZXR1cD5gLCBpcyBjb21waWxlZCBhd2F5IGluIHRoZVxyXG4gKiBvdXRwdXQgYW5kIHNob3VsZCAqKm5vdCoqIGJlIGFjdHVhbGx5IGNhbGxlZCBhdCBydW50aW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lRXhwb3NlKGV4cG9zZWQpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGBkZWZpbmVFeHBvc2VgKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVnVlIGA8c2NyaXB0IHNldHVwPmAgY29tcGlsZXIgbWFjcm8gZm9yIHByb3ZpZGluZyBwcm9wcyBkZWZhdWx0IHZhbHVlcyB3aGVuXHJcbiAqIHVzaW5nIHR5cGUtYmFzZWQgYGRlZmluZVByb3BzYCBkZWNsYXJhdGlvbi5cclxuICpcclxuICogRXhhbXBsZSB1c2FnZTpcclxuICogYGBgdHNcclxuICogd2l0aERlZmF1bHRzKGRlZmluZVByb3BzPHtcclxuICogICBzaXplPzogbnVtYmVyXHJcbiAqICAgbGFiZWxzPzogc3RyaW5nW11cclxuICogfT4oKSwge1xyXG4gKiAgIHNpemU6IDMsXHJcbiAqICAgbGFiZWxzOiAoKSA9PiBbJ2RlZmF1bHQgbGFiZWwnXVxyXG4gKiB9KVxyXG4gKiBgYGBcclxuICpcclxuICogVGhpcyBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgYDxzY3JpcHQgc2V0dXA+YCwgaXMgY29tcGlsZWQgYXdheSBpbiB0aGUgb3V0cHV0XHJcbiAqIGFuZCBzaG91bGQgKipub3QqKiBiZSBhY3R1YWxseSBjYWxsZWQgYXQgcnVudGltZS5cclxuICovXHJcbmZ1bmN0aW9uIHdpdGhEZWZhdWx0cyhwcm9wcywgZGVmYXVsdHMpIHtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICB3YXJuUnVudGltZVVzYWdlKGB3aXRoRGVmYXVsdHNgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xyXG4gICAgcmV0dXJuIGdldENvbnRleHQoKS5zbG90cztcclxufVxyXG5mdW5jdGlvbiB1c2VBdHRycygpIHtcclxuICAgIHJldHVybiBnZXRDb250ZXh0KCkuYXR0cnM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcclxuICAgIGNvbnN0IGkgPSBnZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgIWkpIHtcclxuICAgICAgICB3YXJuJDEoYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaS5zZXR1cENvbnRleHQgfHwgKGkuc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KGkpKTtcclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcclxuICogb25seS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcclxuICAgIGNvbnN0IHByb3BzID0gaXNBcnJheShyYXcpXHJcbiAgICAgICAgPyByYXcucmVkdWNlKChub3JtYWxpemVkLCBwKSA9PiAoKG5vcm1hbGl6ZWRbcF0gPSB7fSksIG5vcm1hbGl6ZWQpLCB7fSlcclxuICAgICAgICA6IHJhdztcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgICAgICBpZiAob3B0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpIHtcclxuICAgICAgICAgICAgd2FybiQxKGBwcm9wcyBkZWZhdWx0IGtleSBcIiR7a2V5fVwiIGhhcyBubyBjb3JyZXNwb25kaW5nIGRlY2xhcmF0aW9uLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwcm9wcztcclxufVxyXG4vKipcclxuICogVXNlZCB0byBjcmVhdGUgYSBwcm94eSBmb3IgdGhlIHJlc3QgZWxlbWVudCB3aGVuIGRlc3RydWN0dXJpbmcgcHJvcHMgd2l0aFxyXG4gKiBkZWZpbmVQcm9wcygpLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVByb3BzUmVzdFByb3h5KHByb3BzLCBleGNsdWRlZEtleXMpIHtcclxuICAgIGNvbnN0IHJldCA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICBpZiAoIWV4Y2x1ZGVkS2V5cy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXQsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gcHJvcHNba2V5XVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbi8qKlxyXG4gKiBgPHNjcmlwdCBzZXR1cD5gIGhlbHBlciBmb3IgcGVyc2lzdGluZyB0aGUgY3VycmVudCBpbnN0YW5jZSBjb250ZXh0IG92ZXJcclxuICogYXN5bmMvYXdhaXQgZmxvd3MuXHJcbiAqXHJcbiAqIGBAdnVlL2NvbXBpbGVyLXNmY2AgY29udmVydHMgdGhlIGZvbGxvd2luZzpcclxuICpcclxuICogYGBgdHNcclxuICogY29uc3QgeCA9IGF3YWl0IGZvbygpXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBpbnRvOlxyXG4gKlxyXG4gKiBgYGB0c1xyXG4gKiBsZXQgX190ZW1wLCBfX3Jlc3RvcmVcclxuICogY29uc3QgeCA9ICgoW19fdGVtcCwgX19yZXN0b3JlXSA9IHdpdGhBc3luY0NvbnRleHQoKCkgPT4gZm9vKCkpKSxfX3RlbXA9YXdhaXQgX190ZW1wLF9fcmVzdG9yZSgpLF9fdGVtcClcclxuICogYGBgXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gd2l0aEFzeW5jQ29udGV4dChnZXRBd2FpdGFibGUpIHtcclxuICAgIGNvbnN0IGN0eCA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhY3R4KSB7XHJcbiAgICAgICAgd2FybiQxKGB3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBgICtcclxuICAgICAgICAgICAgYFRoaXMgaXMgbGlrZWx5IGEgYnVnLmApO1xyXG4gICAgfVxyXG4gICAgbGV0IGF3YWl0YWJsZSA9IGdldEF3YWl0YWJsZSgpO1xyXG4gICAgdW5zZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgIGlmIChpc1Byb21pc2UoYXdhaXRhYmxlKSkge1xyXG4gICAgICAgIGF3YWl0YWJsZSA9IGF3YWl0YWJsZS5jYXRjaChlID0+IHtcclxuICAgICAgICAgICAgc2V0Q3VycmVudEluc3RhbmNlKGN0eCk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2F3YWl0YWJsZSwgKCkgPT4gc2V0Q3VycmVudEluc3RhbmNlKGN0eCldO1xyXG59XG5cbi8vIEFjdHVhbCBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzT3JDaGlsZHJlbiwgY2hpbGRyZW4pIHtcclxuICAgIGNvbnN0IGwgPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgaWYgKGwgPT09IDIpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3QocHJvcHNPckNoaWxkcmVuKSAmJiAhaXNBcnJheShwcm9wc09yQ2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgIC8vIHNpbmdsZSB2bm9kZSB3aXRob3V0IHByb3BzXHJcbiAgICAgICAgICAgIGlmIChpc1ZOb2RlKHByb3BzT3JDaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBudWxsLCBbcHJvcHNPckNoaWxkcmVuXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcHJvcHMgd2l0aG91dCBjaGlsZHJlblxyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHNPckNoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG9taXQgcHJvcHNcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG51bGwsIHByb3BzT3JDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGwgPiAzKSB7XHJcbiAgICAgICAgICAgIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobCA9PT0gMyAmJiBpc1ZOb2RlKGNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IFtjaGlsZHJlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wc09yQ2hpbGRyZW4sIGNoaWxkcmVuKTtcclxuICAgIH1cclxufVxuXG5jb25zdCBzc3JDb250ZXh0S2V5ID0gU3ltYm9sKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSA/IGBzc3JDb250ZXh0YCA6IGBgKTtcclxuY29uc3QgdXNlU1NSQ29udGV4dCA9ICgpID0+IHtcclxuICAgIHtcclxuICAgICAgICBjb25zdCBjdHggPSBpbmplY3Qoc3NyQ29udGV4dEtleSk7XHJcbiAgICAgICAgaWYgKCFjdHgpIHtcclxuICAgICAgICAgICAgd2FybiQxKGBTZXJ2ZXIgcmVuZGVyaW5nIGNvbnRleHQgbm90IHByb3ZpZGVkLiBNYWtlIHN1cmUgdG8gb25seSBjYWxsIGAgK1xyXG4gICAgICAgICAgICAgICAgYHVzZVNTUkNvbnRleHQoKSBjb25kaXRpb25hbGx5IGluIHRoZSBzZXJ2ZXIgYnVpbGQuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdHg7XHJcbiAgICB9XHJcbn07XG5cbmZ1bmN0aW9uIGluaXRDdXN0b21Gb3JtYXR0ZXIoKSB7XHJcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgKi9cclxuICAgIGlmICghKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdnVlU3R5bGUgPSB7IHN0eWxlOiAnY29sb3I6IzNiYTc3NicgfTtcclxuICAgIGNvbnN0IG51bWJlclN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiMwYjFiYzknIH07XHJcbiAgICBjb25zdCBzdHJpbmdTdHlsZSA9IHsgc3R5bGU6ICdjb2xvcjojYjYyZTI0JyB9O1xyXG4gICAgY29uc3Qga2V5d29yZFN0eWxlID0geyBzdHlsZTogJ2NvbG9yOiM5ZDI4OGMnIH07XHJcbiAgICAvLyBjdXN0b20gZm9ybWF0dGVyIGZvciBDaHJvbWVcclxuICAgIC8vIGh0dHBzOi8vd3d3Lm1hdHR6ZXVuZXJ0LmNvbS8yMDE2LzAyLzE5L2N1c3RvbS1jaHJvbWUtZGV2dG9vbHMtb2JqZWN0LWZvcm1hdHRlcnMuaHRtbFxyXG4gICAgY29uc3QgZm9ybWF0dGVyID0ge1xyXG4gICAgICAgIGhlYWRlcihvYmopIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBhbHNvIGZvcm1hdCBDb21wb25lbnRQdWJsaWNJbnN0YW5jZSAmIGN0eC5zbG90cy9hdHRycyBpbiBzZXR1cFxyXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnZGl2JywgdnVlU3R5bGUsIGBWdWVJbnN0YW5jZWBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmKG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGdlblJlZkZsYWcob2JqKV0sXHJcbiAgICAgICAgICAgICAgICAgICAgJzwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFZhbHVlKG9iai52YWx1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgYD5gXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICBbJ3NwYW4nLCB2dWVTdHlsZSwgaXNTaGFsbG93KG9iaikgPyAnU2hhbGxvd1JlYWN0aXZlJyA6ICdSZWFjdGl2ZSddLFxyXG4gICAgICAgICAgICAgICAgICAgICc8JyxcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRWYWx1ZShvYmopLFxyXG4gICAgICAgICAgICAgICAgICAgIGA+JHtpc1JlYWRvbmx5KG9iaikgPyBgIChyZWFkb25seSlgIDogYGB9YFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWRvbmx5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXHJcbiAgICAgICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICAgICAgWydzcGFuJywgdnVlU3R5bGUsIGlzU2hhbGxvdyhvYmopID8gJ1NoYWxsb3dSZWFkb25seScgOiAnUmVhZG9ubHknXSxcclxuICAgICAgICAgICAgICAgICAgICAnPCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUob2JqKSxcclxuICAgICAgICAgICAgICAgICAgICAnPidcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBoYXNCb2R5KG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2lzVnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keShvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouX19pc1Z1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAuLi5mb3JtYXRJbnN0YW5jZShvYmouJClcclxuICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0SW5zdGFuY2UoaW5zdGFuY2UpIHtcclxuICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcclxuICAgICAgICBpZiAoaW5zdGFuY2UudHlwZS5wcm9wcyAmJiBpbnN0YW5jZS5wcm9wcykge1xyXG4gICAgICAgICAgICBibG9ja3MucHVzaChjcmVhdGVJbnN0YW5jZUJsb2NrKCdwcm9wcycsIHRvUmF3KGluc3RhbmNlLnByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2Uuc2V0dXBTdGF0ZSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ3NldHVwJywgaW5zdGFuY2Uuc2V0dXBTdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5zdGFuY2UuZGF0YSAhPT0gRU1QVFlfT0JKKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2RhdGEnLCB0b1JhdyhpbnN0YW5jZS5kYXRhKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnY29tcHV0ZWQnKTtcclxuICAgICAgICBpZiAoY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3JlYXRlSW5zdGFuY2VCbG9jaygnY29tcHV0ZWQnLCBjb21wdXRlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbmplY3RlZCA9IGV4dHJhY3RLZXlzKGluc3RhbmNlLCAnaW5qZWN0Jyk7XHJcbiAgICAgICAgaWYgKGluamVjdGVkKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyZWF0ZUluc3RhbmNlQmxvY2soJ2luamVjdGVkJywgaW5qZWN0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmxvY2tzLnB1c2goW1xyXG4gICAgICAgICAgICAnZGl2JyxcclxuICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdzcGFuJyxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZToga2V5d29yZFN0eWxlLnN0eWxlICsgJztvcGFjaXR5OjAuNjYnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgJyQgKGludGVybmFsKTogJ1xyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBbJ29iamVjdCcsIHsgb2JqZWN0OiBpbnN0YW5jZSB9XVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHJldHVybiBibG9ja3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUJsb2NrKHR5cGUsIHRhcmdldCkge1xyXG4gICAgICAgIHRhcmdldCA9IGV4dGVuZCh7fSwgdGFyZ2V0KTtcclxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRhcmdldCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCB7fV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICB7IHN0eWxlOiAnbGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW0nIH0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnY29sb3I6IzQ3NjU4MidcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0eXBlXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlOiAncGFkZGluZy1sZWZ0OjEuMjVlbSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyh0YXJnZXQpLm1hcChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdkaXYnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgWydzcGFuJywga2V5d29yZFN0eWxlLCBrZXkgKyAnOiAnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0VmFsdWUodGFyZ2V0W2tleV0sIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHYsIGFzUmF3ID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFsnc3BhbicsIG51bWJlclN0eWxlLCB2XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBzdHJpbmdTdHlsZSwgSlNPTi5zdHJpbmdpZnkodildO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbJ3NwYW4nLCBrZXl3b3JkU3R5bGUsIHZdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gWydvYmplY3QnLCB7IG9iamVjdDogYXNSYXcgPyB0b1Jhdyh2KSA6IHYgfV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gWydzcGFuJywgc3RyaW5nU3R5bGUsIFN0cmluZyh2KV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZXh0cmFjdEtleXMoaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgICAgICBjb25zdCBDb21wID0gaW5zdGFuY2UudHlwZTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihDb21wKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluc3RhbmNlLmN0eCkge1xyXG4gICAgICAgICAgICBpZiAoaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkW2tleV0gPSBpbnN0YW5jZS5jdHhba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXh0cmFjdGVkO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNLZXlPZlR5cGUoQ29tcCwga2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0cyA9IENvbXBbdHlwZV07XHJcbiAgICAgICAgaWYgKChpc0FycmF5KG9wdHMpICYmIG9wdHMuaW5jbHVkZXMoa2V5KSkgfHxcclxuICAgICAgICAgICAgKGlzT2JqZWN0KG9wdHMpICYmIGtleSBpbiBvcHRzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKENvbXAuZXh0ZW5kcyAmJiBpc0tleU9mVHlwZShDb21wLmV4dGVuZHMsIGtleSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChDb21wLm1peGlucyAmJiBDb21wLm1peGlucy5zb21lKG0gPT4gaXNLZXlPZlR5cGUobSwga2V5LCB0eXBlKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZ2VuUmVmRmxhZyh2KSB7XHJcbiAgICAgICAgaWYgKGlzU2hhbGxvdyh2KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYFNoYWxsb3dSZWZgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodi5lZmZlY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGBDb21wdXRlZFJlZmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBgUmVmYDtcclxuICAgIH1cclxuICAgIGlmICh3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzKSB7XHJcbiAgICAgICAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuZGV2dG9vbHNGb3JtYXR0ZXJzID0gW2Zvcm1hdHRlcl07XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gd2l0aE1lbW8obWVtbywgcmVuZGVyLCBjYWNoZSwgaW5kZXgpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2luZGV4XTtcclxuICAgIGlmIChjYWNoZWQgJiYgaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldCA9IHJlbmRlcigpO1xyXG4gICAgLy8gc2hhbGxvdyBjbG9uZVxyXG4gICAgcmV0Lm1lbW8gPSBtZW1vLnNsaWNlKCk7XHJcbiAgICByZXR1cm4gKGNhY2hlW2luZGV4XSA9IHJldCk7XHJcbn1cclxuZnVuY3Rpb24gaXNNZW1vU2FtZShjYWNoZWQsIG1lbW8pIHtcclxuICAgIGNvbnN0IHByZXYgPSBjYWNoZWQubWVtbztcclxuICAgIGlmIChwcmV2Lmxlbmd0aCAhPSBtZW1vLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKHByZXZbaV0sIG1lbW9baV0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBtYWtlIHN1cmUgdG8gbGV0IHBhcmVudCBibG9jayB0cmFjayBpdCB3aGVuIHJldHVybmluZyBjYWNoZWRcclxuICAgIGlmIChpc0Jsb2NrVHJlZUVuYWJsZWQgPiAwICYmIGN1cnJlbnRCbG9jaykge1xyXG4gICAgICAgIGN1cnJlbnRCbG9jay5wdXNoKGNhY2hlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vLyBDb3JlIEFQSSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuY29uc3QgdmVyc2lvbiA9IFwiMy4yLjM3XCI7XHJcbmNvbnN0IF9zc3JVdGlscyA9IHtcclxuICAgIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlLFxyXG4gICAgc2V0dXBDb21wb25lbnQsXHJcbiAgICByZW5kZXJDb21wb25lbnRSb290LFxyXG4gICAgc2V0Q3VycmVudFJlbmRlcmluZ0luc3RhbmNlLFxyXG4gICAgaXNWTm9kZSxcclxuICAgIG5vcm1hbGl6ZVZOb2RlXHJcbn07XHJcbi8qKlxyXG4gKiBTU1IgdXRpbHMgZm9yIFxcQHZ1ZS9zZXJ2ZXItcmVuZGVyZXIuIE9ubHkgZXhwb3NlZCBpbiBzc3ItcG9zc2libGUgYnVpbGRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IHNzclV0aWxzID0gKF9zc3JVdGlscyApO1xyXG4vKipcclxuICogQGludGVybmFsIG9ubHkgZXhwb3NlZCBpbiBjb21wYXQgYnVpbGRzXHJcbiAqL1xyXG5jb25zdCByZXNvbHZlRmlsdGVyJDEgPSByZXNvbHZlRmlsdGVyIDtcclxuY29uc3QgX2NvbXBhdFV0aWxzID0ge1xyXG4gICAgd2FybkRlcHJlY2F0aW9uLFxyXG4gICAgY3JlYXRlQ29tcGF0VnVlLFxyXG4gICAgaXNDb21wYXRFbmFibGVkLFxyXG4gICAgY2hlY2tDb21wYXRFbmFibGVkLFxyXG4gICAgc29mdEFzc2VydENvbXBhdEVuYWJsZWRcclxufTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBvbmx5IGV4cG9zZWQgaW4gY29tcGF0IGJ1aWxkcy5cclxuICovXHJcbmNvbnN0IGNvbXBhdFV0aWxzID0gKF9jb21wYXRVdGlscyApO1xuXG5jb25zdCBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbmNvbnN0IGRvYyA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcclxuY29uc3QgdGVtcGxhdGVDb250YWluZXIgPSBkb2MgJiYgLyojX19QVVJFX18qLyBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcclxuY29uc3Qgbm9kZU9wcyA9IHtcclxuICAgIGluc2VydDogKGNoaWxkLCBwYXJlbnQsIGFuY2hvcikgPT4ge1xyXG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGFuY2hvciB8fCBudWxsKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmU6IGNoaWxkID0+IHtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlRWxlbWVudDogKHRhZywgaXNTVkcsIGlzLCBwcm9wcykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gaXNTVkdcclxuICAgICAgICAgICAgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0YWcpXHJcbiAgICAgICAgICAgIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnLCBpcyA/IHsgaXMgfSA6IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMgJiYgcHJvcHMubXVsdGlwbGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgcHJvcHMubXVsdGlwbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlVGV4dDogdGV4dCA9PiBkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCksXHJcbiAgICBjcmVhdGVDb21tZW50OiB0ZXh0ID0+IGRvYy5jcmVhdGVDb21tZW50KHRleHQpLFxyXG4gICAgc2V0VGV4dDogKG5vZGUsIHRleHQpID0+IHtcclxuICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IHRleHQ7XHJcbiAgICB9LFxyXG4gICAgc2V0RWxlbWVudFRleHQ6IChlbCwgdGV4dCkgPT4ge1xyXG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICAgIH0sXHJcbiAgICBwYXJlbnROb2RlOiBub2RlID0+IG5vZGUucGFyZW50Tm9kZSxcclxuICAgIG5leHRTaWJsaW5nOiBub2RlID0+IG5vZGUubmV4dFNpYmxpbmcsXHJcbiAgICBxdWVyeVNlbGVjdG9yOiBzZWxlY3RvciA9PiBkb2MucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXHJcbiAgICBzZXRTY29wZUlkKGVsLCBpZCkge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShpZCwgJycpO1xyXG4gICAgfSxcclxuICAgIGNsb25lTm9kZShlbCkge1xyXG4gICAgICAgIGNvbnN0IGNsb25lZCA9IGVsLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAvLyAjMzA3MlxyXG4gICAgICAgIC8vIC0gaW4gYHBhdGNoRE9NUHJvcGAsIHdlIHN0b3JlIHRoZSBhY3R1YWwgdmFsdWUgaW4gdGhlIGBlbC5fdmFsdWVgIHByb3BlcnR5LlxyXG4gICAgICAgIC8vIC0gbm9ybWFsbHksIGVsZW1lbnRzIHVzaW5nIGA6dmFsdWVgIGJpbmRpbmdzIHdpbGwgbm90IGJlIGhvaXN0ZWQsIGJ1dCBpZlxyXG4gICAgICAgIC8vICAgdGhlIGJvdW5kIHZhbHVlIGlzIGEgY29uc3RhbnQsIGUuZy4gYDp2YWx1ZT1cInRydWVcImAgLSB0aGV5IGRvIGdldFxyXG4gICAgICAgIC8vICAgaG9pc3RlZC5cclxuICAgICAgICAvLyAtIGluIHByb2R1Y3Rpb24sIGhvaXN0ZWQgbm9kZXMgYXJlIGNsb25lZCB3aGVuIHN1YnNlcXVlbnQgaW5zZXJ0cywgYnV0XHJcbiAgICAgICAgLy8gICBjbG9uZU5vZGUoKSBkb2VzIG5vdCBjb3B5IHRoZSBjdXN0b20gcHJvcGVydHkgd2UgYXR0YWNoZWQuXHJcbiAgICAgICAgLy8gLSBUaGlzIG1heSBuZWVkIHRvIGFjY291bnQgZm9yIG90aGVyIGN1c3RvbSBET00gcHJvcGVydGllcyB3ZSBhdHRhY2ggdG9cclxuICAgICAgICAvLyAgIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIGBfdmFsdWVgIGluIHRoZSBmdXR1cmUuXHJcbiAgICAgICAgaWYgKGBfdmFsdWVgIGluIGVsKSB7XHJcbiAgICAgICAgICAgIGNsb25lZC5fdmFsdWUgPSBlbC5fdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWQ7XHJcbiAgICB9LFxyXG4gICAgLy8gX19VTlNBRkVfX1xyXG4gICAgLy8gUmVhc29uOiBpbm5lckhUTUwuXHJcbiAgICAvLyBTdGF0aWMgY29udGVudCBoZXJlIGNhbiBvbmx5IGNvbWUgZnJvbSBjb21waWxlZCB0ZW1wbGF0ZXMuXHJcbiAgICAvLyBBcyBsb25nIGFzIHRoZSB1c2VyIG9ubHkgdXNlcyB0cnVzdGVkIHRlbXBsYXRlcywgdGhpcyBpcyBzYWZlLlxyXG4gICAgaW5zZXJ0U3RhdGljQ29udGVudChjb250ZW50LCBwYXJlbnQsIGFuY2hvciwgaXNTVkcsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyA8cGFyZW50PiBiZWZvcmUgfCBmaXJzdCAuLi4gbGFzdCB8IGFuY2hvciA8L3BhcmVudD5cclxuICAgICAgICBjb25zdCBiZWZvcmUgPSBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZDtcclxuICAgICAgICAvLyAjNTMwOCBjYW4gb25seSB0YWtlIGNhY2hlZCBwYXRoIGlmOlxyXG4gICAgICAgIC8vIC0gaGFzIGEgc2luZ2xlIHJvb3Qgbm9kZVxyXG4gICAgICAgIC8vIC0gbmV4dFNpYmxpbmcgaW5mbyBpcyBzdGlsbCBhdmFpbGFibGVcclxuICAgICAgICBpZiAoc3RhcnQgJiYgKHN0YXJ0ID09PSBlbmQgfHwgc3RhcnQubmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgIC8vIGNhY2hlZFxyXG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShzdGFydC5jbG9uZU5vZGUodHJ1ZSksIGFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCB8fCAhKHN0YXJ0ID0gc3RhcnQubmV4dFNpYmxpbmcpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmcmVzaCBpbnNlcnRcclxuICAgICAgICAgICAgdGVtcGxhdGVDb250YWluZXIuaW5uZXJIVE1MID0gaXNTVkcgPyBgPHN2Zz4ke2NvbnRlbnR9PC9zdmc+YCA6IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVDb250YWluZXIuY29udGVudDtcclxuICAgICAgICAgICAgaWYgKGlzU1ZHKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgb3V0ZXIgc3ZnIHdyYXBwZXJcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSB0ZW1wbGF0ZS5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHdyYXBwZXIuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLmFwcGVuZENoaWxkKHdyYXBwZXIuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBhbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAvLyBmaXJzdFxyXG4gICAgICAgICAgICBiZWZvcmUgPyBiZWZvcmUubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCxcclxuICAgICAgICAgICAgLy8gbGFzdFxyXG4gICAgICAgICAgICBhbmNob3IgPyBhbmNob3IucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Lmxhc3RDaGlsZFxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcbn07XG5cbi8vIGNvbXBpbGVyIHNob3VsZCBub3JtYWxpemUgY2xhc3MgKyA6Y2xhc3MgYmluZGluZ3Mgb24gdGhlIHNhbWUgZWxlbWVudFxyXG4vLyBpbnRvIGEgc2luZ2xlIGJpbmRpbmcgWydzdGF0aWNDbGFzcycsIGR5bmFtaWNdXHJcbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoZWwsIHZhbHVlLCBpc1NWRykge1xyXG4gICAgLy8gZGlyZWN0bHkgc2V0dGluZyBjbGFzc05hbWUgc2hvdWxkIGJlIGZhc3RlciB0aGFuIHNldEF0dHJpYnV0ZSBpbiB0aGVvcnlcclxuICAgIC8vIGlmIHRoaXMgaXMgYW4gZWxlbWVudCBkdXJpbmcgYSB0cmFuc2l0aW9uLCB0YWtlIHRoZSB0ZW1wb3JhcnkgdHJhbnNpdGlvblxyXG4gICAgLy8gY2xhc3NlcyBpbnRvIGFjY291bnQuXHJcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl92dGM7XHJcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFt2YWx1ZSwgLi4udHJhbnNpdGlvbkNsYXNzZXNdIDogWy4uLnRyYW5zaXRpb25DbGFzc2VzXSkuam9pbignICcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NWRykge1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBlbC5jbGFzc05hbWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBwYXRjaFN0eWxlKGVsLCBwcmV2LCBuZXh0KSB7XHJcbiAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgY29uc3QgaXNDc3NTdHJpbmcgPSBpc1N0cmluZyhuZXh0KTtcclxuICAgIGlmIChuZXh0ICYmICFpc0Nzc1N0cmluZykge1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcclxuICAgICAgICAgICAgc2V0U3R5bGUoc3R5bGUsIGtleSwgbmV4dFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByZXYgJiYgIWlzU3RyaW5nKHByZXYpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0W2tleV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlLCBrZXksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnREaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAoaXNDc3NTdHJpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHByZXYgIT09IG5leHQpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSBuZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByZXYpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmRpY2F0ZXMgdGhhdCB0aGUgYGRpc3BsYXlgIG9mIHRoZSBlbGVtZW50IGlzIGNvbnRyb2xsZWQgYnkgYHYtc2hvd2AsXHJcbiAgICAgICAgLy8gc28gd2UgYWx3YXlzIGtlZXAgdGhlIGN1cnJlbnQgYGRpc3BsYXlgIHZhbHVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzdHlsZWBcclxuICAgICAgICAvLyB2YWx1ZSwgdGh1cyBoYW5kaW5nIG92ZXIgY29udHJvbCB0byBgdi1zaG93YC5cclxuICAgICAgICBpZiAoJ192b2QnIGluIGVsKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBjdXJyZW50RGlzcGxheTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcclxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHZhbCkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIHZhbC5mb3JFYWNoKHYgPT4gc2V0U3R5bGUoc3R5bGUsIG5hbWUsIHYpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWwgPT0gbnVsbClcclxuICAgICAgICAgICAgdmFsID0gJyc7XHJcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLS0nKSkge1xyXG4gICAgICAgICAgICAvLyBjdXN0b20gcHJvcGVydHkgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcHJlZml4ZWQgPSBhdXRvUHJlZml4KHN0eWxlLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gIWltcG9ydGFudFxyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKHByZWZpeGVkKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbcHJlZml4ZWRdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbmNvbnN0IHByZWZpeENhY2hlID0ge307XHJcbmZ1bmN0aW9uIGF1dG9QcmVmaXgoc3R5bGUsIHJhd05hbWUpIHtcclxuICAgIGNvbnN0IGNhY2hlZCA9IHByZWZpeENhY2hlW3Jhd05hbWVdO1xyXG4gICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgbmFtZSA9IGNhbWVsaXplKHJhd05hbWUpO1xyXG4gICAgaWYgKG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgaW4gc3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gKHByZWZpeENhY2hlW3Jhd05hbWVdID0gbmFtZSk7XHJcbiAgICB9XHJcbiAgICBuYW1lID0gY2FwaXRhbGl6ZShuYW1lKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgbmFtZTtcclxuICAgICAgICBpZiAocHJlZml4ZWQgaW4gc3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChwcmVmaXhDYWNoZVtyYXdOYW1lXSA9IHByZWZpeGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmF3TmFtZTtcclxufVxuXG5jb25zdCB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xyXG5mdW5jdGlvbiBwYXRjaEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzU1ZHLCBpbnN0YW5jZSkge1xyXG4gICAgaWYgKGlzU1ZHICYmIGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleS5zbGljZSg2LCBrZXkubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoY29tcGF0Q29lcmNlQXR0cihlbCwga2V5LCB2YWx1ZSwgaW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm90ZSB3ZSBhcmUgb25seSBjaGVja2luZyBib29sZWFuIGF0dHJpYnV0ZXMgdGhhdCBkb24ndCBoYXZlIGFcclxuICAgICAgICAvLyBjb3JyZXNwb25kaW5nIGRvbSBwcm9wIG9mIHRoZSBzYW1lIG5hbWUgaGVyZS5cclxuICAgICAgICBjb25zdCBpc0Jvb2xlYW4gPSBpc1NwZWNpYWxCb29sZWFuQXR0cihrZXkpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IChpc0Jvb2xlYW4gJiYgIWluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNCb29sZWFuID8gJycgOiB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIDIueCBjb21wYXRcclxuY29uc3QgaXNFbnVtZXJhdGVkQXR0ciA9IC8qI19fUFVSRV9fKi8gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJylcclxuICAgIDtcclxuZnVuY3Rpb24gY29tcGF0Q29lcmNlQXR0cihlbCwga2V5LCB2YWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XHJcbiAgICBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XHJcbiAgICAgICAgY29uc3QgdjJDb2NlcmNlZFZhbHVlID0gdmFsdWUgPT09IG51bGxcclxuICAgICAgICAgICAgPyAnZmFsc2UnXHJcbiAgICAgICAgICAgIDogdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicgJiYgdmFsdWUgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgPyAndHJ1ZSdcclxuICAgICAgICAgICAgICAgIDogbnVsbDtcclxuICAgICAgICBpZiAodjJDb2NlcmNlZFZhbHVlICYmXHJcbiAgICAgICAgICAgIGNvbXBhdFV0aWxzLnNvZnRBc3NlcnRDb21wYXRFbmFibGVkKFwiQVRUUl9FTlVNRVJBVEVEX0NPRVJDSU9OXCIgLyogQVRUUl9FTlVNRVJBVEVEX0NPRVJDSU9OICovLCBpbnN0YW5jZSwga2V5LCB2YWx1ZSwgdjJDb2NlcmNlZFZhbHVlKSkge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2MkNvY2VyY2VkVmFsdWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UgJiZcclxuICAgICAgICAhaXNTcGVjaWFsQm9vbGVhbkF0dHIoa2V5KSAmJlxyXG4gICAgICAgIGNvbXBhdFV0aWxzLnNvZnRBc3NlcnRDb21wYXRFbmFibGVkKFwiQVRUUl9GQUxTRV9WQUxVRVwiIC8qIEFUVFJfRkFMU0VfVkFMVUUgKi8sIGluc3RhbmNlLCBrZXkpKSB7XHJcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cblxuLy8gX19VTlNBRkVfX1xyXG4vLyBmdW5jdGlvbnMuIFRoZSB1c2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1c2luZyB0aGVtIHdpdGggb25seSB0cnVzdGVkIGNvbnRlbnQuXHJcbmZ1bmN0aW9uIHBhdGNoRE9NUHJvcChlbCwga2V5LCB2YWx1ZSwgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJncyBhcmUgcGFzc2VkIG9ubHkgZHVlIHRvIHBvdGVudGlhbCBpbm5lckhUTUwvdGV4dENvbnRlbnRcclxuLy8gb3ZlcnJpZGluZyBleGlzdGluZyBWTm9kZXMsIGluIHdoaWNoIGNhc2UgdGhlIG9sZCB0cmVlIG11c3QgYmUgcHJvcGVybHlcclxuLy8gdW5tb3VudGVkLlxyXG5wcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikge1xyXG4gICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xyXG4gICAgICAgICAgICB1bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiZcclxuICAgICAgICBlbC50YWdOYW1lICE9PSAnUFJPR1JFU1MnICYmXHJcbiAgICAgICAgLy8gY3VzdG9tIGVsZW1lbnRzIG1heSB1c2UgX3ZhbHVlIGludGVybmFsbHlcclxuICAgICAgICAhZWwudGFnTmFtZS5pbmNsdWRlcygnLScpKSB7XHJcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcclxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkLlxyXG4gICAgICAgIGVsLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSB8fFxyXG4gICAgICAgICAgICAvLyAjNDk1NjogYWx3YXlzIHNldCBmb3IgT1BUSU9OIGVsZW1lbnRzIGJlY2F1c2UgaXRzIHZhbHVlIGZhbGxzIGJhY2sgdG9cclxuICAgICAgICAgICAgLy8gdGV4dENvbnRlbnQgaWYgbm8gdmFsdWUgYXR0cmlidXRlIGlzIHByZXNlbnQuIEFuZCBzZXR0aW5nIC52YWx1ZSBmb3JcclxuICAgICAgICAgICAgLy8gT1BUSU9OIGhhcyBubyBzaWRlIGVmZmVjdFxyXG4gICAgICAgICAgICBlbC50YWdOYW1lID09PSAnT1BUSU9OJykge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IG5lZWRSZW1vdmUgPSBmYWxzZTtcclxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPHNlbGVjdCBtdWx0aXBsZT4gY29tcGlsZXMgdG8geyBtdWx0aXBsZTogJycgfVxyXG4gICAgICAgICAgICB2YWx1ZSA9IGluY2x1ZGVCb29sZWFuQXR0cih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IG51bGwgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gZS5nLiA8ZGl2IDppZD1cIm51bGxcIj5cclxuICAgICAgICAgICAgdmFsdWUgPSAnJztcclxuICAgICAgICAgICAgbmVlZFJlbW92ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGUuZy4gPGltZyA6d2lkdGg9XCJudWxsXCI+XHJcbiAgICAgICAgICAgIC8vIHRoZSB2YWx1ZSBvZiBzb21lIElETCBhdHRyIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAsIGUuZy4gaW5wdXQuc2l6ZSA9IDAgLT4gZXJyb3JcclxuICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICBuZWVkUmVtb3ZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlICYmXHJcbiAgICAgICAgICAgIGNvbXBhdFV0aWxzLmlzQ29tcGF0RW5hYmxlZChcIkFUVFJfRkFMU0VfVkFMVUVcIiAvKiBBVFRSX0ZBTFNFX1ZBTFVFICovLCBwYXJlbnRDb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgZWxba2V5XTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgICAgICAgICBjb21wYXRVdGlscy53YXJuRGVwcmVjYXRpb24oXCJBVFRSX0ZBTFNFX1ZBTFVFXCIgLyogQVRUUl9GQUxTRV9WQUxVRSAqLywgcGFyZW50Q29tcG9uZW50LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0eXBlID09PSAnbnVtYmVyJyA/IDAgOiAnJztcclxuICAgICAgICAgICAgICAgIG5lZWRSZW1vdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc29tZSBwcm9wZXJ0aWVzIHBlcmZvcm0gdmFsdWUgdmFsaWRhdGlvbiBhbmQgdGhyb3csXHJcbiAgICAvLyBzb21lIHByb3BlcnRpZXMgaGFzIGdldHRlciwgbm8gc2V0dGVyLCB3aWxsIGVycm9yIGluICd1c2Ugc3RyaWN0J1xyXG4gICAgLy8gZWcuIDxzZWxlY3QgOnR5cGU9XCJudWxsXCI+PC9zZWxlY3Q+IDxzZWxlY3QgOndpbGxWYWxpZGF0ZT1cIm51bGxcIj48L3NlbGVjdD5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgZWxba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7a2V5fVwiIG9uIDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+OiBgICtcclxuICAgICAgICAgICAgICAgIGB2YWx1ZSAke3ZhbHVlfSBpcyBpbnZhbGlkLmAsIGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5lZWRSZW1vdmUgJiYgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XHJcbn1cblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cclxuY29uc3QgW19nZXROb3csIHNraXBUaW1lc3RhbXBDaGVja10gPSAvKiNfX1BVUkVfXyovICgoKSA9PiB7XHJcbiAgICBsZXQgX2dldE5vdyA9IERhdGUubm93O1xyXG4gICAgbGV0IHNraXBUaW1lc3RhbXBDaGVjayA9IGZhbHNlO1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcclxuICAgICAgICAvLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xyXG4gICAgICAgIC8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cclxuICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgbG93LXJlcyB0aW1lc3RhbXAgd2hpY2ggaXMgYmlnZ2VyIHRoYW4gdGhlIGV2ZW50IHRpbWVzdGFtcFxyXG4gICAgICAgICAgICAvLyAod2hpY2ggaXMgZXZhbHVhdGVkIEFGVEVSKSBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxyXG4gICAgICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cclxuICAgICAgICAgICAgX2dldE5vdyA9IHBlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gIzM0ODU6IEZpcmVmb3ggPD0gNTMgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAvLyBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvIHNhZmUgdG8gZXhjbHVkZS5cclxuICAgICAgICBjb25zdCBmZk1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcclxuICAgICAgICBza2lwVGltZXN0YW1wQ2hlY2sgPSAhIShmZk1hdGNoICYmIE51bWJlcihmZk1hdGNoWzFdKSA8PSA1Myk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW19nZXROb3csIHNraXBUaW1lc3RhbXBDaGVja107XHJcbn0pKCk7XHJcbi8vIFRvIGF2b2lkIHRoZSBvdmVyaGVhZCBvZiByZXBlYXRlZGx5IGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCksIHdlIGNhY2hlXHJcbi8vIGFuZCB1c2UgdGhlIHNhbWUgdGltZXN0YW1wIGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIGluIHRoZSBzYW1lIHRpY2suXHJcbmxldCBjYWNoZWROb3cgPSAwO1xyXG5jb25zdCBwID0gLyojX19QVVJFX18qLyBQcm9taXNlLnJlc29sdmUoKTtcclxuY29uc3QgcmVzZXQgPSAoKSA9PiB7XHJcbiAgICBjYWNoZWROb3cgPSAwO1xyXG59O1xyXG5jb25zdCBnZXROb3cgPSAoKSA9PiBjYWNoZWROb3cgfHwgKHAudGhlbihyZXNldCksIChjYWNoZWROb3cgPSBfZ2V0Tm93KCkpKTtcclxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XHJcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBwYXRjaEV2ZW50KGVsLCByYXdOYW1lLCBwcmV2VmFsdWUsIG5leHRWYWx1ZSwgaW5zdGFuY2UgPSBudWxsKSB7XHJcbiAgICAvLyB2ZWkgPSB2dWUgZXZlbnQgaW52b2tlcnNcclxuICAgIGNvbnN0IGludm9rZXJzID0gZWwuX3ZlaSB8fCAoZWwuX3ZlaSA9IHt9KTtcclxuICAgIGNvbnN0IGV4aXN0aW5nSW52b2tlciA9IGludm9rZXJzW3Jhd05hbWVdO1xyXG4gICAgaWYgKG5leHRWYWx1ZSAmJiBleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAvLyBwYXRjaFxyXG4gICAgICAgIGV4aXN0aW5nSW52b2tlci52YWx1ZSA9IG5leHRWYWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IHBhcnNlTmFtZShyYXdOYW1lKTtcclxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIGFkZFxyXG4gICAgICAgICAgICBjb25zdCBpbnZva2VyID0gKGludm9rZXJzW3Jhd05hbWVdID0gY3JlYXRlSW52b2tlcihuZXh0VmFsdWUsIGluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGludm9rZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChleGlzdGluZ0ludm9rZXIpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlXHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGV4aXN0aW5nSW52b2tlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGludm9rZXJzW3Jhd05hbWVdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBvcHRpb25zTW9kaWZpZXJSRSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcclxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcclxuICAgIGxldCBvcHRpb25zO1xyXG4gICAgaWYgKG9wdGlvbnNNb2RpZmllclJFLnRlc3QobmFtZSkpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgbGV0IG07XHJcbiAgICAgICAgd2hpbGUgKChtID0gbmFtZS5tYXRjaChvcHRpb25zTW9kaWZpZXJSRSkpKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIG5hbWUubGVuZ3RoIC0gbVswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBvcHRpb25zW21bMF0udG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBbaHlwaGVuYXRlKG5hbWUuc2xpY2UoMikpLCBvcHRpb25zXTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVJbnZva2VyKGluaXRpYWxWYWx1ZSwgaW5zdGFuY2UpIHtcclxuICAgIGNvbnN0IGludm9rZXIgPSAoZSkgPT4ge1xyXG4gICAgICAgIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICAvLyBhdHRhY2hlZCB0byBvdXRlciBlbGVtZW50IGR1cmluZyBwYXRjaCwgYW5kIHRyaWdnZXJlZCBhZ2Fpbi4gVGhpc1xyXG4gICAgICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcclxuICAgICAgICAvLyBhbmQgdGhlIGhhbmRsZXIgd291bGQgb25seSBmaXJlIGlmIHRoZSBldmVudCBwYXNzZWQgdG8gaXQgd2FzIGZpcmVkXHJcbiAgICAgICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcCA9IGUudGltZVN0YW1wIHx8IF9nZXROb3coKTtcclxuICAgICAgICBpZiAoc2tpcFRpbWVzdGFtcENoZWNrIHx8IHRpbWVTdGFtcCA+PSBpbnZva2VyLmF0dGFjaGVkIC0gMSkge1xyXG4gICAgICAgICAgICBjYWxsV2l0aEFzeW5jRXJyb3JIYW5kbGluZyhwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCBpbnZva2VyLnZhbHVlKSwgaW5zdGFuY2UsIDUgLyogTkFUSVZFX0VWRU5UX0hBTkRMRVIgKi8sIFtlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGludm9rZXIudmFsdWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICBpbnZva2VyLmF0dGFjaGVkID0gZ2V0Tm93KCk7XHJcbiAgICByZXR1cm4gaW52b2tlcjtcclxufVxyXG5mdW5jdGlvbiBwYXRjaFN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihlLCB2YWx1ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTdG9wID0gZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb247XHJcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsU3RvcC5jYWxsKGUpO1xyXG4gICAgICAgICAgICBlLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZm4gPT4gKGUpID0+ICFlLl9zdG9wcGVkICYmIGZuICYmIGZuKGUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5jb25zdCBuYXRpdmVPblJFID0gL15vblthLXpdLztcclxuY29uc3QgcGF0Y2hQcm9wID0gKGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBpc1NWRyA9IGZhbHNlLCBwcmV2Q2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgcGFyZW50U3VzcGVuc2UsIHVubW91bnRDaGlsZHJlbikgPT4ge1xyXG4gICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgIHBhdGNoQ2xhc3MoZWwsIG5leHRWYWx1ZSwgaXNTVkcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgcGF0Y2hTdHlsZShlbCwgcHJldlZhbHVlLCBuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPbihrZXkpKSB7XHJcbiAgICAgICAgLy8gaWdub3JlIHYtbW9kZWwgbGlzdGVuZXJzXHJcbiAgICAgICAgaWYgKCFpc01vZGVsTGlzdGVuZXIoa2V5KSkge1xyXG4gICAgICAgICAgICBwYXRjaEV2ZW50KGVsLCBrZXksIHByZXZWYWx1ZSwgbmV4dFZhbHVlLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGtleVswXSA9PT0gJy4nXHJcbiAgICAgICAgPyAoKGtleSA9IGtleS5zbGljZSgxKSksIHRydWUpXHJcbiAgICAgICAgOiBrZXlbMF0gPT09ICdeJ1xyXG4gICAgICAgICAgICA/ICgoa2V5ID0ga2V5LnNsaWNlKDEpKSwgZmFsc2UpXHJcbiAgICAgICAgICAgIDogc2hvdWxkU2V0QXNQcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgaXNTVkcpKSB7XHJcbiAgICAgICAgcGF0Y2hET01Qcm9wKGVsLCBrZXksIG5leHRWYWx1ZSwgcHJldkNoaWxkcmVuLCBwYXJlbnRDb21wb25lbnQsIHBhcmVudFN1c3BlbnNlLCB1bm1vdW50Q2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciA8aW5wdXQgdi1tb2RlbCB0eXBlPVwiY2hlY2tib3hcIj4gd2l0aFxyXG4gICAgICAgIC8vIDp0cnVlLXZhbHVlICYgOmZhbHNlLXZhbHVlXHJcbiAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgZG9tIHByb3BlcnRpZXMgc2luY2Ugbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZVxyXG4gICAgICAgIC8vIHN0cmluZ2lmaWVkLlxyXG4gICAgICAgIGlmIChrZXkgPT09ICd0cnVlLXZhbHVlJykge1xyXG4gICAgICAgICAgICBlbC5fdHJ1ZVZhbHVlID0gbmV4dFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdmYWxzZS12YWx1ZScpIHtcclxuICAgICAgICAgICAgZWwuX2ZhbHNlVmFsdWUgPSBuZXh0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGNoQXR0cihlbCwga2V5LCBuZXh0VmFsdWUsIGlzU1ZHLCBwYXJlbnRDb21wb25lbnQpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBzaG91bGRTZXRBc1Byb3AoZWwsIGtleSwgdmFsdWUsIGlzU1ZHKSB7XHJcbiAgICBpZiAoaXNTVkcpIHtcclxuICAgICAgICAvLyBtb3N0IGtleXMgbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlIG9uIHN2ZyBlbGVtZW50cyB0byB3b3JrXHJcbiAgICAgICAgLy8gLi4uZXhjZXB0IGlubmVySFRNTCAmIHRleHRDb250ZW50XHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ2lubmVySFRNTCcgfHwga2V5ID09PSAndGV4dENvbnRlbnQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvciBuYXRpdmUgb25jbGljayB3aXRoIGZ1bmN0aW9uIHZhbHVlc1xyXG4gICAgICAgIGlmIChrZXkgaW4gZWwgJiYgbmF0aXZlT25SRS50ZXN0KGtleSkgJiYgaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIHRoZXNlIGFyZSBlbnVtZXJhdGVkIGF0dHJzLCBob3dldmVyIHRoZWlyIGNvcnJlc3BvbmRpbmcgRE9NIHByb3BlcnRpZXNcclxuICAgIC8vIGFyZSBhY3R1YWxseSBib29sZWFucyAtIHRoaXMgbGVhZHMgdG8gc2V0dGluZyBpdCB3aXRoIGEgc3RyaW5nIFwiZmFsc2VcIlxyXG4gICAgLy8gdmFsdWUgbGVhZGluZyBpdCB0byBiZSBjb2VyY2VkIHRvIGB0cnVlYCwgc28gd2UgbmVlZCB0byBhbHdheXMgdHJlYXRcclxuICAgIC8vIHRoZW0gYXMgYXR0cmlidXRlcy5cclxuICAgIC8vIE5vdGUgdGhhdCBgY29udGVudEVkaXRhYmxlYCBkb2Vzbid0IGhhdmUgdGhpcyBwcm9ibGVtOiBpdHMgRE9NXHJcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIGVudW1lcmF0ZWQgc3RyaW5nIHZhbHVlcy5cclxuICAgIGlmIChrZXkgPT09ICdzcGVsbGNoZWNrJyB8fCBrZXkgPT09ICdkcmFnZ2FibGUnIHx8IGtleSA9PT0gJ3RyYW5zbGF0ZScpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMTc4NywgIzI4NDAgZm9ybSBwcm9wZXJ0eSBvbiBmb3JtIGVsZW1lbnRzIGlzIHJlYWRvbmx5IGFuZCBtdXN0IGJlIHNldCBhc1xyXG4gICAgLy8gYXR0cmlidXRlLlxyXG4gICAgaWYgKGtleSA9PT0gJ2Zvcm0nKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gIzE1MjYgPGlucHV0IGxpc3Q+IG11c3QgYmUgc2V0IGFzIGF0dHJpYnV0ZVxyXG4gICAgaWYgKGtleSA9PT0gJ2xpc3QnICYmIGVsLnRhZ05hbWUgPT09ICdJTlBVVCcpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjMjc2NiA8dGV4dGFyZWEgdHlwZT4gbXVzdCBiZSBzZXQgYXMgYXR0cmlidXRlXHJcbiAgICBpZiAoa2V5ID09PSAndHlwZScgJiYgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIG5hdGl2ZSBvbmNsaWNrIHdpdGggc3RyaW5nIHZhbHVlLCBtdXN0IGJlIHNldCBhcyBhdHRyaWJ1dGVcclxuICAgIGlmIChuYXRpdmVPblJFLnRlc3Qoa2V5KSAmJiBpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5IGluIGVsO1xyXG59XG5cbmZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQob3B0aW9ucywgaHlkcmF0ZSkge1xyXG4gICAgY29uc3QgQ29tcCA9IGRlZmluZUNvbXBvbmVudChvcHRpb25zKTtcclxuICAgIGNsYXNzIFZ1ZUN1c3RvbUVsZW1lbnQgZXh0ZW5kcyBWdWVFbGVtZW50IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihpbml0aWFsUHJvcHMpIHtcclxuICAgICAgICAgICAgc3VwZXIoQ29tcCwgaW5pdGlhbFByb3BzLCBoeWRyYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBWdWVDdXN0b21FbGVtZW50LmRlZiA9IENvbXA7XHJcbiAgICByZXR1cm4gVnVlQ3VzdG9tRWxlbWVudDtcclxufVxyXG5jb25zdCBkZWZpbmVTU1JDdXN0b21FbGVtZW50ID0gKChvcHRpb25zKSA9PiB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICByZXR1cm4gZGVmaW5lQ3VzdG9tRWxlbWVudChvcHRpb25zLCBoeWRyYXRlKTtcclxufSk7XHJcbmNvbnN0IEJhc2VDbGFzcyA9ICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnID8gSFRNTEVsZW1lbnQgOiBjbGFzcyB7XHJcbn0pO1xyXG5jbGFzcyBWdWVFbGVtZW50IGV4dGVuZHMgQmFzZUNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKF9kZWYsIF9wcm9wcyA9IHt9LCBoeWRyYXRlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kZWYgPSBfZGVmO1xyXG4gICAgICAgIHRoaXMuX3Byb3BzID0gX3Byb3BzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX251bWJlclByb3BzID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5zaGFkb3dSb290ICYmIGh5ZHJhdGUpIHtcclxuICAgICAgICAgICAgaHlkcmF0ZSh0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgQ3VzdG9tIGVsZW1lbnQgaGFzIHByZS1yZW5kZXJlZCBkZWNsYXJhdGl2ZSBzaGFkb3cgcm9vdCBidXQgaXMgbm90IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgIGBkZWZpbmVkIGFzIGh5ZHJhdGFibGUuIFVzZSBcXGBkZWZpbmVTU1JDdXN0b21FbGVtZW50XFxgLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlRGVmKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuc2hhZG93Um9vdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcclxuICAgICAqL1xyXG4gICAgX3Jlc29sdmVEZWYoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIHNldCBpbml0aWFsIGF0dHJzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QXR0cih0aGlzLmF0dHJpYnV0ZXNbaV0ubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdhdGNoIGZ1dHVyZSBhdHRyIGNoYW5nZXNcclxuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRBdHRyKG0uYXR0cmlidXRlTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KS5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zdCByZXNvbHZlID0gKGRlZikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBzdHlsZXMgfSA9IGRlZjtcclxuICAgICAgICAgICAgY29uc3QgaGFzT3B0aW9ucyA9ICFpc0FycmF5KHByb3BzKTtcclxuICAgICAgICAgICAgY29uc3QgcmF3S2V5cyA9IHByb3BzID8gKGhhc09wdGlvbnMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcykgOiBbXTtcclxuICAgICAgICAgICAgLy8gY2FzdCBOdW1iZXItdHlwZSBwcm9wcyBzZXQgYmVmb3JlIHJlc29sdmVcclxuICAgICAgICAgICAgbGV0IG51bWJlclByb3BzO1xyXG4gICAgICAgICAgICBpZiAoaGFzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5fcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHQgPT09IE51bWJlciB8fCAob3B0ICYmIG9wdC50eXBlID09PSBOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSB0b051bWJlcih0aGlzLl9wcm9wc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKG51bWJlclByb3BzIHx8IChudW1iZXJQcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCkpKVtrZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBudW1iZXJQcm9wcztcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHByb3BzIHNldCBwcmUtdXBncmFkZSBvciBjb25uZWN0XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5WzBdICE9PSAnXycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wKGtleSwgdGhpc1trZXldLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZGVmaW5pbmcgZ2V0dGVyL3NldHRlcnMgb24gcHJvdG90eXBlXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJhd0tleXMubWFwKGNhbWVsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb3Aoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldCh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcChrZXksIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXBwbHkgQ1NTXHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKHN0eWxlcyk7XHJcbiAgICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXN5bmNEZWYgPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcclxuICAgICAgICBpZiAoYXN5bmNEZWYpIHtcclxuICAgICAgICAgICAgYXN5bmNEZWYoKS50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9kZWYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXRBdHRyKGtleSkge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKGtleSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX251bWJlclByb3BzICYmIHRoaXMuX251bWJlclByb3BzW2tleV0pIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldFByb3AoY2FtZWxpemUoa2V5KSwgdmFsdWUsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9nZXRQcm9wKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wc1trZXldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3NldFByb3Aoa2V5LCB2YWwsIHNob3VsZFJlZmxlY3QgPSB0cnVlLCBzaG91bGRVcGRhdGUgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHZhbCAhPT0gdGhpcy5fcHJvcHNba2V5XSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gdmFsO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlICYmIHRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZWZsZWN0XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSZWZsZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaHlwaGVuYXRlKGtleSksIHZhbCArICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShoeXBoZW5hdGUoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlKCkge1xyXG4gICAgICAgIHJlbmRlcih0aGlzLl9jcmVhdGVWTm9kZSgpLCB0aGlzLnNoYWRvd1Jvb3QpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVZOb2RlKCkge1xyXG4gICAgICAgIGNvbnN0IHZub2RlID0gY3JlYXRlVk5vZGUodGhpcy5fZGVmLCBleHRlbmQoe30sIHRoaXMuX3Byb3BzKSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2bm9kZS5jZSA9IGluc3RhbmNlID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pc0NFID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIEhNUlxyXG4gICAgICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNlUmVsb2FkID0gbmV3U3R5bGVzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWx3YXlzIHJlc2V0IHN0eWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3R5bGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMuZm9yRWFjaChzID0+IHRoaXMuc2hhZG93Um9vdC5yZW1vdmVDaGlsZChzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhuZXdTdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGFzeW5jIGNvbXBvbmVudCwgY2VSZWxvYWQgaXMgY2FsbGVkIGZyb20gdGhlIGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBzbyBubyBuZWVkIHRvIHJlbG9hZCB0aGUgYXN5bmMgd3JhcHBlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RlZi5fX2FzeW5jTG9hZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWxvYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGludGVyY2VwdCBlbWl0XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5lbWl0ID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gbG9jYXRlIG5lYXJlc3QgVnVlIGN1c3RvbSBlbGVtZW50IHBhcmVudCBmb3IgcHJvdmlkZS9pbmplY3RcclxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChwYXJlbnQgPVxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJiAocGFyZW50LnBhcmVudE5vZGUgfHwgcGFyZW50Lmhvc3QpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBWdWVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLnBhcmVudCA9IHBhcmVudC5faW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5U3R5bGVzKHN0eWxlcykge1xyXG4gICAgICAgIGlmIChzdHlsZXMpIHtcclxuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goY3NzID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgICAgICAgICAgcy50ZXh0Q29udGVudCA9IGNzcztcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzKTtcclxuICAgICAgICAgICAgICAgIC8vIHJlY29yZCBmb3IgSE1SXHJcbiAgICAgICAgICAgICAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3N0eWxlcyB8fCAodGhpcy5fc3R5bGVzID0gW10pKS5wdXNoKHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4kMShgdXNlQ3NzTW9kdWxlIG11c3QgYmUgY2FsbGVkIGluc2lkZSBzZXR1cCgpYCk7XHJcbiAgICAgICAgICAgIHJldHVybiBFTVBUWV9PQko7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1vZHVsZXMgPSBpbnN0YW5jZS50eXBlLl9fY3NzTW9kdWxlcztcclxuICAgICAgICBpZiAoIW1vZHVsZXMpIHtcclxuICAgICAgICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpICYmIHdhcm4kMShgQ3VycmVudCBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIENTUyBtb2R1bGVzIGluamVjdGVkLmApO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2QgPSBtb2R1bGVzW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQxKGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7bmFtZX1cIi5gKTtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX09CSjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XHJcbiAgICBjb25zdCBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghaW5zdGFuY2UpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybiQxKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXRWYXJzID0gKCkgPT4gc2V0VmFyc09uVk5vZGUoaW5zdGFuY2Uuc3ViVHJlZSwgZ2V0dGVyKGluc3RhbmNlLnByb3h5KSk7XHJcbiAgICB3YXRjaFBvc3RFZmZlY3Qoc2V0VmFycyk7XHJcbiAgICBvbk1vdW50ZWQoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9iID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoc2V0VmFycyk7XHJcbiAgICAgICAgb2Iub2JzZXJ2ZShpbnN0YW5jZS5zdWJUcmVlLmVsLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xyXG4gICAgICAgIG9uVW5tb3VudGVkKCgpID0+IG9iLmRpc2Nvbm5lY3QoKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRWYXJzT25WTm9kZSh2bm9kZSwgdmFycykge1xyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEyOCAvKiBTVVNQRU5TRSAqLykge1xyXG4gICAgICAgIGNvbnN0IHN1c3BlbnNlID0gdm5vZGUuc3VzcGVuc2U7XHJcbiAgICAgICAgdm5vZGUgPSBzdXNwZW5zZS5hY3RpdmVCcmFuY2g7XHJcbiAgICAgICAgaWYgKHN1c3BlbnNlLnBlbmRpbmdCcmFuY2ggJiYgIXN1c3BlbnNlLmlzSHlkcmF0aW5nKSB7XHJcbiAgICAgICAgICAgIHN1c3BlbnNlLmVmZmVjdHMucHVzaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRWYXJzT25WTm9kZShzdXNwZW5zZS5hY3RpdmVCcmFuY2gsIHZhcnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBkcmlsbCBkb3duIEhPQ3MgdW50aWwgaXQncyBhIG5vbi1jb21wb25lbnQgdm5vZGVcclxuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnQpIHtcclxuICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudC5zdWJUcmVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLnNoYXBlRmxhZyAmIDEgLyogRUxFTUVOVCAqLyAmJiB2bm9kZS5lbCkge1xyXG4gICAgICAgIHNldFZhcnNPbk5vZGUodm5vZGUuZWwsIHZhcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gRnJhZ21lbnQpIHtcclxuICAgICAgICB2bm9kZS5jaGlsZHJlbi5mb3JFYWNoKGMgPT4gc2V0VmFyc09uVk5vZGUoYywgdmFycykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodm5vZGUudHlwZSA9PT0gU3RhdGljKSB7XHJcbiAgICAgICAgbGV0IHsgZWwsIGFuY2hvciB9ID0gdm5vZGU7XHJcbiAgICAgICAgd2hpbGUgKGVsKSB7XHJcbiAgICAgICAgICAgIHNldFZhcnNPbk5vZGUoZWwsIHZhcnMpO1xyXG4gICAgICAgICAgICBpZiAoZWwgPT09IGFuY2hvcilcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBlbCA9IGVsLm5leHRTaWJsaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRWYXJzT25Ob2RlKGVsLCB2YXJzKSB7XHJcbiAgICBpZiAoZWwubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICBjb25zdCBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhcnMpIHtcclxuICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcclxuY29uc3QgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XHJcbi8vIERPTSBUcmFuc2l0aW9uIGlzIGEgaGlnaGVyLW9yZGVyLWNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcGxhdGZvcm0tYWdub3N0aWNcclxuLy8gYmFzZSBUcmFuc2l0aW9uIGNvbXBvbmVudCwgd2l0aCBET00tc3BlY2lmaWMgbG9naWMuXHJcbmNvbnN0IFRyYW5zaXRpb24gPSAocHJvcHMsIHsgc2xvdHMgfSkgPT4gaChCYXNlVHJhbnNpdGlvbiwgcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhwcm9wcyksIHNsb3RzKTtcclxuVHJhbnNpdGlvbi5kaXNwbGF5TmFtZSA9ICdUcmFuc2l0aW9uJztcclxue1xyXG4gICAgVHJhbnNpdGlvbi5fX2lzQnVpbHRJbiA9IHRydWU7XHJcbn1cclxuY29uc3QgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IHtcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIGNzczoge1xyXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIGR1cmF0aW9uOiBbU3RyaW5nLCBOdW1iZXIsIE9iamVjdF0sXHJcbiAgICBlbnRlckZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJGcm9tQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUZyb21DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmdcclxufTtcclxuY29uc3QgVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycyA9IChUcmFuc2l0aW9uLnByb3BzID1cclxuICAgIC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBCYXNlVHJhbnNpdGlvbi5wcm9wcywgRE9NVHJhbnNpdGlvblByb3BzVmFsaWRhdG9ycykpO1xyXG4vKipcclxuICogIzMyMjcgSW5jb21pbmcgaG9va3MgbWF5IGJlIG1lcmdlZCBpbnRvIGFycmF5cyB3aGVuIHdyYXBwaW5nIFRyYW5zaXRpb25cclxuICogd2l0aCBjdXN0b20gSE9Dcy5cclxuICovXHJcbmNvbnN0IGNhbGxIb29rJDEgPSAoaG9vaywgYXJncyA9IFtdKSA9PiB7XHJcbiAgICBpZiAoaXNBcnJheShob29rKSkge1xyXG4gICAgICAgIGhvb2suZm9yRWFjaChoID0+IGgoLi4uYXJncykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaG9vaykge1xyXG4gICAgICAgIGhvb2soLi4uYXJncyk7XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGhvb2sgZXhwZWN0cyBhIGNhbGxiYWNrICgybmQgYXJnKSwgd2hpY2ggbWVhbnMgdGhlIHVzZXJcclxuICogaW50ZW5kcyB0byBleHBsaWNpdGx5IGNvbnRyb2wgdGhlIGVuZCBvZiB0aGUgdHJhbnNpdGlvbi5cclxuICovXHJcbmNvbnN0IGhhc0V4cGxpY2l0Q2FsbGJhY2sgPSAoaG9vaykgPT4ge1xyXG4gICAgcmV0dXJuIGhvb2tcclxuICAgICAgICA/IGlzQXJyYXkoaG9vaylcclxuICAgICAgICAgICAgPyBob29rLnNvbWUoaCA9PiBoLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgIDogaG9vay5sZW5ndGggPiAxXHJcbiAgICAgICAgOiBmYWxzZTtcclxufTtcclxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb25Qcm9wcyhyYXdQcm9wcykge1xyXG4gICAgY29uc3QgYmFzZVByb3BzID0ge307XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgIGlmICghKGtleSBpbiBET01UcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzKSkge1xyXG4gICAgICAgICAgICBiYXNlUHJvcHNba2V5XSA9IHJhd1Byb3BzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJhd1Byb3BzLmNzcyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gYmFzZVByb3BzO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBuYW1lID0gJ3YnLCB0eXBlLCBkdXJhdGlvbiwgZW50ZXJGcm9tQ2xhc3MgPSBgJHtuYW1lfS1lbnRlci1mcm9tYCwgZW50ZXJBY3RpdmVDbGFzcyA9IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsIGVudGVyVG9DbGFzcyA9IGAke25hbWV9LWVudGVyLXRvYCwgYXBwZWFyRnJvbUNsYXNzID0gZW50ZXJGcm9tQ2xhc3MsIGFwcGVhckFjdGl2ZUNsYXNzID0gZW50ZXJBY3RpdmVDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGVudGVyVG9DbGFzcywgbGVhdmVGcm9tQ2xhc3MgPSBgJHtuYW1lfS1sZWF2ZS1mcm9tYCwgbGVhdmVBY3RpdmVDbGFzcyA9IGAke25hbWV9LWxlYXZlLWFjdGl2ZWAsIGxlYXZlVG9DbGFzcyA9IGAke25hbWV9LWxlYXZlLXRvYCB9ID0gcmF3UHJvcHM7XHJcbiAgICAvLyBsZWdhY3kgdHJhbnNpdGlvbiBjbGFzcyBjb21wYXRcclxuICAgIGNvbnN0IGxlZ2FjeUNsYXNzRW5hYmxlZCA9IGNvbXBhdFV0aWxzLmlzQ29tcGF0RW5hYmxlZChcIlRSQU5TSVRJT05fQ0xBU1NFU1wiIC8qIFRSQU5TSVRJT05fQ0xBU1NFUyAqLywgbnVsbCk7XHJcbiAgICBsZXQgbGVnYWN5RW50ZXJGcm9tQ2xhc3M7XHJcbiAgICBsZXQgbGVnYWN5QXBwZWFyRnJvbUNsYXNzO1xyXG4gICAgbGV0IGxlZ2FjeUxlYXZlRnJvbUNsYXNzO1xyXG4gICAgaWYgKGxlZ2FjeUNsYXNzRW5hYmxlZCkge1xyXG4gICAgICAgIGNvbnN0IHRvTGVnYWN5Q2xhc3MgPSAoY2xzKSA9PiBjbHMucmVwbGFjZSgvLWZyb20kLywgJycpO1xyXG4gICAgICAgIGlmICghcmF3UHJvcHMuZW50ZXJGcm9tQ2xhc3MpIHtcclxuICAgICAgICAgICAgbGVnYWN5RW50ZXJGcm9tQ2xhc3MgPSB0b0xlZ2FjeUNsYXNzKGVudGVyRnJvbUNsYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyYXdQcm9wcy5hcHBlYXJGcm9tQ2xhc3MpIHtcclxuICAgICAgICAgICAgbGVnYWN5QXBwZWFyRnJvbUNsYXNzID0gdG9MZWdhY3lDbGFzcyhhcHBlYXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJhd1Byb3BzLmxlYXZlRnJvbUNsYXNzKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeUxlYXZlRnJvbUNsYXNzID0gdG9MZWdhY3lDbGFzcyhsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZHVyYXRpb25zID0gbm9ybWFsaXplRHVyYXRpb24oZHVyYXRpb24pO1xyXG4gICAgY29uc3QgZW50ZXJEdXJhdGlvbiA9IGR1cmF0aW9ucyAmJiBkdXJhdGlvbnNbMF07XHJcbiAgICBjb25zdCBsZWF2ZUR1cmF0aW9uID0gZHVyYXRpb25zICYmIGR1cmF0aW9uc1sxXTtcclxuICAgIGNvbnN0IHsgb25CZWZvcmVFbnRlciwgb25FbnRlciwgb25FbnRlckNhbmNlbGxlZCwgb25MZWF2ZSwgb25MZWF2ZUNhbmNlbGxlZCwgb25CZWZvcmVBcHBlYXIgPSBvbkJlZm9yZUVudGVyLCBvbkFwcGVhciA9IG9uRW50ZXIsIG9uQXBwZWFyQ2FuY2VsbGVkID0gb25FbnRlckNhbmNlbGxlZCB9ID0gYmFzZVByb3BzO1xyXG4gICAgY29uc3QgZmluaXNoRW50ZXIgPSAoZWwsIGlzQXBwZWFyLCBkb25lKSA9PiB7XHJcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBpc0FwcGVhciA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZpbmlzaExlYXZlID0gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgZWwuX2lzTGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcclxuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIGRvbmUgJiYgZG9uZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG1ha2VFbnRlckhvb2sgPSAoaXNBcHBlYXIpID0+IHtcclxuICAgICAgICByZXR1cm4gKGVsLCBkb25lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvb2sgPSBpc0FwcGVhciA/IG9uQXBwZWFyIDogb25FbnRlcjtcclxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZSA9ICgpID0+IGZpbmlzaEVudGVyKGVsLCBpc0FwcGVhciwgZG9uZSk7XHJcbiAgICAgICAgICAgIGNhbGxIb29rJDEoaG9vaywgW2VsLCByZXNvbHZlXSk7XHJcbiAgICAgICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyRnJvbUNsYXNzIDogZW50ZXJGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZ2FjeUNsYXNzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgaXNBcHBlYXIgPyBsZWdhY3lBcHBlYXJGcm9tQ2xhc3MgOiBsZWdhY3lFbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2soaG9vaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGVudGVyRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBleHRlbmQoYmFzZVByb3BzLCB7XHJcbiAgICAgICAgb25CZWZvcmVFbnRlcihlbCkge1xyXG4gICAgICAgICAgICBjYWxsSG9vayQxKG9uQmVmb3JlRW50ZXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGVudGVyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgaWYgKGxlZ2FjeUNsYXNzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWdhY3lFbnRlckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBlbnRlckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQmVmb3JlQXBwZWFyKGVsKSB7XHJcbiAgICAgICAgICAgIGNhbGxIb29rJDEob25CZWZvcmVBcHBlYXIsIFtlbF0pO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgIGlmIChsZWdhY3lDbGFzc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVnYWN5QXBwZWFyRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFwcGVhckFjdGl2ZUNsYXNzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRW50ZXI6IG1ha2VFbnRlckhvb2soZmFsc2UpLFxyXG4gICAgICAgIG9uQXBwZWFyOiBtYWtlRW50ZXJIb29rKHRydWUpLFxyXG4gICAgICAgIG9uTGVhdmUoZWwsIGRvbmUpIHtcclxuICAgICAgICAgICAgZWwuX2lzTGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmUgPSAoKSA9PiBmaW5pc2hMZWF2ZShlbCwgZG9uZSk7XHJcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVGcm9tQ2xhc3MpO1xyXG4gICAgICAgICAgICBpZiAobGVnYWN5Q2xhc3NFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlZ2FjeUxlYXZlRnJvbUNsYXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmb3JjZSByZWZsb3cgc28gKi1sZWF2ZS1mcm9tIGNsYXNzZXMgaW1tZWRpYXRlbHkgdGFrZSBlZmZlY3QgKCMyNTkzKVxyXG4gICAgICAgICAgICBmb3JjZVJlZmxvdygpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbC5faXNMZWF2aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVnYWN5Q2xhc3NFbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWdhY3lMZWF2ZUZyb21DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0Q2FsbGJhY2sob25MZWF2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGxlYXZlRHVyYXRpb24sIHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY2FsbEhvb2skMShvbkxlYXZlLCBbZWwsIHJlc29sdmVdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRW50ZXJDYW5jZWxsZWQoZWwpIHtcclxuICAgICAgICAgICAgZmluaXNoRW50ZXIoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2skMShvbkVudGVyQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uQXBwZWFyQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaEVudGVyKGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgY2FsbEhvb2skMShvbkFwcGVhckNhbmNlbGxlZCwgW2VsXSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkxlYXZlQ2FuY2VsbGVkKGVsKSB7XHJcbiAgICAgICAgICAgIGZpbmlzaExlYXZlKGVsKTtcclxuICAgICAgICAgICAgY2FsbEhvb2skMShvbkxlYXZlQ2FuY2VsbGVkLCBbZWxdKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXJhdGlvbikge1xyXG4gICAgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KGR1cmF0aW9uKSkge1xyXG4gICAgICAgIHJldHVybiBbTnVtYmVyT2YoZHVyYXRpb24uZW50ZXIpLCBOdW1iZXJPZihkdXJhdGlvbi5sZWF2ZSldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgbiA9IE51bWJlck9mKGR1cmF0aW9uKTtcclxuICAgICAgICByZXR1cm4gW24sIG5dO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIE51bWJlck9mKHZhbCkge1xyXG4gICAgY29uc3QgcmVzID0gdG9OdW1iZXIodmFsKTtcclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykpXHJcbiAgICAgICAgdmFsaWRhdGVEdXJhdGlvbihyZXMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0ZUR1cmF0aW9uKHZhbCkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgd2FybiQxKGA8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gYCArXHJcbiAgICAgICAgICAgIGBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICB3YXJuJDEoYDx0cmFuc2l0aW9uPiBleHBsaWNpdCBkdXJhdGlvbiBpcyBOYU4gLSBgICtcclxuICAgICAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xyXG4gICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChjID0+IGMgJiYgZWwuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICAoZWwuX3Z0YyB8fFxyXG4gICAgICAgIChlbC5fdnRjID0gbmV3IFNldCgpKSkuYWRkKGNscyk7XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgY29uc3QgeyBfdnRjIH0gPSBlbDtcclxuICAgIGlmIChfdnRjKSB7XHJcbiAgICAgICAgX3Z0Yy5kZWxldGUoY2xzKTtcclxuICAgICAgICBpZiAoIV92dGMuc2l6ZSkge1xyXG4gICAgICAgICAgICBlbC5fdnRjID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBuZXh0RnJhbWUoY2IpIHtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcclxuICAgIH0pO1xyXG59XHJcbmxldCBlbmRJZCA9IDA7XHJcbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBleHBsaWNpdFRpbWVvdXQsIHJlc29sdmUpIHtcclxuICAgIGNvbnN0IGlkID0gKGVsLl9lbmRJZCA9ICsrZW5kSWQpO1xyXG4gICAgY29uc3QgcmVzb2x2ZUlmTm90U3RhbGUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGlkID09PSBlbC5fZW5kSWQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoZXhwbGljaXRUaW1lb3V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZUlmTm90U3RhbGUsIGV4cGxpY2l0VGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHR5cGUsIHRpbWVvdXQsIHByb3BDb3VudCB9ID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5kRXZlbnQgPSB0eXBlICsgJ2VuZCc7XHJcbiAgICBsZXQgZW5kZWQgPSAwO1xyXG4gICAgY29uc3QgZW5kID0gKCkgPT4ge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIG9uRW5kKTtcclxuICAgICAgICByZXNvbHZlSWZOb3RTdGFsZSgpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG9uRW5kID0gKGUpID0+IHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsICYmICsrZW5kZWQgPj0gcHJvcENvdW50KSB7XHJcbiAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGltZW91dCArIDEpO1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgb25FbmQpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpIHtcclxuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcclxuICAgIGNvbnN0IGdldFN0eWxlUHJvcGVydGllcyA9IChrZXkpID0+IChzdHlsZXNba2V5XSB8fCAnJykuc3BsaXQoJywgJyk7XHJcbiAgICBjb25zdCB0cmFuc2l0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKFRSQU5TSVRJT04gKyAnRGVsYXknKTtcclxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbnMgPSBnZXRTdHlsZVByb3BlcnRpZXMoVFJBTlNJVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRGVsYXlzID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEZWxheScpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uRHVyYXRpb25zID0gZ2V0U3R5bGVQcm9wZXJ0aWVzKEFOSU1BVElPTiArICdEdXJhdGlvbicpO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xyXG4gICAgbGV0IHR5cGUgPSBudWxsO1xyXG4gICAgbGV0IHRpbWVvdXQgPSAwO1xyXG4gICAgbGV0IHByb3BDb3VudCA9IDA7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcclxuICAgICAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XHJcbiAgICAgICAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XHJcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBBTklNQVRJT047XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XHJcbiAgICAgICAgdHlwZSA9XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxyXG4gICAgICAgICAgICAgICAgICAgID8gVFJBTlNJVElPTlxyXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXHJcbiAgICAgICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgcHJvcENvdW50ID0gdHlwZVxyXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYXNUcmFuc2Zvcm0gPSB0eXBlID09PSBUUkFOU0lUSU9OICYmXHJcbiAgICAgICAgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KHN0eWxlc1tUUkFOU0lUSU9OICsgJ1Byb3BlcnR5J10pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHRpbWVvdXQsXHJcbiAgICAgICAgcHJvcENvdW50LFxyXG4gICAgICAgIGhhc1RyYW5zZm9ybVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uZHVyYXRpb25zLm1hcCgoZCwgaSkgPT4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKSkpO1xyXG59XHJcbi8vIE9sZCB2ZXJzaW9ucyBvZiBDaHJvbWl1bSAoYmVsb3cgNjEuMC4zMTYzLjEwMCkgZm9ybWF0cyBmbG9hdGluZyBwb2ludGVyXHJcbi8vIG51bWJlcnMgaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxyXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duXHJcbi8vIChpLmUuIGFjdGluZyBhcyBhIGZsb29yIGZ1bmN0aW9uKSBjYXVzaW5nIHVuZXhwZWN0ZWQgYmVoYXZpb3JzXHJcbmZ1bmN0aW9uIHRvTXMocykge1xyXG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwO1xyXG59XHJcbi8vIHN5bmNocm9ub3VzbHkgZm9yY2UgbGF5b3V0IHRvIHB1dCBlbGVtZW50cyBpbnRvIGEgY2VydGFpbiBzdGF0ZVxyXG5mdW5jdGlvbiBmb3JjZVJlZmxvdygpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcclxufVxuXG5jb25zdCBwb3NpdGlvbk1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IG5ld1Bvc2l0aW9uTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3QgVHJhbnNpdGlvbkdyb3VwSW1wbCA9IHtcclxuICAgIG5hbWU6ICdUcmFuc2l0aW9uR3JvdXAnLFxyXG4gICAgcHJvcHM6IC8qI19fUFVSRV9fKi8gZXh0ZW5kKHt9LCBUcmFuc2l0aW9uUHJvcHNWYWxpZGF0b3JzLCB7XHJcbiAgICAgICAgdGFnOiBTdHJpbmcsXHJcbiAgICAgICAgbW92ZUNsYXNzOiBTdHJpbmdcclxuICAgIH0pLFxyXG4gICAgc2V0dXAocHJvcHMsIHsgc2xvdHMgfSkge1xyXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB1c2VUcmFuc2l0aW9uU3RhdGUoKTtcclxuICAgICAgICBsZXQgcHJldkNoaWxkcmVuO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbjtcclxuICAgICAgICBvblVwZGF0ZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjaGlsZHJlbiBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IGFmdGVyIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgIGlmICghcHJldkNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG1vdmVDbGFzcyA9IHByb3BzLm1vdmVDbGFzcyB8fCBgJHtwcm9wcy5uYW1lIHx8ICd2J30tbW92ZWA7XHJcbiAgICAgICAgICAgIGlmICghaGFzQ1NTVHJhbnNmb3JtKHByZXZDaGlsZHJlblswXS5lbCwgaW5zdGFuY2Uudm5vZGUuZWwsIG1vdmVDbGFzcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcclxuICAgICAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcclxuICAgICAgICAgICAgcHJldkNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBtb3ZlZENoaWxkcmVuID0gcHJldkNoaWxkcmVuLmZpbHRlcihhcHBseVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGZvcmNlUmVmbG93KCk7XHJcbiAgICAgICAgICAgIG1vdmVkQ2hpbGRyZW4uZm9yRWFjaChjID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gYy5lbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBzdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gKGVsLl9tb3ZlQ2IgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBjYik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhd1Byb3BzID0gdG9SYXcocHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBjc3NUcmFuc2l0aW9uUHJvcHMgPSByZXNvbHZlVHJhbnNpdGlvblByb3BzKHJhd1Byb3BzKTtcclxuICAgICAgICAgICAgbGV0IHRhZyA9IHJhd1Byb3BzLnRhZyB8fCBGcmFnbWVudDtcclxuICAgICAgICAgICAgaWYgKCFyYXdQcm9wcy50YWcgJiZcclxuICAgICAgICAgICAgICAgIGNvbXBhdFV0aWxzLmNoZWNrQ29tcGF0RW5hYmxlZChcIlRSQU5TSVRJT05fR1JPVVBfUk9PVFwiIC8qIFRSQU5TSVRJT05fR1JPVVBfUk9PVCAqLywgaW5zdGFuY2UucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGFnID0gJ3NwYW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZDaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgICAgICBjaGlsZHJlbiA9IHNsb3RzLmRlZmF1bHQgPyBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4oc2xvdHMuZGVmYXVsdCgpKSA6IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQxKGA8VHJhbnNpdGlvbkdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBwcmV2Q2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkhvb2tzKGNoaWxkLCByZXNvbHZlVHJhbnNpdGlvbkhvb2tzKGNoaWxkLCBjc3NUcmFuc2l0aW9uUHJvcHMsIHN0YXRlLCBpbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChjaGlsZCwgY2hpbGQuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVWTm9kZSh0YWcsIG51bGwsIGNoaWxkcmVuKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG57XHJcbiAgICBUcmFuc2l0aW9uR3JvdXBJbXBsLl9faXNCdWlsdEluID0gdHJ1ZTtcclxufVxyXG5jb25zdCBUcmFuc2l0aW9uR3JvdXAgPSBUcmFuc2l0aW9uR3JvdXBJbXBsO1xyXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XHJcbiAgICBjb25zdCBlbCA9IGMuZWw7XHJcbiAgICBpZiAoZWwuX21vdmVDYikge1xyXG4gICAgICAgIGVsLl9tb3ZlQ2IoKTtcclxuICAgIH1cclxuICAgIGlmIChlbC5fZW50ZXJDYikge1xyXG4gICAgICAgIGVsLl9lbnRlckNiKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24oYykge1xyXG4gICAgbmV3UG9zaXRpb25NYXAuc2V0KGMsIGMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xyXG59XHJcbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24oYykge1xyXG4gICAgY29uc3Qgb2xkUG9zID0gcG9zaXRpb25NYXAuZ2V0KGMpO1xyXG4gICAgY29uc3QgbmV3UG9zID0gbmV3UG9zaXRpb25NYXAuZ2V0KGMpO1xyXG4gICAgY29uc3QgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xyXG4gICAgY29uc3QgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcclxuICAgIGlmIChkeCB8fCBkeSkge1xyXG4gICAgICAgIGNvbnN0IHMgPSBjLmVsLnN0eWxlO1xyXG4gICAgICAgIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xyXG4gICAgICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcclxuICAgICAgICByZXR1cm4gYztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXNDU1NUcmFuc2Zvcm0oZWwsIHJvb3QsIG1vdmVDbGFzcykge1xyXG4gICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXHJcbiAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcclxuICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcclxuICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xyXG4gICAgLy8gaXMgYXBwbGllZC5cclxuICAgIGNvbnN0IGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XHJcbiAgICBpZiAoZWwuX3Z0Yykge1xyXG4gICAgICAgIGVsLl92dGMuZm9yRWFjaChjbHMgPT4ge1xyXG4gICAgICAgICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAmJiBjbG9uZS5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1vdmVDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICYmIGNsb25lLmNsYXNzTGlzdC5hZGQoYykpO1xyXG4gICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IChyb290Lm5vZGVUeXBlID09PSAxID8gcm9vdCA6IHJvb3QucGFyZW50Tm9kZSk7XHJcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgY29uc3QgeyBoYXNUcmFuc2Zvcm0gfSA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcclxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjbG9uZSk7XHJcbiAgICByZXR1cm4gaGFzVHJhbnNmb3JtO1xyXG59XG5cbmNvbnN0IGdldE1vZGVsQXNzaWduZXIgPSAodm5vZGUpID0+IHtcclxuICAgIGNvbnN0IGZuID0gdm5vZGUucHJvcHNbJ29uVXBkYXRlOm1vZGVsVmFsdWUnXSB8fFxyXG4gICAgICAgICh2bm9kZS5wcm9wc1snb25Nb2RlbENvbXBhdDppbnB1dCddKTtcclxuICAgIHJldHVybiBpc0FycmF5KGZuKSA/IHZhbHVlID0+IGludm9rZUFycmF5Rm5zKGZuLCB2YWx1ZSkgOiBmbjtcclxufTtcclxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGUpIHtcclxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XHJcbn1cclxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChlKSB7XHJcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgIGlmICh0YXJnZXQuY29tcG9zaW5nKSB7XHJcbiAgICAgICAgdGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XHJcbiAgICB9XHJcbn1cclxuLy8gV2UgYXJlIGV4cG9ydGluZyB0aGUgdi1tb2RlbCBydW50aW1lIGRpcmVjdGx5IGFzIHZub2RlIGhvb2tzIHNvIHRoYXQgaXQgY2FuXHJcbi8vIGJlIHRyZWUtc2hha2VuIGluIGNhc2Ugdi1tb2RlbCBpcyBuZXZlciB1c2VkLlxyXG5jb25zdCB2TW9kZWxUZXh0ID0ge1xyXG4gICAgY3JlYXRlZChlbCwgeyBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgY29uc3QgY2FzdFRvTnVtYmVyID0gbnVtYmVyIHx8ICh2bm9kZS5wcm9wcyAmJiB2bm9kZS5wcm9wcy50eXBlID09PSAnbnVtYmVyJyk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgbGF6eSA/ICdjaGFuZ2UnIDogJ2lucHV0JywgZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBkb21WYWx1ZSA9IGVsLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSBkb21WYWx1ZS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhc3RUb051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgZG9tVmFsdWUgPSB0b051bWJlcihkb21WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihkb21WYWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gZWwudmFsdWUudHJpbSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFsYXp5KSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZWwsICdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cclxuICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxyXG4gICAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXHJcbiAgICAgICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcclxuICAgIG1vdW50ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIGVsLnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCB7IHZhbHVlLCBtb2RpZmllcnM6IHsgbGF6eSwgdHJpbSwgbnVtYmVyIH0gfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgLy8gYXZvaWQgY2xlYXJpbmcgdW5yZXNvbHZlZCB0ZXh0LiAjMjMwMlxyXG4gICAgICAgIGlmIChlbC5jb21wb3NpbmcpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWwgJiYgZWwudHlwZSAhPT0gJ3JhbmdlJykge1xyXG4gICAgICAgICAgICBpZiAobGF6eSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmltICYmIGVsLnZhbHVlLnRyaW0oKSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG51bWJlciB8fCBlbC50eXBlID09PSAnbnVtYmVyJykgJiYgdG9OdW1iZXIoZWwudmFsdWUpID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XHJcbiAgICAgICAgaWYgKGVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsQ2hlY2tib3ggPSB7XHJcbiAgICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcclxuICAgIGRlZXA6IHRydWUsXHJcbiAgICBjcmVhdGVkKGVsLCBfLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBhZGRFdmVudExpc3RlbmVyKGVsLCAnY2hhbmdlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtb2RlbFZhbHVlID0gZWwuX21vZGVsVmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRWYWx1ZSA9IGdldFZhbHVlKGVsKTtcclxuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVsLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbiA9IGVsLl9hc3NpZ247XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG1vZGVsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxvb3NlSW5kZXhPZihtb2RlbFZhbHVlLCBlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBpbmRleCAhPT0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAmJiAhZm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NpZ24obW9kZWxWYWx1ZS5jb25jYXQoZWxlbWVudFZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hlY2tlZCAmJiBmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkID0gWy4uLm1vZGVsVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduKGZpbHRlcmVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NldChtb2RlbFZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3IFNldChtb2RlbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmFkZChlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVkLmRlbGV0ZShlbGVtZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXNzaWduKGNsb25lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NpZ24oZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXHJcbiAgICBtb3VudGVkOiBzZXRDaGVja2VkLFxyXG4gICAgYmVmb3JlVXBkYXRlKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgICAgICBzZXRDaGVja2VkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldENoZWNrZWQoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICBlbC5fbW9kZWxWYWx1ZSA9IHZhbHVlO1xyXG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpID4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICBlbC5jaGVja2VkID0gdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgIGVsLmNoZWNrZWQgPSBsb29zZUVxdWFsKHZhbHVlLCBnZXRDaGVja2JveFZhbHVlKGVsLCB0cnVlKSk7XHJcbiAgICB9XHJcbn1cclxuY29uc3Qgdk1vZGVsUmFkaW8gPSB7XHJcbiAgICBjcmVhdGVkKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XHJcbiAgICAgICAgZWwuY2hlY2tlZCA9IGxvb3NlRXF1YWwodmFsdWUsIHZub2RlLnByb3BzLnZhbHVlKTtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihnZXRWYWx1ZShlbCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgeyB2YWx1ZSwgb2xkVmFsdWUgfSwgdm5vZGUpIHtcclxuICAgICAgICBlbC5fYXNzaWduID0gZ2V0TW9kZWxBc3NpZ25lcih2bm9kZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbC5jaGVja2VkID0gbG9vc2VFcXVhbCh2YWx1ZSwgdm5vZGUucHJvcHMudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuY29uc3Qgdk1vZGVsU2VsZWN0ID0ge1xyXG4gICAgLy8gPHNlbGVjdCBtdWx0aXBsZT4gdmFsdWUgbmVlZCB0byBiZSBkZWVwIHRyYXZlcnNlZFxyXG4gICAgZGVlcDogdHJ1ZSxcclxuICAgIGNyZWF0ZWQoZWwsIHsgdmFsdWUsIG1vZGlmaWVyczogeyBudW1iZXIgfSB9LCB2bm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGlzU2V0TW9kZWwgPSBpc1NldCh2YWx1ZSk7XHJcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihlbCwgJ2NoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAuY2FsbChlbC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZClcclxuICAgICAgICAgICAgICAgIC5tYXAoKG8pID0+IG51bWJlciA/IHRvTnVtYmVyKGdldFZhbHVlKG8pKSA6IGdldFZhbHVlKG8pKTtcclxuICAgICAgICAgICAgZWwuX2Fzc2lnbihlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgPyBpc1NldE1vZGVsXHJcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgU2V0KHNlbGVjdGVkVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxcclxuICAgICAgICAgICAgICAgIDogc2VsZWN0ZWRWYWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGVsLl9hc3NpZ24gPSBnZXRNb2RlbEFzc2lnbmVyKHZub2RlKTtcclxuICAgIH0sXHJcbiAgICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXHJcbiAgICAvLyA8b3B0aW9uPnMuXHJcbiAgICBtb3VudGVkKGVsLCB7IHZhbHVlIH0pIHtcclxuICAgICAgICBzZXRTZWxlY3RlZChlbCwgdmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGJlZm9yZVVwZGF0ZShlbCwgX2JpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgZWwuX2Fzc2lnbiA9IGdldE1vZGVsQXNzaWduZXIodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZWQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCB2YWx1ZSkge1xyXG4gICAgY29uc3QgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xyXG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIWlzQXJyYXkodmFsdWUpICYmICFpc1NldCh2YWx1ZSkpIHtcclxuICAgICAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICAgICAgd2FybiQxKGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYCArXHJcbiAgICAgICAgICAgICAgICBgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpfS5gKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcclxuICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGdldFZhbHVlKG9wdGlvbik7XHJcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIG9wdGlvblZhbHVlKSA+IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaGFzKG9wdGlvblZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSlcclxuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNNdWx0aXBsZSAmJiBlbC5zZWxlY3RlZEluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgIH1cclxufVxyXG4vLyByZXRyaWV2ZSByYXcgdmFsdWUgc2V0IHZpYSA6dmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0VmFsdWUoZWwpIHtcclxuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBlbCA/IGVsLl92YWx1ZSA6IGVsLnZhbHVlO1xyXG59XHJcbi8vIHJldHJpZXZlIHJhdyB2YWx1ZSBmb3IgdHJ1ZS12YWx1ZSBhbmQgZmFsc2UtdmFsdWUgc2V0IHZpYSA6dHJ1ZS12YWx1ZSBvciA6ZmFsc2UtdmFsdWUgYmluZGluZ3NcclxuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShlbCwgY2hlY2tlZCkge1xyXG4gICAgY29uc3Qga2V5ID0gY2hlY2tlZCA/ICdfdHJ1ZVZhbHVlJyA6ICdfZmFsc2VWYWx1ZSc7XHJcbiAgICByZXR1cm4ga2V5IGluIGVsID8gZWxba2V5XSA6IGNoZWNrZWQ7XHJcbn1cclxuY29uc3Qgdk1vZGVsRHluYW1pYyA9IHtcclxuICAgIGNyZWF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIG51bGwsICdjcmVhdGVkJyk7XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgYmluZGluZywgdm5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgbnVsbCwgJ21vdW50ZWQnKTtcclxuICAgIH0sXHJcbiAgICBiZWZvcmVVcGRhdGUoZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUpIHtcclxuICAgICAgICBjYWxsTW9kZWxIb29rKGVsLCBiaW5kaW5nLCB2bm9kZSwgcHJldlZOb2RlLCAnYmVmb3JlVXBkYXRlJyk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSkge1xyXG4gICAgICAgIGNhbGxNb2RlbEhvb2soZWwsIGJpbmRpbmcsIHZub2RlLCBwcmV2Vk5vZGUsICd1cGRhdGVkJyk7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljTW9kZWwodGFnTmFtZSwgdHlwZSkge1xyXG4gICAgc3dpdGNoICh0YWdOYW1lKSB7XHJcbiAgICAgICAgY2FzZSAnU0VMRUNUJzpcclxuICAgICAgICAgICAgcmV0dXJuIHZNb2RlbFNlbGVjdDtcclxuICAgICAgICBjYXNlICdURVhUQVJFQSc6XHJcbiAgICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxDaGVja2JveDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdk1vZGVsUmFkaW87XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2TW9kZWxUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2FsbE1vZGVsSG9vayhlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSwgaG9vaykge1xyXG4gICAgY29uc3QgbW9kZWxUb1VzZSA9IHJlc29sdmVEeW5hbWljTW9kZWwoZWwudGFnTmFtZSwgdm5vZGUucHJvcHMgJiYgdm5vZGUucHJvcHMudHlwZSk7XHJcbiAgICBjb25zdCBmbiA9IG1vZGVsVG9Vc2VbaG9va107XHJcbiAgICBmbiAmJiBmbihlbCwgYmluZGluZywgdm5vZGUsIHByZXZWTm9kZSk7XHJcbn1cclxuLy8gU1NSIHZub2RlIHRyYW5zZm9ybXMsIG9ubHkgdXNlZCB3aGVuIHVzZXIgaW5jbHVkZXMgY2xpZW50LW9yaWVudGVkIHJlbmRlclxyXG4vLyBmdW5jdGlvbiBpbiBTU1JcclxuZnVuY3Rpb24gaW5pdFZNb2RlbEZvclNTUigpIHtcclxuICAgIHZNb2RlbFRleHQuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiAoeyB2YWx1ZSB9KTtcclxuICAgIHZNb2RlbFJhZGlvLmdldFNTUlByb3BzID0gKHsgdmFsdWUgfSwgdm5vZGUpID0+IHtcclxuICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VFcXVhbCh2bm9kZS5wcm9wcy52YWx1ZSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdk1vZGVsQ2hlY2tib3guZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9LCB2bm9kZSkgPT4ge1xyXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgbG9vc2VJbmRleE9mKHZhbHVlLCB2bm9kZS5wcm9wcy52YWx1ZSkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzU2V0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAodm5vZGUucHJvcHMgJiYgdmFsdWUuaGFzKHZub2RlLnByb3BzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGNoZWNrZWQ6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdk1vZGVsRHluYW1pYy5nZXRTU1JQcm9wcyA9IChiaW5kaW5nLCB2bm9kZSkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygdm5vZGUudHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtb2RlbFRvVXNlID0gcmVzb2x2ZUR5bmFtaWNNb2RlbChcclxuICAgICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcclxuICAgICAgICB2bm9kZS50eXBlLnRvVXBwZXJDYXNlKCksIHZub2RlLnByb3BzICYmIHZub2RlLnByb3BzLnR5cGUpO1xyXG4gICAgICAgIGlmIChtb2RlbFRvVXNlLmdldFNTUlByb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2RlbFRvVXNlLmdldFNTUlByb3BzKGJpbmRpbmcsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmNvbnN0IHN5c3RlbU1vZGlmaWVycyA9IFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddO1xyXG5jb25zdCBtb2RpZmllckd1YXJkcyA9IHtcclxuICAgIHN0b3A6IGUgPT4gZS5zdG9wUHJvcGFnYXRpb24oKSxcclxuICAgIHByZXZlbnQ6IGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpLFxyXG4gICAgc2VsZjogZSA9PiBlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LFxyXG4gICAgY3RybDogZSA9PiAhZS5jdHJsS2V5LFxyXG4gICAgc2hpZnQ6IGUgPT4gIWUuc2hpZnRLZXksXHJcbiAgICBhbHQ6IGUgPT4gIWUuYWx0S2V5LFxyXG4gICAgbWV0YTogZSA9PiAhZS5tZXRhS2V5LFxyXG4gICAgbGVmdDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAwLFxyXG4gICAgbWlkZGxlOiBlID0+ICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gIT09IDEsXHJcbiAgICByaWdodDogZSA9PiAnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAyLFxyXG4gICAgZXhhY3Q6IChlLCBtb2RpZmllcnMpID0+IHN5c3RlbU1vZGlmaWVycy5zb21lKG0gPT4gZVtgJHttfUtleWBdICYmICFtb2RpZmllcnMuaW5jbHVkZXMobSkpXHJcbn07XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3Qgd2l0aE1vZGlmaWVycyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XHJcbiAgICByZXR1cm4gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBtb2RpZmllckd1YXJkc1ttb2RpZmllcnNbaV1dO1xyXG4gICAgICAgICAgICBpZiAoZ3VhcmQgJiYgZ3VhcmQoZXZlbnQsIG1vZGlmaWVycykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmbihldmVudCwgLi4uYXJncyk7XHJcbiAgICB9O1xyXG59O1xyXG4vLyBLZXB0IGZvciAyLnggY29tcGF0LlxyXG4vLyBOb3RlOiBJRTExIGNvbXBhdCBmb3IgYHNwYWNlYmFyYCBhbmQgYGRlbGAgaXMgcmVtb3ZlZCBmb3Igbm93LlxyXG5jb25zdCBrZXlOYW1lcyA9IHtcclxuICAgIGVzYzogJ2VzY2FwZScsXHJcbiAgICBzcGFjZTogJyAnLFxyXG4gICAgdXA6ICdhcnJvdy11cCcsXHJcbiAgICBsZWZ0OiAnYXJyb3ctbGVmdCcsXHJcbiAgICByaWdodDogJ2Fycm93LXJpZ2h0JyxcclxuICAgIGRvd246ICdhcnJvdy1kb3duJyxcclxuICAgIGRlbGV0ZTogJ2JhY2tzcGFjZSdcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB3aXRoS2V5cyA9IChmbiwgbW9kaWZpZXJzKSA9PiB7XHJcbiAgICBsZXQgZ2xvYmFsS2V5Q29kZXM7XHJcbiAgICBsZXQgaW5zdGFuY2UgPSBudWxsO1xyXG4gICAge1xyXG4gICAgICAgIGluc3RhbmNlID0gZ2V0Q3VycmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGNvbXBhdFV0aWxzLmlzQ29tcGF0RW5hYmxlZChcIkNPTkZJR19LRVlfQ09ERVNcIiAvKiBDT05GSUdfS0VZX0NPREVTICovLCBpbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBnbG9iYWxLZXlDb2RlcyA9IGluc3RhbmNlLmFwcENvbnRleHQuY29uZmlnLmtleUNvZGVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiYgbW9kaWZpZXJzLnNvbWUobSA9PiAvXlxcZCskLy50ZXN0KG0pKSkge1xyXG4gICAgICAgICAgICBjb21wYXRVdGlscy53YXJuRGVwcmVjYXRpb24oXCJWX09OX0tFWUNPREVfTU9ESUZJRVJcIiAvKiBWX09OX0tFWUNPREVfTU9ESUZJRVIgKi8sIGluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCEoJ2tleScgaW4gZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRLZXkgPSBoeXBoZW5hdGUoZXZlbnQua2V5KTtcclxuICAgICAgICBpZiAobW9kaWZpZXJzLnNvbWUoayA9PiBrID09PSBldmVudEtleSB8fCBrZXlOYW1lc1trXSA9PT0gZXZlbnRLZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmbihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5Q29kZSA9IFN0cmluZyhldmVudC5rZXlDb2RlKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBhdFV0aWxzLmlzQ29tcGF0RW5hYmxlZChcIlZfT05fS0VZQ09ERV9NT0RJRklFUlwiIC8qIFZfT05fS0VZQ09ERV9NT0RJRklFUiAqLywgaW5zdGFuY2UpICYmXHJcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMuc29tZShtb2QgPT4gbW9kID09IGtleUNvZGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChnbG9iYWxLZXlDb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtb2Qgb2YgbW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZXMgPSBnbG9iYWxLZXlDb2Rlc1ttb2RdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2Rlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gaXNBcnJheShjb2RlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29kZXMuc29tZShjb2RlID0+IFN0cmluZyhjb2RlKSA9PT0ga2V5Q29kZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGNvZGVzKSA9PT0ga2V5Q29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xuXG5jb25zdCB2U2hvdyA9IHtcclxuICAgIGJlZm9yZU1vdW50KGVsLCB7IHZhbHVlIH0sIHsgdHJhbnNpdGlvbiB9KSB7XHJcbiAgICAgICAgZWwuX3ZvZCA9IGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcclxuICAgICAgICBpZiAodHJhbnNpdGlvbiAmJiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0cmFuc2l0aW9uLmJlZm9yZUVudGVyKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZChlbCwgeyB2YWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uICYmIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1cGRhdGVkKGVsLCB7IHZhbHVlLCBvbGRWYWx1ZSB9LCB7IHRyYW5zaXRpb24gfSkge1xyXG4gICAgICAgIGlmICghdmFsdWUgPT09ICFvbGRWYWx1ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5iZWZvcmVFbnRlcihlbCk7XHJcbiAgICAgICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZW50ZXIoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi5sZWF2ZShlbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERpc3BsYXkoZWwsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXREaXNwbGF5KGVsLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGJlZm9yZVVubW91bnQoZWwsIHsgdmFsdWUgfSkge1xyXG4gICAgICAgIHNldERpc3BsYXkoZWwsIHZhbHVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gc2V0RGlzcGxheShlbCwgdmFsdWUpIHtcclxuICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl92b2QgOiAnbm9uZSc7XHJcbn1cclxuLy8gU1NSIHZub2RlIHRyYW5zZm9ybXMsIG9ubHkgdXNlZCB3aGVuIHVzZXIgaW5jbHVkZXMgY2xpZW50LW9yaWVudGVkIHJlbmRlclxyXG4vLyBmdW5jdGlvbiBpbiBTU1JcclxuZnVuY3Rpb24gaW5pdFZTaG93Rm9yU1NSKCkge1xyXG4gICAgdlNob3cuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZSB9KSA9PiB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuY29uc3QgcmVuZGVyZXJPcHRpb25zID0gLyojX19QVVJFX18qLyBleHRlbmQoeyBwYXRjaFByb3AgfSwgbm9kZU9wcyk7XHJcbi8vIGxhenkgY3JlYXRlIHRoZSByZW5kZXJlciAtIHRoaXMgbWFrZXMgY29yZSByZW5kZXJlciBsb2dpYyB0cmVlLXNoYWthYmxlXHJcbi8vIGluIGNhc2UgdGhlIHVzZXIgb25seSBpbXBvcnRzIHJlYWN0aXZpdHkgdXRpbGl0aWVzIGZyb20gVnVlLlxyXG5sZXQgcmVuZGVyZXI7XHJcbmxldCBlbmFibGVkSHlkcmF0aW9uID0gZmFsc2U7XHJcbmZ1bmN0aW9uIGVuc3VyZVJlbmRlcmVyKCkge1xyXG4gICAgcmV0dXJuIChyZW5kZXJlciB8fFxyXG4gICAgICAgIChyZW5kZXJlciA9IGNyZWF0ZVJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucykpKTtcclxufVxyXG5mdW5jdGlvbiBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpIHtcclxuICAgIHJlbmRlcmVyID0gZW5hYmxlZEh5ZHJhdGlvblxyXG4gICAgICAgID8gcmVuZGVyZXJcclxuICAgICAgICA6IGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XHJcbiAgICBlbmFibGVkSHlkcmF0aW9uID0gdHJ1ZTtcclxuICAgIHJldHVybiByZW5kZXJlcjtcclxufVxyXG4vLyB1c2UgZXhwbGljaXQgdHlwZSBjYXN0cyBoZXJlIHRvIGF2b2lkIGltcG9ydCgpIGNhbGxzIGluIHJvbGxlZC11cCBkLnRzXHJcbmNvbnN0IHJlbmRlciA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgZW5zdXJlUmVuZGVyZXIoKS5yZW5kZXIoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBoeWRyYXRlID0gKCguLi5hcmdzKSA9PiB7XHJcbiAgICBlbnN1cmVIeWRyYXRpb25SZW5kZXJlcigpLmh5ZHJhdGUoLi4uYXJncyk7XHJcbn0pO1xyXG5jb25zdCBjcmVhdGVBcHAgPSAoKC4uLmFyZ3MpID0+IHtcclxuICAgIGNvbnN0IGFwcCA9IGVuc3VyZVJlbmRlcmVyKCkuY3JlYXRlQXBwKC4uLmFyZ3MpO1xyXG4gICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCk7XHJcbiAgICAgICAgaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHsgbW91bnQgfSA9IGFwcDtcclxuICAgIGFwcC5tb3VudCA9IChjb250YWluZXJPclNlbGVjdG9yKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lck9yU2VsZWN0b3IpO1xyXG4gICAgICAgIGlmICghY29udGFpbmVyKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gYXBwLl9jb21wb25lbnQ7XHJcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGNvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5yZW5kZXIgJiYgIWNvbXBvbmVudC50ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAvLyBfX1VOU0FGRV9fXHJcbiAgICAgICAgICAgIC8vIFJlYXNvbjogcG90ZW50aWFsIGV4ZWN1dGlvbiBvZiBKUyBleHByZXNzaW9ucyBpbiBpbi1ET00gdGVtcGxhdGUuXHJcbiAgICAgICAgICAgIC8vIFRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoZSBpbi1ET00gdGVtcGxhdGUgaXMgdHJ1c3RlZC4gSWYgaXQnc1xyXG4gICAgICAgICAgICAvLyByZW5kZXJlZCBieSB0aGUgc2VydmVyLCB0aGUgdGVtcGxhdGUgc2hvdWxkIG5vdCBjb250YWluIGFueSB1c2VyIGRhdGEuXHJcbiAgICAgICAgICAgIGNvbXBvbmVudC50ZW1wbGF0ZSA9IGNvbnRhaW5lci5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgIC8vIDIueCBjb21wYXQgY2hlY2tcclxuICAgICAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXIuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBjb250YWluZXIuYXR0cmlidXRlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lICE9PSAndi1jbG9haycgJiYgL14odi18OnxAKS8udGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhdFV0aWxzLndhcm5EZXByZWNhdGlvbihcIkdMT0JBTF9NT1VOVF9DT05UQUlORVJcIiAvKiBHTE9CQUxfTU9VTlRfQ09OVEFJTkVSICovLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNsZWFyIGNvbnRlbnQgYmVmb3JlIG1vdW50aW5nXHJcbiAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIGNvbnN0IHByb3h5ID0gbW91bnQoY29udGFpbmVyLCBmYWxzZSwgY29udGFpbmVyIGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndi1jbG9haycpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdkYXRhLXYtYXBwJywgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmNvbnN0IGNyZWF0ZVNTUkFwcCA9ICgoLi4uYXJncykgPT4ge1xyXG4gICAgY29uc3QgYXBwID0gZW5zdXJlSHlkcmF0aW9uUmVuZGVyZXIoKS5jcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgaW5qZWN0TmF0aXZlVGFnQ2hlY2soYXBwKTtcclxuICAgICAgICBpbmplY3RDb21waWxlck9wdGlvbnNDaGVjayhhcHApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBtb3VudCB9ID0gYXBwO1xyXG4gICAgYXBwLm1vdW50ID0gKGNvbnRhaW5lck9yU2VsZWN0b3IpID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub3JtYWxpemVDb250YWluZXIoY29udGFpbmVyT3JTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbW91bnQoY29udGFpbmVyLCB0cnVlLCBjb250YWluZXIgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGFwcDtcclxufSk7XHJcbmZ1bmN0aW9uIGluamVjdE5hdGl2ZVRhZ0NoZWNrKGFwcCkge1xyXG4gICAgLy8gSW5qZWN0IGBpc05hdGl2ZVRhZ2BcclxuICAgIC8vIHRoaXMgaXMgdXNlZCBmb3IgY29tcG9uZW50IG5hbWUgdmFsaWRhdGlvbiAoZGV2IG9ubHkpXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBwLmNvbmZpZywgJ2lzTmF0aXZlVGFnJywge1xyXG4gICAgICAgIHZhbHVlOiAodGFnKSA9PiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWR1RhZyh0YWcpLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgfSk7XHJcbn1cclxuLy8gZGV2IG9ubHlcclxuZnVuY3Rpb24gaW5qZWN0Q29tcGlsZXJPcHRpb25zQ2hlY2soYXBwKSB7XHJcbiAgICBpZiAoaXNSdW50aW1lT25seSgpKSB7XHJcbiAgICAgICAgY29uc3QgaXNDdXN0b21FbGVtZW50ID0gYXBwLmNvbmZpZy5pc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcC5jb25maWcsICdpc0N1c3RvbUVsZW1lbnQnLCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShgVGhlIFxcYGlzQ3VzdG9tRWxlbWVudFxcYCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBgICtcclxuICAgICAgICAgICAgICAgICAgICBgXFxgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudFxcYCBpbnN0ZWFkLmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgY29tcGlsZXJPcHRpb25zID0gYXBwLmNvbmZpZy5jb21waWxlck9wdGlvbnM7XHJcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZSBcXGBjb21waWxlck9wdGlvbnNcXGAgY29uZmlnIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIGAgK1xyXG4gICAgICAgICAgICBgYSBidWlsZCBvZiBWdWUuanMgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlciAoYWthIFwiZnVsbCBidWlsZFwiKS4gYCArXHJcbiAgICAgICAgICAgIGBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBgICtcclxuICAgICAgICAgICAgYG11c3QgYmUgcGFzc2VkIHRvIFxcYEB2dWUvY29tcGlsZXItZG9tXFxgIGluIHRoZSBidWlsZCBzZXR1cCBpbnN0ZWFkLlxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlcidzIFxcYGNvbXBpbGVyT3B0aW9uc1xcYCBsb2FkZXIgb3B0aW9uLlxcbmAgK1xyXG4gICAgICAgICAgICBgLSBGb3IgdnVlLWNsaTogc2VlIGh0dHBzOi8vY2xpLnZ1ZWpzLm9yZy9ndWlkZS93ZWJwYWNrLmh0bWwjbW9kaWZ5aW5nLW9wdGlvbnMtb2YtYS1sb2FkZXJcXG5gICtcclxuICAgICAgICAgICAgYC0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlL3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tdnVlI2V4YW1wbGUtZm9yLXBhc3Npbmctb3B0aW9ucy10by12dWVjb21waWxlci1kb21gO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcHAuY29uZmlnLCAnY29tcGlsZXJPcHRpb25zJywge1xyXG4gICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDEobXNnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlck9wdGlvbnM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldCgpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMShtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGFpbmVyKGNvbnRhaW5lcikge1xyXG4gICAgaWYgKGlzU3RyaW5nKGNvbnRhaW5lcikpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSAmJiAhcmVzKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMShgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHtjb250YWluZXJ9XCIgcmV0dXJuZWQgbnVsbC5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGlmICgocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykgJiZcclxuICAgICAgICB3aW5kb3cuU2hhZG93Um9vdCAmJlxyXG4gICAgICAgIGNvbnRhaW5lciBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290ICYmXHJcbiAgICAgICAgY29udGFpbmVyLm1vZGUgPT09ICdjbG9zZWQnKSB7XHJcbiAgICAgICAgd2FybiQxKGBtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBcXGB7bW9kZTogXCJjbG9zZWRcIn1cXGAgbWF5IGxlYWQgdG8gdW5wcmVkaWN0YWJsZSBidWdzYCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG59XHJcbmxldCBzc3JEaXJlY3RpdmVJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBpbml0RGlyZWN0aXZlc0ZvclNTUiA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIXNzckRpcmVjdGl2ZUluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHNzckRpcmVjdGl2ZUluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaW5pdFZNb2RlbEZvclNTUigpO1xyXG4gICAgICAgICAgICBpbml0VlNob3dGb3JTU1IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XG5cbnZhciBydW50aW1lRG9tID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHJlbmRlcjogcmVuZGVyLFxuICBoeWRyYXRlOiBoeWRyYXRlLFxuICBjcmVhdGVBcHA6IGNyZWF0ZUFwcCxcbiAgY3JlYXRlU1NSQXBwOiBjcmVhdGVTU1JBcHAsXG4gIGluaXREaXJlY3RpdmVzRm9yU1NSOiBpbml0RGlyZWN0aXZlc0ZvclNTUixcbiAgZGVmaW5lQ3VzdG9tRWxlbWVudDogZGVmaW5lQ3VzdG9tRWxlbWVudCxcbiAgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudDogZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCxcbiAgVnVlRWxlbWVudDogVnVlRWxlbWVudCxcbiAgdXNlQ3NzTW9kdWxlOiB1c2VDc3NNb2R1bGUsXG4gIHVzZUNzc1ZhcnM6IHVzZUNzc1ZhcnMsXG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwLFxuICB2TW9kZWxUZXh0OiB2TW9kZWxUZXh0LFxuICB2TW9kZWxDaGVja2JveDogdk1vZGVsQ2hlY2tib3gsXG4gIHZNb2RlbFJhZGlvOiB2TW9kZWxSYWRpbyxcbiAgdk1vZGVsU2VsZWN0OiB2TW9kZWxTZWxlY3QsXG4gIHZNb2RlbER5bmFtaWM6IHZNb2RlbER5bmFtaWMsXG4gIHdpdGhNb2RpZmllcnM6IHdpdGhNb2RpZmllcnMsXG4gIHdpdGhLZXlzOiB3aXRoS2V5cyxcbiAgdlNob3c6IHZTaG93LFxuICByZWFjdGl2ZTogcmVhY3RpdmUsXG4gIHJlZjogcmVmLFxuICByZWFkb25seTogcmVhZG9ubHksXG4gIHVucmVmOiB1bnJlZixcbiAgcHJveHlSZWZzOiBwcm94eVJlZnMsXG4gIGlzUmVmOiBpc1JlZixcbiAgdG9SZWY6IHRvUmVmLFxuICB0b1JlZnM6IHRvUmVmcyxcbiAgaXNQcm94eTogaXNQcm94eSxcbiAgaXNSZWFjdGl2ZTogaXNSZWFjdGl2ZSxcbiAgaXNSZWFkb25seTogaXNSZWFkb25seSxcbiAgaXNTaGFsbG93OiBpc1NoYWxsb3csXG4gIGN1c3RvbVJlZjogY3VzdG9tUmVmLFxuICB0cmlnZ2VyUmVmOiB0cmlnZ2VyUmVmLFxuICBzaGFsbG93UmVmOiBzaGFsbG93UmVmLFxuICBzaGFsbG93UmVhY3RpdmU6IHNoYWxsb3dSZWFjdGl2ZSxcbiAgc2hhbGxvd1JlYWRvbmx5OiBzaGFsbG93UmVhZG9ubHksXG4gIG1hcmtSYXc6IG1hcmtSYXcsXG4gIHRvUmF3OiB0b1JhdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHN0b3A6IHN0b3AsXG4gIFJlYWN0aXZlRWZmZWN0OiBSZWFjdGl2ZUVmZmVjdCxcbiAgZWZmZWN0U2NvcGU6IGVmZmVjdFNjb3BlLFxuICBFZmZlY3RTY29wZTogRWZmZWN0U2NvcGUsXG4gIGdldEN1cnJlbnRTY29wZTogZ2V0Q3VycmVudFNjb3BlLFxuICBvblNjb3BlRGlzcG9zZTogb25TY29wZURpc3Bvc2UsXG4gIGNvbXB1dGVkOiBjb21wdXRlZCQxLFxuICB3YXRjaDogd2F0Y2gsXG4gIHdhdGNoRWZmZWN0OiB3YXRjaEVmZmVjdCxcbiAgd2F0Y2hQb3N0RWZmZWN0OiB3YXRjaFBvc3RFZmZlY3QsXG4gIHdhdGNoU3luY0VmZmVjdDogd2F0Y2hTeW5jRWZmZWN0LFxuICBvbkJlZm9yZU1vdW50OiBvbkJlZm9yZU1vdW50LFxuICBvbk1vdW50ZWQ6IG9uTW91bnRlZCxcbiAgb25CZWZvcmVVcGRhdGU6IG9uQmVmb3JlVXBkYXRlLFxuICBvblVwZGF0ZWQ6IG9uVXBkYXRlZCxcbiAgb25CZWZvcmVVbm1vdW50OiBvbkJlZm9yZVVubW91bnQsXG4gIG9uVW5tb3VudGVkOiBvblVubW91bnRlZCxcbiAgb25BY3RpdmF0ZWQ6IG9uQWN0aXZhdGVkLFxuICBvbkRlYWN0aXZhdGVkOiBvbkRlYWN0aXZhdGVkLFxuICBvblJlbmRlclRyYWNrZWQ6IG9uUmVuZGVyVHJhY2tlZCxcbiAgb25SZW5kZXJUcmlnZ2VyZWQ6IG9uUmVuZGVyVHJpZ2dlcmVkLFxuICBvbkVycm9yQ2FwdHVyZWQ6IG9uRXJyb3JDYXB0dXJlZCxcbiAgb25TZXJ2ZXJQcmVmZXRjaDogb25TZXJ2ZXJQcmVmZXRjaCxcbiAgcHJvdmlkZTogcHJvdmlkZSxcbiAgaW5qZWN0OiBpbmplY3QsXG4gIG5leHRUaWNrOiBuZXh0VGljayxcbiAgZGVmaW5lQ29tcG9uZW50OiBkZWZpbmVDb21wb25lbnQsXG4gIGRlZmluZUFzeW5jQ29tcG9uZW50OiBkZWZpbmVBc3luY0NvbXBvbmVudCxcbiAgdXNlQXR0cnM6IHVzZUF0dHJzLFxuICB1c2VTbG90czogdXNlU2xvdHMsXG4gIGRlZmluZVByb3BzOiBkZWZpbmVQcm9wcyxcbiAgZGVmaW5lRW1pdHM6IGRlZmluZUVtaXRzLFxuICBkZWZpbmVFeHBvc2U6IGRlZmluZUV4cG9zZSxcbiAgd2l0aERlZmF1bHRzOiB3aXRoRGVmYXVsdHMsXG4gIG1lcmdlRGVmYXVsdHM6IG1lcmdlRGVmYXVsdHMsXG4gIGNyZWF0ZVByb3BzUmVzdFByb3h5OiBjcmVhdGVQcm9wc1Jlc3RQcm94eSxcbiAgd2l0aEFzeW5jQ29udGV4dDogd2l0aEFzeW5jQ29udGV4dCxcbiAgZ2V0Q3VycmVudEluc3RhbmNlOiBnZXRDdXJyZW50SW5zdGFuY2UsXG4gIGg6IGgsXG4gIGNyZWF0ZVZOb2RlOiBjcmVhdGVWTm9kZSxcbiAgY2xvbmVWTm9kZTogY2xvbmVWTm9kZSxcbiAgbWVyZ2VQcm9wczogbWVyZ2VQcm9wcyxcbiAgaXNWTm9kZTogaXNWTm9kZSxcbiAgRnJhZ21lbnQ6IEZyYWdtZW50LFxuICBUZXh0OiBUZXh0LFxuICBDb21tZW50OiBDb21tZW50LFxuICBTdGF0aWM6IFN0YXRpYyxcbiAgVGVsZXBvcnQ6IFRlbGVwb3J0LFxuICBTdXNwZW5zZTogU3VzcGVuc2UsXG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlLFxuICBCYXNlVHJhbnNpdGlvbjogQmFzZVRyYW5zaXRpb24sXG4gIHdpdGhEaXJlY3RpdmVzOiB3aXRoRGlyZWN0aXZlcyxcbiAgdXNlU1NSQ29udGV4dDogdXNlU1NSQ29udGV4dCxcbiAgc3NyQ29udGV4dEtleTogc3NyQ29udGV4dEtleSxcbiAgY3JlYXRlUmVuZGVyZXI6IGNyZWF0ZVJlbmRlcmVyLFxuICBjcmVhdGVIeWRyYXRpb25SZW5kZXJlcjogY3JlYXRlSHlkcmF0aW9uUmVuZGVyZXIsXG4gIHF1ZXVlUG9zdEZsdXNoQ2I6IHF1ZXVlUG9zdEZsdXNoQ2IsXG4gIHdhcm46IHdhcm4kMSxcbiAgaGFuZGxlRXJyb3I6IGhhbmRsZUVycm9yLFxuICBjYWxsV2l0aEVycm9ySGFuZGxpbmc6IGNhbGxXaXRoRXJyb3JIYW5kbGluZyxcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmc6IGNhbGxXaXRoQXN5bmNFcnJvckhhbmRsaW5nLFxuICByZXNvbHZlQ29tcG9uZW50OiByZXNvbHZlQ29tcG9uZW50LFxuICByZXNvbHZlRGlyZWN0aXZlOiByZXNvbHZlRGlyZWN0aXZlLFxuICByZXNvbHZlRHluYW1pY0NvbXBvbmVudDogcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsXG4gIHJlZ2lzdGVyUnVudGltZUNvbXBpbGVyOiByZWdpc3RlclJ1bnRpbWVDb21waWxlcixcbiAgaXNSdW50aW1lT25seTogaXNSdW50aW1lT25seSxcbiAgdXNlVHJhbnNpdGlvblN0YXRlOiB1c2VUcmFuc2l0aW9uU3RhdGUsXG4gIHJlc29sdmVUcmFuc2l0aW9uSG9va3M6IHJlc29sdmVUcmFuc2l0aW9uSG9va3MsXG4gIHNldFRyYW5zaXRpb25Ib29rczogc2V0VHJhbnNpdGlvbkhvb2tzLFxuICBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW46IGdldFRyYW5zaXRpb25SYXdDaGlsZHJlbixcbiAgaW5pdEN1c3RvbUZvcm1hdHRlcjogaW5pdEN1c3RvbUZvcm1hdHRlcixcbiAgZ2V0IGRldnRvb2xzICgpIHsgcmV0dXJuIGRldnRvb2xzOyB9LFxuICBzZXREZXZ0b29sc0hvb2s6IHNldERldnRvb2xzSG9vayxcbiAgd2l0aEN0eDogd2l0aEN0eCxcbiAgcHVzaFNjb3BlSWQ6IHB1c2hTY29wZUlkLFxuICBwb3BTY29wZUlkOiBwb3BTY29wZUlkLFxuICB3aXRoU2NvcGVJZDogd2l0aFNjb3BlSWQsXG4gIHJlbmRlckxpc3Q6IHJlbmRlckxpc3QsXG4gIHRvSGFuZGxlcnM6IHRvSGFuZGxlcnMsXG4gIHJlbmRlclNsb3Q6IHJlbmRlclNsb3QsXG4gIGNyZWF0ZVNsb3RzOiBjcmVhdGVTbG90cyxcbiAgd2l0aE1lbW86IHdpdGhNZW1vLFxuICBpc01lbW9TYW1lOiBpc01lbW9TYW1lLFxuICBvcGVuQmxvY2s6IG9wZW5CbG9jayxcbiAgY3JlYXRlQmxvY2s6IGNyZWF0ZUJsb2NrLFxuICBzZXRCbG9ja1RyYWNraW5nOiBzZXRCbG9ja1RyYWNraW5nLFxuICBjcmVhdGVUZXh0Vk5vZGU6IGNyZWF0ZVRleHRWTm9kZSxcbiAgY3JlYXRlQ29tbWVudFZOb2RlOiBjcmVhdGVDb21tZW50Vk5vZGUsXG4gIGNyZWF0ZVN0YXRpY1ZOb2RlOiBjcmVhdGVTdGF0aWNWTm9kZSxcbiAgY3JlYXRlRWxlbWVudFZOb2RlOiBjcmVhdGVCYXNlVk5vZGUsXG4gIGNyZWF0ZUVsZW1lbnRCbG9jazogY3JlYXRlRWxlbWVudEJsb2NrLFxuICBndWFyZFJlYWN0aXZlUHJvcHM6IGd1YXJkUmVhY3RpdmVQcm9wcyxcbiAgdG9EaXNwbGF5U3RyaW5nOiB0b0Rpc3BsYXlTdHJpbmcsXG4gIGNhbWVsaXplOiBjYW1lbGl6ZSxcbiAgY2FwaXRhbGl6ZTogY2FwaXRhbGl6ZSxcbiAgdG9IYW5kbGVyS2V5OiB0b0hhbmRsZXJLZXksXG4gIG5vcm1hbGl6ZVByb3BzOiBub3JtYWxpemVQcm9wcyxcbiAgbm9ybWFsaXplQ2xhc3M6IG5vcm1hbGl6ZUNsYXNzLFxuICBub3JtYWxpemVTdHlsZTogbm9ybWFsaXplU3R5bGUsXG4gIHRyYW5zZm9ybVZOb2RlQXJnczogdHJhbnNmb3JtVk5vZGVBcmdzLFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICBzc3JVdGlsczogc3NyVXRpbHMsXG4gIHJlc29sdmVGaWx0ZXI6IHJlc29sdmVGaWx0ZXIkMSxcbiAgY29tcGF0VXRpbHM6IGNvbXBhdFV0aWxzXG59KTtcblxuZnVuY3Rpb24gaW5pdERldigpIHtcclxuICAgIHtcclxuICAgICAgICBpbml0Q3VzdG9tRm9ybWF0dGVyKCk7XHJcbiAgICB9XHJcbn1cblxuLy8gVGhpcyBlbnRyeSBleHBvcnRzIHRoZSBydW50aW1lIG9ubHksIGFuZCBpcyBidWlsdCBhc1xyXG5pZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICBpbml0RGV2KCk7XHJcbn1cclxuZnVuY3Rpb24gd3JhcHBlZENyZWF0ZUFwcCguLi5hcmdzKSB7XHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBjb25zdCBhcHAgPSBjcmVhdGVBcHAoLi4uYXJncyk7XHJcbiAgICBpZiAoY29tcGF0VXRpbHMuaXNDb21wYXRFbmFibGVkKFwiUkVOREVSX0ZVTkNUSU9OXCIgLyogUkVOREVSX0ZVTkNUSU9OICovLCBudWxsKSkge1xyXG4gICAgICAgIC8vIHJlZ2lzdGVyIGJ1aWx0LWluIGNvbXBvbmVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXNvbHZlZCB2aWEgc3RyaW5nc1xyXG4gICAgICAgIC8vIGluIHRoZSBsZWdhY3kgaCgpIGNhbGwuIFRoZSBfX2NvbXBhdF9fIHByZWZpeCBpcyB0byBlbnN1cmUgdGhhdCB2MyBoKClcclxuICAgICAgICAvLyBkb2Vzbid0IGdldCBhZmZlY3RlZC5cclxuICAgICAgICBhcHAuY29tcG9uZW50KCdfX2NvbXBhdF9fdHJhbnNpdGlvbicsIFRyYW5zaXRpb24pO1xyXG4gICAgICAgIGFwcC5jb21wb25lbnQoJ19fY29tcGF0X190cmFuc2l0aW9uLWdyb3VwJywgVHJhbnNpdGlvbkdyb3VwKTtcclxuICAgICAgICBhcHAuY29tcG9uZW50KCdfX2NvbXBhdF9fa2VlcC1hbGl2ZScsIEtlZXBBbGl2ZSk7XHJcbiAgICAgICAgLy8gYnVpbHQtaW4gZGlyZWN0aXZlcy4gTm8gbmVlZCBmb3IgcHJlZml4IHNpbmNlIHRoZXJlJ3Mgbm8gcmVuZGVyIGZuIEFQSVxyXG4gICAgICAgIC8vIGZvciByZXNvbHZpbmcgZGlyZWN0aXZlcyB2aWEgc3RyaW5nIGluIHYzLlxyXG4gICAgICAgIGFwcC5fY29udGV4dC5kaXJlY3RpdmVzLnNob3cgPSB2U2hvdztcclxuICAgICAgICBhcHAuX2NvbnRleHQuZGlyZWN0aXZlcy5tb2RlbCA9IHZNb2RlbER5bmFtaWM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBhdFZ1ZSQxKCkge1xyXG4gICAgY29uc3QgVnVlID0gY29tcGF0VXRpbHMuY3JlYXRlQ29tcGF0VnVlKGNyZWF0ZUFwcCwgd3JhcHBlZENyZWF0ZUFwcCk7XHJcbiAgICBleHRlbmQoVnVlLCBydW50aW1lRG9tKTtcclxuICAgIHJldHVybiBWdWU7XHJcbn1cblxuLy8gVGhpcyBlbnRyeSBleHBvcnRzIHRoZSBydW50aW1lIG9ubHksIGFuZCBpcyBidWlsdCBhc1xyXG5jb25zdCBWdWUgPSBjcmVhdGVDb21wYXRWdWUkMSgpO1xyXG5WdWUuY29tcGlsZSA9ICgoKSA9PiB7XHJcbiAgICBpZiAoKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpKSB7XHJcbiAgICAgICAgd2FybiQxKGBSdW50aW1lIGNvbXBpbGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBWdWUuYCArXHJcbiAgICAgICAgICAgIChgIENvbmZpZ3VyZSB5b3VyIGJ1bmRsZXIgdG8gYWxpYXMgXCJ2dWVcIiB0byBcIkB2dWUvY29tcGF0L2Rpc3QvdnVlLmVzbS1idW5kbGVyLmpzXCIuYFxyXG4gICAgICAgICAgICAgICAgKSAvKiBzaG91bGQgbm90IGhhcHBlbiAqLyk7XHJcbiAgICB9XHJcbn0pO1xuXG5jb25zdCB7IGNvbmZpZ3VyZUNvbXBhdDogY29uZmlndXJlQ29tcGF0JDEgfSA9IFZ1ZTtcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuZXhwb3J0IHsgQmFzZVRyYW5zaXRpb24sIENvbW1lbnQsIEVmZmVjdFNjb3BlLCBGcmFnbWVudCwgS2VlcEFsaXZlLCBSZWFjdGl2ZUVmZmVjdCwgU3RhdGljLCBTdXNwZW5zZSwgVGVsZXBvcnQsIFRleHQsIFRyYW5zaXRpb24sIFRyYW5zaXRpb25Hcm91cCwgVnVlRWxlbWVudCwgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmcsIGNhbGxXaXRoRXJyb3JIYW5kbGluZywgY2FtZWxpemUsIGNhcGl0YWxpemUsIGNsb25lVk5vZGUsIGNvbXBhdFV0aWxzLCBjb21wdXRlZCQxIGFzIGNvbXB1dGVkLCBjb25maWd1cmVDb21wYXQkMSBhcyBjb25maWd1cmVDb21wYXQsIGNyZWF0ZUFwcCwgY3JlYXRlQmxvY2ssIGNyZWF0ZUNvbW1lbnRWTm9kZSwgY3JlYXRlRWxlbWVudEJsb2NrLCBjcmVhdGVCYXNlVk5vZGUgYXMgY3JlYXRlRWxlbWVudFZOb2RlLCBjcmVhdGVIeWRyYXRpb25SZW5kZXJlciwgY3JlYXRlUHJvcHNSZXN0UHJveHksIGNyZWF0ZVJlbmRlcmVyLCBjcmVhdGVTU1JBcHAsIGNyZWF0ZVNsb3RzLCBjcmVhdGVTdGF0aWNWTm9kZSwgY3JlYXRlVGV4dFZOb2RlLCBjcmVhdGVWTm9kZSwgY3VzdG9tUmVmLCBkZWZpbmVBc3luY0NvbXBvbmVudCwgZGVmaW5lQ29tcG9uZW50LCBkZWZpbmVDdXN0b21FbGVtZW50LCBkZWZpbmVFbWl0cywgZGVmaW5lRXhwb3NlLCBkZWZpbmVQcm9wcywgZGVmaW5lU1NSQ3VzdG9tRWxlbWVudCwgZGV2dG9vbHMsIGVmZmVjdCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0Q3VycmVudFNjb3BlLCBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW4sIGd1YXJkUmVhY3RpdmVQcm9wcywgaCwgaGFuZGxlRXJyb3IsIGh5ZHJhdGUsIGluaXRDdXN0b21Gb3JtYXR0ZXIsIGluaXREaXJlY3RpdmVzRm9yU1NSLCBpbmplY3QsIGlzTWVtb1NhbWUsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1J1bnRpbWVPbmx5LCBpc1NoYWxsb3csIGlzVk5vZGUsIG1hcmtSYXcsIG1lcmdlRGVmYXVsdHMsIG1lcmdlUHJvcHMsIG5leHRUaWNrLCBub3JtYWxpemVDbGFzcywgbm9ybWFsaXplUHJvcHMsIG5vcm1hbGl6ZVN0eWxlLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2NvcGVEaXNwb3NlLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBvcGVuQmxvY2ssIHBvcFNjb3BlSWQsIHByb3ZpZGUsIHByb3h5UmVmcywgcHVzaFNjb3BlSWQsIHF1ZXVlUG9zdEZsdXNoQ2IsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmLCByZWdpc3RlclJ1bnRpbWVDb21waWxlciwgcmVuZGVyLCByZW5kZXJMaXN0LCByZW5kZXJTbG90LCByZXNvbHZlQ29tcG9uZW50LCByZXNvbHZlRGlyZWN0aXZlLCByZXNvbHZlRHluYW1pY0NvbXBvbmVudCwgcmVzb2x2ZUZpbHRlciQxIGFzIHJlc29sdmVGaWx0ZXIsIHJlc29sdmVUcmFuc2l0aW9uSG9va3MsIHNldEJsb2NrVHJhY2tpbmcsIHNldERldnRvb2xzSG9vaywgc2V0VHJhbnNpdGlvbkhvb2tzLCBzaGFsbG93UmVhY3RpdmUsIHNoYWxsb3dSZWFkb25seSwgc2hhbGxvd1JlZiwgc3NyQ29udGV4dEtleSwgc3NyVXRpbHMsIHN0b3AsIHRvRGlzcGxheVN0cmluZywgdG9IYW5kbGVyS2V5LCB0b0hhbmRsZXJzLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJhbnNmb3JtVk5vZGVBcmdzLCB0cmlnZ2VyUmVmLCB1bnJlZiwgdXNlQXR0cnMsIHVzZUNzc01vZHVsZSwgdXNlQ3NzVmFycywgdXNlU1NSQ29udGV4dCwgdXNlU2xvdHMsIHVzZVRyYW5zaXRpb25TdGF0ZSwgdk1vZGVsQ2hlY2tib3gsIHZNb2RlbER5bmFtaWMsIHZNb2RlbFJhZGlvLCB2TW9kZWxTZWxlY3QsIHZNb2RlbFRleHQsIHZTaG93LCB2ZXJzaW9uLCB3YXJuJDEgYXMgd2Fybiwgd2F0Y2gsIHdhdGNoRWZmZWN0LCB3YXRjaFBvc3RFZmZlY3QsIHdhdGNoU3luY0VmZmVjdCwgd2l0aEFzeW5jQ29udGV4dCwgd2l0aEN0eCwgd2l0aERlZmF1bHRzLCB3aXRoRGlyZWN0aXZlcywgd2l0aEtleXMsIHdpdGhNZW1vLCB3aXRoTW9kaWZpZXJzLCB3aXRoU2NvcGVJZCB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQgKz0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtKTtcblxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBtb2R1bGVzLmxlbmd0aDsgX2srKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfa10pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpKSB7XG4gIHJldHVybiBpWzFdO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHJ1bnRpbWUgaGVscGVyIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gY29tcG9uZW50c1xuLy8gaW4gYSB0cmVlLXNoYWthYmxlIHdheVxuZXhwb3J0cy5kZWZhdWx0ID0gKHNmYywgcHJvcHMpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBzZmMuX192Y2NPcHRzIHx8IHNmYztcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgcHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG5pbXBvcnQgbGlzdFRvU3R5bGVzIGZyb20gJy4vbGlzdFRvU3R5bGVzJ1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cbnZhciBvcHRpb25zID0gbnVsbFxudmFyIHNzcklkS2V5ID0gJ2RhdGEtdnVlLXNzci1pZCdcblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkU3R5bGVzQ2xpZW50IChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbiwgX29wdGlvbnMpIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIG9wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlWycgKyBzc3JJZEtleSArICd+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuICBpZiAob3B0aW9ucy5zc3JJZCkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoc3NySWRLZXksIG9iai5pZClcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG4pe3JldHVybnthbGw6bj1ufHxuZXcgTWFwLG9uOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bi5nZXQodCk7aT9pLnB1c2goZSk6bi5zZXQodCxbZV0pfSxvZmY6ZnVuY3Rpb24odCxlKXt2YXIgaT1uLmdldCh0KTtpJiYoZT9pLnNwbGljZShpLmluZGV4T2YoZSk+Pj4wLDEpOm4uc2V0KHQsW10pKX0sZW1pdDpmdW5jdGlvbih0LGUpe3ZhciBpPW4uZ2V0KHQpO2kmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bihlKX0pLChpPW4uZ2V0KFwiKlwiKSkmJmkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bih0LGUpfSl9fX1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pdHQubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9